/* The copyright in this software is being made available under the BSD
 * License, included below. This software may be subject to other third party
 * and contributor rights, including patent rights, and no such rights are
 * granted under this license.
 *
 * Copyright (c) 2010-2023, ITU/ISO/IEC
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 *  * Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
 *    be used to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/** \file     Prediction.cpp
    \brief    prediction class
*/

#include "IntraPrediction.h"

#include "Unit.h"
#include "UnitTools.h"
#include "Buffer.h"

#include "dtrace_next.h"
#include "Rom.h"

#include <memory.h>
#if INTRA_TRANS_ENC_OPT && defined(TARGET_SIMD_X86)
#include <smmintrin.h>
#endif
#include "CommonLib/InterpolationFilter.h"

//! \ingroup CommonLib
//! \{

// ====================================================================================================================
// Tables
// ====================================================================================================================

const uint8_t IntraPrediction::m_aucIntraFilter[MAX_INTRA_FILTER_DEPTHS] =
{
  24, //   1xn
  24, //   2xn
  24, //   4xn
  14, //   8xn
  2,  //  16xn
  0,  //  32xn
  0,  //  64xn
  0   // 128xn
};

#if JVET_W0123_TIMD_FUSION
const uint8_t IntraPrediction::m_aucIntraFilterExt[MAX_INTRA_FILTER_DEPTHS] =
{
  48, //   1xn
  48, //   2xn
  48, //   4xn
  28, //   8xn
  4,  //  16xn
  0,  //  32xn
  0,  //  64xn
  0   // 128xn
};
#endif

// ====================================================================================================================
// Constructor / destructor / initialize
// ====================================================================================================================

IntraPrediction::IntraPrediction()
:
  m_currChromaFormat( NUM_CHROMA_FORMAT )
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  , m_evalIdx(-1)
#endif
{
#if !MERGE_ENC_OPT
  for( uint32_t ch = 0; ch < MAX_NUM_COMPONENT; ch++ )
  {
    for( uint32_t buf = 0; buf < 4; buf++ )
    {
      m_yuvExt2[ch][buf] = nullptr;
    }
  }
#endif

#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  m_pCCFilterTemp = nullptr;
#endif
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  for (int i = 0; i < 2; i++)
  {
    m_decoderDerivedCcpProbeTemplateT[i] = nullptr;
    m_decoderDerivedCcpProbeTemplateL[i] = nullptr;
  }
  for (int i = 0; i < MAX_DDCCP_CAND_LIST_SIZE; i++)
  {
    m_ddCCPFusionTempCb[i] = nullptr;
    m_ddCCPFusionTempCr[i] = nullptr;
  }
  for (int i = 0; i < MAX_CCP_CAND_LIST_SIZE; i++)
  {
    m_CCPFusionTempCb[i] = nullptr;
    m_CCPFusionTempCr[i] = nullptr;
  }
#endif
#if JVET_AF0073_INTER_CCP_MERGE
  m_pCcpMerge[0] = nullptr;
  m_pCcpMerge[1] = nullptr;
#endif
#if JVET_W0123_TIMD_FUSION
  m_timdSatdCost = nullptr;
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  m_itmpSatdCost = nullptr;
#endif
#if JVET_AC0071_DBV
  m_dbvSadCost = nullptr;
#endif
  #if JVET_AB0067_MIP_DIMD_LFNST
  m_pMipTemp = nullptr;
#endif
  m_piTemp = nullptr;
  m_pMdlmTemp = nullptr;
#if JVET_AA0126_GLM
  for (int i = 0; i < NUM_GLM_IDC; i++)
  {
    m_glmTempCb[i] = nullptr;
    m_glmTempCr[i] = nullptr;
#if JVET_AB0092_GLM_WITH_LUMA
    m_glmGradBuf[i] = nullptr;
#endif
  }
#endif
#if MMLM
  m_encPreRDRun = false;
#endif
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
  m_intraOBMCNeighState = INTRA_OBMC_BOTH_NEIGH_AVAIL;
  m_refSampleForOBMC = false;
  memset(m_refSampleForOBMCBuf, -1, sizeof( Pel ) * (MAX_INTRA_SIZE + 3));
  memset(m_refSampleForOBMCBufFiltered, -1, sizeof( Pel ) * (MAX_INTRA_SIZE + 3));
#endif
#if JVET_V0130_INTRA_TMP
  m_pppTarPatch = NULL;
#endif
#if JVET_AA0057_CCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
#if JVET_AD0202_CCCM_MDF
  for (int i = 0; i < (CCCM_NUM_PRED_FILTER + 1); i++)
  {
    m_cccmLumaBuf[i] = nullptr;
  }
#else
  m_cccmLumaBuf[0] = nullptr;
  m_cccmLumaBuf[1] = nullptr;
#endif
#else
  m_cccmLumaBuf = nullptr;
#endif
#if JVET_AE0100_BVGCCCM
  for (int i = 0; i < NUM_BVG_CCCM_CANDS; i++)
  {
    m_bvgCccmLumaBuf[i] = nullptr;
    m_bvgCccmChromaBuf[i][0] = nullptr;
    m_bvgCccmChromaBuf[i][1] = nullptr;
  }
#endif
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
  for (int j = 0; j < MTMP_NUM; j++)
  {
    m_tmpRefBuf[j] = nullptr;
  }
#endif

#if JVET_AC0119_LM_CHROMA_FUSION
  for (int i = 0; i < 3; i++)
  {
    m_cflmBuf[i] = nullptr;
  }
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
  m_pcReshape = nullptr;
  m_pcBilateralFilter = nullptr;
#endif
#if JVET_AH0209_PDP
  for( int i = 0; i < NUM_LUMA_MODE; i++ )
  {
    m_pdpIntraPredBufIP[ i ] = nullptr;
  }

  std::memset( m_pdpIntraPredReady, 0, sizeof( m_pdpIntraPredReady ) );
  std::memset( m_ref, 0, sizeof( m_ref ) );
  std::memset( m_refShort, 0, sizeof( m_refShort ) );
  m_refAvailable = false;
#endif
}

IntraPrediction::~IntraPrediction()
{
  destroy();
}

void IntraPrediction::destroy()
{
#if !MERGE_ENC_OPT
  for( uint32_t ch = 0; ch < MAX_NUM_COMPONENT; ch++ )
  {
    for( uint32_t buf = 0; buf < 4; buf++ )
    {
      delete[] m_yuvExt2[ch][buf];
      m_yuvExt2[ch][buf] = nullptr;
    }
  }
#endif

#if JVET_W0123_TIMD_FUSION
  delete m_timdSatdCost;
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  delete m_itmpSatdCost;
#endif
#if JVET_AC0071_DBV
  delete m_dbvSadCost;
#endif
#if JVET_AB0155_SGPM
  for (auto &buffer: m_sgpmBuffer)
  {
    buffer.destroy();
  }
  m_sgpmBuffer.clear();
#endif
  for (auto &buffer: m_intraPredBuffer)
  {
    buffer.destroy();
  }
  m_intraPredBuffer.clear();

#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  delete[] m_pCCFilterTemp;
  m_pCCFilterTemp = nullptr;
#endif
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  for (int i = 0; i < 2; i++)
  {
    delete[] m_decoderDerivedCcpProbeTemplateT[i];
    m_decoderDerivedCcpProbeTemplateT[i] = nullptr;
    delete[] m_decoderDerivedCcpProbeTemplateL[i];
    m_decoderDerivedCcpProbeTemplateL[i] = nullptr;
  }
  for (int i = 0; i < MAX_DDCCP_CAND_LIST_SIZE; i++)
  {
    delete[] m_ddCCPFusionTempCb[i];
    m_ddCCPFusionTempCb[i] = nullptr;
    delete[] m_ddCCPFusionTempCr[i];
    m_ddCCPFusionTempCr[i] = nullptr;
  }
  for (int i = 0; i < MAX_CCP_CAND_LIST_SIZE; i++)
  {
    delete[] m_CCPFusionTempCb[i];
    m_CCPFusionTempCb[i] = nullptr;
    delete[] m_CCPFusionTempCr[i];
    m_CCPFusionTempCr[i] = nullptr;
  }
#endif
#if JVET_AF0073_INTER_CCP_MERGE
  delete[] m_pCcpMerge[0];
  m_pCcpMerge[0] = nullptr;
  delete[] m_pCcpMerge[1];
  m_pCcpMerge[1] = nullptr;
#endif
#if JVET_AB0067_MIP_DIMD_LFNST
  delete[] m_pMipTemp;
  m_pMipTemp = nullptr;
#endif
  delete[] m_piTemp;
  m_piTemp = nullptr;
  delete[] m_pMdlmTemp;
  m_pMdlmTemp = nullptr;
#if JVET_AA0126_GLM
  for (int i = 0; i < NUM_GLM_IDC; i++)
  {
    delete[] m_glmTempCb[i]; m_glmTempCb[i] = nullptr;
    delete[] m_glmTempCr[i]; m_glmTempCr[i] = nullptr;
#if JVET_AB0092_GLM_WITH_LUMA
    delete[] m_glmGradBuf[i]; m_glmGradBuf[i] = nullptr;
#endif
  }
#endif

  for( auto &buffer : m_tempBuffer )
  {
    buffer.destroy();
  }
  m_tempBuffer.clear();

#if JVET_V0130_INTRA_TMP && !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  if( m_pppTarPatch != NULL )
  {
    for( unsigned int uiDepth = 0; uiDepth < USE_MORE_BLOCKSIZE_DEPTH_MAX; uiDepth++ )
    {
      unsigned int blkSize = g_uiDepth2Width[uiDepth];

      unsigned int patchSize = blkSize + TMP_TEMPLATE_SIZE;
      for( unsigned int uiRow = 0; uiRow < patchSize; uiRow++ )
      {
        if( m_pppTarPatch[uiDepth][uiRow] != NULL )
        {
          delete[]m_pppTarPatch[uiDepth][uiRow]; m_pppTarPatch[uiDepth][uiRow] = NULL;
        }
      }
      if( m_pppTarPatch[uiDepth] != NULL )
      {
        delete[]m_pppTarPatch[uiDepth]; m_pppTarPatch[uiDepth] = NULL;
      }
    }
    delete[] m_pppTarPatch;
    m_pppTarPatch = NULL;
  }
#endif

#if JVET_AA0057_CCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
#if JVET_AD0202_CCCM_MDF
  for (int i = 0; i < (CCCM_NUM_PRED_FILTER + 1); i++)
  {
    delete[] m_cccmLumaBuf[i];
    m_cccmLumaBuf[i] = nullptr;
  }
#else
  delete[] m_cccmLumaBuf[0];
  m_cccmLumaBuf[0] = nullptr;

  delete[] m_cccmLumaBuf[1];
  m_cccmLumaBuf[1] = nullptr;
#endif
#else
  delete[] m_cccmLumaBuf;
  m_cccmLumaBuf = nullptr;
#endif
#if JVET_AE0100_BVGCCCM
  for (int i = 0; i < NUM_BVG_CCCM_CANDS; i++)
  {
    delete[] m_bvgCccmLumaBuf[i];
    m_bvgCccmLumaBuf[i] = nullptr;
    delete[] m_bvgCccmChromaBuf[i][0];
    m_bvgCccmChromaBuf[i][0] = nullptr;
    delete[] m_bvgCccmChromaBuf[i][1];
    m_bvgCccmChromaBuf[i][1] = nullptr;
  }
#endif
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
  for (int j = 0; j < MTMP_NUM; j++)
  {
    delete[] m_tmpRefBuf[j];
    m_tmpRefBuf[j] = nullptr;
  }
#endif

#if JVET_AC0119_LM_CHROMA_FUSION
  for (int i = 0; i < 3; i++)
  {
    delete[] m_cflmBuf[i];
    m_cflmBuf[i] = nullptr;
  }
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
  m_pcReshape = nullptr;
  m_pcBilateralFilter = nullptr;
#endif
}

#if JVET_AJ0249_NEURAL_NETWORK_BASED
#if JVET_AK0118_BF_FOR_INTRA_PRED
void IntraPrediction::init(ChromaFormat chromaFormatIDC, const unsigned bitDepthY, const int nnipMode, Reshape* reshape, BilateralFilter* bilateralFilter )
#else
void IntraPrediction::init(ChromaFormat chromaFormatIDC, const unsigned bitDepthY, const int nnipMode)
#endif
#else
void IntraPrediction::init(ChromaFormat chromaFormatIDC, const unsigned bitDepthY)
#endif
{
#if JVET_AB0155_SGPM
  m_if.initInterpolationFilter(true);
#endif

#if MERGE_ENC_OPT
  if (m_currChromaFormat != chromaFormatIDC)
  {
    destroy();
  }

  m_currChromaFormat = chromaFormatIDC;
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  if (nnipMode > 0)
  {
    m_intraPredNN.init(bitDepthY);
  }
  else
  {
    m_intraPredNN.setEnable(false);
  }
#endif
#else
  if( m_yuvExt2[COMPONENT_Y][0] != nullptr && m_currChromaFormat != chromaFormatIDC )
  {
    destroy();
  }

  m_currChromaFormat = chromaFormatIDC;


  if( m_yuvExt2[COMPONENT_Y][0] == nullptr ) // check if first is null (in which case, nothing initialised yet)
  {
    m_yuvExtSize2 = ( MAX_CU_SIZE ) * ( MAX_CU_SIZE );

    for( uint32_t ch = 0; ch < MAX_NUM_COMPONENT; ch++ )
    {
      for( uint32_t buf = 0; buf < 4; buf++ )
      {
        m_yuvExt2[ch][buf] = new Pel[m_yuvExtSize2];
      }
    }
  }
#endif

#if LMS_LINEAR_MODEL
  int shift = bitDepthY + 4;
  for (int i = 32; i < 64; i++)
  {
    m_auShiftLM[i - 32] = ((1 << shift) + i / 2) / i;
  }
#endif

#if JVET_W0123_TIMD_FUSION
  if (m_timdSatdCost == nullptr)
  {
    m_timdSatdCost = new RdCost;
  }
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  if (m_itmpSatdCost == nullptr)
  {
    m_itmpSatdCost = new RdCost;
  }
#endif
#if JVET_AC0071_DBV
  if (m_dbvSadCost == nullptr)
  {
    m_dbvSadCost = new RdCost;
  }
#endif
#if JVET_AB0155_SGPM
  for (auto &buffer: m_sgpmBuffer)
  {
    buffer.destroy();
  }

  // the number of total temporal buffers can be adjusted by changing the number here
#if JVET_AJ0112_REGRESSION_SGPM
  m_sgpmBuffer.resize(NUM_PRIMARY_MOST_PROBABLE_MODES + SGPM_NUM_BVS + 1);
#else
  m_sgpmBuffer.resize(1);
#endif

  for (auto &buffer: m_sgpmBuffer)
  {
    buffer.create(CHROMA_400, Area(0, 0, MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE, MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE));
  }
#endif
  for (auto &buffer: m_intraPredBuffer)
  {
    buffer.destroy();
  }

  // the number of total temporal buffers can be adjusted by changing the number here
  m_intraPredBuffer.resize(1);

#if JVET_AJ0146_TIMDSAD
  for (auto &buffer: m_intraPredBuffer)
  {
    buffer.create(CHROMA_400, Area(0, 0, MAX_CU_SIZE + TIMDDIFF_MAX_TEMP_SIZE, MAX_CU_SIZE + TIMDDIFF_MAX_TEMP_SIZE));
  }
#else
  for (auto &buffer: m_intraPredBuffer)
  {
    buffer.create(CHROMA_400, Area(0, 0, MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE, MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE));
  }
#endif

  memset(m_tempRefAbove, 0, ((MAX_CU_SIZE << 3) + 5 + 33 * MAX_REF_LINE_IDX) * sizeof(Pel));
  memset(m_tempRefLeft, 0, ((MAX_CU_SIZE << 3) + 5 + 33 * MAX_REF_LINE_IDX) * sizeof(Pel));

#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  if (m_pCCFilterTemp == nullptr)
  {
    m_pCCFilterTemp = new Pel[(MAX_CU_SIZE + 2) * (MAX_CU_SIZE + 2)];
  }
#endif
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  for (int i = 0; i < 2; i++)
  {
    if (m_decoderDerivedCcpProbeTemplateT[i] == nullptr)
    {
      m_decoderDerivedCcpProbeTemplateT[i] = new Pel[(MAX_CU_SIZE + 2) * 3];
    }
    if (m_decoderDerivedCcpProbeTemplateL[i] == nullptr)
    {
      m_decoderDerivedCcpProbeTemplateL[i] = new Pel[3 * (MAX_CU_SIZE + 2)];
    }
  }
  for (int i = 0; i < MAX_DDCCP_CAND_LIST_SIZE; i++)
  {
    if (m_ddCCPFusionTempCb[i] == nullptr)
    {
      m_ddCCPFusionTempCb[i] = new Pel[2 * MAX_CU_SIZE];
    }
    if (m_ddCCPFusionTempCr[i] == nullptr)
    {
      m_ddCCPFusionTempCr[i] = new Pel[2 * MAX_CU_SIZE];
    }
  }
  for (int i = 0; i < MAX_CCP_CAND_LIST_SIZE; i++)
  {
    if (m_CCPFusionTempCb[i] == nullptr)
    {
      m_CCPFusionTempCb[i] = new Pel[2 * MAX_CU_SIZE];
    }
    if (m_CCPFusionTempCr[i] == nullptr)
    {
      m_CCPFusionTempCr[i] = new Pel[2 * MAX_CU_SIZE];
    }
  }
#endif
#if JVET_AF0073_INTER_CCP_MERGE
  if (m_pCcpMerge[0] == nullptr)
  {
    m_pCcpMerge[0] = new Pel[(MAX_CU_SIZE + 1) * (MAX_CU_SIZE + 1)];
  }
  if (m_pCcpMerge[1] == nullptr)
  {
    m_pCcpMerge[1] = new Pel[(MAX_CU_SIZE + 1) * (MAX_CU_SIZE + 1)];
  }  
#endif
#if JVET_AB0067_MIP_DIMD_LFNST
  if (m_pMipTemp == nullptr)
  {
    m_pMipTemp = new Pel[(MAX_CU_SIZE + 1) * (MAX_CU_SIZE + 1)];
  }
#endif
  if (m_piTemp == nullptr)
  {
    m_piTemp = new Pel[(MAX_CU_SIZE + 1) * (MAX_CU_SIZE + 1)];
  }
  if (m_pMdlmTemp == nullptr)
  {
    m_pMdlmTemp = new Pel[(2 * MAX_CU_SIZE + 1)*(2 * MAX_CU_SIZE + 1)];//MDLM will use top-above and left-below samples.
  }
#if JVET_AA0126_GLM
  for (int i = 0; i < NUM_GLM_IDC; i++)
  {
    if (m_glmTempCb[i] == nullptr)
    {
      m_glmTempCb[i] = new Pel[(2 * MAX_CU_SIZE + 1)*(2 * MAX_CU_SIZE + 1)];
    }
    if (m_glmTempCr[i] == nullptr)
    {
      m_glmTempCr[i] = new Pel[(2 * MAX_CU_SIZE + 1)*(2 * MAX_CU_SIZE + 1)];
    }
#if JVET_AB0092_GLM_WITH_LUMA
    if (m_glmGradBuf[i] == nullptr)
    {
      m_glmGradBuf[i] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE)];
    }
#endif
  }
#endif

  for( auto &buffer : m_tempBuffer )
  {
    buffer.destroy();
  }

  // the number of total temporal buffers can be adjusted by chaning the number here
#if JVET_AB0157_INTRA_FUSION
#if JVET_AC0098_LOC_DEP_DIMD
  m_tempBuffer.resize( DIMD_FUSION_NUM+2 );
#else
  m_tempBuffer.resize( DIMD_FUSION_NUM-1 );
#endif
#else
  m_tempBuffer.resize( 2 );
#endif

  for( auto &buffer : m_tempBuffer )
  {
    buffer.create( chromaFormatIDC, Area( 0, 0, MAX_CU_SIZE, MAX_CU_SIZE ) );
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    memset(buffer.getBuf(COMPONENT_Y).buf, 0, MAX_CU_SIZE * MAX_CU_SIZE * sizeof(Pel));
#endif
  }
#if ENABLE_DIMD && INTRA_TRANS_ENC_OPT
  m_dimdBlending = dimdBlending;
#endif
#if JVET_W0123_TIMD_FUSION && INTRA_TRANS_ENC_OPT
  m_timdBlending = timdBlending;
#endif
#if JVET_AC0112_IBC_CIIP && INTRA_TRANS_ENC_OPT
  m_ibcCiipBlending = ibcCiipBlending;
#endif
#if JVET_AH0209_PDP
  m_xPredIntraOpt = xPredIntraOpt;
#endif
#if JVET_AG0058_EIP && INTRA_TRANS_ENC_OPT
  m_calcAeipGroupSum = calcAeipGroupSum;
#endif
#if JVET_V0130_INTRA_TMP
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  unsigned int blkSize;
  if( m_pppTarPatch == NULL )
  {
    m_pppTarPatch = new Pel * *[USE_MORE_BLOCKSIZE_DEPTH_MAX];
    for( unsigned int uiDepth = 0; uiDepth < USE_MORE_BLOCKSIZE_DEPTH_MAX; uiDepth++ )
    {
      blkSize = g_uiDepth2Width[uiDepth];

      unsigned int patchSize = blkSize + TMP_TEMPLATE_SIZE;
      m_pppTarPatch[uiDepth] = new Pel *[patchSize];
      for( unsigned int uiRow = 0; uiRow < patchSize; uiRow++ )
      {
        m_pppTarPatch[uiDepth][uiRow] = new Pel[patchSize];
      }
    }
  }
#endif

  m_calcTemplateDiff = calcTemplateDiff;
#if JVET_AG0136_INTRA_TMP_LIC
  m_calcTemplateDiffJointSadMrsad = calcTemplateDiffJointSadMrsad;
  m_calcTargetMean = calcTargetMean;
#endif
#endif

#if JVET_AA0057_CCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
#if JVET_AD0202_CCCM_MDF
  if (m_cccmLumaBuf[0] == nullptr)
  {
    const int chromaScaleX = getChannelTypeScaleX(CHANNEL_TYPE_CHROMA, chromaFormatIDC);
    const int chromaScaleY = getChannelTypeScaleY(CHANNEL_TYPE_CHROMA, chromaFormatIDC);

    m_cccmLumaBuf[0] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + (CCCM_FILTER_PADDING << chromaScaleX) + (CCCM_FILTER_PADDING << chromaScaleY)) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + (CCCM_FILTER_PADDING << chromaScaleX) + (CCCM_FILTER_PADDING << chromaScaleY))];
  }

  for (int i = 1; i < (CCCM_NUM_PRED_FILTER + 1); i++)
  {
    if (m_cccmLumaBuf[i] == nullptr)
    {
      m_cccmLumaBuf[i] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING)];
    }
  }
#else
  if( m_cccmLumaBuf[0] == nullptr )
  {
    m_cccmLumaBuf[0] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING)];
  }

  if( m_cccmLumaBuf[1] == nullptr )
  {
    const int chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, chromaFormatIDC );
    const int chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, chromaFormatIDC );

    m_cccmLumaBuf[1] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + (CCCM_FILTER_PADDING << chromaScaleX) + (CCCM_FILTER_PADDING << chromaScaleY)) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + (CCCM_FILTER_PADDING << chromaScaleX) + (CCCM_FILTER_PADDING << chromaScaleY))];
  }
#endif
#else
  if (m_cccmLumaBuf == nullptr)
  {
    m_cccmLumaBuf = new Pel[(2*MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2*CCCM_FILTER_PADDING) * (2*MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2*CCCM_FILTER_PADDING)];
  }
#endif
#if JVET_AE0100_BVGCCCM
  for (int i = 0; i < NUM_BVG_CCCM_CANDS; i++)
  {
    if( m_bvgCccmLumaBuf[i] == nullptr )
    {
      m_bvgCccmLumaBuf[i] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING)];
    }
    if (m_bvgCccmChromaBuf[i][0] == nullptr)
    {
      m_bvgCccmChromaBuf[i][0] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING)];
    }
    if (m_bvgCccmChromaBuf[i][1] == nullptr)
    {
      m_bvgCccmChromaBuf[i][1] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE + 2 * CCCM_FILTER_PADDING)];
    }
  }
#endif
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
  for (int j = 0; j < MTMP_NUM; j++)
  {
    if (m_tmpRefBuf[j] == nullptr)
    {
      m_tmpRefBuf[j] = new Pel[(2 * MAX_CU_SIZE + TMP_TEMPLATE_SIZE + 2 * TMP_FILTER_PADDING)
                               * (2 * MAX_CU_SIZE + TMP_TEMPLATE_SIZE + 2 * TMP_FILTER_PADDING)];
    }
  }
#endif

#if JVET_AC0119_LM_CHROMA_FUSION
  for (int i = 0; i < 3; i++)
  {
    if (m_cflmBuf[i] == nullptr)
    {
      m_cflmBuf[i] = new Pel[(2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE) * (2 * MAX_CU_SIZE + CCCM_WINDOW_SIZE)];
    }
  }
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
  m_pcReshape = reshape;
  m_pcBilateralFilter = bilateralFilter;
#endif

#if ENABLE_SIMD_TMP
#ifdef TARGET_SIMD_X86
  initIntraX86();
#endif
#endif
}

#if JVET_W0123_TIMD_FUSION || JVET_AC0119_LM_CHROMA_FUSION
void IntraPrediction::xIntraPredTimdAngPdpc(Pel* pDsty,const int dstStride,Pel* refSide,const int width,const int height, int xOffset, int yOffset, int scale,int invAngle)
{
  int xlim = std::min(3 << scale, width);
  for (int y = yOffset; y<height; y++)
  {
    int invAngleSum = 256;
    if (width < 4)
    {
      for (int x = xOffset; x < 2; x++)
      {
        invAngleSum += invAngle;
        int wL   = 32 >> (2 * x >> scale);
        Pel left = refSide[y + (invAngleSum >> 9) + 1];
        pDsty[x] = pDsty[x] + ((wL * (left - pDsty[x]) + 32) >> 6);
      }
    }
    else
    {
      for (int x = xOffset; x < xlim; x++)
      {
        invAngleSum += invAngle;
        int wL   = 32 >> (2 * x >> scale);
        Pel left = refSide[y + (invAngleSum >> 9) + 1];
        pDsty[x] = pDsty[x] + ((wL * (left - pDsty[x]) + 32) >> 6);
      }
    }
    pDsty += dstStride;
  }
}

#if GRAD_PDPC
void IntraPrediction::xIntraPredTimdAngGradPdpc(Pel* pDsty, const int dstStride, Pel* refMain, Pel* refSide, const int width, const int height, int xOffset, int yOffset, int scale, int deltaPos, int intraPredAngle, const ClpRng& clpRng
#if JVET_AC0119_LM_CHROMA_FUSION
  , const bool bExtIntraDir
#endif
)
{
#if JVET_AC0119_LM_CHROMA_FUSION
  if (!bExtIntraDir)
  {
    for (int y = yOffset; y < height; y++)
    {
      const int deltaInt = deltaPos >> 5;
      const int deltaFract = deltaPos & 31;
      const Pel left = refSide[1 + y];
      const Pel topLeft = refMain[deltaInt] + ((deltaFract * (refMain[deltaInt + 1] - refMain[deltaInt]) + 16) >> 5);
      for (int x = xOffset; x < std::min(3 << scale, width); x++)
      {
        int wL = 32 >> (2 * (x - xOffset) >> scale);
        pDsty[x] = ClipPel(pDsty[x] + ((wL * (left - topLeft) + 32) >> 6), clpRng);
      }
      pDsty += dstStride;
      deltaPos += intraPredAngle;
    }
  }
  else
  {
#endif
  for (int y = yOffset; y<height; y++)
  {
    const int deltaInt   = deltaPos >> 6;
    const int deltaFract = deltaPos & 63;
    const Pel left = refSide[1 + y];
    const Pel topLeft = refMain[deltaInt] + ((deltaFract * (refMain[deltaInt + 1] - refMain[deltaInt]) + 32) >> 6);
    for (int x = xOffset; x < std::min(3 << scale, width); x++)
    {
      int wL = 32 >> (2 * (x - xOffset) >> scale);
      pDsty[x] = ClipPel(pDsty[x] + ((wL * (left - topLeft) + 32) >> 6), clpRng);
    }
    pDsty += dstStride;
    deltaPos += intraPredAngle;
  }
#if JVET_AC0119_LM_CHROMA_FUSION
  }
#endif
}
#endif

void IntraPrediction::xIntraPredTimdHorVerPdpc(Pel* pDsty,const int dstStride,Pel* refSide,const int width,const int height, int xOffset, int yOffset, int scale,const Pel* refMain, const ClpRng& clpRng)
{
  const Pel topLeft = refMain[0];

  for( int y = yOffset; y < height; y++ )
  {
    memcpy(pDsty,&refMain[1],width*sizeof(Pel));
    const Pel left    = refSide[1 + y];
    for (int x = xOffset; x < std::min(3 << scale, width); x++)
    {
      const int wL  = 32 >> (2 * x >> scale);
      const Pel val = pDsty[x];
      pDsty[x]      = ClipPel(val + ((wL * (left - topLeft) + 32) >> 6), clpRng);
    }
    pDsty += dstStride;
  }
}

void IntraPrediction::xIntraPredTimdPlanarDcPdpc(const CPelBuf &pSrc, Pel* pDst, int iDstStride, int width, int height, TemplateType eTempType, int iTemplateWidth, int iTemplateHeight)
{
  if (eTempType == LEFT_ABOVE_NEIGHBOR)
  {
    int xOffset = 0;
    int yOffset = 0;
    // PDPC for above template
    {
      const int iWidth  = width;
      const int iHeight = iTemplateHeight;
      xOffset = iTemplateWidth;
      const int scale = ((floorLog2(width) - 2 + floorLog2(height) - 2 + 2) >> 2);
      for (int y = 0; y < iHeight; y++)
      {
        const int wT   = 32 >> std::min(31, ((y << 1) >> scale));
        const Pel left = pSrc.at(y + 1, 1);
        for (int x = xOffset; x < iWidth; x++)
        {
          const int wL    = 32 >> std::min(31, ((x << 1) >> scale));
          const Pel top   = pSrc.at(x + 1, 0);
          const Pel val   = pDst[y * iDstStride + x];
          pDst[y * iDstStride + x] = val + ((wL * (left - val) + wT * (top - val) + 32) >> 6);
        }
      }
    }

    // PDPC for left template
    {
      const int iWidth  = iTemplateWidth;
      const int iHeight = height;
      yOffset = iTemplateHeight;
      const int scale = ((floorLog2(width) - 2 + floorLog2(height) - 2 + 2) >> 2);
      for (int y = yOffset; y < iHeight; y++)
      {
        const int wT   = 32 >> std::min(31, ((y << 1) >> scale));
        const Pel left = pSrc.at(y + 1, 1);
        for (int x = 0; x < iWidth; x++)
        {
          const int wL    = 32 >> std::min(31, ((x << 1) >> scale));
          const Pel top   = pSrc.at(x + 1, 0);
          const Pel val   = pDst[y * iDstStride + x];
          pDst[y * iDstStride + x] = val + ((wL * (left - val) + wT * (top - val) + 32) >> 6);
        }
      }
    }
  }
  else if (eTempType == LEFT_NEIGHBOR)
  {
    const int iHeight = height;
    const int scale = ((floorLog2(width) - 2 + floorLog2(height) - 2 + 2) >> 2);
    for (int y = 0; y < iHeight; y++)
    {
      const int wT   = 32 >> std::min(31, ((y << 1) >> scale));
      const Pel left = pSrc.at(y + 1, 1);
      for (int x = 0; x < iTemplateWidth; x++)
      {
        const int wL    = 32 >> std::min(31, ((x << 1) >> scale));
        const Pel top   = pSrc.at(x + 1, 0);
        const Pel val   = pDst[y * iDstStride + x];
        pDst[y * iDstStride + x] = val + ((wL * (left - val) + wT * (top - val) + 32) >> 6);
      }
    }
  }
  else // eTempType == ABOVE_NEIGHBOR
  {
    const int iWidth  = width;
    const int scale = ((floorLog2(width) - 2 + floorLog2(height) - 2 + 2) >> 2);
    for (int y = 0; y < iTemplateHeight; y++)
    {
      const int wT   = 32 >> std::min(31, ((y << 1) >> scale));
      const Pel left = pSrc.at(y + 1, 1);
      for (int x = 0; x < iWidth; x++)
      {
        const int wL    = 32 >> std::min(31, ((x << 1) >> scale));
        const Pel top   = pSrc.at(x + 1, 0);
        const Pel val   = pDst[y * iDstStride + x];
        pDst[y * iDstStride + x] = val + ((wL * (left - val) + wT * (top - val) + 32) >> 6);
      }
    }
  }
}

void IntraPrediction::xIntraPredTimdAngLuma(Pel* pDstBuf, const ptrdiff_t dstStride, Pel* refMain, int width, int height, int deltaPos, int intraPredAngle, const ClpRng& clpRng, int xOffset, int yOffset)
{
  for (int y = yOffset; y<height; y++ )
  {
    const int deltaInt   = deltaPos >> 6;
    const int deltaFract = deltaPos & 63;
    const TFilterCoeff* const f = InterpolationFilter::getExtIntraCubicFilter(deltaFract);
    int refMainIndex = deltaInt + 1 + xOffset;
    for( int x = xOffset; x < width; x++, refMainIndex++ )
    {
      pDstBuf[y*dstStride + x] = (f[0] * refMain[refMainIndex - 1] + f[1] * refMain[refMainIndex] + f[2] * refMain[refMainIndex + 1] + f[3] * refMain[refMainIndex + 2] + 128) >> 8;
      pDstBuf[y*dstStride + x] = ClipPel( pDstBuf[y*dstStride + x], clpRng ); // always clip even though not always needed
    }
    deltaPos += intraPredAngle;
  }
}

#if JVET_AC0119_LM_CHROMA_FUSION
void IntraPrediction::xIntraPredTimdAngChroma(Pel* pDstBuf, const ptrdiff_t dstStride, Pel* refMain, int width, int height, int deltaPos, int intraPredAngle, const ClpRng& clpRng, int xOffset, int yOffset)
{
  for (int y = yOffset; y < height; y++)
  {
    const int deltaInt = deltaPos >> 5;
    const int deltaFract = deltaPos & 31;
    int refMainIndex = deltaInt + 1 + xOffset;
    for (int x = xOffset; x < width; x++, refMainIndex++)
    {
      pDstBuf[y * dstStride + x] = refMain[refMainIndex] + ((deltaFract * (refMain[refMainIndex + 1] - refMain[refMainIndex]) + 16) >> 5);
    }
    deltaPos += intraPredAngle;
}
}
#endif

#if JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
void IntraPrediction::xIntraPredPlanarDcPdpc( const CPelBuf &pSrc, Pel* pDst, int iDstStride, int width, int height, bool ciipPDPC )
#else
void IntraPrediction::xIntraPredPlanarDcPdpc(const CPelBuf &pSrc, Pel* pDst, int iDstStride, int width, int height)
#endif
{
  const int iWidth  = width;
  const int iHeight = height;
  const int scale  = ((floorLog2(iWidth) - 2 + floorLog2(iHeight) - 2 + 2) >> 2);
  CHECK(scale < 0 || scale > 31, "PDPC: scale < 0 || scale > 31");
  const Pel *srcLeft = pSrc.bufAt(1, 1);
#if CIIP_PDPC
  if (ciipPDPC)
  {
    for (int y = 0; y < iHeight; y++)
    {
      const int  wT     = 32 >> std::min(31, ((y << 1) >> scale));
      const Pel  left    = *srcLeft;
      const Pel *srcTop = pSrc.buf + 1;
      for (int x = 0; x < iWidth; x++)
      {
        const int wL  = 32 >> std::min(31, ((x << 1) >> scale));
        const Pel top = *srcTop;
        pDst[x]        = ((wL * left + wT * top + 32) >> 6);

        srcTop++;
      }
      srcLeft++;
      pDst += iDstStride;
    }
  }
  else
  {
#endif
    for (int y = 0; y < iHeight; y++)
    {
      const int  wT     = 32 >> std::min(31, ((y << 1) >> scale));
      const Pel  left   = *srcLeft;
      const Pel *srcTop = pSrc.buf + 1;

      for (int x = 0; x < iWidth; x++)
      {
        const int wL  = 32 >> std::min(31, ((x << 1) >> scale));
        const Pel top = *srcTop;
        const Pel val = pDst[x];

        pDst[x] = val + ((wL * (left - val) + wT * (top - val) + 32) >> 6);
        srcTop++;
      }

      srcLeft++;
      pDst += iDstStride;
    }
#if CIIP_PDPC
  }
#endif
}
#endif
#endif

#if JVET_Z0056_GPM_SPLIT_MODE_REORDERING && JVET_Y0065_GPM_INTRA
template <uint8_t partIdx>
bool IntraPrediction::xFillIntraGPMRefTemplateAll(PredictionUnit& pu, TemplateType eTempType, bool readBufferedMPMList, bool doInitMPMList, bool loadIntraRef, std::vector<Pel>* lut, uint8_t candIdx)
{
#if JVET_AG0164_AFFINE_GPM
  if (eTempType == NO_NEIGHBOR || candIdx < GEO_MAX_ALL_INTER_UNI_CANDS)
  {
    return false;
  }
#else
  if (eTempType == NO_NEIGHBOR || candIdx < GEO_MAX_NUM_UNI_CANDS)
  {
    return false;
  }
#endif
  doInitMPMList &= !readBufferedMPMList; // No MPM list derivation needed, since MPM list is read from buffer assuming it is already buffered
  const bool doInitAL = true;
  const bool doInitA  = partIdx == 0;
  const bool doInitL  = partIdx == 1;
#if JVET_AG0164_AFFINE_GPM
  uint8_t startIdx = candIdx == std::numeric_limits<uint8_t>::max() ? 0                       : (candIdx - GEO_MAX_ALL_INTER_UNI_CANDS);
#else
  uint8_t startIdx = candIdx == std::numeric_limits<uint8_t>::max() ? 0                       : (candIdx - GEO_MAX_NUM_UNI_CANDS);
#endif
  uint8_t endIdx   = candIdx == std::numeric_limits<uint8_t>::max() ? GEO_MAX_NUM_INTRA_CANDS : (startIdx + 1                   );
#if JVET_AJ0107_GPM_SHAPE_ADAPT
  for (int splitDirIdx = 0; splitDirIdx < GEO_NUM_PARTITION_MODE; splitDirIdx++)
  {
    int whIdx = !pu.cs->slice->getSPS()->getUseGeoShapeAdapt() ? GEO_SQUARE_IDX : Clip3(0, GEO_NUM_CU_SHAPES-1, floorLog2(pu.lwidth()) - floorLog2(pu.lheight()) + GEO_SQUARE_IDX);
    int splitDir = g_gpmSplitDir[whIdx][splitDirIdx];
    uint8_t* geoIntraMPMList = m_aiGpmIntraMPMLists[splitDirIdx][partIdx];
#else
  for (int splitDir = 0; splitDir < GEO_NUM_PARTITION_MODE; splitDir++)
  {
    uint8_t* geoIntraMPMList = m_aiGpmIntraMPMLists[splitDir][partIdx];
#endif
    if (!readBufferedMPMList)
    {
      PU::getGeoIntraMPMs(pu, geoIntraMPMList, splitDir, g_geoTmShape[partIdx][g_geoParams[splitDir][0]], doInitMPMList, doInitAL, doInitA, doInitL);
      doInitMPMList = false; // to prevent duplicating initialization
    }

    for (uint8_t tmpCandIdx = startIdx; tmpCandIdx < endIdx; ++tmpCandIdx)
    {
      uint8_t intraMode = geoIntraMPMList[tmpCandIdx];
      if (!m_abFilledIntraGPMRefTpl[intraMode])
      {
        xFillIntraGPMRefTemplate(pu, eTempType, intraMode, loadIntraRef, &m_acYuvRefGPMIntraTemplate[intraMode][0][0], &m_acYuvRefGPMIntraTemplate[intraMode][1][0], lut);
        loadIntraRef = false; // to prevent duplicating initialization
      }      
    }
  }

  return true;
}

bool IntraPrediction::xFillIntraGPMRefTemplate(PredictionUnit& pu, TemplateType eTempType, uint8_t intraMode, bool loadIntraRef, Pel* bufTop, Pel* bufLeft, std::vector<Pel>* lut)
{
  if (eTempType == NO_NEIGHBOR)
  {
    return false;
  }
  CHECK(intraMode >= NUM_INTRA_MODE, "Invalid intra mode for intra GPM template");
  m_abFilledIntraGPMRefTpl[intraMode] = true;

  const uint32_t uiPredStride = MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE;
  static Pel predLuma[uiPredStride * uiPredStride];
  
  int iTempWidth  = GEO_MODE_SEL_TM_SIZE;
  int iTempHeight = GEO_MODE_SEL_TM_SIZE;

  // Load reference samples
  if (loadIntraRef)
  {
    TemplateType tplType = (TemplateType)prefillIntraGPMReferenceSamples(pu, iTempWidth, iTempHeight);
    CHECK(eTempType != tplType, "Inconsistent template block availability");
  }
  else // Just need setting intra ref parameters, when ref samples have not been swapped out
  {
    m_ipaParam.multiRefIndex = iTempWidth;
    m_topRefLength = (pu.lwidth() + (eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0)) << 1;
    m_leftRefLength = (pu.lheight() + (eTempType != LEFT_NEIGHBOR ? iTempHeight : 0)) << 1;
  }

  // Generate intra pred samples
  int dirMode = intraMode > DC_IDX ? MAP67TO131(intraMode) : intraMode;
  uint32_t uiRealW = pu.lwidth()  + (eTempType != ABOVE_NEIGHBOR ? iTempWidth  : 0);
  uint32_t uiRealH = pu.lheight() + (eTempType != LEFT_NEIGHBOR  ? iTempHeight : 0);
  initPredTimdIntraParams(pu, pu.Y(), dirMode);
  predTimdIntraAng(COMPONENT_Y, pu, dirMode, predLuma, uiPredStride, uiRealW, uiRealH, eTempType, (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth, (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);

  // Store intra pred
  Pel* predSrcAbove = nullptr;
  Pel* predSrcLeft  = nullptr;
  if (eTempType == ABOVE_NEIGHBOR)
  {
    predSrcAbove = predLuma;
  }
  else if (eTempType == LEFT_NEIGHBOR)
  {
    predSrcLeft = predLuma;
  }
  else // Above-left
  {
    predSrcAbove = predLuma + iTempWidth;
    predSrcLeft  = predLuma + iTempHeight * uiPredStride;
  }

  if (predSrcAbove != nullptr)
  {
    Pel*   tmpSrc = predSrcAbove;
    Pel*   tmpDst = bufTop;
    if (lut == nullptr)
    {
      size_t szLine = sizeof(Pel) * pu.lwidth();
      for (int h = 0; h < iTempHeight; ++h)
      {
        memcpy(tmpDst, tmpSrc, szLine);
        tmpSrc += uiPredStride;
        tmpDst += pu.lwidth();
      }
    }
    else
    {
      for (int h = 0; h < iTempHeight; ++h)
      {
        for (int w = 0; w < pu.lwidth(); ++w)
        {
          tmpDst[w] = (*lut)[tmpSrc[w]];
        }
        tmpSrc += uiPredStride;
        tmpDst += pu.lwidth();
      }
    }
  }

  if (predSrcLeft != nullptr)
  {
    Pel*   tmpSrc = predSrcLeft;
    Pel*   tmpDst = bufLeft;
    if (lut == nullptr)
    {
      for (int h = 0; h < pu.lheight(); ++h)
      {
        for (int w = 0; w < iTempWidth; ++w)
        {
          tmpDst[w] = tmpSrc[w];
        }
        tmpSrc += uiPredStride;
        tmpDst += iTempWidth;
      }
    }
    else
    {
      for (int h = 0; h < pu.lheight(); ++h)
      {
        for (int w = 0; w < iTempWidth; ++w)
        {
          tmpDst[w] = (*lut)[tmpSrc[w]];
        }
        tmpSrc += uiPredStride;
        tmpDst += iTempWidth;
      }
    }
  }

  return true;
}

uint8_t IntraPrediction::prefillIntraGPMReferenceSamples(PredictionUnit& pu, int iTempWidth, int iTempHeight)
{
  int  iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;
  TemplateType eTempType = CU::deriveTimdRefType(pu.lx(), pu.ly(), pu.lwidth(), pu.lheight(), iTempWidth, iTempHeight, iRefX, iRefY, uiRefWidth, uiRefHeight);
    
  m_ipaParam.multiRefIndex = iTempWidth;
  initTimdIntraPatternLuma(*pu.cu, pu.Y(), (eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0), (eTempType != LEFT_NEIGHBOR ? iTempHeight : 0), uiRefWidth, uiRefHeight);

  return eTempType;
}

bool IntraPrediction::fillIntraGPMRefTemplateAll(PredictionUnit& pu, bool hasAboveTemplate, bool hasLeftTemplate, bool readBufferedMPMList, bool doInitMPMList, bool loadIntraRef, std::vector<Pel>* lut, uint8_t candIdx0, uint8_t candIdx1)
{
#if JVET_AG0164_AFFINE_GPM
  if (candIdx0 < GEO_MAX_ALL_INTER_UNI_CANDS && candIdx1 < GEO_MAX_ALL_INTER_UNI_CANDS)
#else
  if (candIdx0 < GEO_MAX_NUM_UNI_CANDS && candIdx1 < GEO_MAX_NUM_UNI_CANDS)
#endif
  {
    return false;
  }

  TemplateType templateType = (TemplateType)((hasAboveTemplate ? ABOVE_NEIGHBOR : 0) + (hasLeftTemplate ? LEFT_NEIGHBOR : 0));
  if (templateType == NO_NEIGHBOR)
  {
    return false;
  }
#if JVET_AG0164_AFFINE_GPM
  if (candIdx0 >= GEO_MAX_ALL_INTER_UNI_CANDS)
#else
  if (candIdx0 >= GEO_MAX_NUM_UNI_CANDS)
#endif
  {
    xFillIntraGPMRefTemplateAll<0>(pu, templateType, readBufferedMPMList, doInitMPMList, loadIntraRef, lut, candIdx0);
    doInitMPMList = false; // to prevent duplicating initialization
    loadIntraRef  = false; // to prevent duplicating initialization
  }
#if JVET_AG0164_AFFINE_GPM
  if (candIdx1 >= GEO_MAX_ALL_INTER_UNI_CANDS)
#else
  if (candIdx1 >= GEO_MAX_NUM_UNI_CANDS)
#endif
  {
    xFillIntraGPMRefTemplateAll<1>(pu, templateType, readBufferedMPMList, doInitMPMList, loadIntraRef, lut, candIdx1);
  }

  return true;
}
#endif

// ====================================================================================================================
// Public member functions
// ====================================================================================================================

// Function for calculating DC value of the reference samples used in Intra prediction
//NOTE: Bit-Limit - 25-bit source
Pel IntraPrediction::xGetPredValDc( const CPelBuf &pSrc, const Size &dstSize )
{
  CHECK( dstSize.width == 0 || dstSize.height == 0, "Empty area provided" );

  int idx, sum = 0;
  Pel dcVal;
  const int width  = dstSize.width;
  const int height = dstSize.height;
  const auto denom     = (width == height) ? (width << 1) : std::max(width,height);
  const auto divShift  = floorLog2(denom);
  const auto divOffset = (denom >> 1);
  const Pel* src;

  if ( width >= height )
  {
    src = pSrc.bufAt(m_ipaParam.multiRefIndex + 1, 0);
    for (idx = 0; idx < width; idx++)
    {
      sum += src[idx];
    }
  }
  if ( width <= height )
  {
    src = pSrc.bufAt(m_ipaParam.multiRefIndex + 1, 1);
    for (idx = 0; idx < height; idx++)
    {
      sum += src[idx];
    }
  }

  dcVal = (sum + divOffset) >> divShift;
  return dcVal;
}

int IntraPrediction::getModifiedWideAngle( int width, int height, int predMode )
{
  //The function returns a 'modified' wide angle index, given that it is not necessary 
  //in this software implementation to reserve the values 0 and 1 for Planar and DC to generate the prediction signal.
  //It should only be used to obtain the intraPredAngle parameter.
  //To simply obtain the wide angle index, the function PU::getWideAngle should be used instead.
  if ( predMode > DC_IDX && predMode <= VDIA_IDX )
  {
    int modeShift[] = { 0, 6, 10, 12, 14, 15 };
    int deltaSize = abs(floorLog2(width) - floorLog2(height));
    if (width > height && predMode < 2 + modeShift[deltaSize])
    {
      predMode += (VDIA_IDX - 1);
    }
    else if (height > width && predMode > VDIA_IDX - modeShift[deltaSize])
    {
      predMode -= (VDIA_IDX - 1);
    }
  }
  return predMode;
}
#if JVET_AC0094_REF_SAMPLES_OPT
int IntraPrediction::getTimdWideAngle(int width, int height, int predMode)
{
  int modeShift[] = { 0, 6, 10, 12, 14, 15 };
  int deltaSize   = abs(floorLog2(width) - floorLog2(height));
  int maxIndex    = modeShift[std::min(deltaSize + 2, 5)];
  // Case 1: using a regular mode removed due to WAIP
  if (width > height && predMode < DC_IDX + 1 + maxIndex)
  {
    predMode = (predMode == VDIA_IDX ? DC_IDX + 1 : predMode + 1);
  }
  else if (height > width && predMode > VDIA_IDX - maxIndex)
  {
    predMode = (predMode == DC_IDX + 1 ? VDIA_IDX : predMode - 1);
  }
  // Case 2: using a mode not usually allowed on this block size
  else if (predMode > VDIA_IDX)
  {
    predMode -= (VDIA_IDX - 2);
  }
  else if (predMode < VDIA_IDX)
  {
    predMode += (VDIA_IDX - 2);
  }
  return predMode;
}
#endif

#if JVET_W0123_TIMD_FUSION
#if JVET_AB0155_SGPM
int IntraPrediction::getWideAngleExt(int width, int height, int predMode, bool bSgpm)
#else
int IntraPrediction::getWideAngleExt( int width, int height, int predMode )
#endif
{
  if ( predMode > DC_IDX && predMode <= EXT_VDIA_IDX )
  {
    int modeShift[] = { 0, 11, 19, 23, 27, 29 };
    int deltaSize = abs(floorLog2(width) - floorLog2(height));
    if (width > height && predMode < 2 + modeShift[deltaSize])
    {
#if JVET_AB0155_SGPM
      if (bSgpm)
      {
        predMode += EXT_VDIA_IDX;
      }
      else
      {
        predMode += (EXT_VDIA_IDX - 1);
      }
#else
      predMode += (EXT_VDIA_IDX - 1);
#endif
    }
    else if (height > width && predMode > EXT_VDIA_IDX - modeShift[deltaSize])
    {
#if JVET_AB0155_SGPM
      if (bSgpm)
      {
        predMode -= EXT_VDIA_IDX;
      }
      else
      {
        predMode -= (EXT_VDIA_IDX - 1);
      }
#else
      predMode -= (EXT_VDIA_IDX - 1);
#endif
    }
  }
  return predMode;
}
#if JVET_AC0094_REF_SAMPLES_OPT
int IntraPrediction::getTimdWideAngleExt(int width, int height, int predMode)
{
  int modeShift[] = { 0, 11, 19, 23, 27, 29 };
  int deltaSize   = abs(floorLog2(width) - floorLog2(height));
  int maxIndex    = modeShift[std::min(deltaSize, 5)];
  // Case 1: using a regular mode removed due to WAIP
  if (width > height && predMode < DC_IDX + 1 + maxIndex)
  {
    predMode = (predMode == EXT_VDIA_IDX ? DC_IDX + 1 : predMode + 1);
  }
  else if (height > width && predMode > EXT_VDIA_IDX - maxIndex)
  {
    predMode = (predMode == DC_IDX + 1 ? EXT_VDIA_IDX : predMode - 1);
  }
  // Case 2: using a mode not usually allowed on this block size
  else if (predMode > EXT_DIA_IDX)
  {
    predMode -= (EXT_VDIA_IDX - 2);
  }
  else if (predMode < EXT_DIA_IDX)
  {
    predMode += (EXT_VDIA_IDX - 2);
  }
  return predMode;
}

int IntraPrediction::getTimdRegularAngleExt(int width, int height, int predMode)
{
  int modeShift[] = { 0, 11, 19, 23, 27, 29 };
  int deltaSize   = abs(floorLog2(width) - floorLog2(height));
  int maxIndex    = modeShift[std::min(deltaSize + 2, 5)];
  // Treat edge cases for first and last angular IPMs, 2 and EXT_VDIA_IDX
  if (predMode == EXT_VDIA_IDX)
  {
    return DC_IDX + 1;
  }
  if (predMode == DC_IDX + 1)
  {
    return EXT_VDIA_IDX;
  }
  // Case 1: using a regular mode removed due to WAIP
  if (width > height && predMode <= DC_IDX + 1 + maxIndex && predMode > DC_IDX)
  {
    predMode = predMode - 1;
  }
  else if (height > width && predMode >= EXT_VDIA_IDX - maxIndex && predMode <= EXT_VDIA_IDX)
  {
    predMode = predMode + 1;
  }
  // Case 2: using a mode not usually allowed on this block size
  else if (predMode > EXT_VER_IDX)
  {
    predMode -= (EXT_VDIA_IDX - 2);
  }
  else if (predMode < EXT_HOR_IDX)
  {
    predMode += (EXT_VDIA_IDX - 2);
  }
  CHECK(predMode < DC_IDX + 1 || predMode > EXT_VDIA_IDX, "luma mode out of range");
  return predMode;
}
#endif
#endif

void IntraPrediction::setReferenceArrayLengths( const CompArea &area )
{
  // set Top and Left reference samples length
  const int  width    = area.width;
  const int  height   = area.height;

#if JVET_AC0094_REF_SAMPLES_OPT
  m_leftRefLength = height << 3;
  m_topRefLength  = width << 3;
#else
  m_leftRefLength     = (height << 1);
  m_topRefLength      = (width << 1);
#endif
}
#if JVET_AH0209_PDP
void IntraPrediction::predIntraAng(const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu,
#if JVET_AK0118_BF_FOR_INTRA_PRED
    const bool forceBfOff,
#endif
    const bool applyFusion, const bool applyPDPFilter)
#elif JVET_AB0157_INTRA_FUSION
void IntraPrediction::predIntraAng( const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu, const bool applyFusion)
#else
void IntraPrediction::predIntraAng( const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu)
#endif
{
#if CIIP_PDPC
  CHECK((pu.ciipFlag == false && pu.ciipPDPC == true),"ciip_PDPC can not be true for an non CIIP PU");
#endif
  const ComponentID    compID       = MAP_CHROMA( compId );
  const ChannelType    channelType  = toChannelType( compID );
  const int            iWidth       = piPred.width;
  const int            iHeight      = piPred.height;
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
  CHECK(iWidth == 2, "Width of 2 is not supported");
#endif

  CHECK(PU::isMIP(pu, toChannelType(compId)), "We should not get here for MIP.");
  const uint32_t       uiDirMode    = isLuma( compId ) && pu.cu->bdpcmMode ? BDPCM_IDX : !isLuma(compId) && pu.cu->bdpcmModeChroma ? BDPCM_IDX : PU::getFinalIntraMode(pu, channelType);

#if JVET_AD0085_TMRL_EXTENSION
  bool bExtIntraDir = false;
#if JVET_W0123_TIMD_FUSION
  bExtIntraDir |= (pu.cu->timd && isLuma(compId));
#endif
#if JVET_AD0085_TMRL_EXTENSION
  bExtIntraDir |= (pu.cu->tmrlFlag && isLuma(compId));
#endif
#else
#if JVET_W0123_TIMD_FUSION
  bool bExtIntraDir = pu.cu->timd && isLuma( compId );
#endif
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
  int blkQp = pu.cu->qp;
  bool applyBf = false;
  CodingStructure& cs = *pu.cu->cs;
  const bool intraPredBfEnabled = cs.sps->getUseIntraPredBf();
  const bool isIntraSlice = cs.slice->isIntra() ? true : false;
#endif

#if JVET_AG0152_SGPM_ITMP_IBC
  bool isBvPredicted = 0;
  if (pu.cu->sgpm && pu.cu->sgpmMode0 >= SGPM_BV_START_IDX &&  isLuma( compId ) )
  {
    isBvPredicted = 1;
    Mv bv = pu.cu->sgpmBv0;
#if JVET_AH0200_INTRA_TMP_BV_REORDER
    predUsingBv(piPred.buf, piPred.stride, bv, *pu.cu, false);
#else
    predUsingBv(piPred.buf, piPred.stride, bv, *pu.cu);
#endif
  }
#endif
  CHECK( floorLog2(iWidth) < 2 && pu.cs->pcv->noChroma2x2, "Size not allowed" );
  CHECK( floorLog2(iWidth) > 7, "Size not allowed" );

  const int srcStride  = m_refBufferStride[compID];
  const int srcHStride = 2;

  const CPelBuf & srcBuf = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
  const ClpRng& clpRng(pu.cu->cs->slice->clpRng(compID));

#if JVET_AB0157_INTRA_FUSION
  const CPelBuf & srcBuf2nd = CPelBuf(m_refBuffer2nd[compID], srcStride+1, srcHStride);
#endif

#if JVET_AG0152_SGPM_ITMP_IBC
  if (!isBvPredicted)
  {
#endif
#if JVET_AH0209_PDP
    bool pdpWasApplied = false;
#endif
#if CIIP_PDPC
  if (!pu.ciipPDPC)
  {
#endif
#if JVET_AH0209_PDP
    const uint32_t width = pu.lwidth();
    const uint32_t height = pu.lheight();
    const int sizeKey = (width << 8) + height;
    const int sizeIdx = g_size.find( sizeKey ) != g_size.end() ? g_size[sizeKey] : -1;
    
    if ( isLuma( compId ) && sizeIdx >= 0 && applyPDPFilter && m_refAvailable && !pu.cu->ispMode && uiDirMode != BDPCM_IDX
      && pu.cu->cs->sps->getUsePDP()
      && !pu.cu->plIdx && !pu.cu->sgpm
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      && !pu.cu->timd && !pu.cu->tmrlFlag && !pu.multiRefIdx && !(uiDirMode == PNN_IDX))
#else
      && !pu.cu->timd && !pu.cu->tmrlFlag && !pu.multiRefIdx)
#endif
    {
#if JVET_AI0208_PDP_MIP
      if ((pu.cu->mipFlag ? ( pu.mipTransposedFlag ? g_pdpFiltersMip[uiDirMode+16][sizeIdx] : g_pdpFiltersMip[uiDirMode][sizeIdx]) : g_pdpFilters[uiDirMode][sizeIdx]) && ( pu.cu->mipFlag || !(uiDirMode > 1 && (uiDirMode % 2))) )
#else
      if (g_pdpFilters[uiDirMode][sizeIdx] && !(uiDirMode > 1 && (uiDirMode % 2)))
#endif
      {
        if (pu.cu->cs->pcv->isEncoder && m_pdpIntraPredReady[uiDirMode])
        {
          CHECK( m_pdpIntraPredBufIP[ uiDirMode ] == nullptr, "PDP predictor unavailable" );
          PelBuf predBuf(m_pdpIntraPredBufIP[uiDirMode], pu.Y());
          piPred.copyFrom(predBuf);

          if (!pu.cu->dimd)
          {
            return;
          }
          pdpWasApplied = true;
        }
        else if (m_xPredIntraOpt(piPred, pu, uiDirMode, clpRng, m_ref, m_refShort))
        {
          if (!pu.cu->dimd)
          {
            return;
          }
          pdpWasApplied = true;
        }
      }
    }

    if( !pdpWasApplied )
#endif
    switch (uiDirMode)
    {
#if JVET_AC0105_DIRECTIONAL_PLANAR
    case (PLANAR_IDX): xPredIntraPlanar(srcBuf, piPred, isLuma(compID) ? pu.cu->plIdx : 0); break;
#else
    case (PLANAR_IDX): xPredIntraPlanar(srcBuf, piPred); break;
#endif
    case(DC_IDX):     xPredIntraDc(srcBuf, piPred, channelType, false); break;
    case(BDPCM_IDX):  xPredIntraBDPCM(srcBuf, piPred, isLuma(compID) ? pu.cu->bdpcmMode : pu.cu->bdpcmModeChroma, clpRng); break;
#if JVET_AJ0249_NEURAL_NETWORK_BASED
    case(PNN_IDX):
#if JVET_AK0118_BF_FOR_INTRA_PRED
      applyBf = ( !isIntraSlice || !intraPredBfEnabled ) ? false : true;
      if( applyBf )
      {
        applyBf = checkBfApplication(blkQp, piPred.width, piPred.height);
      }
#endif
      xPredIntraPnn(pu.cs->picture->getRecoBuf(pu.cu->block(compID)), piPred, srcBuf, *pu.cu, compID
#if JVET_AK0118_BF_FOR_INTRA_PRED
      , applyBf
#endif
      );
      break;
#endif
#if JVET_W0123_TIMD_FUSION
#if JVET_AB0157_INTRA_FUSION
    default:
#if !JVET_AB0155_SGPM
      int weightMode = ((pu.cu->timd && pu.cu->timdIsBlended) || !applyFusion) ? 4 : 3;
#else
#if JVET_AJ0146_TIMDSAD
      bool timdIsBlended = pu.cu->timdSad ?  pu.cu->timdIsBlendedSad : pu.cu->timdIsBlended;
      int weightMode = ((pu.cu->timd && timdIsBlended) || !applyFusion || (PU::isSgpm(pu, CHANNEL_TYPE_LUMA))) ? 4 : 3;
#else
      int weightMode = ((pu.cu->timd && pu.cu->timdIsBlended) || !applyFusion || (PU::isSgpm(pu, CHANNEL_TYPE_LUMA))) ? 4 : 3;
#endif
#if JVET_AJ0061_TIMD_MERGE
      if (pu.cu->timd && pu.cu->timdMrg && isLuma(compID))
      {
        weightMode = ((pu.cu->timd && pu.cu->timdMrgIsBlended[pu.cu->timdMrg - 1]) || !applyFusion || (PU::isSgpm(pu, CHANNEL_TYPE_LUMA))) ? 4 : 3;
      }
#endif
#endif
#if JVET_AC0112_IBC_CIIP
      if (pu.ibcCiipFlag)
      {
        weightMode = 4;
      }
#endif
#if JVET_AC0112_IBC_GPM
      if (pu.ibcGpmFlag)
      {
        weightMode = 4;
      }
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
      applyBf = ( pu.cu->timd || pu.cu->timdSad || pu.cu->obicFlag || pu.cu->dimd || (isLuma(compID) && PU::isSgpm(pu)) || forceBfOff || !isIntraSlice || !intraPredBfEnabled ) ? false : true;
      if( applyBf )
      {
        applyBf = checkBfApplication(blkQp, piPred.width, piPred.height);
        int intraMode = bExtIntraDir ? uiDirMode >> 1 : uiDirMode;
        applyBf &= checkBfModeApplication( intraMode );
      }

      xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      pu,
#endif
      srcBuf, piPred, channelType, clpRng, bExtIntraDir, srcBuf2nd, applyBf, cs, blkQp, pu, pu.cu->ispMode != NOT_INTRA_SUBPARTITIONS, weightMode); break;
#else
      xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
        pu,
#endif
        srcBuf, piPred, channelType, clpRng, bExtIntraDir, srcBuf2nd, pu.cu->ispMode != NOT_INTRA_SUBPARTITIONS, weightMode);
        break;
#endif
#else
    default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      pu,
#endif
      srcBuf, piPred, channelType, clpRng, bExtIntraDir); break;
#endif
#else
    default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      pu,
#endif
      srcBuf, piPred, channelType, clpRng); break;
#endif
    }
#if CIIP_PDPC
  }
#endif

#if JVET_AH0209_PDP
  if( !pdpWasApplied )
  {
#endif
#if JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
    if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && (uiDirMode == PLANAR_IDX || uiDirMode == DC_IDX) )
    {
      xIntraPredPlanarDcPdpc( srcBuf, piPred.buf, piPred.stride, iWidth, iHeight, pu.ciipPDPC );
    }
#else
    if( m_ipaParam.applyPDPC && (uiDirMode == PLANAR_IDX || uiDirMode == DC_IDX) )
    {
      xIntraPredPlanarDcPdpc( srcBuf, piPred.buf, piPred.stride, iWidth, iHeight );
    }
#endif
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
    if( uiDirMode == PLANAR_IDX || uiDirMode == DC_IDX )
    {
      applyBf = ( pu.cu->timd || pu.cu->timdSad || pu.cu->obicFlag || pu.cu->dimd || (isLuma(compID) && PU::isSgpm(pu)) || forceBfOff || !isIntraSlice || !intraPredBfEnabled ) ? false : true;
      if( applyBf )
      {
        applyBf = checkBfApplication(blkQp, piPred.width, piPred.height);
      }

      if( applyBf )
      {
        int blkWidth = piPred.width;
        int blkHeight = piPred.height;
        bilateralFilterPredDiamond5x5Clip(cs, toChannelType(compID), piPred, blkWidth, blkHeight, blkQp, clpRng, true, *pu.cu );
      }
    }
#endif
#if JVET_AH0209_PDP
  }
#endif
#if JVET_AG0152_SGPM_ITMP_IBC
  }
#endif

#if ENABLE_DIMD
#if JVET_AB0157_INTRA_FUSION
#if JVET_AH0076_OBIC
  if (pu.cu->dimd && pu.cu->dimdBlending && isLuma(compID) && !pu.cu->obicFlag)
#else
  if (pu.cu->dimd && pu.cu->dimdBlending && isLuma(compID))
#endif
  {
    int width = piPred.width;
    int height = piPred.height;
    const UnitArea localUnitArea( pu.chromaFormat, Area( 0, 0, width, height ) );

    PelBuf planarBuffer = m_tempBuffer[0].getBuf( localUnitArea.Y() );
#if JVET_AH0076_OBIC
    const bool applyPdpc = m_ipaParam.applyPDPC;
    initIntraPatternChType(*pu.cu, pu.Y(), true, 0, false);
#endif
#if JVET_AG0146_DIMD_ITMP_IBC
    if (pu.cu->isBvDimd && pu.cu->ispMode == 0)
    {
      predUsingBv(planarBuffer.buf, planarBuffer.stride, pu.cu->bvDimd, *pu.cu);
    }
    else
    {
#endif
#if JVET_AH0076_OBIC
      PredictionUnit puTmp = pu;
      puTmp.intraDir[0] = PLANAR_IDX;
      initPredIntraParams(puTmp, pu.Y(), *(pu.cs->sps));
      const CPelBuf &srcBuf = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
#if JVET_AC0105_DIRECTIONAL_PLANAR
      xPredIntraPlanar(srcBuf, planarBuffer, 0);
#else
      xPredIntraPlanar(srcBuf, planarBuffer);
#endif
      if (m_ipaParam.applyPDPC)
      {
        xIntraPredPlanarDcPdpc( srcBuf, planarBuffer.buf, planarBuffer.stride, width, height, false );
      }
#else
#if JVET_AC0105_DIRECTIONAL_PLANAR
    xPredIntraPlanar(srcBuf, planarBuffer, 0);
#else
    xPredIntraPlanar(srcBuf, planarBuffer);
#endif
#endif
#if JVET_AG0146_DIMD_ITMP_IBC
    }
#endif
#if !JVET_AH0076_OBIC
    const bool applyPdpc = m_ipaParam.applyPDPC;
#endif

    bool blendModes[DIMD_FUSION_NUM-2] = {false};
    PelBuf predAngExtra[DIMD_FUSION_NUM-2];
    for( int i = 0; i < DIMD_FUSION_NUM-2; ++i)
    {
#if JVET_AC0098_LOC_DEP_DIMD
      blendModes[i] = (pu.cu->dimdBlendMode[i] != PLANAR_IDX);
#else
      blendModes[i] = (i==0 || pu.cu->dimdBlendMode[i] != PLANAR_IDX);
#endif
      if(blendModes[i])
      {
        predAngExtra[i] = m_tempBuffer[i + 1].getBuf( localUnitArea.Y() );
        PredictionUnit puTmp = pu;
        puTmp.intraDir[0] = pu.cu->dimdBlendMode[i];
        initPredIntraParams(puTmp, pu.Y(), *(pu.cs->sps));
#if JVET_AH0076_OBIC
        const CPelBuf &srcBuf = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
#endif

#if JVET_AH0209_PDP
        const int sizeKey = (width << 8) + height;
        const int sizeIdx = g_size.find( sizeKey ) != g_size.end() ? g_size[sizeKey] : -1;
        auto modeIdx = puTmp.intraDir[0];
        if (pu.cu->cs->pcv->isEncoder && m_pdpIntraPredReady[puTmp.intraDir[0]])
        {
          CHECK( m_pdpIntraPredBufIP[ puTmp.intraDir[ 0 ] ] == nullptr, "PDP predictor unavailable" );
          PelBuf predBuf(m_pdpIntraPredBufIP[puTmp.intraDir[0]], pu.Y());
          predAngExtra[i].copyFrom(predBuf);
        }
        else if( sizeIdx >= 0 && applyPDPFilter && m_refAvailable && !pu.cu->ispMode && puTmp.intraDir[0] != BDPCM_IDX
            && puTmp.cu->cs->sps->getUsePDP()
            && !puTmp.multiRefIdx
            && g_pdpFilters[modeIdx][sizeIdx]
            && m_xPredIntraOpt( predAngExtra[i], puTmp, modeIdx, clpRng, m_ref, m_refShort)
            )
        {

        }
        else
        {
#endif
#if JVET_W0123_TIMD_FUSION
#if JVET_AK0118_BF_FOR_INTRA_PRED
          applyBf = false;
          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
          pu,
#endif
          srcBuf, predAngExtra[i], channelType, clpRng, false, srcBuf2nd, applyBf, cs, blkQp, pu, pu.cu->ispMode!=NOT_INTRA_SUBPARTITIONS);
#else
        xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
          pu,
#endif
          srcBuf, predAngExtra[i], channelType, clpRng, false, srcBuf2nd, pu.cu->ispMode!=NOT_INTRA_SUBPARTITIONS);
#endif
#else
        xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
          pu,
#endif
          srcBuf, predAngExtra[i], channelType, clpRng);
#endif
#if JVET_AH0209_PDP
        }
#endif
      }
    }

    m_ipaParam.applyPDPC = applyPdpc;

    // do blending
#if JVET_AC0098_LOC_DEP_DIMD
#if JVET_AJ0267_ADAPTIVE_HOG
    PelBuf predAngVer       = m_tempBuffer[DIMD_FUSION_NUM - 1].getBuf( localUnitArea.Y() );
    PelBuf predAngHor       = m_tempBuffer[DIMD_FUSION_NUM].getBuf( localUnitArea.Y() );
    PelBuf predAngNonLocDep = m_tempBuffer[DIMD_FUSION_NUM + 1].getBuf( localUnitArea.Y() );
#else
    PelBuf predAngNonLocDep = m_tempBuffer[7].getBuf( localUnitArea.Y() );
    PelBuf predAngVer       = m_tempBuffer[5].getBuf( localUnitArea.Y() );
    PelBuf predAngHor       = m_tempBuffer[6].getBuf( localUnitArea.Y() );
#endif

    Pel* pelVer = predAngVer.buf;
    int strideVer = predAngVer.stride;
    Pel* pelHor = predAngHor.buf;
    int strideHor = predAngHor.stride;
    Pel *pelNonLocDep = predAngNonLocDep.buf;
    int strideNonLocDep = predAngNonLocDep.stride;

    bool useLocDepBlending = false;
    int weightVer = 0, weightHor = 0, weightNonLocDep = 0;
    weightNonLocDep += pu.cu->dimdRelWeight[1];
    for (int i = 0; i < DIMD_FUSION_NUM-1; i++)
    {
      if (i == 0  || blendModes[i-1])
      {
        if (pu.cu->dimdLocDep[i] == 1)
        {
          weightVer += (i == 0 ? pu.cu->dimdRelWeight[0] : pu.cu->dimdRelWeight[i+ 1]);
        }
        else if (pu.cu->dimdLocDep[i] == 2)
        {
          weightHor += (i == 0 ? pu.cu->dimdRelWeight[0] : pu.cu->dimdRelWeight[i+ 1]);
        }
        else
        {
          weightNonLocDep += (i == 0 ? pu.cu->dimdRelWeight[0] : pu.cu->dimdRelWeight[i+1]);
        }
      }
    }

    if(weightHor || weightVer)
    {
      useLocDepBlending = true;
    }

    if(!useLocDepBlending)
    {
      pelNonLocDep = piPred.buf;
      strideNonLocDep = piPred.stride;
    }

    for (int locDep = 0; locDep < 3; locDep++)
    {
      int totWeight = (locDep == 0 ? weightNonLocDep : (locDep == 1 ? weightVer : weightHor));
      if (totWeight == 0)
      {
        continue;
      }

#if JVET_AJ0267_ADAPTIVE_HOG
      int weights[DIMD_FUSION_NUM] = {0};
      weights[0] =  (pu.cu->dimdLocDep[0] == locDep) ? pu.cu->dimdRelWeight[0] : 0;
      for (int i = 1; i < DIMD_FUSION_NUM - 1; i ++)
      {
        weights[i] =  (blendModes[i - 1] && pu.cu->dimdLocDep[i] == locDep) ? pu.cu->dimdRelWeight[i + 1] : 0;
      }
      weights[DIMD_FUSION_NUM - 1] =  (locDep == 0) ? pu.cu->dimdRelWeight[1] : 0;
#else
      int weights[6] = {0};
      weights[0] =  (pu.cu->dimdLocDep[0] == locDep) ? pu.cu->dimdRelWeight[0] : 0;
      weights[1] =  (blendModes[0] && pu.cu->dimdLocDep[1] == locDep) ? pu.cu->dimdRelWeight[2] : 0;
      weights[2] =  (blendModes[1] && pu.cu->dimdLocDep[2] == locDep) ? pu.cu->dimdRelWeight[3] : 0;
      weights[3] =  (blendModes[2] && pu.cu->dimdLocDep[3] == locDep) ? pu.cu->dimdRelWeight[4] : 0;
      weights[4] =  (blendModes[3] && pu.cu->dimdLocDep[4] == locDep) ? pu.cu->dimdRelWeight[5] : 0;
      weights[5] =  (locDep == 0) ? pu.cu->dimdRelWeight[1] : 0;
#endif

      int num2blend = 0;
      int blendIndexes[DIMD_FUSION_NUM] = {0};
      for (int i = 0; i < DIMD_FUSION_NUM; i++)
      {
        if (weights[i] != 0)
        {
          blendIndexes[num2blend] = i;
          num2blend++;
        }
      }
#if JVET_W0123_TIMD_FUSION
      if( (num2blend == 1 ) || (num2blend <=3 && (totWeight == (1 << (floorLog2(totWeight))) ) ))
      {
        int index = blendIndexes[0];    
        if(locDep == 0)
        {
#if JVET_AJ0267_ADAPTIVE_HOG
          pelNonLocDep = (index == 0 ? piPred.buf : (index == (DIMD_FUSION_NUM - 1) ? planarBuffer.buf : predAngExtra[index-1].buf));
          strideNonLocDep = (index == 0 ? piPred.stride : (index == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index-1].stride));
#else
          pelNonLocDep = (index == 0 ? piPred.buf : (index == 5 ? planarBuffer.buf : predAngExtra[index-1].buf));
          strideNonLocDep = (index == 0 ? piPred.stride : (index == 5 ? planarBuffer.stride : predAngExtra[index-1].stride));
#endif
        }
        else if(locDep == 1)
        {
          pelVer = (index == 0 ? piPred.buf : predAngExtra[index-1].buf);
          strideVer = (index == 0 ? piPred.stride : predAngExtra[index-1].stride);
        }
        else
        {
          pelHor = (index == 0 ? piPred.buf : predAngExtra[index-1].buf);
          strideHor = (index == 0 ? piPred.stride : predAngExtra[index-1].stride);
        }
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

        int factor = 64 / totWeight;
        if (num2blend == 2)
        {
          int index1 = blendIndexes[1];
#if JVET_AJ0267_ADAPTIVE_HOG
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == (DIMD_FUSION_NUM - 1) ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index1-1].stride));
#else
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 5 ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 5 ? planarBuffer.stride : predAngExtra[index1-1].stride));
#endif

          int w0 = (weights[index]*factor);
          int w1 = 64 - w0;
          m_timdBlending(pCur, strideCur, p1, stride1, w0, w1,width, height);
        }
        else if(num2blend == 3)
        {
          int index1 = blendIndexes[1];
#if JVET_AJ0267_ADAPTIVE_HOG
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == (DIMD_FUSION_NUM - 1) ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index1-1].stride));
#else
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 5 ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 5 ? planarBuffer.stride : predAngExtra[index1-1].stride));
#endif

          int index2 = blendIndexes[2];
#if JVET_AJ0267_ADAPTIVE_HOG
          Pel* p2 = (index2 == 0 ? piPred.buf : (index2 == (DIMD_FUSION_NUM - 1) ?  planarBuffer.buf : predAngExtra[index2-1].buf));
          int stride2 = (index2 == 0 ? piPred.stride : (index2 == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index2-1].stride));
#else
          Pel* p2 = (index2 == 0 ? piPred.buf : (index2 == 5 ?  planarBuffer.buf : predAngExtra[index2-1].buf));
          int stride2 = (index2 == 0 ? piPred.stride : (index2 == 5 ? planarBuffer.stride : predAngExtra[index2-1].stride));
#endif

          int w0 = (weights[index]*factor);
          int w1 = (weights[index1]*factor);
          int w2 = 64  - w0 - w1;
          m_dimdBlending(pCur, strideCur, p1, stride1, p2, stride2, w0, w1, w2, width, height);
        }
      }
      else
#endif
      {
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));
        Pel *pelPlanar = planarBuffer.buf;        
        int stridePlanar = planarBuffer.stride;

#if JVET_AJ0267_ADAPTIVE_HOG
        Pel *pelPredAng[DIMD_FUSION_NUM - 1];
        int strides[DIMD_FUSION_NUM - 1];
        pelPredAng[0] = piPred.buf;
        strides[0] = piPred.stride;
        for (int i = 1; i < DIMD_FUSION_NUM - 1; i++)
        {
          pelPredAng[i] = predAngExtra[i - 1].buf;
          strides[i] = predAngExtra[i - 1].stride;
        }
        for( int y = 0; y < height; y++ )
        {
          for( int x = 0; x < width; x++ )
          {
            int blend = pelPredAng[0][x] * weights[0];
            for (int i = 1; i < DIMD_FUSION_NUM - 1; i++)
            {
              blend += blendModes[i - 1] ? pelPredAng[i][x] * weights[i] : 0;
            }
            blend += pelPlanar[x] * weights[DIMD_FUSION_NUM - 1];
            pCur[x] = (Pel)(blend / totWeight);
          }
          pCur += strideCur;
          for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
          {
            pelPredAng[i] += strides[i];
          }
          pelPlanar += stridePlanar;
        }
#else
        Pel *pelPredAng0 = piPred.buf;
        Pel *pelPredAng1 = predAngExtra[0].buf;
        Pel *pelPredAng2 = predAngExtra[1].buf;
        Pel *pelPredAng3 = predAngExtra[2].buf;
        Pel *pelPredAng4 = predAngExtra[3].buf;
        int stride0 = piPred.stride;
        int stride1 = predAngExtra[0].stride;
        int stride2 = predAngExtra[1].stride;
        int stride3 = predAngExtra[2].stride;
        int stride4 = predAngExtra[3].stride;
        for( int y = 0; y < height; y++ )
        {
          for( int x = 0; x < width; x++ )
          {
            int blend = pelPredAng0[x] * weights[0];
            blend += blendModes[0] ? pelPredAng1[x] * weights[1] : 0;
            blend += blendModes[1] ? pelPredAng2[x] * weights[2] : 0;
            blend += blendModes[2] ? pelPredAng3[x] * weights[3] : 0;
            blend += blendModes[3] ? pelPredAng4[x] * weights[4] : 0;
            blend += pelPlanar[x] * weights[5];
            pCur[x] = (Pel)(blend / totWeight);
          }
          pCur += strideCur;
          pelPredAng0 += stride0;
          pelPredAng1 += stride1;
          pelPredAng2 += stride2;
          pelPredAng3 += stride3;
          pelPredAng4 += stride4;
          pelPlanar += stridePlanar;
        }
#endif
      }
    }

    if (useLocDepBlending)
    {
      int mode = ((weightHor > 0 && weightVer > 0) ? 0 : (weightVer > 0 ? 1 : 2));

      Pel *pelDst = piPred.buf;
      int strideDst = piPred.stride;
#if JVET_W0123_TIMD_FUSION && JVET_AG0092_ENHANCED_TIMD_FUSION
      xLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#else
      xDimdLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#endif
    }
#if JVET_AK0118_BF_FOR_INTRA_PRED
    applyBf = ( !isIntraSlice || !intraPredBfEnabled ) ? false : true;
    if( applyBf )
    {
      applyBf = checkBfApplication(blkQp, piPred.width, piPred.height);
    }

    if( applyBf )
    {
      int blkWidth = piPred.width;
      int blkHeight = piPred.height;
      bilateralFilterPredDiamond5x5Clip(cs, CHANNEL_TYPE_LUMA, piPred, blkWidth, blkHeight, blkQp, clpRng, true, *pu.cu );
    }
#endif
#else
    const int log2WeightSum = 6;
    Pel *pelPred = piPred.buf;
    Pel *pelPlanar = planarBuffer.buf;
    Pel *pelPredAng = predAngExtra[0].buf;
    int  w0 = pu.cu->dimdRelWeight[0], w1 = pu.cu->dimdRelWeight[1], w2 = pu.cu->dimdRelWeight[2];

    Pel *pelPredAng2 = predAngExtra[1].buf;
    Pel *pelPredAng3 = predAngExtra[2].buf;
    Pel *pelPredAng4 = predAngExtra[3].buf;
    int  w3         = pu.cu->dimdRelWeight[3];
    int  w4         = pu.cu->dimdRelWeight[4];
    int  w5         = pu.cu->dimdRelWeight[5];

    for( int y = 0; y < height; y++ )
    {
      for( int x = 0; x < width; x++ )
      {
        int blend = pelPred[x] * w0;
        blend += pelPlanar[x] * w1;
#if JVET_AC0098_LOC_DEP_DIMD
        blend += blendModes[0] ? pelPredAng[x] * w2 : 0;
#else
        blend += pelPredAng[x] * w2;
#endif
        blend += blendModes[1] ? pelPredAng2[x] * w3 : 0;
        blend += blendModes[2] ? pelPredAng3[x] * w4 : 0;
        blend += blendModes[3] ? pelPredAng4[x] * w5 : 0;
        pelPred[x] = (Pel)(blend >> log2WeightSum);
      }

      pelPred += piPred.stride;
      pelPlanar += planarBuffer.stride;
      pelPredAng += predAngExtra[0].stride;
      pelPredAng2 += predAngExtra[1].stride;
      pelPredAng3 += predAngExtra[2].stride;
      pelPredAng4 += predAngExtra[3].stride;
    }
#endif
  }
#else
  if (pu.cu->dimd && pu.cu->dimdBlending && isLuma(compID))
  {
    int width = piPred.width;
    int height = piPred.height;
    const UnitArea localUnitArea( pu.chromaFormat, Area( 0, 0, width, height ) );

    PelBuf planarBuffer = m_tempBuffer[0].getBuf( localUnitArea.Y() );
    PelBuf predAng = m_tempBuffer[1].getBuf( localUnitArea.Y() );

#if JVET_AC0105_DIRECTIONAL_PLANAR
    xPredIntraPlanar(srcBuf, planarBuffer, 0);
#else
    xPredIntraPlanar(srcBuf, planarBuffer);
#endif

    const bool applyPdpc = m_ipaParam.applyPDPC;
#if JVET_AC0098_LOC_DEP_DIMD
    if (pu.cu->dimdBlendMode[0] != 0)
    {
#endif
#if JVET_V0087_DIMD_NO_ISP   // this is pure cleanup to make code easier to read. It generates identical resut to the else part
    PredictionUnit pu2 = pu;
    pu2.intraDir[0] = pu.cu->dimdBlendMode[0];
    initPredIntraParams(pu2, pu.Y(), *(pu.cs->sps));

#if JVET_W0123_TIMD_FUSION
    xPredIntraAng(srcBuf, predAng, channelType, clpRng, false);
#else
    xPredIntraAng(srcBuf, predAng, channelType, clpRng);
#endif
#if JVET_AC0098_LOC_DEP_DIMD
    }
    else
    {
      predAng = piPred;
    }
#endif
#else
    const bool   useISP = NOT_INTRA_SUBPARTITIONS != pu.cu->ispMode && isLuma( CHANNEL_TYPE_LUMA );//ok
    const Size   cuSize = Size( pu.cu->blocks[compId].width, pu.cu->blocks[compId].height ); //ok
    const Size   puSize = Size( piPred.width, piPred.height );
    const Size&  blockSize = useISP ? cuSize : puSize;
    int blendDir = pu.cu->dimdBlendMode[0];
    const int      dirMode = blendDir;
    const int     predMode = getModifiedWideAngle( blockSize.width, blockSize.height, dirMode ); // to check later
    m_ipaParam.isModeVer = predMode >= DIA_IDX;
    m_ipaParam.multiRefIndex = 0;
    m_ipaParam.refFilterFlag = false;
    m_ipaParam.interpolationFlag = false;
    m_ipaParam.applyPDPC = ( ( puSize.width >= MIN_TB_SIZEY && puSize.height >= MIN_TB_SIZEY ) || !isLuma( compId ) ) && m_ipaParam.multiRefIndex == 0;

    const int    intraPredAngleMode = ( m_ipaParam.isModeVer ) ? predMode - VER_IDX : -( predMode - HOR_IDX );//ok
    int absAng = 0;
    if( dirMode > DC_IDX && dirMode < NUM_LUMA_MODE ) // intraPredAngle for directional modes
    {
      static const int angTable[32] = { 0,    1,    2,    3,    4,    6,     8,   10,   12,   14,   16,   18,   20,   23,   26,   29,   32,   35,   39,  45,  51,  57,  64,  73,  86, 102, 128, 171, 256, 341, 512, 1024 };//ok
      static const int invAngTable[32] = { 0,   16384, 8192, 5461, 4096, 2731, 2048, 1638, 1365, 1170, 1024, 910, 819, 712, 630, 565, 512, 468,   420,  364,  321,  287,  256,  224,  191,  161,  128,  96,  64,  48,  32,  16 };   // (512 * 32) / Angle

      const int     absAngMode = abs( intraPredAngleMode );
      const int     signAng = intraPredAngleMode < 0 ? -1 : 1;
      absAng = angTable[absAngMode];

      m_ipaParam.absInvAngle = invAngTable[absAngMode];
      m_ipaParam.intraPredAngle = signAng * absAng;
      if( intraPredAngleMode < 0 )
      {
        m_ipaParam.applyPDPC = false;
      }
      else if( intraPredAngleMode > 0 )
      {
        const int sideSize = m_ipaParam.isModeVer ? puSize.height : puSize.width;
        const int maxScale = 2;
#if GRAD_PDPC
        m_ipaParam.useGradPDPC = false;
#endif

        m_ipaParam.angularScale = std::min( maxScale, floorLog2( sideSize ) - ( floorLog2( 3 * m_ipaParam.absInvAngle - 2 ) - 8 ) );
#if GRAD_PDPC
        if( ( m_ipaParam.angularScale < 0 ) && ( isLuma( compId ) ) )
        {
          m_ipaParam.angularScale = ( floorLog2( puSize.width ) + floorLog2( puSize.height ) - 2 ) >> 2;
          m_ipaParam.useGradPDPC = true;
        }
#endif
        m_ipaParam.applyPDPC &= m_ipaParam.angularScale >= 0;
      }
    }

    if( pu.cs->sps->getSpsRangeExtension().getIntraSmoothingDisabledFlag()
        || ( !isLuma( CHANNEL_TYPE_LUMA ) && pu.chromaFormat != CHROMA_444 )
        || useISP
        || m_ipaParam.multiRefIndex
        || DC_IDX == dirMode
        )
    {
      //do nothing
    }
    else if( !useISP )// HOR, VER and angular modes (MDIS)
    {
      bool filterFlag = false;
      const int diff = std::min<int>( abs( predMode - HOR_IDX ), abs( predMode - VER_IDX ) );
      const int log2Size = ( ( floorLog2( puSize.width ) + floorLog2( puSize.height ) ) >> 1 );
      CHECK( log2Size >= MAX_INTRA_FILTER_DEPTHS, "Size not supported" );
      filterFlag = ( diff > m_aucIntraFilter[log2Size] );


      if( filterFlag )
      {
        const bool isRefFilter = isIntegerSlope( absAng );
        CHECK( puSize.width * puSize.height <= 32, "DCT-IF interpolation filter is always used for 4x4, 4x8, and 8x4 luma CB" );
        m_ipaParam.refFilterFlag = isRefFilter;
        m_ipaParam.interpolationFlag = !isRefFilter;
      }
    }

#if JVET_W0123_TIMD_FUSION
    xPredIntraAng( srcBuf, predAng, channelType, clpRng, false );
#else
    xPredIntraAng( srcBuf, predAng, channelType, clpRng );
#endif
#endif
    m_ipaParam.applyPDPC = applyPdpc;
#if JVET_AC0098_LOC_DEP_DIMD
    if (pu.cu->dimdLocDep[0] != 0 || pu.cu->dimdLocDep[1] != 0)
    {
      Pel *pelPred = piPred.buf;
      Pel *pelPlanar = planarBuffer.buf;
      Pel *pelPredAng = predAng.buf;
      int  wMain = pu.cu->dimdRelWeight[0], wPlanar = pu.cu->dimdRelWeight[1], wSecond = pu.cu->dimdRelWeight[2];

      xDimdLocationdepBlending(pelPred, piPred.stride, pelPred, piPred.stride, pelPredAng, predAng.stride, pelPlanar, planarBuffer.stride, width, height, pu.cu->dimdLocDep[0], pu.cu->dimdLocDep[1], wMain, wSecond, wPlanar);
    }
    else
    {
#endif
    // do blending
#if INTRA_TRANS_ENC_OPT
    Pel *pelPred = piPred.buf;
    Pel *pelPlanar = planarBuffer.buf;
    Pel *pelPredAng = predAng.buf;
    int  w0 = pu.cu->dimdRelWeight[0], w1 = pu.cu->dimdRelWeight[1], w2 = pu.cu->dimdRelWeight[2];
    m_dimdBlending(pelPred, piPred.stride, pelPlanar, planarBuffer.stride, pelPredAng, predAng.stride, w0, w1, w2, width, height);
#else
    const int log2WeightSum = 6;
    Pel *pelPred = piPred.buf;
    Pel *pelPlanar = planarBuffer.buf;
    Pel *pelPredAng = predAng.buf;
    int  w0 = pu.cu->dimdRelWeight[0], w1 = pu.cu->dimdRelWeight[1], w2 = pu.cu->dimdRelWeight[2];

    for( int y = 0; y < height; y++ )
    {
      for( int x = 0; x < width; x++ )
      {
        int blend = pelPred[x] * w0;
        blend += pelPlanar[x] * w1;
        blend += pelPredAng[x] * w2;
        pelPred[x] = (Pel)(blend >> log2WeightSum);
      }

      pelPred += piPred.stride;
      pelPlanar += planarBuffer.stride;
      pelPredAng += predAng.stride;
    }
#endif
#if JVET_AC0098_LOC_DEP_DIMD
    }
#endif
  }
#endif
#endif
#if JVET_AH0076_OBIC
  if (pu.cu->obicFlag && pu.cu->obicIsBlended && isLuma(compID))
  {
    int width = piPred.width;
    int height = piPred.height;
    const UnitArea localUnitArea( pu.chromaFormat, Area( 0, 0, width, height ) );
    bool blendModes[OBIC_FUSION_NUM-1] = {false};
    PelBuf predFusion[OBIC_FUSION_NUM-1];
    const bool applyPdpc = m_ipaParam.applyPDPC;
    initIntraPatternChType(*pu.cu, pu.Y(), true, 0, false);
    PredictionUnit pu2 = pu;

    for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
    {
      blendModes[i] = false;
      predFusion[i] = m_tempBuffer[i].getBuf( localUnitArea.Y() );
      if (pu.cu->obicMode[i + 1] >= 0)
      {
        blendModes[i] = true;
        pu2.intraDir[0]  = pu.cu->obicMode[i + 1];
        initPredIntraParams(pu2, pu.Y(), *(pu.cs->sps));
        pu2.intraDir[0]  = pu.cu->obicMode[0];
        const CPelBuf &srcBuf = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);

        switch (pu.cu->obicMode[i + 1])
        {
#if JVET_AC0105_DIRECTIONAL_PLANAR
          case (PLANAR_IDX): pu.cu->isBvDimd ? predUsingBv(predFusion[i].buf, predFusion[i].stride, pu.cu->bvDimd, *pu.cu) : xPredIntraPlanar(srcBuf, predFusion[i], 0); break;
#else
          case (PLANAR_IDX): pu.cu->isBvDimd ? predUsingBv(predFusion[i].buf, predFusion[i].stride, pu.cu->bvDimd, *pu.cu) : xPredIntraPlanar(srcBuf, predFusion[i]); break;
#endif
          case(DC_IDX):     xPredIntraDc(srcBuf, predFusion[i], channelType, false); break;
#if JVET_AB0157_INTRA_FUSION
#if JVET_AK0118_BF_FOR_INTRA_PRED
          default:
            applyBf = false;
            xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
            pu,
#endif
            srcBuf, predFusion[i], channelType, clpRng, false, srcBuf2nd, applyBf, cs, blkQp, pu, pu.cu->ispMode!=NOT_INTRA_SUBPARTITIONS); break;
#else
          default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
            pu,
#endif
            srcBuf, predFusion[i], channelType, clpRng, false, srcBuf2nd, pu.cu->ispMode!=NOT_INTRA_SUBPARTITIONS); break;
#endif
#else
          default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
            pu,
#endif
            srcBuf, predFusion[i], channelType, clpRng, bExtIntraDir); break;
#endif
        }

        if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && (pu.cu->obicMode[i + 1] == PLANAR_IDX || pu.cu->obicMode[i + 1] == DC_IDX) )
        {
          if (pu.cu->obicMode[i + 1] == PLANAR_IDX && pu.cu->isBvDimd)
          {
            continue;
          }
          xIntraPredPlanarDcPdpc( srcBuf, predFusion[i].buf, predFusion[i].stride, width, height, false );
        }
      }
    }
    m_ipaParam.applyPDPC = applyPdpc;
#if JVET_AK0056_WEIGHTED_OBIC
    PelBuf predAngNonLocDep = m_tempBuffer[7].getBuf( localUnitArea.Y() );
    PelBuf predAngVer       = m_tempBuffer[5].getBuf( localUnitArea.Y() );
    PelBuf predAngHor       = m_tempBuffer[6].getBuf( localUnitArea.Y() );

    Pel* pelVer = predAngVer.buf;
    int strideVer = predAngVer.stride;
    Pel* pelHor = predAngHor.buf;
    int strideHor = predAngHor.stride; 
    Pel *pelNonLocDep = predAngNonLocDep.buf;
    int strideNonLocDep = predAngNonLocDep.stride;

    bool useLocDepBlending = false;
    int weightVer = 0, weightHor = 0, weightNonLocDep = 0;

    for (int i = 0; i < OBIC_FUSION_NUM; i++)
    {
      if(i == 0 || blendModes[i-1])
      {
        if (pu.cu->obicLocDep[i] == 1)
        {
          weightVer += pu.cu->obicFusionWeight[i];
        }
        else if (pu.cu->obicLocDep[i] == 2)
        {
          weightHor += pu.cu->obicFusionWeight[i];
        }
        else
        {
          weightNonLocDep += pu.cu->obicFusionWeight[i];
        }
      }
    }

    if(weightHor || weightVer)
    {
      useLocDepBlending = true;
    }
    
    if(!useLocDepBlending)
    {
      pelNonLocDep = piPred.buf;
      strideNonLocDep = piPred.stride;
    }
#if JVET_W0123_TIMD_FUSION 
    for (int locDep = 0; locDep < 3; locDep++) 
    {
      int totWeight = (locDep == 0 ? weightNonLocDep : (locDep == 1 ? weightVer : weightHor));
      if (totWeight == 0)
      {
        continue;
      }

      int weights[OBIC_FUSION_NUM] = {0};
      weights[0] = (pu.cu->obicLocDep[0] == locDep) ? pu.cu->obicFusionWeight[0] : 0;
      for (int i = 1; i < OBIC_FUSION_NUM ; i++)
      {
        weights[i] = (blendModes[i-1] && pu.cu->obicLocDep[i] == locDep) ? pu.cu->obicFusionWeight[i] : 0;
      }
     
      int num2blend = 0;
      int blendIndexes[OBIC_FUSION_NUM] = {0};
      for (int i = 0; i < OBIC_FUSION_NUM; i++)
      {
        if (weights[i] != 0)
        {
          blendIndexes[num2blend] = i;
          num2blend++;
        }
      }
      
      if( (num2blend == 1 ) || (num2blend <=3 && (totWeight == (1 << (floorLog2(totWeight))) ) ) )
      {
        int index = blendIndexes[0]; 
        if(locDep == 0)
        {
          pelNonLocDep = (index == 0 ? piPred.buf : predFusion[index-1].buf);
          strideNonLocDep = (index == 0 ? piPred.stride : predFusion[index-1].stride);
        }
        else if(locDep == 1)
        {
          pelVer = (index == 0 ? piPred.buf : predFusion[index-1].buf);
          strideVer = (index == 0 ? piPred.stride : predFusion[index-1].stride);
        }
        else
        {
          pelHor = (index == 0 ? piPred.buf : predFusion[index-1].buf);
          strideHor = (index == 0 ? piPred.stride : predFusion[index-1].stride);
        }
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

        int factor = 64 / totWeight;
        if (num2blend == 2)
        {
          int index1 = blendIndexes[1];
          Pel* p1 = (index1 == 0 ? piPred.buf : predFusion[index1-1].buf);
          int stride1 = (index1 == 0 ? piPred.stride : predFusion[index1-1].stride);

          int w0 = (weights[index]*factor);
          int w1 = 64 - w0;
          m_timdBlending(pCur, strideCur, p1, stride1, w0, w1,width, height);
        }
        else if(num2blend == 3)
        {
          int index1 = blendIndexes[1];
          Pel* p1 = (index1 == 0 ? piPred.buf : predFusion[index1-1].buf);
          int stride1 = (index1 == 0 ? piPred.stride : predFusion[index1-1].stride);

          int index2 = blendIndexes[2];
          Pel* p2 = (index2 == 0 ? piPred.buf : predFusion[index2-1].buf);
          int stride2 = (index2 == 0 ? piPred.stride : predFusion[index2-1].stride);

          int w0 = (weights[index]*factor);
          int w1 = (weights[index1]*factor);
          int w2 = 64  - w0 - w1;
          m_dimdBlending(pCur, strideCur, p1, stride1, p2, stride2, w0, w1, w2, width, height);
        }
      }
      else
#endif
      {
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));
        
        Pel *pelPred = piPred.buf;
        Pel *pelFusion[OBIC_FUSION_NUM - 1];

        for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
        {
          pelFusion[i] = predFusion[i].buf;
        }
        
        for( int y = 0; y < height; y++ )
        {
          for( int x = 0; x < width; x++ )
          {
            int blend = pelPred[x] * weights[0];
            for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
            {
              blend += blendModes[i] ? pelFusion[i][x] * weights[i + 1] : 0;
            }
            pCur[x] = (Pel)(blend / totWeight);
          }
          pCur += strideCur;
          pelPred += piPred.stride;
          for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
          {
            pelFusion[i] += predFusion[i].stride;
          }
        }
      }
    }

    if(useLocDepBlending)
    {
      int mode = ((weightHor > 0 && weightVer > 0) ? 0 : (weightVer > 0 ? 1 : 2));
      Pel *pelDst = piPred.buf;
      int strideDst = piPred.stride;
#if JVET_W0123_TIMD_FUSION && JVET_AG0092_ENHANCED_TIMD_FUSION
      xLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#else
      xDimdLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#endif
    }
#if JVET_AK0118_BF_FOR_INTRA_PRED
    applyBf = ( !isIntraSlice || !intraPredBfEnabled ) ? false : true;
    if( applyBf )
    {
      applyBf = checkBfApplication(blkQp, piPred.width, piPred.height);
    }

    if( applyBf )
    {
      int blkWidth = piPred.width;
      int blkHeight = piPred.height;
      bilateralFilterPredDiamond5x5Clip(cs, CHANNEL_TYPE_LUMA, piPred, blkWidth, blkHeight, blkQp, clpRng, true, *pu.cu );
    }
#endif
#else
    const int log2WeightSum = 6;
    Pel *pelPred = piPred.buf;
    Pel *pelFusion[OBIC_FUSION_NUM - 1];
    int weight[OBIC_FUSION_NUM];
    weight[0] = pu.cu->obicFusionWeight[0];
    for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
    {
      pelFusion[i] = predFusion[i].buf;
      weight[i + 1] = pu.cu->obicFusionWeight[i + 1];
    }
    for( int y = 0; y < height; y++ )
    {
      for( int x = 0; x < width; x++ )
      {
        int blend = pelPred[x] * weight[0];
        for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
        {
          if (blendModes[i])
          {
            blend += pelFusion[i][x] * weight[ i + 1];
          }
        }
        pelPred[x] = (Pel)(blend >> log2WeightSum);
      }
      pelPred += piPred.stride;
      for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
      {
        pelFusion[i] += predFusion[i].stride;
      }
    }

    return;
#endif
  }
#endif
#if JVET_W0123_TIMD_FUSION
#if JVET_AJ0061_TIMD_MERGE
  if (((pu.cu->timd && !pu.cu->timdMrg && pu.cu->timdIsBlended) || (pu.cu->timdMrg && pu.cu->timdMrgIsBlended[pu.cu->timdMrg - 1])) && isLuma(compID)
#if JVET_AJ0146_TIMDSAD
       && !pu.cu->timdSad 
#endif
    )
#else
  if (pu.cu->timd && pu.cu->timdIsBlended && isLuma(compID)
#if JVET_AJ0146_TIMDSAD
       && !pu.cu->timdSad 
#endif
   )
#endif
  {
    int width = piPred.width;
    int height = piPred.height;
    const UnitArea localUnitArea( pu.chromaFormat, Area( 0, 0, width, height ) );
    CPelBuf srcBuf3rd;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    PelBuf nonAngBuffer = m_tempBuffer[0].getBuf( localUnitArea.Y() );
#if JVET_AJ0061_TIMD_MERGE
    int nonAngFusionWeight = pu.cu->timdMrg ? pu.cu->timdMrgFusionWeight[pu.cu->timdMrg - 1][2] : pu.cu->timdFusionWeight[2];
    if (nonAngFusionWeight > 0)
#else
    if( pu.cu->timdFusionWeight[2] > 0 )
#endif
    {
      PredictionUnit pu3 = pu;
#if JVET_AJ0061_TIMD_MERGE
      int timdModeNonAng = pu.cu->timdMrg ? pu.cu->timdMrgList[pu.cu->timdMrg - 1][2] : pu.cu->timdModeNonAng;
      pu3.intraDir[0] = timdModeNonAng;
#else
      pu3.intraDir[0] = pu.cu->timdModeNonAng;
#endif
      int tmpTimdMode = pu3.cu->timdMode;
      pu3.cu->timdMode = INVALID_TIMD_IDX;
      initPredIntraParams(pu3, pu.Y(), *(pu.cs->sps));
      srcBuf3rd = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
      pu3.cu->timdMode = tmpTimdMode;
#if JVET_AJ0061_TIMD_MERGE
      switch (timdModeNonAng)
#else
      switch (pu.cu->timdModeNonAng)
#endif
      {
#if JVET_AC0105_DIRECTIONAL_PLANAR
      case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, nonAngBuffer, 0); break;
#else
      case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, nonAngBuffer); break;
#endif
      case(DC_IDX):     xPredIntraDc(srcBuf3rd, nonAngBuffer, channelType, false); break;
        default: CHECK( true, "Wrong timdModeNonAng" ); break;
      }
#if JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
#if JVET_AJ0061_TIMD_MERGE
      if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && ( timdModeNonAng == PLANAR_IDX ||  timdModeNonAng == DC_IDX) )
#else
      if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && ( pu.cu->timdModeNonAng == PLANAR_IDX ||  pu.cu->timdModeNonAng == DC_IDX) )
#endif
      {
        xIntraPredPlanarDcPdpc( srcBuf3rd, m_tempBuffer[0].getBuf( localUnitArea.Y() ).buf, m_tempBuffer[0].getBuf( localUnitArea.Y() ).stride, iWidth, iHeight, pu.ciipPDPC );
      }
#else
      if( m_ipaParam.applyPDPC  && ( pu.cu->timdModeNonAng == PLANAR_IDX ||  pu.cu->timdModeNonAng == DC_IDX) )
      {
        xIntraPredPlanarDcPdpc(srcBuf3rd, m_tempBuffer[0].getBuf(localUnitArea.Y()).buf, m_tempBuffer[1].getBuf(localUnitArea.Y()).stride, iWidth, iHeight);
      }
#endif
#endif    
    }
#endif
  
    PelBuf predFusion = m_tempBuffer[1].getBuf( localUnitArea.Y() );

    const bool applyPdpc = m_ipaParam.applyPDPC;
    PredictionUnit pu2 = pu;
#if JVET_AC0094_REF_SAMPLES_OPT
#if JVET_AJ0061_TIMD_MERGE
    int timdModeSecondary = pu.cu->timdMrg ? pu.cu->timdMrgList[pu.cu->timdMrg - 1][1] : pu.cu->timdModeSecondary;
    pu2.intraDir[0]  = timdModeSecondary;
#else
    pu2.intraDir[0]  = pu.cu->timdModeSecondary;
#endif
    int tmpTimdMode  = pu2.cu->timdMode;
    pu2.cu->timdMode = INVALID_TIMD_IDX;
#else
    pu2.intraDir[0] = pu.cu->timdModeSecondary;
#endif
    initPredIntraParams(pu2, pu.Y(), *(pu.cs->sps));
#if JVET_AC0094_REF_SAMPLES_OPT
    pu2.cu->timdMode = tmpTimdMode;
#endif
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    srcBuf3rd = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
#else
    srcBuf3rd = srcBuf;
#endif
#if JVET_AJ0061_TIMD_MERGE
    switch (timdModeSecondary)
#else
    switch (pu.cu->timdModeSecondary)
#endif
    {
#if JVET_AC0105_DIRECTIONAL_PLANAR
    case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, predFusion, 0); break;
#else
    case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, predFusion); break;
#endif
    case(DC_IDX):     xPredIntraDc(srcBuf3rd, predFusion, channelType, false); break;
#if JVET_AB0157_INTRA_FUSION
#if JVET_AK0118_BF_FOR_INTRA_PRED
    default:
        applyBf = false;
        xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
        pu,
#endif
        srcBuf3rd, predFusion, channelType, clpRng, bExtIntraDir, srcBuf2nd, applyBf, cs, blkQp, pu, pu.cu->ispMode != NOT_INTRA_SUBPARTITIONS, 0); break;
#else
    default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      pu,
#endif
      srcBuf3rd, predFusion, channelType, clpRng, bExtIntraDir, srcBuf2nd, pu.cu->ispMode!=NOT_INTRA_SUBPARTITIONS, 0); break;
#endif
#else
    default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      pu,
#endif
      srcBuf3rd, predFusion, channelType, clpRng, bExtIntraDir); break;
#endif
    }

#if JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
#if JVET_AJ0061_TIMD_MERGE
    if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && (timdModeSecondary == PLANAR_IDX || timdModeSecondary == DC_IDX) )
#else
    if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && (pu.cu->timdModeSecondary == PLANAR_IDX || pu.cu->timdModeSecondary == DC_IDX) )
#endif
    {
      xIntraPredPlanarDcPdpc( srcBuf3rd, m_tempBuffer[1].getBuf( localUnitArea.Y() ).buf, m_tempBuffer[1].getBuf( localUnitArea.Y() ).stride, iWidth, iHeight, pu.ciipPDPC );
    }
#else
    if (m_ipaParam.applyPDPC && (pu.cu->timdModeSecondary == PLANAR_IDX || pu.cu->timdModeSecondary == DC_IDX))
    {
      xIntraPredPlanarDcPdpc(srcBuf3rd, m_tempBuffer[1].getBuf(localUnitArea.Y()).buf, m_tempBuffer[1].getBuf(localUnitArea.Y()).stride, iWidth, iHeight);
    }
#endif
#endif
    m_ipaParam.applyPDPC = applyPdpc;

    // do blending
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
#if INTRA_TRANS_ENC_OPT
    Pel *pelPred = piPred.buf;
    Pel *pelPredFusion = predFusion.buf;
    int  w0 = pu.cu->timdFusionWeight[0], w1 = pu.cu->timdFusionWeight[1];
    m_timdBlending(pelPred, piPred.stride, pelPredFusion, predFusion.stride, w0, w1, width, height);
#else
    const int log2WeightSum = 6;
    Pel *pelPred = piPred.buf;
    Pel *pelPredFusion = predFusion.buf;
    int  w0 = pu.cu->timdFusionWeight[0], w1 = pu.cu->timdFusionWeight[1];

    for( int y = 0; y < height; y++ )
    {
      for( int x = 0; x < width; x++ )
      {
        int blend = pelPred[x] * w0;
        blend += pelPredFusion[x] * w1;
        pelPred[x] = (Pel)(blend >> log2WeightSum);
      }

      pelPred += piPred.stride;
      pelPredFusion += predFusion.stride;
    }
#endif
#else
    Pel *pelPred = piPred.buf;
    Pel *pelPredFusion = predFusion.buf;
#if JVET_AJ0061_TIMD_MERGE
    int timdFusionWeight = pu.cu->timdMrg ? pu.cu->timdMrgFusionWeight[pu.cu->timdMrg - 1][2] : pu.cu->timdFusionWeight[2];
    Pel *pelPredNonAng = timdFusionWeight > 0 ? nonAngBuffer.buf : nullptr;
#else
    Pel *pelPredNonAng = pu.cu->timdFusionWeight[2] > 0 ? nonAngBuffer.buf : nullptr;
#endif
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    PelBuf predAngNonLocDep = m_tempBuffer[4].getBuf( localUnitArea.Y() );
    PelBuf predAngVer       = m_tempBuffer[2].getBuf( localUnitArea.Y() );
    PelBuf predAngHor       = m_tempBuffer[3].getBuf( localUnitArea.Y() );

    Pel* pelVer = predAngVer.buf;
    int strideVer = predAngVer.stride;
    Pel* pelHor = predAngHor.buf;
    int strideHor = predAngHor.stride;
    Pel *pelNonLocDep = predAngNonLocDep.buf;
    int strideNonLocDep = predAngNonLocDep.stride;

    bool useLocDepBlending = false;
    int weightVer = 0, weightHor = 0, weightNonLocDep = 0;
#if JVET_AJ0061_TIMD_MERGE
    if (!pu.cu->timdMrg)
    {
#endif
    for (int i = 0; i < TIMD_FUSION_NUM; i++)
    {
      if (pu.cu->timdLocDep[i] == 1)
      {
        weightVer += pu.cu->timdFusionWeight[i];
      }
      else if (pu.cu->timdLocDep[i] == 2)
      {
        weightHor += pu.cu->timdFusionWeight[i];
      }
      else
      {
        weightNonLocDep += pu.cu->timdFusionWeight[i];
      }
    }
#if JVET_AJ0061_TIMD_MERGE
    }
    else
    {
      for (int i = 0; i < TIMD_FUSION_NUM; i++)
      {
        if (pu.cu->timdMrgLocDep[pu.cu->timdMrg - 1][i] == 1)
        {
          weightVer += pu.cu->timdMrgFusionWeight[pu.cu->timdMrg - 1][i];
        }
        else if (pu.cu->timdMrgLocDep[pu.cu->timdMrg - 1][i] == 2)
        {
          weightHor += pu.cu->timdMrgFusionWeight[pu.cu->timdMrg - 1][i];
        }
        else
        {
          weightNonLocDep += pu.cu->timdMrgFusionWeight[pu.cu->timdMrg - 1][i];
        }
      }
    }
#endif

    if(weightHor || weightVer)
    {
      useLocDepBlending = true;
    }

    if(!useLocDepBlending)
    {
      pelNonLocDep = piPred.buf;
      strideNonLocDep = piPred.stride;
    }
    
    for (int locDep = 0; locDep < 3; locDep++) 
    {
      int totWeight = (locDep == 0 ? weightNonLocDep : (locDep == 1 ? weightVer : weightHor));
      if (totWeight == 0)
      {
        continue;
      }

      int weights[TIMD_FUSION_NUM] = {0};
#if JVET_AJ0061_TIMD_MERGE
      if (!pu.cu->timdMrg)
      {
#endif
      for (int i = 0; i < TIMD_FUSION_NUM ; i++)
      {
        weights[i] = (pu.cu->timdLocDep[i] == locDep) ? pu.cu->timdFusionWeight[i] : 0;
      }
#if JVET_AJ0061_TIMD_MERGE
      }
      else
      {
        for (int i = 0; i < TIMD_FUSION_NUM ; i++)
        {
          weights[i] = (pu.cu->timdMrgLocDep[pu.cu->timdMrg - 1][i] == locDep) ? pu.cu->timdMrgFusionWeight[pu.cu->timdMrg - 1][i] : 0;
        }
      }
#endif
     
      int num2blend = 0;
      int blendIndexes[3] = {0};
      for (int i = 0; i < TIMD_FUSION_NUM; i++)
      {
        if (weights[i] != 0)
        {
          blendIndexes[num2blend] = i;
          num2blend++;
        }
      }

      if( (num2blend == 1 ) || (num2blend <=3 && (totWeight == (1 << (floorLog2(totWeight))) ) ) )
      {
        int index = blendIndexes[0]; 
        if(locDep == 0)
        {
          pelNonLocDep = (index == 0 ? pelPred : (index == 2 ? pelPredNonAng : pelPredFusion));
          strideNonLocDep = (index == 0 ? piPred.stride : (index == 2 ? nonAngBuffer.stride : predFusion.stride));
        }
        else if(locDep == 1)
        {
          pelVer = (index == 0 ? pelPred : (index == 2 ? pelPredNonAng : pelPredFusion));
          strideVer = (index == 0 ? piPred.stride : (index == 2 ? nonAngBuffer.stride : predFusion.stride));
        }
        else
        {
          pelHor = (index == 0 ? pelPred : (index == 2 ? pelPredNonAng : pelPredFusion));
          strideHor = (index == 0 ? piPred.stride : (index == 2 ? nonAngBuffer.stride : predFusion.stride));
        }
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

        int factor = 64 / totWeight;

        if( num2blend == 2 )
        {
          int index1 = blendIndexes[1];
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 2 ?  pelPredNonAng : pelPredFusion));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 2 ? nonAngBuffer.stride : predFusion.stride));

          int w0 = (weights[index]*factor);
          int w1 = 64 - w0;
          m_timdBlending(pCur, strideCur, p1, stride1, w0, w1,width, height);
        }
        else if ( num2blend == 3 )
        {
          int index1 = blendIndexes[1];
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 2 ?  pelPredNonAng: pelPredFusion));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 2 ? nonAngBuffer.stride : predFusion.stride));

          int index2 = blendIndexes[2];
          Pel* p2 = (index2 == 0 ? piPred.buf : (index2 == 2 ?  pelPredNonAng : pelPredFusion));
          int stride2 = (index2 == 0 ? piPred.stride : (index2 == 2 ? nonAngBuffer.stride : predFusion.stride));

          int w0 = (weights[index]*factor);
          int w1 = (weights[index1]*factor);
          int w2 = 64  - w0 - w1;
          m_dimdBlending(pCur, strideCur, p1, stride1, p2, stride2, w0, w1, w2, width, height);
        }
      }
      else
      {
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

        Pel *pelPredAng0 = piPred.buf;
        Pel *pelPredAng1 = predFusion.buf;
        Pel *pelNonAngBuf = nonAngBuffer.buf;
        int stride0 = piPred.stride;
        int stride1 = predFusion.stride;
        int stridePlanar = nonAngBuffer.stride;
        for( int y = 0; y < height; y++ )
        {
          for( int x = 0; x < width; x++ )
          {
            int blend = pelPredAng0[x] * weights[0];
            blend += pelPredAng1[x] * weights[1];
            blend += pelNonAngBuf[x] * weights[2];
            pCur[x] = (Pel)(blend / totWeight);
          }
          pCur += strideCur;
          pelPredAng0 += stride0;
          pelPredAng1 += stride1;
          pelNonAngBuf += stridePlanar;
        }
      }
    }

    if (useLocDepBlending)
    {
      int mode = ((weightHor > 0 && weightVer > 0) ? 0 : (weightVer > 0 ? 1 : 2));
      Pel *pelDst = piPred.buf;
      int strideDst = piPred.stride;
      int range = width * height > 127 ? 8: 10;
      
      xLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep,strideNonLocDep, width, height ,mode, weightVer, weightHor, weightNonLocDep, range);
    }

#if JVET_AK0118_BF_FOR_INTRA_PRED
    applyBf = ( !isIntraSlice || !intraPredBfEnabled ) ? false : true;
    if( applyBf )
    {
      applyBf = checkBfApplication(blkQp, piPred.width, piPred.height);
    }

    if( applyBf )
    {
      int blkWidth = piPred.width;
      int blkHeight = piPred.height;
      bilateralFilterPredDiamond5x5Clip(cs, CHANNEL_TYPE_LUMA, piPred, blkWidth, blkHeight, blkQp, clpRng, true, *pu.cu );
    }
#endif
#else
    int  w0 = pu.cu->timdFusionWeight[0], w1 = pu.cu->timdFusionWeight[1]; int w2 = pu.cu->timdFusionWeight[2];
#if INTRA_TRANS_ENC_OPT
    if(w2)
    {
      m_dimdBlending(pelPred, piPred.stride, pelPredFusion, predFusion.stride, pelPredNonAng, nonAngBuffer.stride, w0, w1, w2, width, height);
    }
    else
    {
      m_timdBlending(pelPred, piPred.stride, pelPredFusion, predFusion.stride, w0, w1, width, height);
    }
#else
    const int log2WeightSum = 6;
    if(w2)
    {
      Pel *pelPredAng = pelPredFusion;
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int blend = pelPred[x] * w0;
          blend    += pelPredNonAng[x] * w1;
          blend    += pelPredAng[x] * w2;
          pelPred[x] = (Pel)(blend >> log2WeightSum);
        }

        pelPred    += piPred.stride;
        pelPlanar  += nonAngBuffer.stride;
        pelPredAng += predFusion.stride;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int blend = pelPred[x] * w0;
          blend += pelPredFusion[x] * w1;
          pelPred[x] = (Pel)(blend >> log2WeightSum);
        }

        pelPred += piPred.stride;
        pelPredFusion += predFusion.stride;
      }
    }
#endif
#endif
#endif
  }
#if JVET_AJ0146_TIMDSAD
  if (pu.cu->timdSad && pu.cu->timd && pu.cu->timdIsBlendedSad && isLuma(compID))
  {
    int width = piPred.width;
    int height = piPred.height;
    const UnitArea localUnitArea( pu.chromaFormat, Area( 0, 0, width, height ) );
    CPelBuf srcBuf3rd;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    PelBuf nonAngBuffer = m_tempBuffer[0].getBuf( localUnitArea.Y() );
    if( pu.cu->timdFusionWeightSad[2] > 0 )
    {
      PredictionUnit pu3 = pu;
      pu3.intraDir[0] = pu.cu->timdModeNonAngSad;
      int tmpTimdMode = pu3.cu->timdModeSad;
      pu3.cu->timdModeSad = INVALID_TIMD_IDX;
      initPredIntraParams(pu3, pu.Y(), *(pu.cs->sps));
      srcBuf3rd = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
      pu3.cu->timdModeSad = tmpTimdMode;
      switch (pu.cu->timdModeNonAngSad)
      {
#if JVET_AC0105_DIRECTIONAL_PLANAR
      case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, nonAngBuffer, 0); break;
#else
      case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, nonAngBuffer); break;
#endif
      case(DC_IDX):     xPredIntraDc(srcBuf3rd, nonAngBuffer, channelType, false); break;
      default: CHECK( true, "Wrong timdModeNonAng" ); break;
      }
#if JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
      if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && ( pu.cu->timdModeNonAngSad == PLANAR_IDX ||  pu.cu->timdModeNonAngSad == DC_IDX) )
      {
        xIntraPredPlanarDcPdpc( srcBuf3rd, m_tempBuffer[0].getBuf( localUnitArea.Y() ).buf, m_tempBuffer[0].getBuf( localUnitArea.Y() ).stride, iWidth, iHeight, pu.ciipPDPC );
      }
#else
      if( m_ipaParam.applyPDPC  && ( pu.cu->timdModeNonAngSad == PLANAR_IDX ||  pu.cu->timdModeNonAngSad == DC_IDX) )
      {
        xIntraPredPlanarDcPdpc(srcBuf3rd, m_tempBuffer[0].getBuf(localUnitArea.Y()).buf, m_tempBuffer[1].getBuf(localUnitArea.Y()).stride, iWidth, iHeight);
      }
#endif
#endif    
    }
#endif

    PelBuf predFusion = m_tempBuffer[1].getBuf( localUnitArea.Y() );

    const bool applyPdpc = m_ipaParam.applyPDPC;
    PredictionUnit pu2 = pu;
#if JVET_AC0094_REF_SAMPLES_OPT
    pu2.intraDir[0]  = pu.cu->timdModeSecondarySad;
    int tmpTimdMode  = pu2.cu->timdModeSad;
    pu2.cu->timdModeSad = INVALID_TIMD_IDX;
#else
    pu2.intraDir[0] = pu.cu->timdModeSecondarySad;
#endif
    initPredIntraParams(pu2, pu.Y(), *(pu.cs->sps));
#if JVET_AC0094_REF_SAMPLES_OPT
    pu2.cu->timdModeSad = tmpTimdMode;
#endif
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    srcBuf3rd = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
#else
    srcBuf3rd = srcBuf;
#endif
    switch (pu.cu->timdModeSecondarySad)
    {
#if JVET_AC0105_DIRECTIONAL_PLANAR
    case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, predFusion, 0); break;
#else
    case (PLANAR_IDX): xPredIntraPlanar(srcBuf3rd, predFusion); break;
#endif
    case(DC_IDX):     xPredIntraDc(srcBuf3rd, predFusion, channelType, false); break;
#if JVET_AB0157_INTRA_FUSION
#if JVET_AK0118_BF_FOR_INTRA_PRED
    default: xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
    pu,
#endif
    srcBuf3rd, predFusion, channelType, clpRng, bExtIntraDir, srcBuf2nd, applyBf, cs, blkQp, pu, pu.cu->ispMode!=NOT_INTRA_SUBPARTITIONS, 0); break;
#else
    default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      pu,
#endif
      srcBuf3rd, predFusion, channelType, clpRng, bExtIntraDir, srcBuf2nd, pu.cu->ispMode!=NOT_INTRA_SUBPARTITIONS, 0); break;
#endif
#else
    default:          xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      pu,
#endif
      srcBuf3rd, predFusion, channelType, clpRng, bExtIntraDir); break;
#endif
    }

#if JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
    if( (m_ipaParam.applyPDPC || pu.ciipPDPC) && (pu.cu->timdModeSecondarySad == PLANAR_IDX || pu.cu->timdModeSecondarySad == DC_IDX) )
    {
      xIntraPredPlanarDcPdpc( srcBuf3rd, m_tempBuffer[1].getBuf( localUnitArea.Y() ).buf, m_tempBuffer[1].getBuf( localUnitArea.Y() ).stride, iWidth, iHeight, pu.ciipPDPC );
    }
#else
    if (m_ipaParam.applyPDPC && (pu.cu->timdModeSecondarySad == PLANAR_IDX || pu.cu->timdModeSecondarySad == DC_IDX))
    {
      xIntraPredPlanarDcPdpc(srcBuf3rd, m_tempBuffer[1].getBuf(localUnitArea.Y()).buf, m_tempBuffer[1].getBuf(localUnitArea.Y()).stride, iWidth, iHeight);
    }
#endif
#endif
    m_ipaParam.applyPDPC = applyPdpc;

    // do blending
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
#if INTRA_TRANS_ENC_OPT
    Pel *pelPred = piPred.buf;
    Pel *pelPredFusion = predFusion.buf;
    int  w0 = pu.cu->timdFusionWeightSad[0], w1 = pu.cu->timdFusionWeightSad[1];
    m_timdBlending(pelPred, piPred.stride, pelPredFusion, predFusion.stride, w0, w1, width, height);
#else
    const int log2WeightSum = 6;
    Pel *pelPred = piPred.buf;
    Pel *pelPredFusion = predFusion.buf;
    int  w0 = pu.cu->timdFusionWeightSad[0], w1 = pu.cu->timdFusionWeightSad[1];

    for( int y = 0; y < height; y++ )
    {
      for( int x = 0; x < width; x++ )
      {
        int blend = pelPred[x] * w0;
        blend += pelPredFusion[x] * w1;
        pelPred[x] = (Pel)(blend >> log2WeightSum);
    }

      pelPred += piPred.stride;
      pelPredFusion += predFusion.stride;
  }
#endif
#else
    Pel *pelPred = piPred.buf;
    Pel *pelPredFusion = predFusion.buf;
    Pel *pelPredNonAng = pu.cu->timdFusionWeightSad[2] > 0 ? nonAngBuffer.buf : nullptr;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    PelBuf predAngNonLocDep = m_tempBuffer[4].getBuf( localUnitArea.Y() );
    PelBuf predAngVer       = m_tempBuffer[2].getBuf( localUnitArea.Y() );
    PelBuf predAngHor       = m_tempBuffer[3].getBuf( localUnitArea.Y() );

    Pel* pelVer = predAngVer.buf;
    int strideVer = predAngVer.stride;
    Pel* pelHor = predAngHor.buf;
    int strideHor = predAngHor.stride;
    Pel *pelNonLocDep = predAngNonLocDep.buf;
    int strideNonLocDep = predAngNonLocDep.stride;

    bool useLocDepBlending = false;
    int weightVer = 0, weightHor = 0, weightNonLocDep = 0;
    for (int i = 0; i < TIMD_FUSION_NUM; i++)
    {
      if (pu.cu->timdLocDepSad[i] == 1)
      {
        weightVer += pu.cu->timdFusionWeightSad[i];
      }
      else if (pu.cu->timdLocDepSad[i] == 2)
      {
        weightHor += pu.cu->timdFusionWeightSad[i];
      }
      else
      {
        weightNonLocDep += pu.cu->timdFusionWeightSad[i];
      }
    }
    if(weightHor || weightVer)
    {
      useLocDepBlending = true;
    }

    if(!useLocDepBlending)
    {
      pelNonLocDep = piPred.buf;
      strideNonLocDep = piPred.stride;
    }

    for (int locDep = 0; locDep < 3; locDep++) 
    {
      int totWeight = (locDep == 0 ? weightNonLocDep : (locDep == 1 ? weightVer : weightHor));
      if (totWeight == 0)
      {
        continue;
      }

      int weights[TIMD_FUSION_NUM] = {0};
      for (int i = 0; i < TIMD_FUSION_NUM ; i++)
      {
        weights[i] = (pu.cu->timdLocDepSad[i] == locDep) ? pu.cu->timdFusionWeightSad[i] : 0;
      }

      int num2blend = 0;
      int blendIndexes[3] = {0};
      for (int i = 0; i < TIMD_FUSION_NUM; i++)
      {
        if (weights[i] != 0)
        {
          blendIndexes[num2blend] = i;
          num2blend++;
        }
      }

      if( (num2blend == 1 ) || (num2blend <=3 && (totWeight == (1 << (floorLog2(totWeight))) ) ) )
      {
        int index = blendIndexes[0]; 
        if(locDep == 0)
        {
          pelNonLocDep = (index == 0 ? pelPred : (index == 2 ? pelPredNonAng : pelPredFusion));
          strideNonLocDep = (index == 0 ? piPred.stride : (index == 2 ? nonAngBuffer.stride : predFusion.stride));
        }
        else if(locDep == 1)
        {
          pelVer = (index == 0 ? pelPred : (index == 2 ? pelPredNonAng : pelPredFusion));
          strideVer = (index == 0 ? piPred.stride : (index == 2 ? nonAngBuffer.stride : predFusion.stride));
        }
        else
        {
          pelHor = (index == 0 ? pelPred : (index == 2 ? pelPredNonAng : pelPredFusion));
          strideHor = (index == 0 ? piPred.stride : (index == 2 ? nonAngBuffer.stride : predFusion.stride));
        }
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

        int factor = 64 / totWeight;

        if( num2blend == 2 )
        {
          int index1 = blendIndexes[1];
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 2 ?  pelPredNonAng : pelPredFusion));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 2 ? nonAngBuffer.stride : predFusion.stride));

          int w0 = (weights[index]*factor);
          int w1 = 64 - w0;
          m_timdBlending(pCur, strideCur, p1, stride1, w0, w1,width, height);
        }
        else if ( num2blend == 3 )
        {
          int index1 = blendIndexes[1];
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 2 ?  pelPredNonAng: pelPredFusion));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 2 ? nonAngBuffer.stride : predFusion.stride));

          int index2 = blendIndexes[2];
          Pel* p2 = (index2 == 0 ? piPred.buf : (index2 == 2 ?  pelPredNonAng : pelPredFusion));
          int stride2 = (index2 == 0 ? piPred.stride : (index2 == 2 ? nonAngBuffer.stride : predFusion.stride));

          int w0 = (weights[index]*factor);
          int w1 = (weights[index1]*factor);
          int w2 = 64  - w0 - w1;
          m_dimdBlending(pCur, strideCur, p1, stride1, p2, stride2, w0, w1, w2, width, height);
        }
      }
      else
      {
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

        Pel *pelPredAng0 = piPred.buf;
        Pel *pelPredAng1 = predFusion.buf;
        Pel *pelNonAngBuf = nonAngBuffer.buf;
        int stride0 = piPred.stride;
        int stride1 = predFusion.stride;
        int stridePlanar = nonAngBuffer.stride;
        for( int y = 0; y < height; y++ )
        {
          for( int x = 0; x < width; x++ )
          {
            int blend = pelPredAng0[x] * weights[0];
            blend += pelPredAng1[x] * weights[1];
            blend += pelNonAngBuf[x] * weights[2];
            pCur[x] = (Pel)(blend / totWeight);
          }
          pCur += strideCur;
          pelPredAng0 += stride0;
          pelPredAng1 += stride1;
          pelNonAngBuf += stridePlanar;
        }
      }
    }

    if (useLocDepBlending)
    {
      int mode = ((weightHor > 0 && weightVer > 0) ? 0 : (weightVer > 0 ? 1 : 2));
      Pel *pelDst = piPred.buf;
      int strideDst = piPred.stride;
      int range = width * height > 127 ? 8: 10;

      xLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep,strideNonLocDep, width, height ,mode, weightVer, weightHor, weightNonLocDep, range);
    }
#if JVET_AK0118_BF_FOR_INTRA_PRED
    applyBf = ( !isIntraSlice || !intraPredBfEnabled ) ? false : true;
    if( applyBf )
    {
      applyBf = checkBfApplication(blkQp, piPred.width, piPred.height);
    }

    if( applyBf )
    {
      int blkWidth = piPred.width;
      int blkHeight = piPred.height;
      bilateralFilterPredDiamond5x5Clip(cs, CHANNEL_TYPE_LUMA, piPred, blkWidth, blkHeight, blkQp, clpRng, true, *pu.cu );
    }
#endif
#else
    int  w0 = pu.cu->timdFusionWeightSad[0], w1 = pu.cu->timdFusionWeightSad[1]; int w2 = pu.cu->timdFusionWeightSad[2];
#if INTRA_TRANS_ENC_OPT
    if(w2)
    {
      m_dimdBlending(pelPred, piPred.stride, pelPredFusion, predFusion.stride, pelPredNonAng, nonAngBuffer.stride, w0, w1, w2, width, height);
    }
    else
    {
      m_timdBlending(pelPred, piPred.stride, pelPredFusion, predFusion.stride, w0, w1, width, height);
    }
#else
    const int log2WeightSum = 6;
    if(w2)
    {
      Pel *pelPredAng = pelPredFusion;
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int blend = pelPred[x] * w0;
          blend    += pelPredNonAng[x] * w1;
          blend    += pelPredAng[x] * w2;
          pelPred[x] = (Pel)(blend >> log2WeightSum);
        }

        pelPred    += piPred.stride;
        pelPlanar  += nonAngBuffer.stride;
        pelPredAng += predFusion.stride;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int blend = pelPred[x] * w0;
          blend += pelPredFusion[x] * w1;
          pelPred[x] = (Pel)(blend >> log2WeightSum);
        }

        pelPred += piPred.stride;
        pelPredFusion += predFusion.stride;
      }
    }
#endif
#endif
#endif
  }
#endif
#endif

#if JVET_AB0155_SGPM
  
  if (PU::isSgpm(pu, channelType))
  {
    int            width = piPred.width;
    int            height = piPred.height;
    const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, width, height));
    PelBuf predFusion = m_tempBuffer[1].getBuf(localUnitArea.Y());
    IntraPredParam m_ipaParam2 = m_ipaParam;
    CompArea compArea = (compID == COMPONENT_Y) ? pu.Y()
      : (compID == COMPONENT_Cb) ? pu.Cb() : pu.Cr();
#if JVET_AJ0112_REGRESSION_SGPM
    initIntraPatternChType(*pu.cu, pu.Y(), true, 0, false);
#endif
#if JVET_AG0152_SGPM_ITMP_IBC
    bool isBvPredicted = 0;
    if (pu.cu->sgpmMode1 >= SGPM_BV_START_IDX && pu.cu->ispMode == 0)
    {
      isBvPredicted = 1;
      Mv bv = pu.cu->sgpmBv1;
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      predUsingBv(predFusion.buf, predFusion.stride, bv, *pu.cu, false);
#else
      predUsingBv(predFusion.buf, predFusion.stride, bv, *pu.cu);
#endif
    }
    if (!isBvPredicted)
    {
#endif
      initIntraPatternChType(*pu.cu, compArea, false, 1);
      const uint32_t uiDirMode2 = PU::getFinalIntraMode(pu, channelType, 1);
      const CPelBuf &srcBuf2 = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
      switch (uiDirMode2)
      {
#if JVET_AC0105_DIRECTIONAL_PLANAR
      case (PLANAR_IDX): xPredIntraPlanar(srcBuf2, predFusion, 0); break;
#else
      case (PLANAR_IDX): xPredIntraPlanar(srcBuf2, predFusion); break;
#endif
      case (DC_IDX): xPredIntraDc(srcBuf2, predFusion, channelType, false); break;
#if JVET_AB0157_INTRA_FUSION
      default:
        int weightMode = 4;
#if JVET_AK0118_BF_FOR_INTRA_PRED
       applyBf = false;
       xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
       pu,
#endif
       srcBuf2, predFusion, channelType, clpRng, bExtIntraDir, srcBuf2nd, applyBf, cs, blkQp, pu, pu.cu->ispMode != NOT_INTRA_SUBPARTITIONS, weightMode); break;
#else
        xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
          pu,
#endif
          srcBuf2, predFusion, channelType, clpRng, bExtIntraDir, srcBuf2nd, pu.cu->ispMode != NOT_INTRA_SUBPARTITIONS, weightMode); break;
#endif
#else
      default: xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
        pu,
#endif
        srcBuf2, predFusion, channelType, clpRng, bExtIntraDir); break;
#endif
      }

#if JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
      if ((m_ipaParam.applyPDPC || pu.ciipPDPC) && (uiDirMode2 == PLANAR_IDX || uiDirMode2 == DC_IDX))
#else
      if (m_ipaParam.applyPDPC && (uiDirMode2 == PLANAR_IDX || uiDirMode2 == DC_IDX))
#endif
      {
        xIntraPredPlanarDcPdpc(srcBuf2, m_tempBuffer[1].getBuf(localUnitArea.Y()).buf,
          m_tempBuffer[1].getBuf(localUnitArea.Y()).stride, iWidth, iHeight
#if CIIP_PDPC       
          , pu.ciipPDPC
#endif   
        );
      }
#endif
#if JVET_AG0152_SGPM_ITMP_IBC
    }
#endif

    m_ipaParam = m_ipaParam2;

#if JVET_AJ0107_GPM_SHAPE_ADAPT
    int     splitDir   = g_sgpmSplitDir[pu.cu->sgpmSplitDir];
#else
    int     splitDir   = pu.cu->sgpmSplitDir;
#endif
#if JVET_AJ0112_REGRESSION_SGPM
    if (PU::isRegressionSgpm(pu))
    {
      PelUnitBuf pred = PelUnitBuf(pu.chromaFormat, piPred);
      PelUnitBuf predTemp = PelUnitBuf(pu.chromaFormat, predFusion);
      m_blendBuf.resize(pu.lwidth() * pu.lheight());
      int16_t* blendBuf = m_blendBuf.data();
      WeightBuf bufWeight = WeightBuf(blendBuf, pu.lumaSize());
      const int geoBlendingLog2WeightBase = 5;
      m_if.m_weightAffineBlk(pu, bufWeight, geoBlendingLog2WeightBase, pu.cu->blendModel);
      m_if.weightedBlendBlk(pu, pu.lumaSize().width, pu.lumaSize().height, COMPONENT_Y, pred, pred, predTemp, bufWeight, geoBlendingLog2WeightBase, false);
    }
    else
    {
      m_if.m_weightedSgpm(pu, width, height, compID, splitDir, piPred, piPred, predFusion);
    }
#else
    m_if.m_weightedSgpm(pu, width, height, compID, splitDir, piPred, piPred, predFusion);
#endif
#if JVET_AK0217_INTRA_MTSS || JVET_AK0187_IMPLICIT_MTS_LUT_EXTENSION
    if (isLuma(compID))
    {
      int secondDimd = 0;
      pu.cu->dimdDerivedIntraDir    = deriveIpmForTransform(piPred, *pu.cu, secondDimd);
      pu.cu->dimdDerivedIntraDir2nd = secondDimd;
    }
#endif
  }
#endif

#if !JVET_X0148_TIMD_PDPC
#if CIIP_PDPC
  if (m_ipaParam.applyPDPC || pu.ciipPDPC)
#else
  if (m_ipaParam.applyPDPC)
#endif
  {
    PelBuf dstBuf = piPred;
    const int scale = ((floorLog2(iWidth) - 2 + floorLog2(iHeight) - 2 + 2) >> 2);
    CHECK(scale < 0 || scale > 31, "PDPC: scale < 0 || scale > 31");

    if (uiDirMode == PLANAR_IDX || uiDirMode == DC_IDX)
    { 
      const Pel* srcLeft = srcBuf.bufAt(1, 1);
      Pel* dst = dstBuf.buf;
#if CIIP_PDPC
      if (pu.ciipPDPC)
      {
        for (int y = 0; y < iHeight; y++)
        {
          const int wT = 32 >> std::min(31, ((y << 1) >> scale));
          const Pel left = *srcLeft;
          const Pel* srcTop = srcBuf.buf + 1;
          for (int x = 0; x < iWidth; x++)
          {
            const int wL = 32 >> std::min(31, ((x << 1) >> scale));
            const Pel top = *srcTop;
            dst[x] = ((wL * left  + wT * top + 32) >> 6);

            srcTop++;
          }
          srcLeft++;
          dst += dstBuf.stride;
        }
      }
      else
      {
#endif

      for (int y = 0; y < iHeight; y++)
      {
        const int wT   = 32 >> std::min(31, ((y << 1) >> scale));
        const Pel left = *srcLeft;
        const Pel* srcTop = srcBuf.buf + 1;

        for (int x = 0; x < iWidth; x++)
        {
          const int wL = 32 >> std::min(31, ((x << 1) >> scale));
          const Pel top = *srcTop;
          const Pel val = dst[x];

          dst[x] = val + ((wL * (left - val) + wT * (top - val) + 32) >> 6);
          srcTop++;
        }

        srcLeft++;
        dst += dstBuf.stride;
      }
#if CIIP_PDPC
      }
#endif
    }
  }
#endif
}

#if JVET_AC0071_DBV
void IntraPrediction::predIntraDbv(const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
                                 , InterPrediction *pcInterPred
#endif
)
{
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
  Mv mv = refineChromaBv(compId, pu, pcInterPred);
#if JVET_AF0066_ENABLE_DBV_4_SINGLE_TREE
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if (! ( CS::isDualITree(*pu.cs) || (pu.cu->isSST && pu.cu->separateTree) ) )
#else
  if (!CS::isDualITree(*pu.cs))
#endif
  {
    const int bvShiftHor = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleX(compId, pu.chromaFormat);
    const int bvShiftVer = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleY(compId, pu.chromaFormat);
    int xFrac = mv.hor & ((1 << bvShiftHor) - 1);
    int yFrac = mv.ver & ((1 << bvShiftVer) - 1);

    PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), piPred, piPred);
    if (xFrac != 0 || yFrac != 0)
    {
      pcInterPred->getPredIBCBlk(pu, compId, pu.cu->slice->getPic(), mv, pcBuf, false, false);
    }
    else
    {
      int refx = pu.blocks[compId].x + (mv.hor >> bvShiftHor);
      int refy = pu.blocks[compId].y + (mv.ver >> bvShiftVer);
      int refStride = pu.cs->picture->getRecoBuf(compId).stride;
      Pel *ref = pu.cs->picture->getRecoBuf(compId).buf;
      Pel *refTarget = ref + refy * refStride + refx;
      int iStride = piPred.stride;
      Pel *pred = piPred.buf;
      int iHeight = piPred.height;
      int lineBufSize = piPred.width * sizeof(Pel);
      for (int uiY = 0; uiY < iHeight; uiY++)
      {
        ::memcpy(pred, refTarget, lineBufSize);
        refTarget += refStride;
        pred += iStride;
      }
    }
    return;
  }
#endif
  bool isFracMv = pu.cs->sps->getIBCFracFlag() && mv.isFracMv<false>(pu.chromaFormat);
  if (isFracMv)
  {
    PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), piPred, piPred);
    pcInterPred->getPredIBCBlk(pu, compId, pu.cs->picture, mv, pcBuf);
  }
  else
  {
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
  const int bvShftHor = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleX(compId, pu.chromaFormat);
  const int bvShftVer = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleY(compId, pu.chromaFormat);
  int refx = pu.blocks[compId].x + (mv.hor >> bvShftHor);
  int refy = pu.blocks[compId].y + (mv.ver >> bvShftVer);
#else
  const int shiftSampleHor = ::getComponentScaleX(compId, pu.chromaFormat);
  const int shiftSampleVer = ::getComponentScaleY(compId, pu.chromaFormat);
  Mv chromaBv = Mv(pu.bv.hor >> shiftSampleHor, pu.bv.ver >> shiftSampleVer);
  chromaBv = refineChromaBv(compId, pu);
  int refx = pu.blocks[compId].x + chromaBv.hor;
  int refy = pu.blocks[compId].y + chromaBv.ver;
#endif
  int refStride = pu.cs->picture->getRecoBuf(compId).stride;
  Pel *ref = pu.cs->picture->getRecoBuf(compId).buf;
  Pel *refTarget = ref + refy * refStride + refx;
  int iStride = piPred.stride;
  Pel *pred = piPred.buf;
  int iHeight = piPred.height;
  int iWidth = piPred.width;
  for (int uiY = 0; uiY < iHeight; uiY++)
  {
    for (int uiX = 0; uiX < iWidth; uiX++)
    {
      pred[uiX] = refTarget[uiX];
    }
    refTarget += refStride;
    pred += iStride;
  }
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
  }
#endif
}

Mv IntraPrediction::refineChromaBv(const ComponentID compId, const PredictionUnit &pu
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
                                 , InterPrediction *pcInterPred
#endif
)
{
  const CodingStructure &cs = *pu.cs;
  Position posRT = pu.blocks[compId].topRight();
  const PredictionUnit *puAbove = cs.getPURestricted(posRT.offset(0, -1), pu, pu.chType);
  bool topCanUse = puAbove && pu.cu != puAbove->cu;
  Position posLB = pu.blocks[compId].bottomLeft();
  const PredictionUnit *puLeft = cs.getPURestricted(posLB.offset(-1, 0), pu, pu.chType);
  bool leftCanUse = puLeft && pu.cu != puLeft->cu;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
  const int bvShiftHor = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleX(compId, pu.chromaFormat);
  const int bvShiftVer = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleY(compId, pu.chromaFormat);
#else
  const int shiftSampleHor = ::getComponentScaleX(compId, pu.chromaFormat);
  const int shiftSampleVer = ::getComponentScaleY(compId, pu.chromaFormat);
#endif
#if JVET_AF0066_ENABLE_DBV_4_SINGLE_TREE
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if ( ! (CS::isDualITree(cs) || (pu.cu->isSST && pu.cu->separateTree) ) )
#else
  if (!CS::isDualITree(cs))
#endif
  {
#if JVET_AF0079_STORING_INTRATMP
    if (PU::checkIsChromaBvCandidateValid(pu, pu.mv[0], 0))
    {
      return pu.mv[0];
    }
    else
    {
      Mv mv = pu.bv;
      mv <<= MV_FRACTIONAL_BITS_INTERNAL;
      return mv;
    }
#else
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
    if (pu.cs->sps->getIBCFracFlag() && pu.cu->tmpFlag && !pu.cu->tmpFlmFlag && !pu.cu->tmpFusionFlag && pu.cu->tmpIsSubPel)
    {
      int pXFrac = pu.mv[0].hor;
      int pYFrac = pu.mv[0].ver;
      int fracOffset = (pu.cu->tmpIsSubPel == 1 ? 8 : (pu.cu->tmpIsSubPel == 2 ? 4 : 12));
      if (pu.cu->tmpSubPelIdx == LEFT_POS || pu.cu->tmpSubPelIdx == ABOVE_LEFT_POS || pu.cu->tmpSubPelIdx == LEFT_BOTTOM_POS)
      {
        pXFrac -= fracOffset;
      }
      if (pu.cu->tmpSubPelIdx == RIGHT_POS || pu.cu->tmpSubPelIdx == ABOVE_RIGHT_POS || pu.cu->tmpSubPelIdx == RIGHT_BOTTOM_POS)
      {
        pXFrac += fracOffset;
      }
      if (pu.cu->tmpSubPelIdx == ABOVE_POS || pu.cu->tmpSubPelIdx == ABOVE_LEFT_POS || pu.cu->tmpSubPelIdx == ABOVE_RIGHT_POS)
      {
        pYFrac -= fracOffset;
      }
      if (pu.cu->tmpSubPelIdx == BOTTOM_POS || pu.cu->tmpSubPelIdx == LEFT_BOTTOM_POS || pu.cu->tmpSubPelIdx == RIGHT_BOTTOM_POS)
      {
        pYFrac += fracOffset;
      }
      Mv lumaBv = Mv(pXFrac, pYFrac);
      if (PU::checkIsChromaBvCandidateValid(pu, lumaBv, 0))
      {
        return Mv(pXFrac, pYFrac);
      }
    }
    return pu.cs->sps->getIBCFracFlag() ? pu.mv[0] : Mv((pu.mv[0].hor >> bvShiftHor) << bvShiftHor, (pu.mv[0].ver >> bvShiftVer) << bvShiftVer);
#else
    return Mv(pu.bv.hor >> shiftSampleHor, pu.bv.ver >> shiftSampleVer);
#endif
#endif
  }
#endif
  if (topCanUse == false && leftCanUse == false)
  {
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
    return pu.cs->sps->getIBCFracFlag() ? pu.mv[0] : Mv((pu.mv[0].hor >> bvShiftHor) << bvShiftHor, (pu.mv[0].ver >> bvShiftVer) << bvShiftVer);
#else
    return Mv(pu.bv.hor >> shiftSampleHor, pu.bv.ver >> shiftSampleVer);
#endif
  }

#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
  int filterIdx = 0;
  std::vector<Mv> chromaBvList;
  chromaBvList.push_back(pu.cs->sps->getIBCFracFlag() ? pu.mv[0] : Mv((pu.mv[0].hor >> bvShiftHor) << bvShiftHor, (pu.mv[0].ver >> bvShiftVer) << bvShiftVer));
#else
  Mv lumaBv = pu.bv;
  Mv chromaBv(lumaBv.hor >> shiftSampleHor, lumaBv.ver >> shiftSampleVer);
  std::vector<Mv> chromaBvList;
  chromaBvList.push_back(chromaBv);
#endif
  for (int stephor = 0; stephor < 2; stephor++)
  {
    for (int stepver = 0; stepver < 2; stepver++)
    {
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      Mv lumaBv(pu.mv[0].hor + (stephor << MV_FRACTIONAL_BITS_INTERNAL), pu.mv[0].ver + (stepver << MV_FRACTIONAL_BITS_INTERNAL));
      if (!pu.cs->sps->getIBCFracFlag())
      {
        lumaBv.set((lumaBv.hor >> bvShiftHor) << bvShiftHor, (lumaBv.ver >> bvShiftVer) << bvShiftVer);
      }
      if (!PU::xCheckSimilarChromaBv(chromaBvList, lumaBv) && PU::checkIsChromaBvCandidateValid(pu, lumaBv, filterIdx))
      {
        chromaBvList.push_back(lumaBv);
      }
#else
      lumaBv.set(pu.bv.hor + stephor, pu.bv.ver + stepver);
      chromaBv.set(lumaBv.hor >> shiftSampleHor, lumaBv.ver >> shiftSampleVer);
      if (!PU::xCheckSimilarChromaBv(chromaBvList, chromaBv) && PU::checkIsChromaBvCandidateValid(pu, chromaBv))
      {
        chromaBvList.push_back(chromaBv);
      }
#endif
    }
  }
  if (chromaBvList.size() == 1)
  {
    return chromaBvList[0];
  }

  CompArea area = pu.blocks[compId];
  int uiHeight = area.height;
  int uiWidth = area.width;
  Pel *cur = m_refBuffer[compId][PRED_BUF_UNFILTERED];
  PelBuf tempCurTop = PelBuf(cur + 1, uiWidth, Size(uiWidth, DBV_TEMPLATE_SIZE));
  PelBuf tempCurLeft = PelBuf(cur + 1 + m_refBufferStride[compId], uiHeight, Size(uiHeight, DBV_TEMPLATE_SIZE));

  Pel temp[(MAX_CU_SIZE + 1) * 2];
  memset(temp, 0, (MAX_CU_SIZE + 1) * 2 * sizeof(Pel));
  int stride = MAX_CU_SIZE + 1;
  Pel *refPix = temp;
  Pel *refPixTemp;
  const CPelBuf recBuf = pu.cs->picture->getRecoBuf(pu.cs->picture->blocks[compId]);

  DistParam cDistParam;
  cDistParam.applyWeight = false;
  Distortion uiCost;
  std::vector<std::pair<Mv, Distortion>> aBvCostVec;
  for (std::vector<Mv>::iterator it = chromaBvList.begin(); it != chromaBvList.end(); ++it)
  {
    Mv mvCurr = *it;
    if (topCanUse)
    {
      Mv mvTop(0, -DBV_TEMPLATE_SIZE);
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 2)
      {
        mvTop.setVer(uiHeight);
      }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      mvTop <<= bvShiftVer;
#endif
      mvTop += mvCurr;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      if (!PU::checkIsChromaBvCandidateValid(pu, mvTop, filterIdx, true, true))
      {
#if JVET_AA0070_RRIBC
        if (pu.cu->rribcFlipType == 2)
        {
          mvTop.setVer(mvCurr.getVer() + ((uiHeight - DBV_TEMPLATE_SIZE) << bvShiftVer));
        }
        else
#endif
        {
          mvTop = mvCurr;
        }
      }
#else
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 2)
      {
        if (!PU::checkIsChromaBvCandidateValid(pu, mvTop, true, true))
        {
          mvTop.setVer(mvCurr.getVer() + uiHeight - DBV_TEMPLATE_SIZE);
        }
      }
      else
#endif
      if (!PU::checkIsChromaBvCandidateValid(pu, mvTop, true, true))
      {
        mvTop = mvCurr;
      }
#endif

#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      bool isFracMv = pu.cs->sps->getIBCFracFlag() && mvTop.isFracMv<false>(pu.chromaFormat);
      if (isFracMv)
      {
        PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), PelBuf(refPix + 1, uiWidth, DBV_TEMPLATE_SIZE), PelBuf(refPix + 1, uiWidth, DBV_TEMPLATE_SIZE));
        pcInterPred->getPredIBCBlk(pu, compId, pu.cs->picture, mvTop, pcBuf, filterIdx == 1);
#if JVET_AA0070_RRIBC
        pcBuf.bufs[compId].flip(pu.cu->rribcFlipType);
#endif
      }
      else
      {
#endif
      refPixTemp = refPix + 1;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvTop.hor >> bvShiftHor, mvTop.ver >> bvShiftVer));
#else
      const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvTop.hor, mvTop.ver));
#endif
      for (int k = 0; k < uiWidth; k++)
      {
        for (int l = 0; l < DBV_TEMPLATE_SIZE; l++)
        {
#if JVET_AA0070_RRIBC
          int recVal;
          if (pu.cu->rribcFlipType == 0)
          {
            recVal = rec[k + l * recBuf.stride];
          }
          else if (pu.cu->rribcFlipType == 1)
          {
            recVal = rec[uiWidth - 1 - k + l * recBuf.stride];
          }
          else
          {
            recVal = rec[k + (DBV_TEMPLATE_SIZE - 1 - l) * recBuf.stride];
          }
#else
          int recVal = rec[k + l * recBuf.stride];
#endif
          refPixTemp[k] = recVal;
        }
      }
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      }
#endif
    }

    if (leftCanUse)
    {
      Mv mvLeft(-DBV_TEMPLATE_SIZE, 0);
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 1)
      {
        mvLeft.setHor(uiWidth);
      }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      mvLeft <<= bvShiftHor;
#endif
      mvLeft += mvCurr;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      if (!PU::checkIsChromaBvCandidateValid(pu, mvLeft, filterIdx, true, false))
      {
#if JVET_AA0070_RRIBC
        if (pu.cu->rribcFlipType == 1)
        {
          mvLeft.setHor(mvCurr.getHor() + ((uiWidth - DBV_TEMPLATE_SIZE) << bvShiftHor));
        }
        else
#endif
        {
          mvLeft = mvCurr;
        }
      }
#else
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 1)
      {
        if (!PU::checkIsChromaBvCandidateValid(pu, mvLeft, true, false))
        {
          mvLeft.setHor(mvCurr.getHor() + uiWidth - DBV_TEMPLATE_SIZE);
        }
      }
      else
#endif
      if (!PU::checkIsChromaBvCandidateValid(pu, mvLeft, true, false))
      {
        mvLeft = mvCurr;
      }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      bool isFracMv = pu.cs->sps->getIBCFracFlag() && mvLeft.isFracMv<false>(pu.chromaFormat);
      if (isFracMv)
      {
        PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), PelBuf(refPix + 1 + stride, DBV_TEMPLATE_SIZE, uiHeight), PelBuf(refPix + 1 + stride, DBV_TEMPLATE_SIZE, uiHeight));
        pcInterPred->getPredIBCBlk(pu, compId, pu.cs->picture, mvLeft, pcBuf, filterIdx == 1);
#if JVET_AA0070_RRIBC
        pcBuf.bufs[compId].flip(pu.cu->rribcFlipType);
#endif
      }
      else
      {
#endif
      refPixTemp = refPix + 1 + stride;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvLeft.hor >> bvShiftHor, mvLeft.ver >> bvShiftVer));
#else
      const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvLeft.hor, mvLeft.ver));
#endif
      for (int k = 0; k < uiHeight; k++)
      {
        for (int l = 0; l < DBV_TEMPLATE_SIZE; l++)
        {
#if JVET_AA0070_RRIBC
          int recVal;
          if (pu.cu->rribcFlipType == 0)
          {
            recVal = rec[recBuf.stride * k + l];
          }
          else if (pu.cu->rribcFlipType == 1)
          {
            recVal = rec[recBuf.stride * k + DBV_TEMPLATE_SIZE - 1 - l];
          }
          else
          {
            recVal = rec[recBuf.stride * (uiHeight - 1 - k) + l];
          }
#else
          int recVal = rec[recBuf.stride * k + l];
#endif
          refPixTemp[k] = recVal;
        }
      }
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      }
#endif
    }

    uiCost = 0;
    if (topCanUse)
    {
      PelBuf tempRef = PelBuf(refPix + 1, uiWidth, Size(uiWidth, DBV_TEMPLATE_SIZE));
#if JVET_AJ0096_SATD_REORDER_INTRA
      m_dbvSadCost->setDistParam(cDistParam, tempCurTop, tempRef, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), compId, uiWidth >= 4 && uiHeight >= 4 ? true : false);
#else
      m_dbvSadCost->setDistParam(cDistParam, tempCurTop, tempRef, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), compId, false);
#endif
      uiCost += cDistParam.distFunc(cDistParam);
    }
    if (leftCanUse)
    {
      PelBuf tempRef = PelBuf(refPix + 1 + stride, uiHeight, Size(uiHeight, DBV_TEMPLATE_SIZE));
#if JVET_AJ0096_SATD_REORDER_INTRA
      m_dbvSadCost->setDistParam(cDistParam, tempCurLeft, tempRef, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), compId, uiWidth >= 4 && uiHeight >= 4 ? true : false);
#else
      m_dbvSadCost->setDistParam(cDistParam, tempCurLeft, tempRef, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), compId, false);
#endif
      uiCost += cDistParam.distFunc(cDistParam);
    }
    aBvCostVec.push_back(std::pair<Mv, Distortion>(*it, uiCost));
  }
  std::stable_sort(aBvCostVec.begin(), aBvCostVec.end(), [](const std::pair<Mv, Distortion> &l, const std::pair<Mv, Distortion> &r) { return l.second < r.second; });
  return aBvCostVec[0].first;
}
#endif

#if JVET_Z0050_CCLM_SLOPE
void IntraPrediction::xUpdateCclmModel(int &a, int &b, int &iShift, int midLuma, int delta)
{
  if ( delta )
  {
    const int dShift = 3; // For 1/8 sample value adjustment
    
    delta = a > 0 ? -delta : delta;
    
    // Make final shift at least the size of the precision of the update
    if ( iShift < dShift )
    {
      a    <<= ( dShift - iShift );
      iShift = dShift;
    }
    else if ( iShift > dShift )
    {
      // Final shift is larger than the precision of the update: scale the update up to the final precision
      delta <<= ( iShift - dShift );
    }
    
    a += delta;
    b -= ( delta * midLuma ) >> iShift;
  }
}
#endif

#if JVET_AD0188_CCP_MERGE
void IntraPrediction::predIntraChromaLM( const ComponentID compID, PelBuf &piPred, PredictionUnit &pu, const CompArea& chromaArea, int intraDir, bool createModel, CclmModel *cclmModelStored )
#else
void IntraPrediction::predIntraChromaLM(const ComponentID compID, PelBuf &piPred, const PredictionUnit &pu, const CompArea& chromaArea, int intraDir, bool createModel, CclmModel *cclmModelStored)
#endif
{
#if JVET_AC0119_LM_CHROMA_FUSION
  if (pu.isChromaFusion > 1)
  {
    CccmModel cflmModel( CFLM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA));
#if MMLM
    if (PU::isMultiModeLM(pu.intraDir[1]))
    {
      int modelThr = xCflmCalcRefAver(pu, chromaArea);

      xCflmCalcModels(pu, compID, chromaArea, cflmModel, 1, modelThr);
      xCflmApplyModel(pu, compID, chromaArea, cflmModel, 1, modelThr, piPred);

      xCflmCalcModels(pu, compID, chromaArea, cflmModel, 2, modelThr);
      xCflmApplyModel(pu, compID, chromaArea, cflmModel, 2, modelThr, piPred);
    }
    else
    {
#endif
      xCflmCalcModels(pu, compID, chromaArea, cflmModel, 0, 0);
      xCflmApplyModel(pu, compID, chromaArea, cflmModel, 0, 0, piPred);
#if MMLM
    }
#endif
    return;
  }
#endif

#if JVET_AB0092_GLM_WITH_LUMA
  if (pu.glmIdc.getIdc(compID, 0) > NUM_GLM_PATTERN)
  {
    CccmModel glmModel( GLM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA));
    xGlmCalcModel(pu, compID, chromaArea, glmModel);
    xGlmApplyModel(pu, compID, chromaArea, glmModel, piPred);

 #if JVET_AD0188_CCP_MERGE
    pu.curCand.type   = CCP_TYPE_GLM4567;
    pu.curCand.glmIdc = pu.glmIdc.getIdc(compID, 0);
    PU::glmModelToCcpParams(compID, pu.curCand, glmModel 
#if JVET_AB0174_CCCM_DIV_FREE
                            , m_glmLumaOffset
#endif
                            );
#endif
    return;
  }
#endif

  int  iLumaStride = 0;
  PelBuf temp;
#if JVET_AA0126_GLM
  if (pu.glmIdc.isActive())
  {
    int glmIdc = pu.glmIdc.getIdc(compID, 0);
    Pel* glmTemp = compID == COMPONENT_Cb ? m_glmTempCb[glmIdc] : m_glmTempCr[glmIdc];
    iLumaStride = 2 * MAX_CU_SIZE + 1;
    temp = PelBuf(glmTemp + iLumaStride + 1, iLumaStride, Size(chromaArea));
  }
  else
  {
#endif
#if MMLM
    if ((intraDir == MDLM_L_IDX) || (intraDir == MDLM_T_IDX) || (intraDir == MMLM_L_IDX) || (intraDir == MMLM_T_IDX) || (m_encPreRDRun && intraDir == MMLM_CHROMA_IDX))
#else
    if ((intraDir == MDLM_L_IDX) || (intraDir == MDLM_T_IDX))
#endif
    {
      iLumaStride = 2 * MAX_CU_SIZE + 1;
      temp = PelBuf(m_pMdlmTemp + iLumaStride + 1, iLumaStride, Size(chromaArea));
    }
    else
    {
      iLumaStride = MAX_CU_SIZE + 1;
      temp = PelBuf(m_piTemp + iLumaStride + 1, iLumaStride, Size(chromaArea));
    }
#if JVET_AA0126_GLM
  }
#endif

  CclmModel cclmModel;

  if (createModel)
  {
#if LMS_LINEAR_MODEL
    xGetLMParametersLMS(pu, compID, chromaArea, cclmModel);
#else
    xGetLMParameters(pu, compID, chromaArea, cclmModel);
#endif

    // Store the created model if storage struct was provided
    if (cclmModelStored != nullptr)
    {
      *cclmModelStored = cclmModel;
    }
  }
  else
  {
    // Use the pre-calculated model
    cclmModel = *cclmModelStored;
  }

#if JVET_Z0050_CCLM_SLOPE
  xUpdateCclmModel(cclmModel.a, cclmModel.b, cclmModel.shift, cclmModel.midLuma, compID == COMPONENT_Cb ? pu.cclmOffsets.cb0 : pu.cclmOffsets.cr0);
#if MMLM
  xUpdateCclmModel(cclmModel.a2, cclmModel.b2, cclmModel.shift2, cclmModel.midLuma2, compID == COMPONENT_Cb ? pu.cclmOffsets.cb1 : pu.cclmOffsets.cr1);
#endif
#endif

#if JVET_AD0188_CCP_MERGE
  int glmIdc = pu.glmIdc.getIdc(compID, 0);
  pu.curCand.type = (glmIdc > 0) ? CCP_TYPE_GLM0123 : CCP_TYPE_CCLM;

  if (PU::isMultiModeLM(pu.intraDir[1]))
  {
    pu.curCand.type |= CCP_TYPE_MMLM;
  }

  pu.curCand.glmIdc = glmIdc;
  PU::cclmModelToCcpParams(compID, pu.curCand, cclmModel);
#endif

  ////// final prediction
  piPred.copyFrom(temp);
#if MMLM
  if (PU::isMultiModeLM(pu.intraDir[1]))
  {
    Pel*  pPred = piPred.bufAt(0, 0);
    Pel  *pLuma = temp.bufAt(0, 0);
    int uiPredStride = piPred.stride;
    int uiCWidth = chromaArea.width;
    int uiCHeight = chromaArea.height;

    for (int i = 0; i < uiCHeight; i++)
    {
      for (int j = 0; j < uiCWidth; j++)
      {
        if (pLuma[j] <= cclmModel.yThres)
        {
          pPred[j] = (Pel)ClipPel(((cclmModel.a * pLuma[j]) >> cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
        }
        else
        {
          pPred[j] = (Pel)ClipPel(((cclmModel.a2 * pLuma[j]) >> cclmModel.shift2) + cclmModel.b2, pu.cs->slice->clpRng(compID));
        }
      }
      pPred += uiPredStride;
      pLuma += iLumaStride;
    }
  }
  else
  {
#endif
    piPred.linearTransform(cclmModel.a, cclmModel.shift, cclmModel.b, true, pu.cs->slice->clpRng(compID));
#if MMLM
  }
#endif
#if JVET_AD0120_LBCCP
  if (pu.ccInsideFilter)
  {
    filterPredInside(compID, piPred, pu);
  }
#endif
}
#if JVET_AH0209_PDP
bool IntraPrediction::xPredIntraOpt(PelBuf &pDst, const PredictionUnit &pu, const uint32_t modeIdx, const ClpRng& clpRng, Pel* refF, Pel* refS)
{
#if JVET_AK0061_PDP_MPM
  uint32_t width = pu.lumaSize().width;
  uint32_t height = pu.lumaSize().height;
#else
  const uint32_t width = pDst.width;
  const uint32_t height = pDst.height;
#endif
  const int sizeKey = (width << 8) + height;
  const int sizeIdx = g_size.find( sizeKey ) != g_size.end() ? g_size[sizeKey] : -1;
  
  if( sizeIdx < 0 )
  {
    return false;
  }  
  
#if JVET_AI0208_PDP_MIP
  if( !pu.cu->mipFlag && (sizeIdx < 0 || (sizeIdx > 12 && modeIdx > 1 && (modeIdx % 4 != 2))) )
#else
  if( sizeIdx < 0 || (sizeIdx > 12 && modeIdx > 1 && (modeIdx % 4 != 2)) )
#endif
  {
    return false;
  }

  const uint32_t stride = pDst.stride;
  Pel*           pred = pDst.buf;
  const int xShift = g_sizeData[sizeIdx][8], yShift = g_sizeData[sizeIdx][9];
  bool shortLen = modeIdx < PDP_SHORT_TH[0] || (modeIdx >= PDP_SHORT_TH[1] && modeIdx <= PDP_SHORT_TH[2]);
  const int refLen = shortLen ? g_sizeData[sizeIdx][10] : g_sizeData[sizeIdx][7];
  auto ref = shortLen ? refS : refF;
#if JVET_AI0208_PDP_MIP
  int16_t*** filter = pu.cu->mipFlag ? (pu.mipTransposedFlag ? g_pdpFiltersMip[modeIdx+16][sizeIdx] : g_pdpFiltersMip[modeIdx][sizeIdx]) : g_pdpFilters[modeIdx][sizeIdx];
#else
  int16_t*** filter = g_pdpFilters[modeIdx][sizeIdx];
#endif
  const int addShift = 1 << 13;
#if JVET_AK0061_PDP_MPM 
  width = pDst.width;
  height = ((height == 32) && !pu.cu->mipFlag) ? pu.lumaSize().height : pDst.height;
#endif
  for (int y = 0; y < height; y++, pred += stride)
  {
    for (int x = 0; x < width; x++)
    {
      int sum = 0;

      const int16_t* f = filter[y >> yShift][(x >> xShift)>>2];
      for (int i = 0; i < refLen; ++i)
      {
        auto xs = x>>xShift;
        sum += ref[i] * f[(i / 8) * 32 + (xs % 4) * 8 + ( i % 8 )];
      }
      pred[x] = (Pel)Clip3(clpRng.min, clpRng.max, (std::max(0, sum) + addShift) >> 14);
    }
  }

#if JVET_AI0208_PDP_MIP
  if (sizeIdx > 12 && !pu.cu->mipFlag)
#else
  if (sizeIdx > 12)
#endif
  {

#if JVET_AK0061_PDP_MPM
    int sampFacHor = pu.lumaSize().width / 16;
    int sampFacVer = pu.lumaSize().height / 16;
    
#else
    int sampFacHor = pDst.width / 16;
    int sampFacVer = pDst.height / 16;
    
#endif
    
    int numMRLLeft = g_sizeData[sizeIdx][5];
    int numMRLTop = g_sizeData[sizeIdx][6];

#if JVET_AK0061_PDP_MPM
    int strideDst = (pu.lumaSize().width << 1) + numMRLLeft; //fetching from g_ref always.
#else
    int strideDst = (pDst.width << 1) + numMRLLeft; //fetching from g_ref always.
#endif
    Pel* ptrSrc = refF + ( strideDst * numMRLTop ) + numMRLLeft - 1;
    Pel* ref2 = refF + ( strideDst*( numMRLTop - 1 ) ) + numMRLLeft;

    pred = pDst.buf;
    for( int y = 0; y < pDst.height; y++ )
    {
      if( 0 != ( sampFacHor - 1 ) && ( y%sampFacVer == ( sampFacVer - 1 ) ) )
      {
        pred[0] = ( ptrSrc[0] + pred[1] + 1 ) >> 1;
      }

      for( int x = 1; x < pDst.width; x++ )
      {
        if( ( x%sampFacHor != ( sampFacHor - 1 ) ) && ( y%sampFacVer == ( sampFacVer - 1 ) ) )
        {
          pred[x] = ( pred[x - 1] + pred[x + 1] + 1 ) >> 1;
        }
      }

      pred += stride;
      ptrSrc += numMRLLeft;
    }

    pred = pDst.buf;
    Pel* pred1 = pred + stride;
    if( 0 != ( sampFacVer - 1 ) )
    {
      for( int x = 0; x < pDst.width; x++ )
      {
        pred[x] = ( ref2[x] + pred1[x] + 1 ) >> 1;
      }
    }

    pred += stride;
    Pel* pred0 = pred - stride;
    pred1 = pred + stride;

    for( int y = 1; y < pDst.height; y++ )
    {
      if( ( y%sampFacVer != ( sampFacVer - 1 ) ) )
      {
        for( int x = 0; x < pDst.width; x++ )
        {
          pred[x] = ( pred0[x] + pred1[x] + 1 ) >> 1;
        }
      }
      pred += stride;
      pred0 += stride;
      pred1 += stride;
    }
  }
  return true;
}
#endif
/** Function for deriving planar intra prediction. This function derives the prediction samples for planar mode (intra coding).
 */

//NOTE: Bit-Limit - 24-bit source
void IntraPrediction::xPredIntraPlanar( const CPelBuf &pSrc, PelBuf &pDst
#if JVET_AC0105_DIRECTIONAL_PLANAR
  , uint8_t plidx
#endif
)
{
  const uint32_t width  = pDst.width;
  const uint32_t height = pDst.height;

  const uint32_t log2W = floorLog2( width );
  const uint32_t log2H = floorLog2( height );

  int leftColumn[MAX_CU_SIZE + 1], topRow[MAX_CU_SIZE + 1], bottomRow[MAX_CU_SIZE], rightColumn[MAX_CU_SIZE];
  const uint32_t offset = 1 << (log2W + log2H);

  // Get left and above reference column and row
  const Pel* src = pSrc.bufAt(1, 0);

  for (int k = 0; k < width + 1; k++)
  {
    topRow[k] = src[k];
  }

  src = pSrc.bufAt(1, 1);

  for (int k = 0; k < height + 1; k++)
  {
    leftColumn[k] = src[k];
  }
#if JVET_AC0105_DIRECTIONAL_PLANAR
  if (plidx == 0)   // original planar
  {
    // Prepare intermediate variables used in interpolation
    int bottomLeft = leftColumn[height];
    int topRight   = topRow[width];

    for (int k = 0; k < width; k++)
    {
      bottomRow[k] = bottomLeft - topRow[k];
      topRow[k]    = topRow[k] << log2H;
    }

    for (int k = 0; k < height; k++)
    {
      rightColumn[k] = topRight - leftColumn[k];
      leftColumn[k]  = leftColumn[k] << log2W;
    }

    const uint32_t finalShift = 1 + log2W + log2H;
    const uint32_t stride     = pDst.stride;
    Pel *          pred       = pDst.buf;
    for (int y = 0; y < height; y++, pred += stride)
    {
      int horPred = leftColumn[y];

      for (int x = 0; x < width; x++)
      {
        horPred += rightColumn[y];
        topRow[x] += bottomRow[x];

        int vertPred = topRow[x];
        pred[x]      = ((horPred << log2H) + (vertPred << log2W) + offset) >> finalShift;
      }
    }
  }
  else if (plidx == 1)   // planar hor
  {
    // Prepare intermediate variables used in interpolation
    int topRight = topRow[width];
    for (int k = 0; k < height; k++)
    {
      rightColumn[k] = topRight - leftColumn[k];
      leftColumn[k]  = leftColumn[k] << log2W;
    }

    const uint32_t stride = pDst.stride;
    Pel *          pred   = pDst.buf;
    int            horPred;
    for (int y = 0; y < height; y++, pred += stride)
    {
      horPred = leftColumn[y];
      for (int x = 0; x < width; x++)
      {
        horPred += rightColumn[y];
        pred[x] = (horPred + (1 << (log2W - 1))) >> log2W;
      }
    }
  }
  else   // planar ver
  {
    // Prepare intermediate variables used in interpolation
    int bottomLeft = leftColumn[height];
    for (int k = 0; k < width; k++)
    {
      bottomRow[k] = bottomLeft - topRow[k];
      topRow[k]    = topRow[k] << log2H;
    }

    const uint32_t stride = pDst.stride;
    Pel *          pred   = pDst.buf;
    int            vertPred;
    for (int y = 0; y < height; y++, pred += stride)
    {
      for (int x = 0; x < width; x++)
      {
        topRow[x] += bottomRow[x];
        vertPred = topRow[x];
        pred[x]  = (vertPred + (1 << (log2H - 1))) >> log2H;
      }
    }
  }
#else
  // Prepare intermediate variables used in interpolation
  int bottomLeft = leftColumn[height];
  int topRight = topRow[width];

  for( int k = 0; k < width; k++ )
  {
    bottomRow[k] = bottomLeft - topRow[k];
    topRow[k]    = topRow[k] << log2H;
  }

  for( int k = 0; k < height; k++ )
  {
    rightColumn[k] = topRight - leftColumn[k];
    leftColumn[k]  = leftColumn[k] << log2W;
  }

  const uint32_t finalShift = 1 + log2W + log2H;
  const uint32_t stride     = pDst.stride;
  Pel*       pred       = pDst.buf;
  for( int y = 0; y < height; y++, pred += stride )
  {
    int horPred = leftColumn[y];

    for( int x = 0; x < width; x++ )
    {
      horPred += rightColumn[y];
      topRow[x] += bottomRow[x];

      int vertPred = topRow[x];
      pred[x]      = ( ( horPred << log2H ) + ( vertPred << log2W ) + offset ) >> finalShift;
    }
  }
#endif
}

void IntraPrediction::xPredIntraDc( const CPelBuf &pSrc, PelBuf &pDst, const ChannelType channelType, const bool enableBoundaryFilter )
{
  const Pel dcval = xGetPredValDc( pSrc, pDst );
  pDst.fill( dcval );
}

// Function for initialization of intra prediction parameters
#if JVET_AB0155_SGPM
void IntraPrediction::initPredIntraParams(const PredictionUnit &pu, const CompArea area, const SPS &sps, const int partIdx)
#else
void IntraPrediction::initPredIntraParams(const PredictionUnit & pu, const CompArea area, const SPS& sps)
#endif
{
  const ComponentID compId = area.compID;
  const ChannelType chType = toChannelType(compId);
#if JVET_AD0085_TMRL_EXTENSION
  bool bExtIntraDir = false;
#if JVET_W0123_TIMD_FUSION
  bExtIntraDir |= (pu.cu->timd && isLuma(chType));
#endif
#if JVET_AD0085_TMRL_EXTENSION
  bExtIntraDir |= (pu.cu->tmrlFlag && isLuma(chType));
#endif
#else
#if JVET_W0123_TIMD_FUSION
  bool bExtIntraDir = pu.cu->timd && isLuma( chType );
#endif
#endif

  const bool        useISP = NOT_INTRA_SUBPARTITIONS != pu.cu->ispMode && isLuma( chType );

  const Size   cuSize    = Size( pu.cu->blocks[compId].width, pu.cu->blocks[compId].height );
  const Size   puSize    = Size( area.width, area.height );
  const Size&  blockSize = useISP ? cuSize : puSize;
#if JVET_AB0155_SGPM
  const int dirMode = PU::getFinalIntraMode(pu, chType, partIdx);
#else
  const int      dirMode = PU::getFinalIntraMode(pu, chType);
#endif
#if JVET_W0123_TIMD_FUSION
#if JVET_AC0094_REF_SAMPLES_OPT
#if JVET_AD0085_TMRL_EXTENSION
#if JVET_AJ0146_TIMDSAD
  int timdMode = pu.cu->timdSad ? pu.cu->timdModeSad : pu.cu->timdMode;
  bool timdModeCheckWA = pu.cu->timdSad ? pu.cu->timdModeCheckWASad : pu.cu->timdModeCheckWA;
  bool timdModeSecondaryCheckWA = pu.cu->timdSad ? pu.cu->timdModeSecondaryCheckWASad : pu.cu->timdModeSecondaryCheckWA;
  bool checkWideAngle = !bExtIntraDir ? true : (timdMode != INVALID_TIMD_IDX ? timdModeCheckWA : timdModeSecondaryCheckWA);
#else
  bool checkWideAngle = !bExtIntraDir ? true : (pu.cu->timdMode != INVALID_TIMD_IDX ? pu.cu->timdModeCheckWA : pu.cu->timdModeSecondaryCheckWA);
#endif
#if JVET_AJ0061_TIMD_MERGE
  if (pu.cu->timd && pu.cu->timdMrg)
  {
    checkWideAngle = !bExtIntraDir ? true : (pu.cu->timdMode != INVALID_TIMD_IDX ? pu.cu->timdMrgModeCheckWA[pu.cu->timdMrg - 1][0] : pu.cu->timdMrgModeCheckWA[pu.cu->timdMrg - 1][1]);
  }
#endif
  int predMode = checkWideAngle ? (bExtIntraDir ? getWideAngleExt(blockSize.width, blockSize.height, dirMode) : getModifiedWideAngle(blockSize.width, blockSize.height, dirMode))
    : (bExtIntraDir ? getTimdWideAngleExt(blockSize.width, blockSize.height, dirMode) : getTimdWideAngle(blockSize.width, blockSize.height, dirMode));
  if (pu.cu->tmrlFlag && isLuma(chType))
  {
    predMode = getWideAngleExt(blockSize.width, blockSize.height, dirMode);
  }
#else
  if (bExtIntraDir)
  {
    CHECK(pu.cu->timdMode != dirMode && pu.cu->timdModeSecondary != dirMode, "Unexpected dirMode");
  }
  bool checkWideAngle = !bExtIntraDir ? true : (pu.cu->timdMode != INVALID_TIMD_IDX ? pu.cu->timdModeCheckWA : pu.cu->timdModeSecondaryCheckWA);
  const int predMode = checkWideAngle ? (bExtIntraDir ? getWideAngleExt(blockSize.width, blockSize.height, dirMode) : getModifiedWideAngle(blockSize.width, blockSize.height, dirMode))
                         : (bExtIntraDir ? getTimdWideAngleExt(blockSize.width, blockSize.height, dirMode) : getTimdWideAngle(blockSize.width, blockSize.height, dirMode));
  CHECK(!checkWideAngle && dirMode <= DC_IDX, "Unexpected mode");
#endif
#else
  const int     predMode = bExtIntraDir ? getWideAngleExt( blockSize.width, blockSize.height, dirMode ) : getModifiedWideAngle( blockSize.width, blockSize.height, dirMode );
#endif
#else
  const int     predMode = getModifiedWideAngle( blockSize.width, blockSize.height, dirMode );
#endif

#if JVET_W0123_TIMD_FUSION
  m_ipaParam.isModeVer            = bExtIntraDir ? (predMode >= EXT_DIA_IDX) : (predMode >= DIA_IDX);
#else
  m_ipaParam.isModeVer            = predMode >= DIA_IDX;
#endif
#if JVET_AJ0081_CHROMA_TMRL
  m_ipaParam.multiRefIndex        = isLuma(chType) ? pu.multiRefIdx : pu.chromaMrlIdx;
#else
  m_ipaParam.multiRefIndex        = isLuma(chType) ? pu.multiRefIdx : 0;
#endif
  m_ipaParam.refFilterFlag        = false;
  m_ipaParam.interpolationFlag    = false;
  m_ipaParam.applyPDPC            = (puSize.width >= MIN_TB_SIZEY && puSize.height >= MIN_TB_SIZEY) && m_ipaParam.multiRefIndex == 0;

#if JVET_W0123_TIMD_FUSION
  const int    intraPredAngleMode = (m_ipaParam.isModeVer) ? (predMode - (bExtIntraDir? EXT_VER_IDX : VER_IDX)) : (-(predMode - (bExtIntraDir ? EXT_HOR_IDX : HOR_IDX)));
#else
  const int    intraPredAngleMode = (m_ipaParam.isModeVer) ? predMode - VER_IDX : -(predMode - HOR_IDX);
#endif


  int absAng = 0;
#if JVET_W0123_TIMD_FUSION
  if (dirMode > DC_IDX && dirMode < (bExtIntraDir ? EXT_VDIA_IDX + 1 : NUM_LUMA_MODE)) // intraPredAngle for directional modes
#else
  if (dirMode > DC_IDX && dirMode < NUM_LUMA_MODE) // intraPredAngle for directional modes
#endif
  {
    static const int angTable[32]    = { 0,    1,    2,    3,    4,    6,     8,   10,   12,   14,   16,   18,   20,   23,   26,   29,   32,   35,   39,  45,  51,  57,  64,  73,  86, 102, 128, 171, 256, 341, 512, 1024 };
    static const int invAngTable[32] = {
      0,   16384, 8192, 5461, 4096, 2731, 2048, 1638, 1365, 1170, 1024, 910, 819, 712, 630, 565,
      512, 468,   420,  364,  321,  287,  256,  224,  191,  161,  128,  96,  64,  48,  32,  16
    };   // (512 * 32) / Angle
#if JVET_W0123_TIMD_FUSION
    static const int extAngTable[64]    = { 0, 1, 2, 3, 4, 5, 6,7, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 43, 46, 49, 52, 55, 58, 61, 64, 67, 70, 74, 78, 84, 90, 96, 102, 108, 114, 121, 128, 137, 146, 159, 172, 188, 204, 230, 256, 299, 342, 427, 512, 597, 682, 853, 1024, 1536, 2048, 3072 };
    static const int extInvAngTable[64] = {
        0, 32768, 16384, 10923, 8192, 6554, 5461, 4681, 4096, 3277, 2731, 2341, 2048, 1820, 1638, 1489, 1365, 1260, 1170, 1092, 1024, 964, 910, 862, 819, 762, 712, 669, 630, 596, 565, 537, 512, 489, 468, 443, 420, 390, 364, 341, 321, 303, 287, 271, 256, 239, 224, 206, 191, 174, 161, 142, 128, 110, 96, 77, 64, 55, 48, 38, 32, 21, 16, 11
    };   // (512 * 64) / Angle
#endif

    const int     absAngMode         = abs(intraPredAngleMode);
    const int     signAng            = intraPredAngleMode < 0 ? -1 : 1;
#if JVET_W0123_TIMD_FUSION
                  absAng             = bExtIntraDir ? extAngTable[absAngMode] : angTable[absAngMode];
    m_ipaParam.absInvAngle              = bExtIntraDir ? extInvAngTable[absAngMode] : invAngTable[absAngMode];
#else
                  absAng             = angTable  [absAngMode];

    m_ipaParam.absInvAngle           = invAngTable[absAngMode];
#endif
    m_ipaParam.intraPredAngle        = signAng * absAng;
    if (intraPredAngleMode < 0)
    {
      m_ipaParam.applyPDPC = false;
    }
    else if (intraPredAngleMode > 0)
    {
      const int sideSize = m_ipaParam.isModeVer ? puSize.height : puSize.width;
      const int maxScale = 2;
#if GRAD_PDPC
      m_ipaParam.useGradPDPC = false;
#endif

      m_ipaParam.angularScale = std::min(maxScale, floorLog2(sideSize) - (floorLog2(3 * m_ipaParam.absInvAngle - 2) - 8));
#if GRAD_PDPC
      if ((m_ipaParam.angularScale < 0) && (isLuma(compId)))
      {
        m_ipaParam.angularScale = (floorLog2(puSize.width) + floorLog2(puSize.height) - 2) >> 2;
        m_ipaParam.useGradPDPC = true;
      }
#endif
      m_ipaParam.applyPDPC &= m_ipaParam.angularScale >= 0;
    }
  }

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
  if (pu.cu->isobmcMC)
  {
    m_ipaParam.applyPDPC &= (m_intraOBMCNeighState == INTRA_OBMC_BOTH_NEIGH_AVAIL);
    m_ipaParam.useGradPDPC &= (m_intraOBMCNeighState == INTRA_OBMC_BOTH_NEIGH_AVAIL);
  }
#endif
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  if (pu.cu->cs->sps->getDisablePdpc())
  {
    m_ipaParam.applyPDPC = false;
    m_ipaParam.useGradPDPC = false;
  }
#endif

  // high level conditions and DC intra prediction
  if(   sps.getSpsRangeExtension().getIntraSmoothingDisabledFlag()
    || !isLuma( chType )
    || useISP
#if JVET_V0130_INTRA_TMP
    || PU::isTmp(pu, chType)
#endif
    || PU::isMIP( pu, chType )
    || m_ipaParam.multiRefIndex
    || DC_IDX == dirMode
    )
  {
  }
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  else if (dirMode == PNN_IDX)
  {
    m_ipaParam.refFilterFlag = false;
  }
#endif
  else if ((isLuma(chType) && pu.cu->bdpcmMode) || (!isLuma(chType) && pu.cu->bdpcmModeChroma)) // BDPCM
  {
    m_ipaParam.refFilterFlag = false;
  }
  else if (dirMode == PLANAR_IDX) // Planar intra prediction
  {
    m_ipaParam.refFilterFlag = puSize.width * puSize.height > 32 ? true : false;
  }
  else if (!useISP)// HOR, VER and angular modes (MDIS)
  {
    bool filterFlag = false;
    {
#if JVET_W0123_TIMD_FUSION
      const int diff = std::min<int>( abs( predMode - (bExtIntraDir ? EXT_HOR_IDX : HOR_IDX) ), abs( predMode - (bExtIntraDir ? EXT_VER_IDX : VER_IDX) ) );
#else
      const int diff = std::min<int>( abs( predMode - HOR_IDX ), abs( predMode - VER_IDX ) );
#endif
      const int log2Size = ((floorLog2(puSize.width) + floorLog2(puSize.height)) >> 1);
      CHECK( log2Size >= MAX_INTRA_FILTER_DEPTHS, "Size not supported" );
#if JVET_W0123_TIMD_FUSION
      filterFlag = (diff > (bExtIntraDir ? m_aucIntraFilterExt[log2Size] : m_aucIntraFilter[log2Size]));
#if JVET_AC0094_REF_SAMPLES_OPT
      filterFlag = filterFlag && (puSize.width * puSize.height > 32);
#endif
#else
      filterFlag = (diff > m_aucIntraFilter[log2Size]);
#endif
    }

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
    if (pu.cu->isobmcMC)
    {
      filterFlag = false;
    }
#endif

    // Selelection of either ([1 2 1] / 4 ) refrence filter OR Gaussian 4-tap interpolation filter
    if (filterFlag)
    {
#if JVET_W0123_TIMD_FUSION
      const bool isRefFilter       =  bExtIntraDir ? isIntegerSlopeExt(absAng) : isIntegerSlope(absAng);
#else
      const bool isRefFilter       =  isIntegerSlope(absAng);
#endif
      CHECK( puSize.width * puSize.height <= 32, "DCT-IF interpolation filter is always used for 4x4, 4x8, and 8x4 luma CB" );
      m_ipaParam.refFilterFlag     =  isRefFilter;
      m_ipaParam.interpolationFlag = !isRefFilter;
    }
  }

#if JVET_AB0157_INTRA_FUSION
#if JVET_AG0128_REF_LINE_OPT_TIMD_FUSION
#if JVET_AJ0061_TIMD_MERGE
#if JVET_AJ0146_TIMDSAD
  bool timdIsBlended = pu.cu->timdSad ? pu.cu->timdIsBlendedSad : pu.cu->timdIsBlended;
  if(pu.cu->timd && timdIsBlended  && !pu.cu->timdMrg)
#else
  if (pu.cu->timd && pu.cu->timdIsBlended && !pu.cu->timdMrg)
#endif
#else
#if JVET_AJ0146_TIMDSAD
  bool timdIsBlended = pu.cu->timdSad ? pu.cu->timdIsBlendedSad : pu.cu->timdIsBlended;
  if(pu.cu->timd && timdIsBlended)
#else
  if (pu.cu->timd && pu.cu->timdIsBlended)
#endif
#endif
  {
#if JVET_AJ0146_TIMDSAD
    if (pu.cu->timdSad)
    {
      if (pu.cu->timdModeSad != INVALID_TIMD_IDX)
      {
        m_ipaParam.fetchRef2nd = false;
        m_ipaParam.applyFusion = false;
        if (!useISP)
        {
#if JVET_AC0094_REF_SAMPLES_OPT
          int predMode2 = pu.cu->timdModeSecondaryCheckWASad ? getWideAngleExt(blockSize.width, blockSize.height, pu.cu->timdModeSecondarySad) :
            getTimdWideAngleExt(blockSize.width, blockSize.height, pu.cu->timdModeSecondarySad);
#else
          int predMode2 = getWideAngleExt(blockSize.width, blockSize.height, dirMode);
#endif
          if ( (pu.cu->timdModeSad > DC_IDX && pu.cu->timdModeSecondarySad > DC_IDX && !(abs(predMode - predMode2) > (puSize.width * puSize.height > 128? 8 : 4) || (predMode - EXT_HOR_IDX) * (predMode2 - EXT_HOR_IDX) < 0 || (predMode - EXT_VER_IDX) * (predMode2 - EXT_VER_IDX) < 0) )
            || ( (pu.cu->timdModeSad == pu.cu->timdModeSecondarySad) && (pu.cu->timdModeSad > DC_IDX) ) )
          {
            m_ipaParam.fetchRef2nd = true;
            m_ipaParam.applyFusion = true;
          }
        }
      }
    }
    else
#endif
    if (pu.cu->timdMode != INVALID_TIMD_IDX)
    {
      m_ipaParam.fetchRef2nd = false;
      m_ipaParam.applyFusion = false;
      if (!useISP)
      {
#if JVET_AC0094_REF_SAMPLES_OPT
        int predMode2 = pu.cu->timdModeSecondaryCheckWA ? getWideAngleExt(blockSize.width, blockSize.height, pu.cu->timdModeSecondary) :
          getTimdWideAngleExt(blockSize.width, blockSize.height, pu.cu->timdModeSecondary);
#else
        int predMode2 = getWideAngleExt(blockSize.width, blockSize.height, dirMode);
#endif
        if ( (pu.cu->timdMode > DC_IDX && pu.cu->timdModeSecondary > DC_IDX && !(abs(predMode - predMode2) > (puSize.width * puSize.height > 128? 8 : 4) || (predMode - EXT_HOR_IDX) * (predMode2 - EXT_HOR_IDX) < 0 || (predMode - EXT_VER_IDX) * (predMode2 - EXT_VER_IDX) < 0) )
          || ( (pu.cu->timdMode == pu.cu->timdModeSecondary) && (pu.cu->timdMode > DC_IDX) ) )
        {
          m_ipaParam.fetchRef2nd = true;
          m_ipaParam.applyFusion = true;
        }
      }
    }
  }
#if JVET_AJ0061_TIMD_MERGE
  else if (pu.cu->timd && pu.cu->timdMrg)
  {
    m_ipaParam.applyFusion = false;
    if (pu.cu->timdMode != INVALID_TIMD_IDX && pu.cu->timdMrgIsBlended[pu.cu->timdMrg - 1])
    {
      m_ipaParam.fetchRef2nd = true;
      m_ipaParam.applyFusion = true;
    }
    else if (m_ipaParam.fetchRef2nd)
    {
      bool isAngularMode = !(dirMode == PLANAR_IDX || dirMode == DC_IDX);
#if JVET_W0123_TIMD_FUSION
      const bool isIntSlope       =  bExtIntraDir ? isIntegerSlopeExt(absAng) : isIntegerSlope(absAng);
#else
      const bool isIntSlope       =  isIntegerSlope(absAng);
#endif
      m_ipaParam.applyFusion = isAngularMode && !isIntSlope && !useISP;
    }
  }
#endif
  else
  {
#endif
  m_ipaParam.applyFusion = false;
  if (m_ipaParam.fetchRef2nd)
  {
    bool isAngularMode = !(dirMode == PLANAR_IDX || dirMode == DC_IDX);

#if JVET_W0123_TIMD_FUSION
    const bool isIntSlope       =  bExtIntraDir ? isIntegerSlopeExt(absAng) : isIntegerSlope(absAng);
#else
    const bool isIntSlope       =  isIntegerSlope(absAng);
#endif

    m_ipaParam.applyFusion = isAngularMode && !isIntSlope && !useISP;

  }
#if JVET_AG0128_REF_LINE_OPT_TIMD_FUSION
  }
#endif
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  if (pu.cu->cs->sps->getDisableIntraFusion())
  {
    m_ipaParam.fetchRef2nd = false;
    m_ipaParam.applyFusion = false;
  }
  if (pu.cu->cs->sps->getDisableRefFilter())
  {
    m_ipaParam.refFilterFlag = false;
  }
#endif
#endif
}


/** Function for deriving the simplified angular intra predictions.
*
* This function derives the prediction samples for the angular mode based on the prediction direction indicated by
* the prediction mode index. The prediction direction is given by the displacement of the bottom row of the block and
* the reference row above the block in the case of vertical prediction or displacement of the rightmost column
* of the block and reference column left from the block in the case of the horizontal prediction. The displacement
* is signalled at 1/32 pixel accuracy. When projection of the predicted pixel falls inbetween reference samples,
* the predicted value for the pixel is linearly interpolated from the reference samples. All reference samples are taken
* from the extended main reference.
*/
//NOTE: Bit-Limit - 25-bit source

#if JVET_W0123_TIMD_FUSION
#if JVET_AB0157_INTRA_FUSION
void IntraPrediction::xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  const PredictionUnit& pu,
#endif
  const CPelBuf &pSrc, PelBuf &pDst, const ChannelType channelType, const ClpRng& clpRng, const bool bExtIntraDir, const CPelBuf &pSrc2nd,
#if JVET_AK0118_BF_FOR_INTRA_PRED
  bool applyBf, CodingStructure& cs, int blkQp, const PredictionUnit& puReco,
#endif
  bool isISP, int weightMode)
#else
void IntraPrediction::xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  const PredictionUnit& pu,
#endif
  const CPelBuf &pSrc, PelBuf &pDst, const ChannelType channelType, const ClpRng& clpRng, const bool bExtIntraDir)
#endif
#else
void IntraPrediction::xPredIntraAng(
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  const PredictionUnit& pu,
#endif
  const CPelBuf &pSrc, PelBuf &pDst, const ChannelType channelType, const ClpRng& clpRng)
#endif
{
  int width =int(pDst.width);
  int height=int(pDst.height);

  const bool bIsModeVer     = m_ipaParam.isModeVer;
  const int  multiRefIdx    = m_ipaParam.multiRefIndex;
#if JVET_AB0157_INTRA_FUSION
  const int  multiRefIdx2nd = multiRefIdx + 1;
#endif
  const int  intraPredAngle = m_ipaParam.intraPredAngle;
  const int  absInvAngle    = m_ipaParam.absInvAngle;

#if JVET_AB0157_INTRA_FUSION
  weightMode = m_ipaParam.applyFusion ? weightMode : 4;

  bool bRefL1Only =  weightMode ==  0;
  bool bRefL0Only =  weightMode ==  4;

  Pel* refMain = 0;
  Pel* refSide = 0;
#else
  Pel* refMain;
  Pel* refSide;
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
  bool isRefSampleMadSkipBf = false;

  if( multiRefIdx == 0 && !isISP )
  {
    const int refSampleStride = pSrc.stride;
    const Pel* refSamplePrt   = pSrc.buf;
    int topLengthLog2   = floorLog2( m_topRefLength  + 1 );
    int leftLengthLog2  = floorLog2( m_leftRefLength + 1 );
    int topLength  = 1 << topLengthLog2;
    int leftLength = 1 << leftLengthLog2;

    int topMad  = calcRefSampleTexture(refSamplePrt +               0, refSampleStride, topLength,          1, topLengthLog2  );
    int leftMad = calcRefSampleTexture(refSamplePrt + refSampleStride, refSampleStride, leftLength,         1, leftLengthLog2 );//Left Still Store by One Line

    int avgMad = ( topMad + leftMad + 1 ) >> 1;

    int refSampleMad = std::min(avgMad >> 4, 15);

    isRefSampleMadSkipBf = refSampleMad > 10 ? true : false;
  }

  if( isISP || multiRefIdx != 0 || isRefSampleMadSkipBf )
  {
    applyBf = false;
  }
#endif

#if !INTRA_6TAP
  Pel  refAbove[2 * MAX_CU_SIZE + 3 + 33 * MAX_REF_LINE_IDX];
  Pel  refLeft [2 * MAX_CU_SIZE + 3 + 33 * MAX_REF_LINE_IDX];
#else
#if JVET_AK0087_INTRA_8TAP
  Pel refAbove[(MAX_CU_SIZE << 3) + 7 + 33 * MAX_REF_LINE_IDX];
  Pel refLeft[(MAX_CU_SIZE << 3) + 7 + 33 * MAX_REF_LINE_IDX];
#else
  // 2 pixels more for 6 tap filter.
#if JVET_AC0094_REF_SAMPLES_OPT
  Pel refAbove[(MAX_CU_SIZE << 3) + 5 + 33 * MAX_REF_LINE_IDX];
  Pel refLeft[(MAX_CU_SIZE << 3) + 5 + 33 * MAX_REF_LINE_IDX];
#else
  Pel  refAbove[2 * MAX_CU_SIZE + 5 + 33 * MAX_REF_LINE_IDX];
  Pel  refLeft[2 * MAX_CU_SIZE + 5 + 33 * MAX_REF_LINE_IDX];
#endif
#endif
#if JVET_AB0157_INTRA_FUSION
  if( !bRefL1Only)
  {
#endif
  // initializing for safeguard.
  ::memset(refAbove, 0, sizeof(refAbove));
  ::memset(refLeft, 0, sizeof(refLeft));
#if JVET_AB0157_INTRA_FUSION
  }

  Pel *refMain2nd = NULL;
  Pel *refSide2nd = NULL;
#if JVET_AK0087_INTRA_8TAP
  Pel refAbove2nd[(MAX_CU_SIZE << 3) + 12 + 33 * (MAX_REF_LINE_IDX + 1)];
  Pel refLeft2nd[(MAX_CU_SIZE << 3) + 12 + 33 * (MAX_REF_LINE_IDX + 1)];
#else
#if JVET_AC0094_REF_SAMPLES_OPT
  Pel refAbove2nd[(MAX_CU_SIZE << 3) + 10 + 33 * (MAX_REF_LINE_IDX + 1)];
  Pel refLeft2nd[(MAX_CU_SIZE << 3) + 10 + 33 * (MAX_REF_LINE_IDX + 1)];
#else
  Pel refAbove2nd[2 * MAX_CU_SIZE + 10 + 33 * (MAX_REF_LINE_IDX+1)];
  Pel refLeft2nd[2 * MAX_CU_SIZE + 10 + 33 * (MAX_REF_LINE_IDX+1)];
#endif
#endif
#endif
#endif

  // Initialize the Main and Left reference array.
  if (intraPredAngle < 0)
  {
#if INTRA_6TAP
#if JVET_AK0087_INTRA_8TAP
    const Pel *src = pSrc.buf;
    Pel *dst = refAbove + height + 2;
    ::memcpy(dst, src, sizeof(Pel) * (width + 3 + multiRefIdx + 1));

    src = pSrc.buf + pSrc.stride;
    dst = refLeft + width + 2;
    ::memcpy(dst, src, sizeof(Pel) * (height + 3 + multiRefIdx + 1));

    refMain = bIsModeVer ? refAbove + height + 2 : refLeft + width + 2;
    refSide = bIsModeVer ? refLeft + width + 2: refAbove + height + 2;
#else
    // x, y range increase by 1 (right extend)
    const Pel *src = pSrc.buf;
    Pel *dst = refAbove + height + 1;
    ::memcpy(dst, src, sizeof(Pel) * (width + 2 + multiRefIdx + 1));

    src = pSrc.buf + pSrc.stride;
    dst = refLeft + width + 1;
    ::memcpy(dst, src, sizeof(Pel) * (height + 2 + multiRefIdx + 1));

    refMain = bIsModeVer ? refAbove + height + 1 : refLeft + width + 1;
    refSide = bIsModeVer ? refLeft + width + 1: refAbove + height + 1;
#endif

    // Extend the Main reference to the left.
    int sizeSide = bIsModeVer ? height : width;
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
    if (m_refSampleForOBMC && (m_intraOBMCNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL && intraPredAngle == -32))
    {
      for (int k = 1; k <= width + 2; k++)
      {
        int val = m_refSampleForOBMCBufFiltered[k];
        refMain[k] = (Pel)ClipPel(val, clpRng);
      }
    }
#endif
#if JVET_AK0087_INTRA_8TAP
    for (int k = -(sizeSide + 2); k <= -1; k++)
#else
    // left extend by 1
    for (int k = -(sizeSide + 1); k <= -1; k++)
#endif
    {
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
      if (m_refSampleForOBMC && !(m_intraOBMCNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL && intraPredAngle == -32))
      {
        if ((m_intraOBMCNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL && bIsModeVer == true) || (m_intraOBMCNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL && bIsModeVer == false))
        {
          int val = m_refSampleForOBMCBufFiltered[abs(k)];
          refMain[k] = (Pel)ClipPel(val, clpRng);
        }
        continue;
      }
#endif
      int frac32precision = (-k * absInvAngle + 8) >> 4;
      int intpel = frac32precision >> 5;
      int fracpel = frac32precision & 31;

      //std::cout << " fracPel: " << fracpel << std::endl;
      int left = refSide[Clip3(0, sizeSide + 2 + multiRefIdx, intpel)];
      int right = refSide[Clip3(0, sizeSide + 2 + multiRefIdx, intpel + 1)];
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      if (pu.cu->cs->sps->getDisableRefFilter())
      {
        refMain[k] = (Pel)(fracpel > 15 ? right : left);
      }
      else
      {
#endif
        int leftMinus1 = refSide[Clip3(0, sizeSide + 2 + multiRefIdx, intpel - 1)];
        int rightPlus1 = refSide[Clip3(0, sizeSide + 2 + multiRefIdx, intpel + 2)];
        const TFilterCoeff* f = InterpolationFilter::getWeak4TapFilterTable(fracpel);
        int val = ((int)f[0] * leftMinus1 + (int)f[1] * left + (int)f[2] * right + f[3] * (int)rightPlus1 + 32) >> 6;
        refMain[k] = (Pel)ClipPel(val, clpRng);
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
      }
#endif
    }
#else
    for (int x = 0; x <= width + 1 + multiRefIdx; x++)
    {
      refAbove[x + height] = pSrc.at(x, 0);
    }
    for (int y = 0; y <= height + 1 + multiRefIdx; y++)
    {
      refLeft[y + width] = pSrc.at(y, 1);
    }
    refMain = bIsModeVer ? refAbove + height : refLeft + width;
    refSide = bIsModeVer ? refLeft + width : refAbove + height;

    // Extend the Main reference to the left.
    int sizeSide = bIsModeVer ? height : width;
    for (int k = -sizeSide; k <= -1; k++)
    {
      refMain[k] = refSide[std::min((-k * absInvAngle + 256) >> 9, sizeSide)];
    }
#endif
  }
  else
  {
#if INTRA_6TAP
#if JVET_AK0087_INTRA_8TAP
    const Pel *src = pSrc.buf;
    Pel *dst = refAbove + 2;
    ::memcpy(dst, src, sizeof(Pel) * (m_topRefLength + multiRefIdx + 2));

    src = pSrc.buf + pSrc.stride;
    dst = refLeft + 2;
    ::memcpy(dst, src, sizeof(Pel) * (m_leftRefLength + multiRefIdx + 2));

    refAbove[1] = refAbove[2];
    refAbove[0] = refAbove[1];
    refLeft[1] = refLeft[2];
    refLeft[0] = refLeft[1];
    refMain = bIsModeVer ? refAbove + 2 : refLeft + 2;
    refSide = bIsModeVer ? refLeft + 2 : refAbove + 2;

    const int log2Ratio = floorLog2(width) - floorLog2(height);
    const int s = std::max<int>(0, bIsModeVer ? log2Ratio : -log2Ratio);
#if JVET_W0123_TIMD_FUSION
    const int maxIndex  = (multiRefIdx << s) + 6;
#else
    const int maxIndex = (multiRefIdx << s) + 2;
#endif
    const int refLength = bIsModeVer ? m_topRefLength : m_leftRefLength;
    const Pel val = refMain[refLength + multiRefIdx];
    for (int z = 1; z <= (maxIndex+2); z++)
    {
      refMain[refLength + multiRefIdx + z] = val;
    }
#else
    const Pel *src = pSrc.buf;
    Pel *dst = refAbove + 1;
    ::memcpy(dst, src, sizeof(Pel) * (m_topRefLength + multiRefIdx + 1));

    src = pSrc.buf + pSrc.stride;
    dst = refLeft + 1;
    ::memcpy(dst, src, sizeof(Pel) * (m_leftRefLength + multiRefIdx + 1));

    // left extended by 1
    refAbove[0] = refAbove[1];
    refLeft[0] = refLeft[1];
    refMain = bIsModeVer ? refAbove + 1 : refLeft + 1;
    refSide = bIsModeVer ? refLeft + 1 : refAbove + 1;

    // Extend main reference to right using replication
    const int log2Ratio = floorLog2(width) - floorLog2(height);
    const int s = std::max<int>(0, bIsModeVer ? log2Ratio : -log2Ratio);
#if JVET_W0123_TIMD_FUSION
    const int maxIndex  = (multiRefIdx << s) + 6;
#else
    const int maxIndex = (multiRefIdx << s) + 2;
#endif
    const int refLength = bIsModeVer ? m_topRefLength : m_leftRefLength;
    const Pel val = refMain[refLength + multiRefIdx];
    // right extended by 1 (z range)
    for (int z = 1; z <= (maxIndex + 1); z++)
    {
      refMain[refLength + multiRefIdx + z] = val;
    }
#endif
#else
    for (int x = 0; x <= m_topRefLength + multiRefIdx; x++)
    {
      refAbove[x] = pSrc.at(x, 0);
    }
    for (int y = 0; y <= m_leftRefLength + multiRefIdx; y++)
    {
      refLeft[y] = pSrc.at(y, 1);
    }

    refMain = bIsModeVer ? refAbove : refLeft;
    refSide = bIsModeVer ? refLeft : refAbove;

    // Extend main reference to right using replication
    const int log2Ratio = floorLog2(width) - floorLog2(height);
    const int s         = std::max<int>(0, bIsModeVer ? log2Ratio : -log2Ratio);
#if JVET_W0123_TIMD_FUSION
    const int maxIndex  = (multiRefIdx << s) + 6;
#else
    const int maxIndex  = (multiRefIdx << s) + 2;
#endif
    const int refLength = bIsModeVer ? m_topRefLength : m_leftRefLength;
    const Pel val       = refMain[refLength + multiRefIdx];
    for (int z = 1; z <= maxIndex; z++)
    {
      refMain[refLength + multiRefIdx + z] = val;
    }
#endif
  }


#if JVET_AB0157_INTRA_FUSION
  if (!bRefL0Only)
  {
    // initializing for safeguard.
    ::memset(refAbove2nd, 0, sizeof(refAbove2nd));
    ::memset(refLeft2nd, 0, sizeof(refAbove2nd));
    // Initialize the Main and Left reference array.
    if (intraPredAngle < 0)
    {
#if JVET_AK0087_INTRA_8TAP
      const Pel *src = pSrc2nd.buf;
      Pel *      dst = refAbove2nd + height + 3;
      ::memcpy(dst, src, sizeof(Pel) * (m_topRefLength + 2 + multiRefIdx2nd));

      src = pSrc2nd.buf + pSrc2nd.stride;
      dst = refLeft2nd + width + 3;
      ::memcpy(dst, src, sizeof(Pel) * (m_leftRefLength + 2 + multiRefIdx2nd));

      refMain2nd = bIsModeVer ? refAbove2nd + height + 3 : refLeft2nd + width + 3;
      refSide2nd = bIsModeVer ? refLeft2nd + width + 3 : refAbove2nd + height + 3;
#else
      // x, y range increase by 1 (right extend)
      const Pel *src = pSrc2nd.buf;
      Pel *      dst = refAbove2nd + height + 2;
      ::memcpy(dst, src, sizeof(Pel) * (m_topRefLength + 1 + multiRefIdx2nd));

      src = pSrc2nd.buf + pSrc2nd.stride;
      dst = refLeft2nd + width + 2;
      ::memcpy(dst, src, sizeof(Pel) * (m_leftRefLength + 1 + multiRefIdx2nd));

      refMain2nd = bIsModeVer ? refAbove2nd + height + 2 : refLeft2nd + width + 2;
      refSide2nd = bIsModeVer ? refLeft2nd + width + 2 : refAbove2nd + height + 2;
#endif

      // Extend the Main reference to the left.
      int sizeSide = bIsModeVer ? height : width;
      int sizeSideRange = bIsModeVer ? m_leftRefLength + multiRefIdx2nd : m_topRefLength + multiRefIdx2nd;
#if JVET_AK0087_INTRA_8TAP
      for (int k = -(sizeSide + 3); k <= -1; k++)
#else
      // left extend by 1
      for (int k = -(sizeSide + 2); k <= -1; k++)
#endif
      {
        int frac32precision = (-k * absInvAngle + 8) >> 4;
        int intpel          = frac32precision >> 5;
        int fracpel         = frac32precision & 31;

        // std::cout << " fracPel: " << fracpel << std::endl;        
        int left        = refSide2nd[Clip3(0, sizeSideRange, intpel)];
        int right       = refSide2nd[Clip3(0, sizeSideRange, intpel + 1)];
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
        if (pu.cu->cs->sps->getDisableRefFilter())
        {
          refMain2nd[k] = (Pel)(fracpel > 15 ? right : left);
        }
        else
        {
#endif
          int leftMinus1 = refSide2nd[Clip3(0, sizeSideRange, intpel - 1)];
          int rightPlus1 = refSide2nd[Clip3(0, sizeSideRange, intpel + 2)];
          const TFilterCoeff* f = InterpolationFilter::getWeak4TapFilterTable(fracpel);
          int val = ((int)f[0] * leftMinus1 + (int)f[1] * left + (int)f[2] * right + f[3] * (int)rightPlus1 + 32) >> 6;
          refMain2nd[k] = (Pel)ClipPel(val, clpRng);
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
        }
#endif
      }
    }
    else
    {
#if JVET_AK0087_INTRA_8TAP
      const Pel *src = pSrc2nd.buf;
      Pel *      dst = refAbove2nd + 2;
      ::memcpy(dst, src, sizeof(Pel) * (m_topRefLength + multiRefIdx2nd + 2));

      src = pSrc2nd.buf + pSrc2nd.stride;
      dst = refLeft2nd + 2;
      ::memcpy(dst, src, sizeof(Pel) * (m_leftRefLength + multiRefIdx2nd + 2));

      refAbove2nd[1] = refAbove2nd[2];
      refAbove2nd[0] = refAbove2nd[1];
      refLeft2nd[1]  = refLeft2nd[2];
      refLeft2nd[0]  = refLeft2nd[1];
      refMain2nd     = bIsModeVer ? refAbove2nd + 2 : refLeft2nd + 2;
      refSide2nd     = bIsModeVer ? refLeft2nd + 2 : refAbove2nd + 2;

      const int log2Ratio = floorLog2(width) - floorLog2(height);
      const int s = std::max<int>(0, bIsModeVer ? log2Ratio : -log2Ratio);

#if JVET_W0123_TIMD_FUSION
      const int maxIndex = (multiRefIdx2nd << s) + 6 + 4;
#else
      const int maxIndex = (multiRefIdx2nd << s) + 2;
#endif
      const int refLength = bIsModeVer ? m_topRefLength : m_leftRefLength;
      const Pel val       = refMain2nd[refLength + multiRefIdx2nd];
      for (int z = 1; z <= (maxIndex + 2); z++)
      {
        refMain2nd[refLength + multiRefIdx2nd + z] = val;
      }
#else
      const Pel *src = pSrc2nd.buf;
      Pel *      dst = refAbove2nd + 1;
      ::memcpy(dst, src, sizeof(Pel) * (m_topRefLength + multiRefIdx2nd + 1));

      src = pSrc2nd.buf + pSrc2nd.stride;
      dst = refLeft2nd + 1;
      ::memcpy(dst, src, sizeof(Pel) * (m_leftRefLength + multiRefIdx2nd + 1));

      // left extended by 1
      refAbove2nd[0] = refAbove2nd[1];
      refLeft2nd[0]  = refLeft2nd[1];
      refMain2nd     = bIsModeVer ? refAbove2nd + 1 : refLeft2nd + 1;
      refSide2nd     = bIsModeVer ? refLeft2nd + 1 : refAbove2nd + 1;

      const int log2Ratio = floorLog2(width) - floorLog2(height);
      const int s = std::max<int>(0, bIsModeVer ? log2Ratio : -log2Ratio);

      // Extend main reference to right using replication
#if JVET_W0123_TIMD_FUSION
      const int maxIndex = (multiRefIdx2nd << s) + 6 + 4;
#else
      const int maxIndex = (multiRefIdx2nd << s) + 2;
#endif
      const int refLength = bIsModeVer ? m_topRefLength : m_leftRefLength;
      const Pel val       = refMain2nd[refLength + multiRefIdx2nd];
      // right extended by 1 (z range)
      for (int z = 1; z <= (maxIndex + 1); z++)
      {
        refMain2nd[refLength + multiRefIdx2nd + z] = val;
      }
#endif
    }


    refMain2nd += multiRefIdx2nd;
    refSide2nd += multiRefIdx2nd;
  }

#endif

  // swap width/height if we are doing a horizontal mode:
  if (!bIsModeVer)
  {
    std::swap(width, height);
  }
  Pel       tempArray[MAX_CU_SIZE * MAX_CU_SIZE];
  const int dstStride = bIsModeVer ? pDst.stride : width;
  Pel *     pDstBuf   = bIsModeVer ? pDst.buf : tempArray;

  // compensate for line offset in reference line buffers
  refMain += multiRefIdx;
  refSide += multiRefIdx;

  Pel *pDsty = pDstBuf;

  if( intraPredAngle == 0 )  // pure vertical or pure horizontal
  {
    for( int y = 0; y < height; y++ )
    {
      ::memcpy(pDsty, refMain + 1, width * sizeof(Pel));

      if (m_ipaParam.applyPDPC)
      {
        const int scale   = (floorLog2(width) + floorLog2(height) - 2) >> 2;
        const Pel topLeft = refMain[0];
        const Pel left    = refSide[1 + y];
        for (int x = 0; x < std::min(3 << scale, width); x++)
        {
          const int wL  = 32 >> (2 * x >> scale);
          const Pel val = pDsty[x];
          pDsty[x]      = ClipPel(val + ((wL * (left - topLeft) + 32) >> 6), clpRng);
        }
      }

      pDsty += dstStride;
    }
  }
  else
  {
    for (int y = 0, deltaPos = intraPredAngle * (1 + multiRefIdx); y<height; y++, deltaPos += intraPredAngle, pDsty += dstStride)
    {
#if JVET_W0123_TIMD_FUSION
      const int deltaInt   = bExtIntraDir ? deltaPos >> 6 : deltaPos >> 5;
      const int deltaFract = bExtIntraDir ? deltaPos & 63 : deltaPos & 31;
#if JVET_AB0157_INTRA_FUSION
      const int deltaInt2nd   = bExtIntraDir ? (deltaPos + intraPredAngle) >> 6 : (deltaPos + intraPredAngle) >> 5;
      const int deltaFract2nd = bExtIntraDir ? (deltaPos + intraPredAngle) & 63 : (deltaPos + intraPredAngle) & 31;
#endif
#else
      const int deltaInt   = deltaPos >> 5;
      const int deltaFract = deltaPos & 31;
#endif

#if JVET_W0123_TIMD_FUSION
      bool bIntSlope = bExtIntraDir ? isIntegerSlopeExt( abs(intraPredAngle) ) : isIntegerSlope( abs(intraPredAngle) );
      if ( !bIntSlope )
#else
      if ( !isIntegerSlope( abs(intraPredAngle) ) )
#endif
      {
        if( isLuma(channelType) )
        {
          const bool useCubicFilter = !m_ipaParam.interpolationFlag;

#if JVET_AK0087_INTRA_8TAP
          bool use8TapFilter=false;
          if (useCubicFilter)
          {
            const int log2Size = (floorLog2(width) + floorLog2(height)) >> 1;
            const int diff = std::min( abs( intraPredAngle - (bExtIntraDir ? EXT_HOR_IDX : HOR_IDX) ), abs( intraPredAngle - (bExtIntraDir ? EXT_VER_IDX : VER_IDX) ) );
            use8TapFilter = (diff > (bExtIntraDir ? log2Size: log2Size/2)) && (log2Size < (bExtIntraDir ? 6 : 4));
          }
#endif

#if INTRA_6TAP
          const TFilterCoeff        intraSmoothingFilter[6] = { TFilterCoeff(0), TFilterCoeff(64 - (deltaFract << 1)), TFilterCoeff(128 - (deltaFract << 1)), TFilterCoeff(64 + (deltaFract << 1)), TFilterCoeff(deltaFract << 1), TFilterCoeff(0) };
          const TFilterCoeff        intraSmoothingFilter2[6] = { TFilterCoeff(16 - (deltaFract >> 1)), TFilterCoeff(64 - 3*(deltaFract >> 1)), TFilterCoeff(96 - (deltaFract)), TFilterCoeff(64 + (deltaFract)),
            TFilterCoeff(16 + 3*(deltaFract >> 1)), TFilterCoeff((deltaFract >> 1)) };
#if JVET_W0123_TIMD_FUSION
          const TFilterCoeff        intraSmoothingFilterExt[6] = { TFilterCoeff(0), TFilterCoeff(64 - (deltaFract)), TFilterCoeff(128 - (deltaFract)), TFilterCoeff(64 + (deltaFract)), TFilterCoeff(deltaFract), TFilterCoeff(0) };
          const TFilterCoeff        intraSmoothingFilter2Ext[6] = { TFilterCoeff(16 - (deltaFract >> 2)), TFilterCoeff(64 - 3*(deltaFract >> 2)), TFilterCoeff(96 - (deltaFract >> 1)), TFilterCoeff(64 + (deltaFract >> 1)),
            TFilterCoeff(16 + 3*(deltaFract >> 2)), TFilterCoeff((deltaFract >> 2)) };
#if JVET_AK0087_INTRA_8TAP
          const TFilterCoeff* const f = (useCubicFilter)  ? (use8TapFilter  ? ( bExtIntraDir ? InterpolationFilter::getExtIntra8tapCubicFilter(deltaFract) : InterpolationFilter::getIntra8tapCubicFilter(deltaFract) )
                                                                            : ( bExtIntraDir ? InterpolationFilter::getIntraLumaFilterTableExt(deltaFract) : InterpolationFilter::getIntraLumaFilterTable(deltaFract) ) )
                                                          : (width >= 32 && height >= 32) ? (bExtIntraDir ? intraSmoothingFilter2Ext : intraSmoothingFilter2) 
                                                                                          : (bExtIntraDir ? intraSmoothingFilterExt  : intraSmoothingFilter);
#else
          const TFilterCoeff* const f = (useCubicFilter) ? ( bExtIntraDir ? InterpolationFilter::getIntraLumaFilterTableExt(deltaFract) : InterpolationFilter::getIntraLumaFilterTable(deltaFract)) : (width >=32 && height >=32)? (bExtIntraDir ? intraSmoothingFilter2Ext : intraSmoothingFilter2) : (bExtIntraDir ? intraSmoothingFilterExt : intraSmoothingFilter);
#endif
#else
          const TFilterCoeff* const f = (useCubicFilter) ? InterpolationFilter::getIntraLumaFilterTable(deltaFract) : (width >=32 && height >=32)? intraSmoothingFilter2 : intraSmoothingFilter;
#endif
#else
#if IF_12TAP
          const TFilterCoeff        intraSmoothingFilter[4] = { TFilterCoeff(64 - (deltaFract << 1)), TFilterCoeff(128 - (deltaFract << 1)), TFilterCoeff(64 + (deltaFract << 1)), TFilterCoeff(deltaFract << 1) };   
#if JVET_W0123_TIMD_FUSION
          const TFilterCoeff        intraSmoothingFilterExt[4] = { TFilterCoeff(64 - (deltaFract)), TFilterCoeff(128 - (deltaFract)), TFilterCoeff(64 + (deltaFract)), TFilterCoeff(deltaFract) };
#endif
#else
          const TFilterCoeff        intraSmoothingFilter[4] = {TFilterCoeff(16 - (deltaFract >> 1)), TFilterCoeff(32 - (deltaFract >> 1)), TFilterCoeff(16 + (deltaFract >> 1)), TFilterCoeff(deltaFract >> 1)};
#endif  

#if JVET_W0123_TIMD_FUSION
          const TFilterCoeff* const f                       = (useCubicFilter) ? (bExtIntraDir ? InterpolationFilter::getExtIntraCubicFilter(deltaFract) : InterpolationFilter::getChromaFilterTable(deltaFract)) : (bExtIntraDir ? InterpolationFilter::getExtIntraGaussFilter(deltaFract) : intraSmoothingFilter);
#else
          const TFilterCoeff* const f                       = (useCubicFilter) ? InterpolationFilter::getChromaFilterTable(deltaFract) : intraSmoothingFilter;
#endif
#endif

#if JVET_AB0157_INTRA_FUSION
          const TFilterCoeff        intraSmoothingFilterRL[6] = { TFilterCoeff(0), TFilterCoeff(64 - (deltaFract2nd << 1)), TFilterCoeff(128 - (deltaFract2nd << 1)), TFilterCoeff(64 + (deltaFract2nd << 1)), TFilterCoeff(deltaFract2nd << 1), TFilterCoeff(0) };
          const TFilterCoeff        intraSmoothingFilter2RL[6] = { TFilterCoeff(16 - (deltaFract2nd >> 1)), TFilterCoeff(64 - 3*(deltaFract2nd >> 1)), TFilterCoeff(96 - (deltaFract2nd)), TFilterCoeff(64 + (deltaFract2nd)),
            TFilterCoeff(16 + 3*(deltaFract2nd >> 1)), TFilterCoeff((deltaFract2nd >> 1)) };
#if JVET_W0123_TIMD_FUSION
          const TFilterCoeff        intraSmoothingFilterExtRL[6] = { TFilterCoeff(0), TFilterCoeff(64 - (deltaFract2nd)), TFilterCoeff(128 - (deltaFract2nd)), TFilterCoeff(64 + (deltaFract2nd)), TFilterCoeff(deltaFract2nd), TFilterCoeff(0) };
          const TFilterCoeff        intraSmoothingFilter2ExtRL[6] = { TFilterCoeff(16 - (deltaFract2nd >> 2)), TFilterCoeff(64 - 3*(deltaFract2nd >> 2)), TFilterCoeff(96 - (deltaFract2nd >> 1)), TFilterCoeff(64 + (deltaFract2nd >> 1)),
            TFilterCoeff(16 + 3*(deltaFract2nd >> 2)), TFilterCoeff((deltaFract2nd >> 2)) };
#if JVET_AK0087_INTRA_8TAP
          const TFilterCoeff* const fRL = (useCubicFilter)  ? ( use8TapFilter  ? ( bExtIntraDir ? InterpolationFilter::getExtIntra8tapCubicFilter(deltaFract2nd) : InterpolationFilter::getIntra8tapCubicFilter(deltaFract2nd))
                                                                               : ( bExtIntraDir ? InterpolationFilter::getIntraLumaFilterTableExt(deltaFract2nd) : InterpolationFilter::getIntraLumaFilterTable(deltaFract2nd)) )
                                                            : (width >=32 && height >=32) ? (bExtIntraDir ? intraSmoothingFilter2ExtRL : intraSmoothingFilter2RL) 
                                                                                          : (bExtIntraDir ? intraSmoothingFilterExtRL  : intraSmoothingFilterRL);
#else
          const TFilterCoeff* const fRL = (useCubicFilter) ? ( bExtIntraDir ? InterpolationFilter::getIntraLumaFilterTableExt(deltaFract2nd) : InterpolationFilter::getIntraLumaFilterTable(deltaFract2nd)) : (width >=32 && height >=32)? (bExtIntraDir ? intraSmoothingFilter2ExtRL : intraSmoothingFilter2RL) : (bExtIntraDir ? intraSmoothingFilterExtRL : intraSmoothingFilterRL);
#endif
#else
          const TFilterCoeff* const fRL = (useCubicFilter) ? InterpolationFilter::getIntraLumaFilterTable(deltaFract2nd) : (width >=32 && height >=32)? intraSmoothingFilter2RL : intraSmoothingFilterRL;
#endif
#if JVET_AK0087_INTRA_8TAP
          if ( use8TapFilter )
          {
            const int normNum = 128; 
            const int bitShift = 8;
            if (weightMode == 0)
            {
              for (int x = 0; x < width; x++)
              {
                Pel *q = refMain2nd + deltaInt2nd + x - 2;
                const int val32 = ( ((int) fRL[0] * q[0] + (int) fRL[1] * q[1] + (int) fRL[2] * q[2] + (int) fRL[3] * q[3] + (int) fRL[4] * q[4] + (int) fRL[5] * q[5] + (int) fRL[6] * q[6] + (int) fRL[7] * q[7]) + normNum) >> bitShift;
                const Pel val   = (Pel)ClipPel(val32, clpRng);
                pDsty[x]        = ClipPel(val, clpRng);   // always clip even though not always needed
              }
            }
            else if(weightMode == 4)
            {
              for (int x = 0; x < width; x++)
              {
                Pel *p = refMain + deltaInt + x - 2;
                const int val32 = ((int) f[0] * p[0] + (int) f[1] * p[1] + (int) f[2] * p[2] + (int) f[3] * p[3] + (int) f[4] * p[4] + (int) f[5] * p[5]  + (int) f[6] * p[6] + (int) f[7] * p[7] + normNum) >> bitShift;
                const Pel val   = (Pel)ClipPel(val32, clpRng);
                pDsty[x]        = ClipPel(val, clpRng);   // always clip even though not always needed
              }
            }
            else
            {
              for (int x = 0; x < width; x++)
              {
                const int w0 = weightMode;
                const int w1 = 4 - weightMode;
                Pel *q     = refMain2nd + deltaInt2nd + x - 2;
                Pel *p     = refMain + deltaInt + x - 2;
                const int val32 = (w0*((int) f[0] * p[0] + (int) f[1] * p[1] + (int) f[2] * p[2] + (int) f[3] * p[3] + (int) f[4] * p[4] + (int) f[5] * p[5] + (int) f[6] * p[6] + (int) f[7] * p[7])
                                 + w1*((int) fRL[0] * q[0] + (int) fRL[1] * q[1] + (int) fRL[2] * q[2] + (int) fRL[3] * q[3] + (int) fRL[4] * q[4] + (int) fRL[5] * q[5] + (int) fRL[6] * q[6] + (int) fRL[7] * q[7])
                                 + normNum*4 ) >> (bitShift+2);
                const Pel val   = (Pel)ClipPel(val32, clpRng);
                pDsty[x] = ClipPel(val, clpRng);   // always clip even though not always needed
              }
            }
          }
          else //6-tap non-smoothing interpolation filter or smoothing interpolation filters
          {
#endif
          if (weightMode == 0)
          {
            for (int x = 0; x < width; x++)
            {
              int val32 = 0;
              Pel *q     = refMain2nd + deltaInt2nd + x - 1;
              val32 = ( ((int) fRL[0] * q[0] + (int) fRL[1] * q[1] + (int) fRL[2] * q[2] + (int) fRL[3] * q[3] + (int) fRL[4] * q[4] + (int) fRL[5] * q[5]) + 128) >> 8;
              Pel val = (Pel)ClipPel(val32, clpRng);
              pDsty[x] = ClipPel(val, clpRng);   // always clip even though not always needed
            }
          }
          else if(weightMode == 4)
          {
            for (int x = 0; x < width; x++)
            {
              int val32 = 0;
              Pel *p     = refMain + deltaInt + x - 1;
              val32 = ((int) f[0] * p[0] + (int) f[1] * p[1] + (int) f[2] * p[2] + (int) f[3] * p[3] + (int) f[4] * p[4] + (int) f[5] * p[5] + 128) >> 8;
              Pel val = (Pel)ClipPel(val32, clpRng);
              pDsty[x] = ClipPel(val, clpRng);   // always clip even though not always needed
            }
          }
          else
          {
            for (int x = 0; x < width; x++)
            {
              int val32 = 0;
              int w0 = weightMode, w1;
              w1 = 4 - weightMode;

              Pel *q     = refMain2nd + deltaInt2nd + x - 1;
              Pel *p     = refMain + deltaInt + x - 1;
              val32 = (w0*((int) f[0] * p[0] + (int) f[1] * p[1] + (int) f[2] * p[2] + (int) f[3] * p[3] + (int) f[4] * p[4] + (int) f[5] * p[5])
                  + w1*((int) fRL[0] * q[0] + (int) fRL[1] * q[1] + (int) fRL[2] * q[2] + (int) fRL[3] * q[3] + (int) fRL[4] * q[4] + (int) fRL[5] * q[5]) + 512) >> 10;
              Pel val = (Pel)ClipPel(val32, clpRng);
              pDsty[x] = ClipPel(val, clpRng);   // always clip even though not always needed
            }
          }
#if JVET_AK0087_INTRA_8TAP
          }
#endif
#else
          for (int x = 0; x < width; x++)
          {
#if INTRA_6TAP
            Pel* p = refMain + deltaInt + x - 1;
            int val32 = ((int)f[0] * p[0] + (int)f[1] * p[1] + (int)f[2] * p[2] + (int)f[3] * p[3] + (int)f[4] * p[4] + (int)f[5] * p[5] + 128) >> 8;
            Pel val = (Pel)ClipPel(val32, clpRng);
#else
            Pel p[4];

            p[0] = refMain[deltaInt + x];
            p[1] = refMain[deltaInt + x + 1];
            p[2] = refMain[deltaInt + x + 2];
            p[3] = refMain[deltaInt + x + 3];

#if IF_12TAP
            Pel val = ( f[0] * p[0] + f[1] * p[1] + f[2] * p[2] + f[3] * p[3] + 128 ) >> 8;
#else
#if JVET_W0123_TIMD_FUSION
            int tOffset = 32;
            int tShift = 6;
            if (bExtIntraDir)
            {
              tOffset = 128;
              tShift = 8;
            }
            Pel val = (f[0] * p[0] + f[1] * p[1] + f[2] * p[2] + f[3] * p[3] + tOffset) >> tShift;
#else
            Pel val = (f[0] * p[0] + f[1] * p[1] + f[2] * p[2] + f[3] * p[3] + 32) >> 6;
#endif
#endif
#endif

            pDsty[x] = ClipPel(val, clpRng);   // always clip even though not always needed
          }
#endif
        }
        else
        {
          // Do linear filtering
          for (int x = 0; x < width; x++)
          {
            Pel* p = refMain + deltaInt + x + 1;
            pDsty[x] = p[0] + ((deltaFract * (p[1] - p[0]) + 16) >> 5);
          }
        }
      }
      else
      {
        // Just copy the integer samples
        ::memcpy(pDsty, refMain + deltaInt + 1, width * sizeof(Pel));
      }
#if GRAD_PDPC
#if JVET_AB0157_INTRA_FUSION
      if (m_ipaParam.applyPDPC && m_ipaParam.useGradPDPC && !bRefL1Only)
#else
      if (m_ipaParam.applyPDPC && m_ipaParam.useGradPDPC)
#endif
      {
        const int scale = m_ipaParam.angularScale;
        const Pel left = refSide[1 + y];
#if JVET_W0123_TIMD_FUSION
        int gradOffset = 16;
        int gradShift = 5;
        if (bExtIntraDir)
        {
          gradOffset = 32;
          gradShift = 6;
        }
        const Pel topLeft = refMain[deltaInt] + ((deltaFract * (refMain[deltaInt + 1] - refMain[deltaInt]) + gradOffset) >> gradShift);
#else
        const Pel topLeft = refMain[deltaInt] + ((deltaFract * (refMain[deltaInt + 1] - refMain[deltaInt]) + 16) >> 5);
#endif

        for (int x = 0; x < std::min(3 << scale, width); x++)
        {
          int wL = 32 >> (2 * x >> scale);
          const Pel val = pDsty[x];
          pDsty[x] = ClipPel(val + ((wL * (left - topLeft) + 32) >> 6), clpRng);
        }
      }
      else
#endif
#if JVET_AB0157_INTRA_FUSION
      if (m_ipaParam.applyPDPC && !bRefL1Only)
#else
      if (m_ipaParam.applyPDPC)
#endif
      {
        const int scale       = m_ipaParam.angularScale;
        int       invAngleSum = 256;

        for (int x = 0; x < std::min(3 << scale, width); x++)
        {
          invAngleSum += absInvAngle;

          int wL   = 32 >> (2 * x >> scale);
          Pel left = refSide[y + (invAngleSum >> 9) + 1];
          pDsty[x] = pDsty[x] + ((wL * (left - pDsty[x]) + 32) >> 6);
        }
      }
    }
  }

  // Flip the block if this is the horizontal mode
  if( !bIsModeVer )
  {
    for( int y = 0; y < height; y++ )
    {
      Pel *dst = pDst.buf + y;

      for( int x = 0; x < width; x++ )
      {
        *dst = pDstBuf[x];
        dst += pDst.stride;
      }
      pDstBuf += dstStride;
    }
  }
#if JVET_AK0118_BF_FOR_INTRA_PRED
  if( applyBf )
  {
    int blkWidth   = pDst.width;
    int blkHeight  = pDst.height;
    bilateralFilterPredDiamond5x5Clip(cs, channelType, pDst, blkWidth, blkHeight, blkQp, clpRng, true, *pu.cu );
  }
#endif
}
#if JVET_AH0076_OBIC
void IntraPrediction::generateObicBlending(PelBuf &piPred, const PredictionUnit &pu, PelBuf predFusion[OBIC_FUSION_NUM - 1], bool blendModes[OBIC_FUSION_NUM - 1], int planarIdx)
{
  const int height = piPred.height;
  const int width = piPred.width;
  const UnitArea localUnitArea( pu.chromaFormat, Area( 0, 0, width, height ) );
  PelBuf predFusionBV = m_tempBuffer[7].getBuf( localUnitArea.Y() );
  if (pu.cu->isBvDimd)
  {
    predUsingBv(predFusionBV.buf, predFusionBV.stride, pu.cu->bvDimd, *pu.cu);
  }
#if JVET_AK0056_WEIGHTED_OBIC
  Pel *pelFusion[OBIC_FUSION_NUM - 1];
  int strideFusion[OBIC_FUSION_NUM - 1];

  for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
  {
    pelFusion[i] = (i == planarIdx && pu.cu->isBvDimd) ? predFusionBV.buf : predFusion[i].buf;
    strideFusion[i] = (i == planarIdx && pu.cu->isBvDimd) ? predFusionBV.stride : predFusion[i].stride;
  }

  PelBuf predAngNonLocDep = m_tempBuffer[7].getBuf( localUnitArea.Y() );
  PelBuf predAngVer       = m_tempBuffer[5].getBuf( localUnitArea.Y() );
  PelBuf predAngHor       = m_tempBuffer[6].getBuf( localUnitArea.Y() );

  Pel* pelVer = predAngVer.buf;
  int strideVer = predAngVer.stride;
  Pel* pelHor = predAngHor.buf;
  int strideHor = predAngHor.stride; 
  Pel *pelNonLocDep = predAngNonLocDep.buf;
  int strideNonLocDep = predAngNonLocDep.stride;

  bool useLocDepBlending = false;
  int weightVer = 0, weightHor = 0, weightNonLocDep = 0;

  for (int i = 0; i < OBIC_FUSION_NUM; i++)
  {
    if(i == 0 || blendModes[i-1])
    {
      if (pu.cu->obicLocDep[i] == 1)
      {
        weightVer += pu.cu->obicFusionWeight[i];
      }
      else if (pu.cu->obicLocDep[i] == 2)
      {
        weightHor += pu.cu->obicFusionWeight[i];
      }
      else
      {
        weightNonLocDep += pu.cu->obicFusionWeight[i];
      }
    }
  }
  
  if(weightHor || weightVer)
  {
    useLocDepBlending = true;
  }
    
  if(!useLocDepBlending)
  {
    pelNonLocDep = piPred.buf;
    strideNonLocDep = piPred.stride;
  }
#if JVET_W0123_TIMD_FUSION 
  for (int locDep = 0; locDep < 3; locDep++) 
  {
    for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
    {
      pelFusion[i] = (i == planarIdx && pu.cu->isBvDimd) ? predFusionBV.buf : predFusion[i].buf;
      strideFusion[i] = (i == planarIdx && pu.cu->isBvDimd) ? predFusionBV.stride : predFusion[i].stride;
    }  

    int totWeight = (locDep == 0 ? weightNonLocDep : (locDep == 1 ? weightVer : weightHor));
    if (totWeight == 0)
    {
      continue;
    }

    int weights[OBIC_FUSION_NUM] = {0};
    weights[0] = (pu.cu->obicLocDep[0] == locDep) ? pu.cu->obicFusionWeight[0] : 0;
    for (int i = 1; i < OBIC_FUSION_NUM ; i++)
    {
      weights[i] = (blendModes[i-1] && pu.cu->obicLocDep[i] == locDep) ? pu.cu->obicFusionWeight[i] : 0;
    }
   
    int num2blend = 0;
    int blendIndexes[OBIC_FUSION_NUM] = {0};
    for (int i = 0; i < OBIC_FUSION_NUM; i++)
    {
      if (weights[i] != 0)
      {
        blendIndexes[num2blend] = i;
        num2blend++;
      }
    }
      
    if( (num2blend == 1 ) || (num2blend <=3 && (totWeight == (1 << (floorLog2(totWeight))) ) ) )
    {
      int index = blendIndexes[0]; 
      if(locDep == 0)
      {
        pelNonLocDep = (index == 0 ? piPred.buf : pelFusion[index-1]);
        strideNonLocDep = (index == 0 ? piPred.stride : strideFusion[index-1]);
      }
      else if(locDep == 1)
      {
        pelVer = (index == 0 ? piPred.buf : pelFusion[index-1]);
        strideVer = (index == 0 ? piPred.stride : strideFusion[index-1]);
      }
      else
      {
        pelHor = (index == 0 ? piPred.buf : pelFusion[index-1]);
        strideHor = (index == 0 ? piPred.stride : strideFusion[index-1]);
      }
      Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
      int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

      int factor = 64 / totWeight;
      if (num2blend == 2)
      {
        int index1 = blendIndexes[1];
        Pel* p1 = (index1 == 0 ? piPred.buf : pelFusion[index1-1]);
        int stride1 = (index1 == 0 ? piPred.stride : strideFusion[index1-1]);

        int w0 = (weights[index]*factor);
        int w1 = 64 - w0;
        m_timdBlending(pCur, strideCur, p1, stride1, w0, w1,width, height);
      }
      else if(num2blend == 3)
      {
        int index1 = blendIndexes[1];
        Pel* p1 = (index1 == 0 ? piPred.buf : pelFusion[index1-1]);
        int stride1 = (index1 == 0 ? piPred.stride : strideFusion[index1-1]);

        int index2 = blendIndexes[2];
        Pel* p2 = (index2 == 0 ? piPred.buf : pelFusion[index2-1]);
        int stride2 = (index2 == 0 ? piPred.stride : strideFusion[index2-1]);

        int w0 = (weights[index]*factor);
        int w1 = (weights[index1]*factor);
        int w2 = 64  - w0 - w1;
        m_dimdBlending(pCur, strideCur, p1, stride1, p2, stride2, w0, w1, w2, width, height);
      }
    }
    else
#endif
    {
      Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
      int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));
      Pel *pelPred = piPred.buf;
        
      for( int y = 0; y < height; y++ )
      {
        for( int x = 0; x < width; x++ )
        {
          int blend = pelPred[x] * weights[0];
          for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
          {
            blend += blendModes[i] ? pelFusion[i][x] * weights[i + 1] : 0;
          }
          pCur[x] = (Pel)(blend / totWeight);
        }
        pCur += strideCur;
        pelPred += piPred.stride;
        for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
        {
          pelFusion[i] += strideFusion[i];
        }
      }
    }
  }

  if(useLocDepBlending)
  {
    int mode = ((weightHor > 0 && weightVer > 0) ? 0 : (weightVer > 0 ? 1 : 2));
    Pel *pelDst = piPred.buf;
    int strideDst = piPred.stride;
#if JVET_W0123_TIMD_FUSION && JVET_AG0092_ENHANCED_TIMD_FUSION
    xLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#else
    xDimdLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#endif
  }
#if JVET_AK0118_BF_FOR_INTRA_PRED
  int blkQp = pu.cu->qp;
  int blkWidth = piPred.width;
  int blkHeight = piPred.height;
  CodingStructure &cs = *pu.cu->cs;
  bool applyBf = checkBfApplication(blkQp, blkWidth, blkHeight);
  if( applyBf && cs.slice->isIntra() && cs.sps->getUseIntraPredBf() )
  {
    bilateralFilterPredDiamond5x5Clip(cs, CHANNEL_TYPE_LUMA, piPred, blkWidth, blkHeight, blkQp, cs.slice->clpRng(COMPONENT_Y), true, *pu.cu );
  }
#endif
#else
  const int log2WeightSum = 6;
  Pel *pelPred = piPred.buf;
  Pel *pelFusion[OBIC_FUSION_NUM - 1];
  Pel *pelFusionBv = predFusionBV.buf;
  int weight[OBIC_FUSION_NUM];
  weight[0] = pu.cu->obicFusionWeight[0];
  for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
  {
    pelFusion[i] = predFusion[i].buf;
    weight[i + 1] = pu.cu->obicFusionWeight[i + 1];
  }
  for( int y = 0; y < height; y++ )
  {
    for( int x = 0; x < width; x++ )
    {
      int blend = pelPred[x] * weight[0];
      for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
      {
        if (blendModes[i])
        {
          if (i == planarIdx && pu.cu->isBvDimd)
          {
            blend += pelFusionBv[x] * weight[ i + 1];
          }
          else
          {
            blend += pelFusion[i][x] * weight[ i + 1];
          }
        }
      }
      pelPred[x] = (Pel)(blend >> log2WeightSum);
    }
    pelPred += piPred.stride;
    for (int i = 0; i < OBIC_FUSION_NUM - 1; i++)
    {
      pelFusion[i] += predFusion[i].stride;
    }
    pelFusionBv += predFusionBV.stride;
  }

  return;
#endif
}
#if JVET_AJ0267_ADAPTIVE_HOG
void IntraPrediction::generateDimdBlending(PelBuf &piPred, const PredictionUnit &pu, PelBuf predFusion[DIMD_FUSION_NUM - 2], PelBuf &plnBlock)
#else
void IntraPrediction::generateDimdBlending(PelBuf &piPred, const PredictionUnit &pu, PelBuf &piBlock0, PelBuf &piBlock1, PelBuf &piBlock2, PelBuf &piBlock3, PelBuf &plnBlock)
#endif
{
    // do blending
    int width = piPred.width;
    int height = piPred.height;
    const UnitArea localUnitArea( pu.chromaFormat, Area( 0, 0, width, height ) );
    PelBuf planarBuffer = m_tempBuffer[0].getBuf( localUnitArea.Y() );
#if JVET_AG0146_DIMD_ITMP_IBC
    if (pu.cu->isBvDimd && pu.cu->ispMode == 0)
    {
      predUsingBv(planarBuffer.buf, planarBuffer.stride, pu.cu->bvDimd, *pu.cu);
    }
    else
    {
#endif
      planarBuffer.copyFrom(plnBlock);
#if JVET_AG0146_DIMD_ITMP_IBC
    }
#endif

    bool blendModes[DIMD_FUSION_NUM-2] = {false};
    for( int i = 0; i < DIMD_FUSION_NUM-2; ++i)
    {
#if JVET_AC0098_LOC_DEP_DIMD
      blendModes[i] = (pu.cu->dimdBlendMode[i] != PLANAR_IDX);
#else
      blendModes[i] = (i==0 || pu.cu->dimdBlendMode[i] != PLANAR_IDX);
#endif

    }
    PelBuf predAngExtra[DIMD_FUSION_NUM-2];
#if JVET_AJ0267_ADAPTIVE_HOG
    for( int i = 0; i < DIMD_FUSION_NUM-2; ++i)
    {
      predAngExtra[i] = m_tempBuffer[i+1].getBuf( localUnitArea.Y() );
      if (blendModes[i])
      {
        predAngExtra[i].copyFrom(predFusion[i]);
      }
    }
#else
    predAngExtra[0] = m_tempBuffer[1].getBuf( localUnitArea.Y() );
    predAngExtra[1] = m_tempBuffer[2].getBuf( localUnitArea.Y() );
    predAngExtra[2] = m_tempBuffer[3].getBuf( localUnitArea.Y() );
    predAngExtra[3] = m_tempBuffer[4].getBuf( localUnitArea.Y() );
    predAngExtra[0].copyFrom(piBlock0);
    predAngExtra[1].copyFrom(piBlock1);
    predAngExtra[2].copyFrom(piBlock2);
    predAngExtra[3].copyFrom(piBlock3);
#endif
#if JVET_AC0098_LOC_DEP_DIMD
#if JVET_AJ0267_ADAPTIVE_HOG
    PelBuf predAngVer       = m_tempBuffer[DIMD_FUSION_NUM - 1].getBuf( localUnitArea.Y() );
    PelBuf predAngHor       = m_tempBuffer[DIMD_FUSION_NUM].getBuf( localUnitArea.Y() );
    PelBuf predAngNonLocDep = m_tempBuffer[DIMD_FUSION_NUM + 1].getBuf( localUnitArea.Y() );
#else
    PelBuf predAngNonLocDep = m_tempBuffer[7].getBuf( localUnitArea.Y() );
    PelBuf predAngVer       = m_tempBuffer[5].getBuf( localUnitArea.Y() );
    PelBuf predAngHor       = m_tempBuffer[6].getBuf( localUnitArea.Y() );
#endif

    Pel* pelVer = predAngVer.buf;
    int strideVer = predAngVer.stride;
    Pel* pelHor = predAngHor.buf;
    int strideHor = predAngHor.stride;
    Pel *pelNonLocDep = predAngNonLocDep.buf;
    int strideNonLocDep = predAngNonLocDep.stride;

    bool useLocDepBlending = false;
    int weightVer = 0, weightHor = 0, weightNonLocDep = 0;
    weightNonLocDep += pu.cu->dimdRelWeight[1];
    for (int i = 0; i < DIMD_FUSION_NUM-1; i++)
    {
      if (i == 0  || blendModes[i-1])
      {
        if (pu.cu->dimdLocDep[i] == 1)
        {
          weightVer += (i == 0 ? pu.cu->dimdRelWeight[0] : pu.cu->dimdRelWeight[i+ 1]);
        }
        else if (pu.cu->dimdLocDep[i] == 2)
        {
          weightHor += (i == 0 ? pu.cu->dimdRelWeight[0] : pu.cu->dimdRelWeight[i+ 1]);
        }
        else
        {
          weightNonLocDep += (i == 0 ? pu.cu->dimdRelWeight[0] : pu.cu->dimdRelWeight[i+1]);
        }
      }
    }

    if(weightHor || weightVer)
    {
      useLocDepBlending = true;
    }

    if(!useLocDepBlending)
    {
      pelNonLocDep = piPred.buf;
      strideNonLocDep = piPred.stride;
    }

    for (int locDep = 0; locDep < 3; locDep++)
    {
      int totWeight = (locDep == 0 ? weightNonLocDep : (locDep == 1 ? weightVer : weightHor));
      if (totWeight == 0)
      {
        continue;
      }

#if JVET_AJ0267_ADAPTIVE_HOG
      int weights[DIMD_FUSION_NUM] = {0};
      weights[0] =  (pu.cu->dimdLocDep[0] == locDep) ? pu.cu->dimdRelWeight[0] : 0;
      for (int i = 1; i < DIMD_FUSION_NUM - 1; i ++)
      {
        weights[i] =  (blendModes[i - 1] && pu.cu->dimdLocDep[i] == locDep) ? pu.cu->dimdRelWeight[i + 1] : 0;
      }
      weights[DIMD_FUSION_NUM - 1] =  (locDep == 0) ? pu.cu->dimdRelWeight[1] : 0;
#else
      int weights[6] = {0};
      weights[0] =  (pu.cu->dimdLocDep[0] == locDep) ? pu.cu->dimdRelWeight[0] : 0;
      weights[1] =  (blendModes[0] && pu.cu->dimdLocDep[1] == locDep) ? pu.cu->dimdRelWeight[2] : 0;
      weights[2] =  (blendModes[1] && pu.cu->dimdLocDep[2] == locDep) ? pu.cu->dimdRelWeight[3] : 0;
      weights[3] =  (blendModes[2] && pu.cu->dimdLocDep[3] == locDep) ? pu.cu->dimdRelWeight[4] : 0;
      weights[4] =  (blendModes[3] && pu.cu->dimdLocDep[4] == locDep) ? pu.cu->dimdRelWeight[5] : 0;
      weights[5] =  (locDep == 0) ? pu.cu->dimdRelWeight[1] : 0;
#endif

      int num2blend = 0;
      int blendIndexes[DIMD_FUSION_NUM] = {0};
      for (int i = 0; i < DIMD_FUSION_NUM; i++)
      {
        if (weights[i] != 0)
        {
          blendIndexes[num2blend] = i;
          num2blend++;
        }
      }
#if JVET_W0123_TIMD_FUSION
      if( (num2blend == 1 ) || (num2blend <=3 && (totWeight == (1 << (floorLog2(totWeight))) ) ))
      {
        int index = blendIndexes[0];
        if(locDep == 0)
        {
#if JVET_AJ0267_ADAPTIVE_HOG
          pelNonLocDep = (index == 0 ? piPred.buf : (index == (DIMD_FUSION_NUM - 1) ? planarBuffer.buf : predAngExtra[index-1].buf));
          strideNonLocDep = (index == 0 ? piPred.stride : (index == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index-1].stride));
#else
          pelNonLocDep = (index == 0 ? piPred.buf : (index == 5 ? planarBuffer.buf : predAngExtra[index-1].buf));
          strideNonLocDep = (index == 0 ? piPred.stride : (index == 5 ? planarBuffer.stride : predAngExtra[index-1].stride));
#endif
        }
        else if(locDep == 1)
        {
          pelVer = (index == 0 ? piPred.buf : predAngExtra[index-1].buf);
          strideVer = (index == 0 ? piPred.stride : predAngExtra[index-1].stride);
        }
        else
        {
          pelHor = (index == 0 ? piPred.buf : predAngExtra[index-1].buf);
          strideHor = (index == 0 ? piPred.stride : predAngExtra[index-1].stride);
        }
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));

        int factor = 64 / totWeight;
        if (num2blend == 2)
        {
          int index1 = blendIndexes[1];
#if JVET_AJ0267_ADAPTIVE_HOG
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == (DIMD_FUSION_NUM - 1) ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index1-1].stride));
#else
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 5 ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 5 ? planarBuffer.stride : predAngExtra[index1-1].stride));
#endif
          int w0 = (weights[index]*factor);
          int w1 = 64 - w0;
          m_timdBlending(pCur, strideCur, p1, stride1, w0, w1,width, height);
        }
        else if(num2blend == 3)
        {
          int index1 = blendIndexes[1];
#if JVET_AJ0267_ADAPTIVE_HOG
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == (DIMD_FUSION_NUM - 1) ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index1-1].stride));
#else
          Pel* p1 = (index1 == 0 ? piPred.buf : (index1 == 5 ?  planarBuffer.buf : predAngExtra[index1-1].buf));
          int stride1 = (index1 == 0 ? piPred.stride : (index1 == 5 ? planarBuffer.stride : predAngExtra[index1-1].stride));
#endif

          int index2 = blendIndexes[2];
#if JVET_AJ0267_ADAPTIVE_HOG
          Pel* p2 = (index2 == 0 ? piPred.buf : (index2 == (DIMD_FUSION_NUM - 1) ?  planarBuffer.buf : predAngExtra[index2-1].buf));
          int stride2 = (index2 == 0 ? piPred.stride : (index2 == (DIMD_FUSION_NUM - 1) ? planarBuffer.stride : predAngExtra[index2-1].stride));
#else
          Pel* p2 = (index2 == 0 ? piPred.buf : (index2 == 5 ?  planarBuffer.buf : predAngExtra[index2-1].buf));
          int stride2 = (index2 == 0 ? piPred.stride : (index2 == 5 ? planarBuffer.stride : predAngExtra[index2-1].stride));
#endif
          int w0 = (weights[index]*factor);
          int w1 = (weights[index1]*factor);
          int w2 = 64  - w0 - w1;
          m_dimdBlending(pCur, strideCur, p1, stride1, p2, stride2, w0, w1, w2, width, height);
        }
      }
      else
#endif
      {
        Pel* pCur = (locDep == 0 ? pelNonLocDep : (locDep == 1 ? pelVer : pelHor));
        int strideCur = (locDep == 0 ? strideNonLocDep : (locDep == 1 ? strideVer : strideHor));
        Pel *pelPlanar = planarBuffer.buf;
        int stridePlanar = planarBuffer.stride;
#if JVET_AJ0267_ADAPTIVE_HOG
        Pel *pelPredAng[DIMD_FUSION_NUM - 1];
        int strides[DIMD_FUSION_NUM - 1];
        pelPredAng[0] = piPred.buf;
        strides[0] = piPred.stride;
        for (int i = 1; i < DIMD_FUSION_NUM - 1; i++)
        {
          pelPredAng[i] = predAngExtra[i - 1].buf;
          strides[i] = predAngExtra[i - 1].stride;
        }
        for( int y = 0; y < height; y++ )
        {
          for( int x = 0; x < width; x++ )
          {
            int blend = pelPredAng[0][x] * weights[0];
            for (int i = 1; i < DIMD_FUSION_NUM - 1; i++)
            {
              blend += blendModes[i - 1] ? pelPredAng[i][x] * weights[i] : 0;
            }
            blend += pelPlanar[x] * weights[DIMD_FUSION_NUM - 1];
            pCur[x] = (Pel)(blend / totWeight);
          }
          pCur += strideCur;
          for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
          {
            pelPredAng[i] += strides[i];
          }
          pelPlanar += stridePlanar;
        }
#else
        Pel *pelPredAng0 = piPred.buf;
        Pel *pelPredAng1 = predAngExtra[0].buf;
        Pel *pelPredAng2 = predAngExtra[1].buf;
        Pel *pelPredAng3 = predAngExtra[2].buf;
        Pel *pelPredAng4 = predAngExtra[3].buf;
        int stride0 = piPred.stride;
        int stride1 = predAngExtra[0].stride;
        int stride2 = predAngExtra[1].stride;
        int stride3 = predAngExtra[2].stride;
        int stride4 = predAngExtra[3].stride;
        for( int y = 0; y < height; y++ )
        {
          for( int x = 0; x < width; x++ )
          {
            int blend = pelPredAng0[x] * weights[0];
            blend += blendModes[0] ? pelPredAng1[x] * weights[1] : 0;
            blend += blendModes[1] ? pelPredAng2[x] * weights[2] : 0;
            blend += blendModes[2] ? pelPredAng3[x] * weights[3] : 0;
            blend += blendModes[3] ? pelPredAng4[x] * weights[4] : 0;
            blend += pelPlanar[x] * weights[5];
            pCur[x] = (Pel)(blend / totWeight);
          }
          pCur += strideCur;
          pelPredAng0 += stride0;
          pelPredAng1 += stride1;
          pelPredAng2 += stride2;
          pelPredAng3 += stride3;
          pelPredAng4 += stride4;
          pelPlanar += stridePlanar;
        }
#endif
      }
    }

    if (useLocDepBlending)
    {
      int mode = ((weightHor > 0 && weightVer > 0) ? 0 : (weightVer > 0 ? 1 : 2));

      Pel *pelDst = piPred.buf;
      int strideDst = piPred.stride;
#if JVET_W0123_TIMD_FUSION && JVET_AG0092_ENHANCED_TIMD_FUSION
      xLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#else
      xDimdLocationdepBlending(pelDst, strideDst, pelVer, strideVer, pelHor, strideHor, pelNonLocDep, strideNonLocDep, width, height,mode, weightVer, weightHor, weightNonLocDep);
#endif
    }
#if JVET_AK0118_BF_FOR_INTRA_PRED
    int blkQp = pu.cu->qp;
    int blkWidth = piPred.width;
    int blkHeight = piPred.height;
    CodingStructure &cs = *pu.cu->cs;
    bool applyBf = checkBfApplication(blkQp, blkWidth, blkHeight);
    if( applyBf && cs.slice->isIntra() && cs.sps->getUseIntraPredBf() )
    {
      bilateralFilterPredDiamond5x5Clip(cs, CHANNEL_TYPE_LUMA, piPred, blkWidth, blkHeight, blkQp, cs.slice->clpRng(COMPONENT_Y), true, *pu.cu );
    }
#endif
#else
    const int log2WeightSum = 6;
    Pel *pelPred = piPred.buf;
    Pel *pelPlanar = planarBuffer.buf;
    Pel *pelPredAng = predAngExtra[0].buf;
    int  w0 = pu.cu->dimdRelWeight[0], w1 = pu.cu->dimdRelWeight[1], w2 = pu.cu->dimdRelWeight[2];

    Pel *pelPredAng2 = predAngExtra[1].buf;
    Pel *pelPredAng3 = predAngExtra[2].buf;
    Pel *pelPredAng4 = predAngExtra[3].buf;
    int  w3         = pu.cu->dimdRelWeight[3];
    int  w4         = pu.cu->dimdRelWeight[4];
    int  w5         = pu.cu->dimdRelWeight[5];

    for( int y = 0; y < height; y++ )
    {
      for( int x = 0; x < width; x++ )
      {
        int blend = pelPred[x] * w0;
        blend += pelPlanar[x] * w1;
#if JVET_AC0098_LOC_DEP_DIMD
        blend += blendModes[0] ? pelPredAng[x] * w2 : 0;
#else
        blend += pelPredAng[x] * w2;
#endif
        blend += blendModes[1] ? pelPredAng2[x] * w3 : 0;
        blend += blendModes[2] ? pelPredAng3[x] * w4 : 0;
        blend += blendModes[3] ? pelPredAng4[x] * w5 : 0;
        pelPred[x] = (Pel)(blend >> log2WeightSum);
      }

      pelPred += piPred.stride;
      pelPlanar += planarBuffer.stride;
      pelPredAng += predAngExtra[0].stride;
      pelPredAng2 += predAngExtra[1].stride;
      pelPredAng3 += predAngExtra[2].stride;
      pelPredAng4 += predAngExtra[3].stride;
    }
#endif
}
#endif

#if JVET_Z0050_DIMD_CHROMA_FUSION
#if JVET_AD0188_CCP_MERGE
void IntraPrediction::geneChromaFusionPred( const ComponentID compId, PelBuf &piPred, PredictionUnit &pu 
#if JVET_AH0136_CHROMA_REORDERING
  , InterPrediction *pcInterPred
#endif
)
#else
void IntraPrediction::geneChromaFusionPred(const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu)
#endif
{
  int width = piPred.width;
  int height = piPred.height;
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, width, height));

  PelBuf predLmBuffer = m_tempBuffer[0].getBuf(localUnitArea.Y());
  PredictionUnit pu2 = pu;

#if MMLM
  pu2.intraDir[1] = MMLM_CHROMA_IDX;
#else
  pu2.intraDir[1] = LM_CHROMA_IDX;
#endif

  const CompArea &area = pu2.blocks[compId];

#if JVET_AC0119_LM_CHROMA_FUSION
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if (!pu.cs->pcv->isEncoder || !pu2.cs->slice->isIntra() || !( CS::isDualITree(*pu.cs) || (pu.cu->isSST && pu.cu->separateTree) ))
#else
  if (!pu.cs->pcv->isEncoder || !pu2.cs->slice->isIntra() || !CS::isDualITree(*pu.cs))
#endif
  {
#endif
  xGetLumaRecPixels(pu2, area);
#if JVET_AC0119_LM_CHROMA_FUSION
  }
#endif

#if JVET_AC0119_LM_CHROMA_FUSION
  if (pu.isChromaFusion > 1)
  {
    pu2.intraDir[1] = LM_CHROMA_IDX + pu.isChromaFusion - 2;
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
    if (!pu.cs->pcv->isEncoder || !pu2.cs->slice->isIntra() || ! ( CS::isDualITree(*pu.cs) || (pu.cu->isSST && pu.cu->separateTree) ))
#else
    if (!pu.cs->pcv->isEncoder || !pu2.cs->slice->isIntra() || !CS::isDualITree(*pu.cs))
#endif
    {
#if JVET_AH0136_CHROMA_REORDERING
      xCflmCreateChromaPred(pu, compId, piPred, pcInterPred);
#else
      xCflmCreateChromaPred(pu, compId, piPred);
#endif
    }
    predIntraChromaLM(compId, piPred, pu2, area, pu2.intraDir[1]);
#if JVET_AH0136_CHROMA_REORDERING && JVET_AC0071_DBV
    if (PU::isDbvMode(pu.intraDir[1]) && pu.cu->rribcFlipType != 0)
    {
      piPred.flipSignal(pu.cu->rribcFlipType == 1);
    }
#endif
    return;
  }
#endif

#if JVET_AD0120_LBCCP
  static int cclmSAD  = MAX_INT;
  static int cccmSAD  = MAX_INT;
#if JVET_AA0057_CCCM
#if JVET_AE0174_NONINTER_TM_TOOLS_CONTROL
  if (pu.cs->slice->isIntra() && PU::cccmMultiModeAvail(pu, MMLM_CHROMA_IDX) && pu.cs->sps->getTMnoninterToolsEnableFlag())
#else
  bool isMultiCccmFullEnabled = false;
  isMultiCccmFullEnabled = PU::cccmMultiModeAvail(pu, MMLM_CHROMA_IDX);
  if (pu.cs->slice->isIntra() && isMultiCccmFullEnabled)
#endif
  {
    const int  bitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
    const CompArea                   &areaCb = pu2.blocks[COMPONENT_Cb];
    const CompArea                   &areaCr = pu2.blocks[COMPONENT_Cr];
    static CclmModel                  cclmModelCb;
    static CclmModel                  cclmModelCr;
    static int                        modelThr       = 0;
    static CccmModel cccmModelCb[2] = { CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth) };
    static CccmModel cccmModelCr[2] = { CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth) };

    if (compId == COMPONENT_Cb)
    {
      pu2.cccmFlag = 1;
#if JVET_AC0054_GLCCCM
      pu2.glCccmFlag = 0;
#endif
#if JVET_AD0202_CCCM_MDF
      pu2.cccmMultiFilterIdx = 0;
#endif
      xGetLumaRecPixels(pu2, area);
      modelThr = xCccmCalcRefAver(pu2);
      xCccmCalcModels(pu2, cccmModelCb[0], cccmModelCr[0], 1, modelThr);
      xCccmCalcModels(pu2, cccmModelCb[1], cccmModelCr[1], 2, modelThr);
      cccmSAD = xCalculateCCCMcost(pu2, COMPONENT_Cb, pu2.intraDir[1], areaCb, cccmModelCb, modelThr);
      cccmSAD += xCalculateCCCMcost(pu2, COMPONENT_Cr, pu2.intraDir[1], areaCr, cccmModelCr, modelThr);

      pu2.cccmFlag = 0;
      xGetLumaRecPixels(pu2, area);
      initIntraPatternChType(*pu.cu, areaCb);
      xGetLMParametersLMS(pu2, COMPONENT_Cb, areaCb, cclmModelCb);
      initIntraPatternChType(*pu.cu, areaCr);
      xGetLMParametersLMS(pu2, COMPONENT_Cr, areaCr, cclmModelCr);
      cclmSAD = xCalculateCCLMcost(pu2, COMPONENT_Cb, pu2.intraDir[1], areaCb, cclmModelCb);
      cclmSAD += xCalculateCCLMcost(pu2, COMPONENT_Cr, pu2.intraDir[1], areaCr, cclmModelCr);
    }

    if (cccmSAD < cclmSAD)
    {
      xCccmApplyModel(pu2, compId, compId == COMPONENT_Cb ? cccmModelCb[0] : cccmModelCr[0], 1, modelThr, predLmBuffer);
      xCccmApplyModel(pu2, compId, compId == COMPONENT_Cb ? cccmModelCb[1] : cccmModelCr[1], 2, modelThr, predLmBuffer);
    }
    else
    {
      applyChromaLM(compId, predLmBuffer, pu2, area, pu2.intraDir[1], compId == COMPONENT_Cb ? cclmModelCb : cclmModelCr);
    }
#if JVET_AD0188_CCP_MERGE
    if (compId == COMPONENT_Cr)
    {
      if (cccmSAD < cclmSAD)
      {
#if JVET_AC0054_GLCCCM
        pu.curCand.type = ((pu.glCccmFlag ? CCP_TYPE_GLCCCM : CCP_TYPE_CCCM) | CCP_TYPE_MMLM);
        pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
        pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;
#else
        pu.curCand.type = (CCP_TYPE_CCCM | CCP_TYPE_MMLM);
#endif
        PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, modelThr
#if JVET_AB0174_CCCM_DIV_FREE
                                 , m_cccmLumaOffset
#endif
        );
      }
      else
      {
        pu.curCand.type = (CCP_TYPE_CCLM | CCP_TYPE_MMLM);
        PU::cclmModelToCcpParams(COMPONENT_Cb, pu.curCand, cclmModelCb);
        PU::cclmModelToCcpParams(COMPONENT_Cr, pu.curCand, cclmModelCr);
      }
    }
#endif
  }
  else
#endif
  {
#endif
    predIntraChromaLM(compId, predLmBuffer, pu2, area, pu2.intraDir[1]);

#if JVET_AD0188_CCP_MERGE
    pu.curCand      = pu2.curCand;
    pu.curCand.type = CCP_TYPE_CCLM;

    if (PU::isMultiModeLM(pu2.intraDir[1]))
    {
      pu.curCand.type |= CCP_TYPE_MMLM;
    }
#endif
#if JVET_AD0120_LBCCP
  }
#endif

#if JVET_AC0071_DBV && JVET_AA0070_RRIBC
#if JVET_AH0136_CHROMA_REORDERING
  if (PU::isDbvMode(pu.intraDir[1]) && pu.cu->rribcFlipType != 0)
#else
  if (pu.intraDir[1] == DBV_CHROMA_IDX && pu.cu->rribcFlipType != 0)
#endif
  {
    predLmBuffer.flipSignal(pu.cu->rribcFlipType == 1);
  }
#endif

  Pel *pelPred = piPred.buf;
  Pel *pelLm = predLmBuffer.buf;
  int  w0 = 2;
  int  w1 = 2;
  int  shift = 2;

#if JVET_AD0120_LBCCP
#if JVET_AE0174_NONINTER_TM_TOOLS_CONTROL
  if (pu.cs->slice->isIntra() && PU::cccmMultiModeAvail(pu, MMLM_CHROMA_IDX) && pu.cs->sps->getTMnoninterToolsEnableFlag())
#else
  if (pu.cs->slice->isIntra() && isMultiCccmFullEnabled)
#endif
  {
    const bool aboveAvailable = pu.cu->cs->getCU(pu.blocks[compId].pos().offset(0, -1), toChannelType(compId)) ? true : false;
    const bool leftAvailable = pu.cu->cs->getCU(pu.blocks[compId].pos().offset(-1, 0), toChannelType(compId)) ? true : false;
    int numSample = (aboveAvailable ? width : 0) + (leftAvailable ? height : 0);

    if (numSample > 0)
    {
      int bestSAD = cccmSAD < cclmSAD ? cccmSAD : cclmSAD;
#if JVET_AJ0096_SATD_REORDER_INTRA
      if (bestSAD > 144 * numSample)
#else
      if (bestSAD > 64 * numSample)
#endif
      {
        w0 = 3;
        w1 = 1;
      }
      else if (bestSAD < 4 * numSample)
      {
        w0 = 1;
        w1 = 3;
      }
    }
  }
  else
#endif
  if (pu.cs->slice->isIntra())
  {
    const Position posBL = pu.Cb().bottomLeft();
    const Position posTR = pu.Cb().topRight();
    const PredictionUnit *neigh0 = pu.cs->getPURestricted(posBL.offset(-1, 0), pu, CHANNEL_TYPE_CHROMA);
    const PredictionUnit *neigh1 = pu.cs->getPURestricted(posTR.offset(0, -1), pu, CHANNEL_TYPE_CHROMA);
    bool isNeigh0LM = neigh0 && PU::isLMCMode(neigh0->intraDir[1]);
    bool isNeigh1LM = neigh1 && PU::isLMCMode(neigh1->intraDir[1]);

    if (isNeigh0LM && isNeigh1LM)
    {
      w0 = 1; w1 = 3;
    }
    else if (!isNeigh0LM && !isNeigh1LM)
    {
      w0 = 3; w1 = 1;
    }
  }

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int blend = pelPred[x] * w0;
      blend += pelLm[x] * w1;
      blend += 2;
      pelPred[x] = (Pel) (blend >> shift);
    }
    pelPred += piPred.stride;
    pelLm += predLmBuffer.stride;
  }
}
#endif

void IntraPrediction::xPredIntraBDPCM(const CPelBuf &pSrc, PelBuf &pDst, const uint32_t dirMode, const ClpRng& clpRng )
{
  const int wdt = pDst.width;
  const int hgt = pDst.height;

  const int strideP = pDst.stride;
  const int strideS = pSrc.stride;

  CHECK( !( dirMode == 1 || dirMode == 2 ), "Incorrect BDPCM mode parameter." );

  Pel* pred = &pDst.buf[0];
  if( dirMode == 1 )
  {
    Pel  val;
    for( int y = 0; y < hgt; y++ )
    {
      val = pSrc.buf[(y + 1) + strideS];
      for( int x = 0; x < wdt; x++ )
      {
        pred[x] = val;
      }
      pred += strideP;
    }
  }
  else
  {
    for( int y = 0; y < hgt; y++ )
    {
      for( int x = 0; x < wdt; x++ )
      {
        pred[x] = pSrc.buf[x + 1];
      }
      pred += strideP;
    }
  }
}

// Explicit instanciation since the implementation is in cpp file
template void IntraPrediction::geneWeightedPred<false>( const ComponentID compId, AreaBuf<Pel>& pred, const PredictionUnit &pu, const AreaBuf<Pel> &interPred, const AreaBuf<Pel> &intraPred, const Pel* pLUT );
template void IntraPrediction::geneWeightedPred<true>( const ComponentID compId, AreaBuf<Pel>& pred, const PredictionUnit &pu, const AreaBuf<Pel> &interPred, const AreaBuf<Pel> &intraPred, const Pel* pLUT );

template<bool lmcs>
void IntraPrediction::geneWeightedPred( const ComponentID compId, PelBuf& pred, const PredictionUnit &pu, const PelBuf& interPred, const PelBuf& intraPred, const Pel* pLUT )
{
  const int            width = pred.width;
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
  CHECK(width == 2, "Width of 2 is not supported");
#endif
  const int            height = pred.height;
  Pel*                 interPredBuf = interPred.buf;
  const int            interPredStride = interPred.stride;
  Pel*                 intraPredBuf = intraPred.buf;
  const int            intraPredStride = intraPred.stride;
  const int            dstStride = pred.stride;

  Pel*                 dstBuf = pred.buf;
#if CIIP_PDPC
  if (!pu.ciipPDPC)
  {
#endif
  int wIntra, wMerge;

  const Position posBL = pu.Y().bottomLeft();
  const Position posTR = pu.Y().topRight();
  const PredictionUnit *neigh0 = pu.cs->getPURestricted(posBL.offset(-1, 0), pu, CHANNEL_TYPE_LUMA);
  const PredictionUnit *neigh1 = pu.cs->getPURestricted(posTR.offset(0, -1), pu, CHANNEL_TYPE_LUMA);
  bool isNeigh0Intra = neigh0 && (CU::isIntra(*neigh0->cu));
  bool isNeigh1Intra = neigh1 && (CU::isIntra(*neigh1->cu));

  if (isNeigh0Intra && isNeigh1Intra)
  {
    wIntra = 3; wMerge = 1;
  }
  else
  {
    if (!isNeigh0Intra && !isNeigh1Intra)
    {
      wIntra = 1; wMerge = 3;
    }
    else
    {
      wIntra = 2; wMerge = 2;
    }
  }
#if JVET_X0141_CIIP_TIMD_TM && JVET_W0123_TIMD_FUSION
  const ChannelType chType = toChannelType(compId);
  int dirMode = PU::getFinalIntraMode(pu, chType);
  if (dirMode == PLANAR_IDX || dirMode == DC_IDX || width < 4 || height < 4)
  {
    for (int y = 0; y < height; y++)
    {
      for( int x = 0; x < width; x++ )
      {
        if( lmcs )
        {
          dstBuf[x] = ( wMerge * pLUT[interPredBuf[x]] + wIntra * intraPredBuf[x] + 2 ) >> 2;
        }
        else
        {
          dstBuf[x] = ( wMerge * interPredBuf[x] + wIntra * intraPredBuf[x] + 2 ) >> 2;
        }
      }
      dstBuf += dstStride;
      interPredBuf += interPredStride;
      intraPredBuf += intraPredStride;
    }
  }
  else if (dirMode < DIA_IDX)
  {
    int interval = (width >> 2);
    for (int y = 0; y < height; y++)
    {
      for (int x = 0; x < width; x++)
      {
        if (x < interval)
        {
          if (lmcs)
          {
            dstBuf[x] = (2 * pLUT[interPredBuf[x]] + 6 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (2 * interPredBuf[x] + 6 * intraPredBuf[x] + 4) >> 3;
          }
        }
        else if (x >= interval && x < (2 * interval))
        {
          if (lmcs)
          {
            dstBuf[x] = (3 * pLUT[interPredBuf[x]] + 5 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (3 * interPredBuf[x] + 5 * intraPredBuf[x] + 4) >> 3;
          }
        }
        else if (x >= (interval * 2) && x < (3 * interval))
        {
          if (lmcs)
          {
            dstBuf[x] = (5 * pLUT[interPredBuf[x]] + 3 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (5 * interPredBuf[x] + 3 * intraPredBuf[x] + 4) >> 3;
          }
        }
        else
        {
          if (lmcs)
          {
            dstBuf[x] = (6 * pLUT[interPredBuf[x]] + 2 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (6 * interPredBuf[x] + 2 * intraPredBuf[x] + 4) >> 3;
          }
        }
      }
      dstBuf += dstStride;
      interPredBuf += interPredStride;
      intraPredBuf += intraPredStride;
    }
  }
  else
  {
    int interval = (height >> 2);
    for (int y = 0; y < height; y++)
    {
      for (int x = 0; x < width; x++)
      {
        if (y < interval)
        {
          if (lmcs)
          {
            dstBuf[x] = (2 * pLUT[interPredBuf[x]] + 6 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (2 * interPredBuf[x] + 6 * intraPredBuf[x] + 4) >> 3;
          }
        }
        else if (y >= interval && y < (2 * interval))
        {
          if (lmcs)
          {
            dstBuf[x] = (3 * pLUT[interPredBuf[x]] + 5 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (3 * interPredBuf[x] + 5 * intraPredBuf[x] + 4) >> 3;
          }
        }
        else if (y >= (interval * 2) && y < (3 * interval))
        {
          if (lmcs)
          {
            dstBuf[x] = (5 * pLUT[interPredBuf[x]] + 3 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (5 * interPredBuf[x] + 3 * intraPredBuf[x] + 4) >> 3;
          }
        }
        else
        {
          if (lmcs)
          {
            dstBuf[x] = (6 * pLUT[interPredBuf[x]] + 2 * intraPredBuf[x] + 4) >> 3;
          }
          else
          {
            dstBuf[x] = (6 * interPredBuf[x] + 2 * intraPredBuf[x] + 4) >> 3;
          }
        }
      }
      dstBuf += dstStride;
      interPredBuf += interPredStride;
      intraPredBuf += intraPredStride;
    }
  }
#else
  for (int y = 0; y < height; y++)
  {
    for( int x = 0; x < width; x++ )
    {
      if( lmcs )
      {
        dstBuf[x] = ( wMerge * pLUT[interPredBuf[x]] + wIntra * intraPredBuf[x] + 2 ) >> 2;
      }
      else
      {
        dstBuf[x] = ( wMerge * interPredBuf[x] + wIntra * intraPredBuf[x] + 2 ) >> 2;
      }
    }

    dstBuf += dstStride;
    interPredBuf += interPredStride;
    intraPredBuf += intraPredStride;
  }
#endif
#if CIIP_PDPC
  }
  else
  {
    const int scale = ((floorLog2(width) - 2 + floorLog2(height) - 2 + 2) >> 2);
    for (int y = 0; y < height; y++)
    {
      const int wT = 32 >> std::min(31, ((y << 1) >> scale));
      for (int x = 0; x < width; x++)
      {
        const int wL = 32 >> std::min(31, ((x << 1) >> scale));

        if( lmcs )
        {
          dstBuf[x] = ( Pel ) ClipPel( ( ( int( intraPredBuf[x] ) << 6 ) + ( 64 - wT - wL ) * int( pLUT[interPredBuf[x]] ) + 32 ) >> 6, pu.cs->slice->clpRng( compId ) );
        }
        else
        {
          dstBuf[x] = ( Pel ) ClipPel( ( ( int( intraPredBuf[x] ) << 6 ) + ( 64 - wT - wL ) * int( interPredBuf[x] ) + 32 ) >> 6, pu.cs->slice->clpRng( compId ) );
        }
      }

      dstBuf += dstStride;
      interPredBuf += interPredStride;
      intraPredBuf += intraPredStride;
    }
  }
#endif
}
#if JVET_AG0135_AFFINE_CIIP
template void IntraPrediction::geneWeightedCIIPAffinePred<false>(const ComponentID compId, AreaBuf<Pel>& pred, const PredictionUnit &pu, const AreaBuf<Pel> &interPred, const AreaBuf<Pel> &intraPred, const Pel* pLUT);
template void IntraPrediction::geneWeightedCIIPAffinePred<true>(const ComponentID compId, AreaBuf<Pel>& pred, const PredictionUnit &pu, const AreaBuf<Pel> &interPred, const AreaBuf<Pel> &intraPred, const Pel* pLUT);

template<bool lmcs>
void IntraPrediction::geneWeightedCIIPAffinePred(const ComponentID compId, PelBuf& pred, const PredictionUnit &pu, const PelBuf& interPred, const PelBuf& intraPred, const Pel* pLUT)
{
  const int            width = pred.width;
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
  CHECK(width == 2, "Width of 2 is not supported");
#endif
  const int            height = pred.height;
  Pel*                 interPredBuf = interPred.buf;
  const int            interPredStride = interPred.stride;
  Pel*                 intraPredBuf = intraPred.buf;
  const int            intraPredStride = intraPred.stride;
  const int            dstStride = pred.stride;
  Pel*                 dstBuf = pred.buf;

  const Position posBL = pu.Y().bottomLeft();
  const Position posTR = pu.Y().topRight();
  const PredictionUnit *neigh0 = pu.cs->getPURestricted(posBL.offset(-1, 0), pu, CHANNEL_TYPE_LUMA);
  const PredictionUnit *neigh1 = pu.cs->getPURestricted(posTR.offset(0, -1), pu, CHANNEL_TYPE_LUMA);
  bool isNeigh0Intra = neigh0 && (CU::isIntra(*neigh0->cu));
  bool isNeigh1Intra = neigh1 && (CU::isIntra(*neigh1->cu));
  int wIntra, wMerge;
  if (isNeigh0Intra && isNeigh1Intra)
  {
    wIntra = 3; wMerge = 1;
  }
  else
  {
    if (!isNeigh0Intra && !isNeigh1Intra)
    {
      wIntra = 1; wMerge = 3;
    }
    else
    {
      wIntra = 2; wMerge = 2;
    }
  }

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      if (lmcs)
      {
        dstBuf[x] = (wMerge * pLUT[interPredBuf[x]] + wIntra * intraPredBuf[x] + 2) >> 2;
      }
      else
      {
        dstBuf[x] = (wMerge * interPredBuf[x] + wIntra * intraPredBuf[x] + 2) >> 2;
      }
    }
    dstBuf += dstStride;
    interPredBuf += interPredStride;
    intraPredBuf += intraPredStride;
  }
}
#endif
#if JVET_AC0112_IBC_CIIP
void IntraPrediction::geneWeightedPred( const ComponentID compId, PelBuf& pred, const PredictionUnit &pu, const PelBuf& interPred, const PelBuf& intraPred)
{
  const int            width = pred.width;
  const int            height = pred.height;
  const Pel*           interPredBuf = interPred.buf;
  const int            interPredStride = interPred.stride;
  Pel*                 intraPredBuf = intraPred.buf;
  const int            intraPredStride = intraPred.stride;
  const int            dstStride = pred.stride;
  Pel*                 dstBuf = pred.buf;
  int wMerge = 13;
  int wIntra = 3;
  int shift = 4;
  if (!pu.mergeFlag)
  {
    wMerge = 1;
    wIntra = 1;
    shift = 1;
  }
  if (width < 4)
  {
    ibcCiipBlending(dstBuf, dstStride, interPredBuf, interPredStride, intraPredBuf, intraPredStride, wMerge, wIntra, shift, width, height);
  }
  else
  {
    m_ibcCiipBlending(dstBuf, dstStride, interPredBuf, interPredStride, intraPredBuf, intraPredStride, wMerge, wIntra, shift, width, height);
  }
}
#endif

void IntraPrediction::geneIntrainterPred(const CodingUnit &cu, PelStorage& pred)
{
#if JVET_AC0112_IBC_CIIP
  if (!cu.firstPU->ciipFlag && !cu.firstPU->ibcCiipFlag)
#else
  if (!cu.firstPU->ciipFlag)
#endif
  {
    return;
  }

  const PredictionUnit* pu = cu.firstPU;

  initIntraPatternChType(cu, pu->Y());

  const UnitArea localUnitArea(pu->cs->area.chromaFormat, Area(0, 0, pu->Y().width, pu->Y().height));
  PelBuf ciipBuff = pred.getBuf(localUnitArea.Y());
  predIntraAng(COMPONENT_Y, ciipBuff, *pu);
#if JVET_AC0112_IBC_CIIP
#if INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  const bool chroma = !cu.separateTree;
#else
  const bool chroma = !(CS::isDualITree(*pu->cs));
#endif
#else
  const bool chroma = !pu.cu->isSepTree();
#endif
  if (cu.firstPU->ibcCiipFlag && !chroma)
  {
    return;
  }
#endif

  if (isChromaEnabled(pu->chromaFormat))
  {
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
  if (pu->chromaSize().width > 2)
  {
#endif
    initIntraPatternChType(cu, pu->Cb());
    PelBuf ciipBuffCb = pred.getBuf(localUnitArea.Cb());
    predIntraAng(COMPONENT_Cb, ciipBuffCb, *pu);

    initIntraPatternChType(cu, pu->Cr());
    PelBuf ciipBuffCr = pred.getBuf(localUnitArea.Cr());
    predIntraAng(COMPONENT_Cr, ciipBuffCr, *pu);
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
  }
#endif
  }
}

#if !MERGE_ENC_OPT
void IntraPrediction::geneWeightedPred( const ComponentID compId, PelBuf &pred, const PredictionUnit &pu, Pel *srcBuf )
{
  const int            width = pred.width;
  CHECK( width == 2, "Width of 2 is not supported" );
  const int            height = pred.height;
  const int            srcStride = width;
  const int            dstStride = pred.stride;

  Pel*                 dstBuf = pred.buf;
  int wIntra, wMerge;

  const Position posBL = pu.Y().bottomLeft();
  const Position posTR = pu.Y().topRight();
  const PredictionUnit *neigh0 = pu.cs->getPURestricted( posBL.offset( -1, 0 ), pu, CHANNEL_TYPE_LUMA );
  const PredictionUnit *neigh1 = pu.cs->getPURestricted( posTR.offset( 0, -1 ), pu, CHANNEL_TYPE_LUMA );
  bool isNeigh0Intra = neigh0 && ( CU::isIntra( *neigh0->cu ) );
  bool isNeigh1Intra = neigh1 && ( CU::isIntra( *neigh1->cu ) );

  if( isNeigh0Intra && isNeigh1Intra )
  {
    wIntra = 3; wMerge = 1;
  }
  else
  {
    if( !isNeigh0Intra && !isNeigh1Intra )
    {
      wIntra = 1; wMerge = 3;
    }
    else
    {
      wIntra = 2; wMerge = 2;
    }
  }
  for( int y = 0; y < height; y++ )
  {
    for( int x = 0; x < width; x++ )
    {
      dstBuf[y*dstStride + x] = ( wMerge * dstBuf[y*dstStride + x] + wIntra * srcBuf[y*srcStride + x] + 2 ) >> 2;
    }
  }
}

void IntraPrediction::switchBuffer( const PredictionUnit &pu, ComponentID compID, PelBuf srcBuff, Pel *dst )
{
  Pel  *src = srcBuff.bufAt( 0, 0 );
  int compWidth = compID == COMPONENT_Y ? pu.Y().width : pu.Cb().width;
  int compHeight = compID == COMPONENT_Y ? pu.Y().height : pu.Cb().height;
  for( int i = 0; i < compHeight; i++ )
  {
    memcpy( dst, src, compWidth * sizeof( Pel ) );
    src += srcBuff.stride;
    dst += compWidth;
  }
}
#endif

#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
inline bool isPosAvailable(const CodingUnit &cu, const ChannelType &chType, const Position &refPos);
#endif
inline bool isAboveLeftAvailable  ( const CodingUnit &cu, const ChannelType &chType, const Position &posLT );
inline int  isAboveAvailable      ( const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *validFlags );
inline int  isLeftAvailable       ( const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *validFlags );
inline int  isAboveRightAvailable ( const CodingUnit &cu, const ChannelType &chType, const Position &posRT, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *validFlags );
inline int  isBelowLeftAvailable  ( const CodingUnit &cu, const ChannelType &chType, const Position &posLB, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *validFlags );
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
inline int  isAboveAvailableOBMC      ( const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *validFlags, const int obmcNeighState );
inline int  isLeftAvailableOBMC       ( const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *validFlags, const int obmcNeighState );
inline int  isAboveRightAvailableOBMC ( const CodingUnit &cu, const ChannelType &chType, const Position &posRT, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *validFlags, const int obmcNeighState );
inline int  isBelowLeftAvailableOBMC  ( const CodingUnit &cu, const ChannelType &chType, const Position &posLB, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *validFlags, const int obmcNeighState );
#endif

#if JVET_AB0155_SGPM
void IntraPrediction::initIntraPatternChType(const CodingUnit &cu, const CompArea &area, const bool forceRefFilterFlag,
                                             const int partIdx
#if JVET_AB0157_INTRA_FUSION
                                             , bool applyFusion
#endif
#if JVET_AJ0249_NEURAL_NETWORK_BASED
                                             , const bool forceDeac0, const bool forceDeac1
#endif
                                             )
#else
#if JVET_AB0157_INTRA_FUSION
void IntraPrediction::initIntraPatternChType(const CodingUnit &cu, const CompArea &area, const bool forceRefFilterFlag, bool applyFusion)
#else
void IntraPrediction::initIntraPatternChType(const CodingUnit &cu, const CompArea &area, const bool forceRefFilterFlag)
#endif
#endif
{
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
  CHECK(area.width == 2, "Width of 2 is not supported");
#endif
  const CodingStructure& cs   = *cu.cs;

#if JVET_AB0157_INTRA_FUSION
  auto mrlIndex2D = cu.firstPU->multiRefIdx;
  m_ipaParam.fetchRef2nd   = area.compID == COMPONENT_Y;
  m_ipaParam.fetchRef2nd  &= area.width * area.height >= SIZE_CONSTRAINT;
#if JVET_AH0076_OBIC
  m_ipaParam.fetchRef2nd  &= !((cu.dimd && !cu.obicFlag && cu.dimdBlending) || (cu.dimd && cu.obicFlag && cu.obicIsBlended));
#else
  m_ipaParam.fetchRef2nd  &= !(cu.dimd && cu.dimdBlending);
#endif

#if JVET_AH0065_RELAX_LINE_BUFFER
  m_ipaParam.fetchRef2nd  &= !(mrlIndex2D == MULTI_REF_LINE_IDX[MRL_NUM_REF_LINES - 1] && (cu.block(COMPONENT_Y).y <= MULTI_REF_LINE_IDX[MRL_NUM_REF_LINES - 1]));
#else
  m_ipaParam.fetchRef2nd  &= !(mrlIndex2D == MULTI_REF_LINE_IDX[MRL_NUM_REF_LINES - 1] && ((cu.block(COMPONENT_Y).y) % ((cu.cs->sps)->getMaxCUWidth()) <= MULTI_REF_LINE_IDX[MRL_NUM_REF_LINES - 1]));
#endif
  m_ipaParam.fetchRef2nd  &= !(mrlIndex2D == 0 && ((cu.block(COMPONENT_Y).y) % ((cu.cs->sps)->getMaxCUWidth()) == 0));
#if JVET_AC0112_IBC_CIIP
  m_ipaParam.fetchRef2nd &= !cu.firstPU->ibcCiipFlag;
#endif
#if JVET_AC0112_IBC_GPM
  m_ipaParam.fetchRef2nd &= !cu.firstPU->ibcGpmFlag;
#endif
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  m_ipaParam.fetchRef2nd &= (!cu.sgpm && !cu.plIdx && !cu.mipFlag && cu.firstPU->intraDir[toChannelType(area.compID)] != PNN_IDX);
#endif
#endif
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
  if (cu.isobmcMC)
  {
    applyFusion = false;
    m_ipaParam.fetchRef2nd = false;
  }
#endif

  if (!forceRefFilterFlag)
  {
#if JVET_AB0155_SGPM
    initPredIntraParams(*cu.firstPU, area, *cs.sps, partIdx);
#else
    initPredIntraParams(*cu.firstPU, area, *cs.sps);
#endif
  }

  Pel *refBufUnfiltered = m_refBuffer[area.compID][PRED_BUF_UNFILTERED];
  Pel *refBufFiltered   = m_refBuffer[area.compID][PRED_BUF_FILTERED];

  setReferenceArrayLengths( area );
#if JVET_AH0209_PDP
  m_refAvailable = false;
#endif
#if JVET_AB0155_SGPM
  if (!partIdx) 
  {
    // ----- Step 1: unfiltered reference samples -----
#if JVET_AJ0249_NEURAL_NETWORK_BASED
    xFillReferenceSamples(cs.picture->getRecoBuf(area), refBufUnfiltered, area, cu, forceDeac0, forceDeac1);
#else
    xFillReferenceSamples(cs.picture->getRecoBuf(area), refBufUnfiltered, area, cu);
#endif
  }
#else
  // ----- Step 1: unfiltered reference samples -----
  xFillReferenceSamples( cs.picture->getRecoBuf( area ), refBufUnfiltered, area, cu );
#endif

#if JVET_AB0157_INTRA_FUSION
#if JVET_AB0155_SGPM
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  if (m_ipaParam.fetchRef2nd && applyFusion && !partIdx && !(forceDeac1 
#if JVET_AH0209_PDP
    && m_refAvailable
#endif
    ))
#else
  if (m_ipaParam.fetchRef2nd && applyFusion && !partIdx)
#endif
#else
  if (m_ipaParam.fetchRef2nd && applyFusion)
#endif
  {
    cu.firstPU->multiRefIdx  = mrlIndex2D + 1;
    Pel *refBufUnfiltered2nd = m_refBuffer2nd[area.compID];
    auto backup              = m_refBufferStride[area.compID];
    xFillReferenceSamples(cs.picture->getRecoBuf(area), refBufUnfiltered2nd, area, cu);
    cu.firstPU->multiRefIdx  = mrlIndex2D;
    m_refBufferStride[area.compID] = backup;
  }
#endif
  // ----- Step 2: filtered reference samples -----
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  if (cu.cs->sps->getDisableRefFilter())
  {
    m_ipaParam.refFilterFlag = false;
  }
  else
#endif
  if( m_ipaParam.refFilterFlag || forceRefFilterFlag 
#if JVET_AG0092_ENHANCED_TIMD_FUSION 
   || cu.timd
#endif  
#if JVET_AJ0146_TIMDSAD
   || cu.timdSad 
#endif
  )
  {
    xFilterReferenceSamples( refBufUnfiltered, refBufFiltered, area, *cs.sps, cu.firstPU->multiRefIdx );
  }
}

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
void IntraPrediction::initIntraPatternChTypeOBMC(const CodingUnit &cu, const CompArea &area)
{
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
  CHECK(area.width == 2, "Width of 2 is not supported");
#endif
  const CodingStructure& cs   = *cu.cs;

  m_ipaParam.fetchRef2nd = false;

  initPredIntraParams(*cu.firstPU, area, *cs.sps);

  m_ipaParam.applyFusion = false;

  Pel *refBufUnfiltered = m_refBuffer[area.compID][PRED_BUF_UNFILTERED];
  Pel *refBufFiltered   = m_refBuffer[area.compID][PRED_BUF_FILTERED];

  setReferenceArrayLengths( area );
#if JVET_AH0209_PDP
  m_refAvailable = false;
#endif
  // ----- Step 1: unfiltered reference samples -----
  xFillReferenceSamplesOBMC(cs.picture->getRecoBuf(area), refBufUnfiltered, area, cu);

  // ----- Step 2: filtered reference samples -----
  if( m_ipaParam.refFilterFlag)
  {
    xFilterReferenceSamples( refBufUnfiltered, refBufFiltered, area, *cs.sps, cu.firstPU->multiRefIdx );
  }
}
#endif

void IntraPrediction::initIntraPatternChTypeISP(const CodingUnit& cu, const CompArea& area, PelBuf& recBuf, const bool forceRefFilterFlag)
{
  const CodingStructure& cs = *cu.cs;

  if (!forceRefFilterFlag)
  {
    initPredIntraParams(*cu.firstPU, area, *cs.sps);
  }

  const Position posLT = area;
  bool           isLeftAvail  = (cs.getCURestricted(posLT.offset(-1, 0), cu, CHANNEL_TYPE_LUMA) != NULL) && cs.isDecomp(posLT.offset(-1, 0), CHANNEL_TYPE_LUMA);
  bool           isAboveAvail = (cs.getCURestricted(posLT.offset(0, -1), cu, CHANNEL_TYPE_LUMA) != NULL) && cs.isDecomp(posLT.offset(0, -1), CHANNEL_TYPE_LUMA);
  // ----- Step 1: unfiltered reference samples -----
  if (cu.blocks[area.compID].x == area.x && cu.blocks[area.compID].y == area.y)
  {
    Pel *refBufUnfiltered = m_refBuffer[area.compID][PRED_BUF_UNFILTERED];
    // With the first subpartition all the CU reference samples are fetched at once in a single call to xFillReferenceSamples
    if (cu.ispMode == HOR_INTRA_SUBPARTITIONS)
    {
      m_leftRefLength = cu.Y().height << 1;
      m_topRefLength = cu.Y().width + area.width;
    }
    else //if (cu.ispMode == VER_INTRA_SUBPARTITIONS)
    {
      m_leftRefLength = cu.Y().height + area.height;
      m_topRefLength = cu.Y().width << 1;
    }
#if JVET_AH0209_PDP
    m_refAvailable = false;
#endif
    xFillReferenceSamples(cs.picture->getRecoBuf(cu.Y()), refBufUnfiltered, cu.Y(), cu);

    // After having retrieved all the CU reference samples, the number of reference samples is now adjusted for the current subpartition
    m_topRefLength = cu.blocks[area.compID].width + area.width;
    m_leftRefLength = cu.blocks[area.compID].height + area.height;
  }
  else
  {
    m_topRefLength = cu.blocks[area.compID].width + area.width;
    m_leftRefLength = cu.blocks[area.compID].height + area.height;

    const int predSizeHor = m_topRefLength;
    const int predSizeVer = m_leftRefLength;
    if (cu.ispMode == HOR_INTRA_SUBPARTITIONS)
    {
      Pel* src = recBuf.bufAt(0, -1);
      Pel *ref = m_refBuffer[area.compID][PRED_BUF_UNFILTERED] + m_refBufferStride[area.compID];
      if (isLeftAvail)
      {
        for (int i = 0; i <= 2 * cu.blocks[area.compID].height - area.height; i++)
        {
          ref[i] = ref[i + area.height];
        }
      }
      else
      {
        for (int i = 0; i <= predSizeVer; i++)
        {
          ref[i] = src[0];
        }
      }
      Pel *dst = m_refBuffer[area.compID][PRED_BUF_UNFILTERED] + 1;
      dst[-1]  = ref[0];
      for (int i = 0; i < area.width; i++)
      {
        dst[i] = src[i];
      }
      Pel sample = src[area.width - 1];
      dst += area.width;
      for (int i = 0; i < predSizeHor - area.width; i++)
      {
        dst[i] = sample;
      }
    }
    else
    {
      Pel* src = recBuf.bufAt(-1, 0);
      Pel *ref = m_refBuffer[area.compID][PRED_BUF_UNFILTERED];
      if (isAboveAvail)
      {
        for (int i = 0; i <= 2 * cu.blocks[area.compID].width - area.width; i++)
        {
          ref[i] = ref[i + area.width];
        }
      }
      else
      {
        for (int i = 0; i <= predSizeHor; i++)
        {
          ref[i] = src[0];
        }
      }
      Pel *dst = m_refBuffer[area.compID][PRED_BUF_UNFILTERED] + m_refBufferStride[area.compID] + 1;
      dst[-1]  = ref[0];
      for (int i = 0; i < area.height; i++)
      {
        *dst = *src;
        src += recBuf.stride;
        dst++;
      }
      Pel sample = src[-recBuf.stride];
      for (int i = 0; i < predSizeVer - area.height; i++)
      {
        *dst = sample;
        dst++;
      }
    }
  }
  // ----- Step 2: filtered reference samples -----
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  if (cu.cs->sps->getDisableRefFilter())
  {
    m_ipaParam.refFilterFlag = false;
  }
  else
#endif
  if (m_ipaParam.refFilterFlag || forceRefFilterFlag)
  {
    Pel *refBufUnfiltered = m_refBuffer[area.compID][PRED_BUF_UNFILTERED];
    Pel *refBufFiltered   = m_refBuffer[area.compID][PRED_BUF_FILTERED];
    xFilterReferenceSamples(refBufUnfiltered, refBufFiltered, area, *cs.sps, cu.firstPU->multiRefIdx);
  }
}

#if JVET_V0130_INTRA_TMP
#if JVET_W0069_TMP_BOUNDARY
RefTemplateType IntraPrediction::getRefTemplateType(CodingUnit& cu, CompArea& area)
#else
bool IntraPrediction::isRefTemplateAvailable(CodingUnit& cu, CompArea& area)
#endif
{
  const ChannelType      chType = toChannelType(area.compID);
  const CodingStructure& cs = *cu.cs;
  const SPS& sps = *cs.sps;
  const PreCalcValues& pcv = *cs.pcv;
  setReferenceArrayLengths( area );

  const int  tuWidth = area.width;
  const int  tuHeight = area.height;
  const int  predSize = m_topRefLength;
  const int  predHSize = m_leftRefLength;

  const int  unitWidth = pcv.minCUWidth >> getComponentScaleX(area.compID, sps.getChromaFormatIdc());
  const int  unitHeight = pcv.minCUHeight >> getComponentScaleY(area.compID, sps.getChromaFormatIdc());

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight;
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
  const int  numAboveUnits = std::max<int>(tuWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(tuHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  if( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0 )
  {
#if JVET_W0069_TMP_BOUNDARY
    return NO_TEMPLATE;
#else
    return false;
#endif
  }

  // ----- Step 1: analyze neighborhood -----
  const Position posLT = area;

  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];

  memset(neighborFlags, 0, totalUnits);


#if JVET_W0069_TMP_BOUNDARY
  if (isAboveLeftAvailable(cu, chType, posLT) && isAboveAvailable(cu, chType, posLT, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1)) && isLeftAvailable(cu, chType, posLT, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1)))
  {
    return L_SHAPE_TEMPLATE;
  }
  else if (isLeftAvailable(cu, chType, posLT, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1)))
  {
    return LEFT_TEMPLATE;
  }
  else if (isAboveAvailable(cu, chType, posLT, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1)))
  {
    return ABOVE_TEMPLATE;
  }
  else
  {
    return NO_TEMPLATE;
  }
  CHECK(1, "un defined template type");
#else
  return isAboveLeftAvailable(cu, chType, posLT) && isAboveAvailable(cu, chType, posLT, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1)) && isLeftAvailable(cu, chType, posLT, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));
#endif

}
#endif

#if JVET_AH0209_PDP
bool xFillReferenceSamplesL(const CPelBuf &refBuf, Pel *ref, int numTemplateLines, int w, int h, int pw, int ph)
{
  int numMRLLeft = numTemplateLines;
  int numMRLTop = numTemplateLines;

  // buffer for top neighbors ( corner included )
  int buf1W = numMRLLeft + w;
  int buf1H = numMRLTop;

  int bs1 = buf1W * buf1H;

  // buffer for left neighbors
  int buf2W = numMRLLeft;
  int buf2H = h;

  CPelBuf refBuf1 = refBuf.subBuf(Position(0, 0), Size(buf1W, buf1H));
  CPelBuf refBuf2 = refBuf.subBuf(Position(0, numMRLTop), Size(buf2W, buf2H));

  PelBuf  targetBuf1 = PelBuf(ref, buf1W, Size(buf1W, buf1H));
  PelBuf  targetBuf2 = PelBuf(ref + bs1, buf2W, Size(buf2W, buf2H));

  targetBuf1.padCopyFrom(refBuf1, buf1W, buf1H, pw, 0);
  targetBuf2.padCopyFrom(refBuf2, buf2W, buf2H, 0, ph);

  return true;
}

void IntraPrediction::xFillReferenceSamples2(const CPelBuf &recoBuf, const CompArea &area, const CodingUnit &cu)
{
  const uint32_t width = cu.lwidth();
  const uint32_t height = cu.lheight();
  const int sizeKey = (width << 8) + height;
  const int sizeIdx = g_size.find( sizeKey ) != g_size.end() ? g_size[sizeKey] : -1;
  
#if JVET_AI0208_PDP_MIP
  bool sizeAvailable = (g_size.find( sizeKey ) != g_size.end()) && ( g_validSize[g_size[sizeKey]] || g_validSizeMip[g_size[sizeKey]]);
#endif
  if ( sizeIdx < 0 || sizeIdx == 6 || sizeIdx == 7 || sizeIdx == 11 || sizeIdx == 12 )
  {
    m_refAvailable = false;
    return;
  }

  const ChannelType      chType = toChannelType(area.compID);
  const CodingStructure &cs = *cu.cs;
  const SPS             &sps = *cs.sps;
  const PreCalcValues   &pcv = *cs.pcv;

#if !JVET_AJ0249_NEURAL_NETWORK_BASED
  const int multiRefIdx = (area.compID == COMPONENT_Y) ? cu.firstPU->multiRefIdx : 0;
#endif

#if JVET_AJ0249_NEURAL_NETWORK_BASED
  if (sizeAvailable)
#else
  if( area.compID == COMPONENT_Y
    && g_size.find( sizeKey ) != g_size.end()
#if JVET_AI0208_PDP_MIP
    && sizeAvailable
#else
    && g_validSize[g_size[sizeKey]]
#endif
    && !cu.timd
#if !JVET_AI0208_PDP_MIP
    && !cu.mipFlag
#endif
    && !cu.ispMode
#if JVET_AC0105_DIRECTIONAL_PLANAR
    && !cu.plIdx
#endif
    && multiRefIdx == 0 )
#endif
  {
#if JVET_AJ0249_NEURAL_NETWORK_BASED
    if ((cu.cs)->pcv->isEncoder && m_evalIdx != -1 && !cu.geoFlag && !cu.firstPU->ibcGpmFlag && !(cu.firstPU)->ciipFlag && !(cu.firstPU)->ibcCiipFlag && !cu.isobmcMC)
    {
      m_refAvailable = static_cast<bool>(m_evalIdx);
      return;
    }
#endif
    const int  tuWidth = area.width;
    const int  tuHeight = area.height;
    const int  predSize = tuWidth << 1;
    const int  predHSize = tuHeight << 1;

    const bool noShift = pcv.noChroma2x2 && area.width == 4; // don't shift on the lowest level (chroma not-split)
    const int  unitWidth = tuWidth <= 2 && cu.ispMode && isLuma( area.compID ) ? tuWidth : pcv.minCUWidth >> ( noShift ? 0 : getComponentScaleX( area.compID, sps.getChromaFormatIdc() ) );
    const int  unitHeight = tuHeight <= 2 && cu.ispMode && isLuma( area.compID ) ? tuHeight : pcv.minCUHeight >> ( noShift ? 0 : getComponentScaleY( area.compID, sps.getChromaFormatIdc() ) );

    const int  totalAboveUnits = ( predSize + ( unitWidth - 1 ) ) / unitWidth;
    const int  totalLeftUnits = ( predHSize + ( unitHeight - 1 ) ) / unitHeight;
    const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
    const int  numAboveUnits = std::max<int>( tuWidth / unitWidth, 1 );
    const int  numLeftUnits = std::max<int>( tuHeight / unitHeight, 1 );
    const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
    const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

    CHECK( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );

    // ----- Step 1: analyze neighborhood -----
    const Position posLT = area;
    const Position posRT = area.topRight();
    const Position posLB = area.bottomLeft();

    bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1] = { false };
    int numIntraNeighbor = 0;

    neighborFlags[ totalLeftUnits ] = isAboveLeftAvailable( cu, chType, posLT );
    numIntraNeighbor += neighborFlags[ totalLeftUnits ] ? 1 : 0;
    numIntraNeighbor += isAboveAvailable( cu, chType, posLT, numAboveUnits, unitWidth, ( neighborFlags + totalLeftUnits + 1 ) );
    numIntraNeighbor += isAboveRightAvailable( cu, chType, posRT, numAboveRightUnits, unitWidth, ( neighborFlags + totalLeftUnits + 1 + numAboveUnits ) );
    numIntraNeighbor += isLeftAvailable( cu, chType, posLT, numLeftUnits, unitHeight, ( neighborFlags + totalLeftUnits - 1 ) );
    numIntraNeighbor += isBelowLeftAvailable( cu, chType, posLB, numLeftBelowUnits, unitHeight, ( neighborFlags + totalLeftUnits - 1 - numLeftUnits ) );

    const int srcStride = recoBuf.stride;

    if( numIntraNeighbor > ( numAboveUnits + numLeftUnits ) )
    {
      int sizeIdx = g_size.find( sizeKey ) != g_size.end() ? g_size[sizeKey] : -1;
      if( sizeIdx < 0 || sizeIdx == 6 || sizeIdx == 7 || sizeIdx == 11 || sizeIdx == 12 )
      {
        m_refAvailable = false;
        return;
      }
      m_refAvailable = true;

      for( int i = numLeftUnits; i <= ( totalLeftUnits + numAboveUnits ); ++i )
      {
        if( !neighborFlags[ i ] )
        {
          m_refAvailable = false;
          return;
        }
      }

      int endUnit = totalLeftUnits + 1 + numAboveUnits;
      while( neighborFlags[ endUnit ] && endUnit != totalUnits )
      {
        ++endUnit;
      }

      int startUnit = 0;
      while( !neighborFlags[ startUnit ] )
      {
        ++startUnit;
      }

      int sizeID = g_size[ sizeKey ];
      int numMRLLeft = g_sizeData[ sizeID ][ 5 ];
      int numMRLTop = g_sizeData[ sizeID ][ 6 ];

      if( m_refAvailable )
      {
        Position refPos = posLT.offset( -numMRLLeft, -numMRLTop );
        if( !( cs.isDecomp( refPos, chType ) && cs.getCURestricted( refPos, cu, chType ) ) )
        {
          m_refAvailable = false;
          return;
        }
      }

      if( cu.sgpm )
      {
        return;
      }

      if( m_refAvailable )
      {
        int padW = ( totalUnits - endUnit ) * 4;
        int padH = startUnit * 4;
        int sizeW = tuWidth << 1;
        int sizeH = tuHeight << 1;

        CPelBuf refBuf = CPelBuf( recoBuf.buf - numMRLTop * srcStride - numMRLLeft, recoBuf.stride, Size( sizeW + numMRLLeft, sizeH + numMRLTop ) );
        xFillReferenceSamplesL( refBuf, m_ref, numMRLTop, sizeW, sizeH, padW, padH );
        xFillReferenceSamplesL( refBuf, m_refShort, numMRLTop, tuWidth, tuHeight, 0, 0 );
      }
    }
  }
}
#endif

#if JVET_AJ0249_NEURAL_NETWORK_BASED
void IntraPrediction::xFillReferenceSamples(const CPelBuf &recoBuf, Pel* refBufUnfiltered, const CompArea &area, const CodingUnit &cu, const bool forceDeac0, const bool forceDeac1)
#else
void IntraPrediction::xFillReferenceSamples( const CPelBuf &recoBuf, Pel* refBufUnfiltered, const CompArea &area, const CodingUnit &cu )
#endif
{
#if JVET_AH0209_PDP
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
#if JVET_AJ0249_NEURAL_NETWORK_BASED
#if JVET_AK0076_EXTENDED_OBMC_IBC
  if (isLuma(area.compID) && (cu.cs)->sps->getUsePDP() && m_intraOBMCNeighState == INTRA_OBMC_BOTH_NEIGH_AVAIL && !cu.tmpFlag && !cu.eipFlag && !cu.timd && !cu.sgpm && !cu.plIdx && !cu.firstPU->multiRefIdx && !cu.ispMode && !forceDeac0 && (cu.firstPU)->intraDir[CHANNEL_TYPE_LUMA] != PNN_IDX && !cu.isobmcMC)
#else
  if (isLuma(area.compID) && (cu.cs)->sps->getUsePDP() && m_intraOBMCNeighState == INTRA_OBMC_BOTH_NEIGH_AVAIL && !cu.tmpFlag && !cu.eipFlag && !cu.timd && !cu.sgpm && !cu.plIdx && !cu.firstPU->multiRefIdx && !cu.ispMode && !forceDeac0 && (cu.firstPU)->intraDir[CHANNEL_TYPE_LUMA] != PNN_IDX)
#endif
#else
  if (m_intraOBMCNeighState == INTRA_OBMC_BOTH_NEIGH_AVAIL && !cu.firstPU->multiRefIdx && !cu.ispMode && !cu.plIdx)
#endif
#else
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  if (isLuma(area.compID) && (cu.cs)->sps->getUsePDP() && !cu.tmpFlag && !cu.eipFlag && !cu.timd && !cu.sgpm && !cu.plIdx && !cu.firstPU->multiRefIdx && !cu.ispMode && !forceDeac0 && (cu.firstPU)->intraDir[CHANNEL_TYPE_LUMA] != PNN_IDX)
#else
  if (!cu.firstPU->multiRefIdx && !cu.ispMode && !cu.plIdx)
#endif
#endif
  {
    xFillReferenceSamples2(recoBuf, area, cu);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
    if ((cu.cs)->pcv->isEncoder && m_evalIdx == -1 && !cu.geoFlag && !cu.firstPU->ibcGpmFlag && !(cu.firstPU)->ciipFlag && !(cu.firstPU)->ibcCiipFlag && !cu.isobmcMC)
    {
      m_evalIdx = m_refAvailable ? 1 : 0;
    }
#endif
  }
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  if (forceDeac1 && m_refAvailable)
  {
    return;
  }
#endif
#endif
  const ChannelType      chType = toChannelType( area.compID );
  const CodingStructure &cs     = *cu.cs;
  const SPS             &sps    = *cs.sps;
  const PreCalcValues   &pcv    = *cs.pcv;

#if JVET_AJ0081_CHROMA_TMRL
  const int multiRefIdx         = (area.compID == COMPONENT_Y) ? cu.firstPU->multiRefIdx : cu.firstPU->chromaMrlIdx;
#else
  const int multiRefIdx         = (area.compID == COMPONENT_Y) ? cu.firstPU->multiRefIdx : 0;
#endif

  const int  tuWidth            = area.width;
  const int  tuHeight           = area.height;
  const int  predSize           = m_topRefLength;
  const int  predHSize          = m_leftRefLength;
  const int predStride = predSize + 1 + multiRefIdx;
  m_refBufferStride[area.compID] = predStride;

  const bool noShift            = pcv.noChroma2x2 && area.width == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth          = tuWidth  <= 2 && cu.ispMode && isLuma(area.compID) ? tuWidth  : pcv.minCUWidth  >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight         = tuHeight <= 2 && cu.ispMode && isLuma(area.compID) ? tuHeight : pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));

 #if JVET_Y0116_EXTENDED_MRL_LIST
  int leftMrlUnitNum  = multiRefIdx / unitHeight;
  int aboveMrlUnitNum = multiRefIdx / unitWidth;
#endif

  const int  totalAboveUnits    = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits     = (predHSize + (unitHeight - 1)) / unitHeight;
#if JVET_Y0116_EXTENDED_MRL_LIST
  const int  totalUnits         = totalAboveUnits + totalLeftUnits + 1 + leftMrlUnitNum + aboveMrlUnitNum; //+1 for top-left
#else
  const int  totalUnits         = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
#endif
  const int  numAboveUnits      = std::max<int>( tuWidth / unitWidth, 1 );
  const int  numLeftUnits       = std::max<int>( tuHeight / unitHeight, 1 );
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits  = totalLeftUnits - numLeftUnits;

  CHECK( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );

  // ----- Step 1: analyze neighborhood -----
  const Position posLT          = area;
  const Position posRT          = area.topRight();
  const Position posLB          = area.bottomLeft();

#if JVET_Y0116_EXTENDED_MRL_LIST
#if JVET_AC0094_REF_SAMPLES_OPT
  bool neighborFlags[4 * (MAX_NUM_PART_IDXS_IN_CTU_WIDTH << 2) + MAX_REF_LINE_IDX + 1];
#else
  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + MAX_REF_LINE_IDX + 1];
#endif
#else
  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
#endif
  int   numIntraNeighbor = 0;

  memset( neighborFlags, 0, totalUnits );

#if JVET_Y0116_EXTENDED_MRL_LIST
  neighborFlags[totalLeftUnits+leftMrlUnitNum] = isAboveLeftAvailable( cu, chType, posLT.offset(-multiRefIdx, -multiRefIdx) );
  numIntraNeighbor += neighborFlags[totalLeftUnits+leftMrlUnitNum] ? 1 : 0;
  numIntraNeighbor += isAboveAvailable     ( cu, chType, posLT.offset(-aboveMrlUnitNum*unitWidth, -multiRefIdx), aboveMrlUnitNum,      unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftMrlUnitNum) );
  numIntraNeighbor += isLeftAvailable      ( cu, chType, posLT.offset(-multiRefIdx, -leftMrlUnitNum*unitHeight), leftMrlUnitNum,       unitHeight, (neighborFlags + totalLeftUnits - 1 + leftMrlUnitNum) );
  numIntraNeighbor += isAboveAvailable     ( cu, chType, posLT.offset(0, -multiRefIdx), numAboveUnits,      unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftMrlUnitNum + aboveMrlUnitNum) );
  numIntraNeighbor += isAboveRightAvailable( cu, chType, posRT.offset(0, -multiRefIdx), numAboveRightUnits, unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftMrlUnitNum + aboveMrlUnitNum + numAboveUnits) );
  numIntraNeighbor += isLeftAvailable      ( cu, chType, posLT.offset(-multiRefIdx, 0), numLeftUnits,       unitHeight, (neighborFlags + totalLeftUnits - 1) );
  numIntraNeighbor += isBelowLeftAvailable ( cu, chType, posLB.offset(-multiRefIdx, 0), numLeftBelowUnits,  unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits) );

#else
  neighborFlags[totalLeftUnits] = isAboveLeftAvailable( cu, chType, posLT );
  numIntraNeighbor += neighborFlags[totalLeftUnits] ? 1 : 0;
  numIntraNeighbor += isAboveAvailable     ( cu, chType, posLT, numAboveUnits,      unitWidth,  (neighborFlags + totalLeftUnits + 1) );
  numIntraNeighbor += isAboveRightAvailable( cu, chType, posRT, numAboveRightUnits, unitWidth,  (neighborFlags + totalLeftUnits + 1 + numAboveUnits) );
  numIntraNeighbor += isLeftAvailable      ( cu, chType, posLT, numLeftUnits,       unitHeight, (neighborFlags + totalLeftUnits - 1) );
  numIntraNeighbor += isBelowLeftAvailable ( cu, chType, posLB, numLeftBelowUnits,  unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits) );
#endif

  // ----- Step 2: fill reference samples (depending on neighborhood) -----

  const Pel*  srcBuf    = recoBuf.buf;
  const int   srcStride = recoBuf.stride;
        Pel*  ptrDst    = refBufUnfiltered;
  const Pel*  ptrSrc;
  const Pel   valueDC   = 1 << (sps.getBitDepth( chType ) - 1);

  if( numIntraNeighbor == 0 )
  {
    // Fill border with DC value
    for (int j = 0; j <= predSize + multiRefIdx; j++)
    {
      ptrDst[j] = valueDC;
    }
    for (int i = 0; i <= predHSize + multiRefIdx; i++)
    {
      ptrDst[i + predStride] = valueDC;
    }
  }
  else if( numIntraNeighbor == totalUnits )
  {
    // Fill top-left border and top and top right with rec. samples
    ptrSrc = srcBuf - (1 + multiRefIdx) * srcStride - (1 + multiRefIdx);

    std::memcpy( ptrDst, ptrSrc, sizeof( *ptrDst ) * ( predSize + multiRefIdx + 1 ) );

    for (int i = 0; i <= predHSize + multiRefIdx; i++)
    {
      ptrDst[i + predStride] = ptrSrc[i * srcStride];
    }
  }
  else // reference samples are partially available
  {
    // Fill top-left sample(s) if available
    ptrSrc = srcBuf - (1 + multiRefIdx) * srcStride - (1 + multiRefIdx);
    ptrDst = refBufUnfiltered;
#if JVET_Y0116_EXTENDED_MRL_LIST
    if (neighborFlags[totalLeftUnits+leftMrlUnitNum])
#else
    if (neighborFlags[totalLeftUnits])
#endif
    {
      ptrDst[0] = ptrSrc[0];
      ptrDst[predStride] = ptrSrc[0];
#if JVET_Y0116_EXTENDED_MRL_LIST
      for (int i = 1; i <= multiRefIdx-leftMrlUnitNum*unitHeight; i++)
#else
      for (int i = 1; i <= multiRefIdx; i++)
#endif
      {
        ptrDst[i] = ptrSrc[i];
        ptrDst[i + predStride] = ptrSrc[i * srcStride];
      }
    }

    // Fill left & below-left samples if available (downwards)
#if JVET_Y0116_EXTENDED_MRL_LIST
    ptrSrc += (1 + multiRefIdx-leftMrlUnitNum*unitHeight) * srcStride;
    ptrDst += (1 + multiRefIdx-leftMrlUnitNum*unitHeight) + predStride;
#else
    ptrSrc += (1 + multiRefIdx) * srcStride;
    ptrDst += (1 + multiRefIdx) + predStride;
#endif
#if JVET_Y0116_EXTENDED_MRL_LIST
    for (int unitIdx = totalLeftUnits + leftMrlUnitNum - 1; unitIdx > 0; unitIdx--)
#else
    for (int unitIdx = totalLeftUnits - 1; unitIdx > 0; unitIdx--)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int i = 0; i < unitHeight; i++)
        {
          ptrDst[i] = ptrSrc[i * srcStride];
        }
      }
      ptrSrc += unitHeight * srcStride;
      ptrDst += unitHeight;
    }
    // Fill last below-left sample(s)
    if (neighborFlags[0])
    {
      int lastSample = (predHSize % unitHeight == 0) ? unitHeight : predHSize % unitHeight;
      for (int i = 0; i < lastSample; i++)
      {
        ptrDst[i] = ptrSrc[i * srcStride];
      }
    }

    // Fill above & above-right samples if available (left-to-right)
#if JVET_Y0116_EXTENDED_MRL_LIST
    ptrSrc = srcBuf - srcStride * (1 + multiRefIdx ) - aboveMrlUnitNum*unitWidth;
    ptrDst = refBufUnfiltered + 1 + multiRefIdx - aboveMrlUnitNum*unitWidth;
#else
    ptrSrc = srcBuf - srcStride * (1 + multiRefIdx);
    ptrDst = refBufUnfiltered + 1 + multiRefIdx;
#endif
#if JVET_Y0116_EXTENDED_MRL_LIST
    for (int unitIdx = totalLeftUnits + leftMrlUnitNum + 1; unitIdx < totalUnits - 1; unitIdx++)
#else
    for (int unitIdx = totalLeftUnits + 1; unitIdx < totalUnits - 1; unitIdx++)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int j = 0; j < unitWidth; j++)
        {
          ptrDst[j] = ptrSrc[j];
        }
      }
      ptrSrc += unitWidth;
      ptrDst += unitWidth;
    }
    // Fill last above-right sample(s)
    if (neighborFlags[totalUnits - 1])
    {
      int lastSample = (predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth;
      for (int j = 0; j < lastSample; j++)
      {
        ptrDst[j] = ptrSrc[j];
      }
    }

    // pad from first available down to the last below-left
    ptrDst = refBufUnfiltered;
    int lastAvailUnit = 0;
    if (!neighborFlags[0])
    {
      int firstAvailUnit = 1;
      while (firstAvailUnit < totalUnits && !neighborFlags[firstAvailUnit])
      {
        firstAvailUnit++;
      }

      // first available sample
      int firstAvailRow = -1;
      int firstAvailCol = 0;

#if JVET_Y0116_EXTENDED_MRL_LIST
      if (firstAvailUnit < totalLeftUnits + leftMrlUnitNum)
      {
        firstAvailRow = (totalLeftUnits + leftMrlUnitNum - firstAvailUnit) * unitHeight + multiRefIdx - leftMrlUnitNum * unitHeight;
      }
      else if (firstAvailUnit == totalLeftUnits + leftMrlUnitNum)
      {
        firstAvailRow = multiRefIdx - leftMrlUnitNum * unitHeight;
      }
      else
      {
        firstAvailCol = (firstAvailUnit - totalLeftUnits - leftMrlUnitNum - 1) * unitWidth + 1 + multiRefIdx - aboveMrlUnitNum * unitWidth;
      }
#else
      if (firstAvailUnit < totalLeftUnits)
      {
        firstAvailRow = (totalLeftUnits - firstAvailUnit) * unitHeight + multiRefIdx;
      }
      else if (firstAvailUnit == totalLeftUnits)
      {
        firstAvailRow = multiRefIdx;
      }
      else
      {
        firstAvailCol = (firstAvailUnit - totalLeftUnits - 1) * unitWidth + 1 + multiRefIdx;
      }
#endif
      const Pel firstAvailSample = ptrDst[firstAvailRow < 0 ? firstAvailCol : firstAvailRow + predStride];

      // last sample below-left (n.a.)
      int lastRow = predHSize + multiRefIdx;

      // fill left column
      for (int i = lastRow; i > firstAvailRow; i--)
      {
        ptrDst[i + predStride] = firstAvailSample;
      }
      // fill top row
      if (firstAvailCol > 0)
      {
        for (int j = 0; j < firstAvailCol; j++)
        {
          ptrDst[j] = firstAvailSample;
        }
      }
      lastAvailUnit = firstAvailUnit;
    }

    // pad all other reference samples.
    int currUnit = lastAvailUnit + 1;
    while (currUnit < totalUnits)
    {
      if (!neighborFlags[currUnit]) // samples not available
      {
        // last available sample
        int lastAvailRow = -1;
        int lastAvailCol = 0;
#if JVET_Y0116_EXTENDED_MRL_LIST
        if (lastAvailUnit < totalLeftUnits + leftMrlUnitNum)
        {
          lastAvailRow = (totalLeftUnits + leftMrlUnitNum - lastAvailUnit - 1) * unitHeight + multiRefIdx - leftMrlUnitNum * unitHeight + 1;
        }
        else if (lastAvailUnit == totalLeftUnits + leftMrlUnitNum)
        {
          lastAvailCol = multiRefIdx- leftMrlUnitNum * unitHeight;
        }
        else
        {
          lastAvailCol = (lastAvailUnit - totalLeftUnits - leftMrlUnitNum) * unitWidth + multiRefIdx - aboveMrlUnitNum * unitWidth;
        }
#else
        if (lastAvailUnit < totalLeftUnits)
        {
          lastAvailRow = (totalLeftUnits - lastAvailUnit - 1) * unitHeight + multiRefIdx + 1;
        }
        else if (lastAvailUnit == totalLeftUnits)
        {
          lastAvailCol = multiRefIdx;
        }
        else
        {
          lastAvailCol = (lastAvailUnit - totalLeftUnits) * unitWidth + multiRefIdx;
        }
#endif
        const Pel lastAvailSample = ptrDst[lastAvailRow < 0 ? lastAvailCol : lastAvailRow + predStride];

        // fill current unit with last available sample
#if JVET_Y0116_EXTENDED_MRL_LIST
        if (currUnit < totalLeftUnits + leftMrlUnitNum)
        {
          for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
        else if (currUnit == totalLeftUnits + leftMrlUnitNum)
        {
          for (int i = 0; i < multiRefIdx - leftMrlUnitNum * unitHeight + 1; i++)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
          for (int j = 0; j < multiRefIdx - aboveMrlUnitNum * unitWidth + 1; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
        else
        {
          int numSamplesInUnit = (currUnit == totalUnits - 1) ? ((predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth) : unitWidth;
          for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
#else
        if (currUnit < totalLeftUnits)
        {
          for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
        else if (currUnit == totalLeftUnits)
        {
          for (int i = 0; i < multiRefIdx + 1; i++)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
          for (int j = 0; j < multiRefIdx + 1; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
        else
        {
          int numSamplesInUnit = (currUnit == totalUnits - 1) ? ((predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth) : unitWidth;
          for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
#endif
      }
      lastAvailUnit = currUnit;
      currUnit++;
    }
  }
}

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
void IntraPrediction::xFillReferenceSamplesOBMC( const CPelBuf &recoBuf, Pel* refBufUnfiltered, const CompArea &area, const CodingUnit &cu )
{
#if JVET_AH0209_PDP
  m_refAvailable                = false;
#endif

  const ChannelType      chType = toChannelType( area.compID );
  const CodingStructure &cs     = *cu.cs;
  const SPS             &sps    = *cs.sps;
  const PreCalcValues   &pcv    = *cs.pcv;

  const int multiRefIdx         = (area.compID == COMPONENT_Y) ? cu.firstPU->multiRefIdx : 0;

  const int  tuWidth            = area.width;
  const int  tuHeight           = area.height;
  const int  predSize           = m_topRefLength;
  const int  predHSize          = m_leftRefLength;
  const int predStride = predSize + 1 + multiRefIdx;
  m_refBufferStride[area.compID] = predStride;

  const bool noShift            = pcv.noChroma2x2 && area.width == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth          = tuWidth  <= 2 && cu.ispMode && isLuma(area.compID) ? tuWidth  : pcv.minCUWidth  >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight         = tuHeight <= 2 && cu.ispMode && isLuma(area.compID) ? tuHeight : pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));

 #if JVET_Y0116_EXTENDED_MRL_LIST
  int leftMrlUnitNum  = multiRefIdx / unitHeight;
  int aboveMrlUnitNum = multiRefIdx / unitWidth;
#endif

  const int  totalAboveUnits    = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits     = (predHSize + (unitHeight - 1)) / unitHeight;
#if JVET_Y0116_EXTENDED_MRL_LIST
  const int  totalUnits         = totalAboveUnits + totalLeftUnits + 1 + leftMrlUnitNum + aboveMrlUnitNum; //+1 for top-left
#else
  const int  totalUnits         = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
#endif
  const int  numAboveUnits      = std::max<int>( tuWidth / unitWidth, 1 );
  const int  numLeftUnits       = std::max<int>( tuHeight / unitHeight, 1 );
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits  = totalLeftUnits - numLeftUnits;

  CHECK( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );

  // ----- Step 1: analyze neighborhood -----
  const Position posLT          = area;
  const Position posRT = area.topRight();
  const Position posLB = area.bottomLeft();

#if JVET_Y0116_EXTENDED_MRL_LIST
#if JVET_AC0094_REF_SAMPLES_OPT
  bool neighborFlags[4 * (MAX_NUM_PART_IDXS_IN_CTU_WIDTH << 2) + MAX_REF_LINE_IDX + 1];
#else
  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + MAX_REF_LINE_IDX + 1];
#endif
#else
  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
#endif

  memset( neighborFlags, 0, totalUnits );

  neighborFlags[totalLeftUnits+leftMrlUnitNum] = isAboveLeftAvailable( cu, chType, posLT.offset(-multiRefIdx, -multiRefIdx) );
  isAboveAvailableOBMC(cu, chType, posLT.offset(-aboveMrlUnitNum * unitWidth, -multiRefIdx), aboveMrlUnitNum, unitWidth, (neighborFlags + totalLeftUnits + 1 + leftMrlUnitNum), m_intraOBMCNeighState);
  isLeftAvailableOBMC(cu, chType, posLT.offset(-multiRefIdx, -leftMrlUnitNum * unitHeight), leftMrlUnitNum, unitHeight, (neighborFlags + totalLeftUnits - 1 + leftMrlUnitNum), m_intraOBMCNeighState);
  isAboveAvailableOBMC(cu, chType, posLT.offset(0, -multiRefIdx), numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1 + leftMrlUnitNum + aboveMrlUnitNum), m_intraOBMCNeighState);
  isAboveRightAvailableOBMC(cu, chType, posRT.offset(0, -multiRefIdx), numAboveRightUnits, unitWidth, (neighborFlags + totalLeftUnits + 1 + leftMrlUnitNum + aboveMrlUnitNum + numAboveUnits), m_intraOBMCNeighState);
  isLeftAvailableOBMC(cu, chType, posLT.offset(-multiRefIdx, 0), numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1), m_intraOBMCNeighState);
  isBelowLeftAvailableOBMC(cu, chType, posLB.offset(-multiRefIdx, 0), numLeftBelowUnits, unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits), m_intraOBMCNeighState);

  // ----- Step 2: fill reference samples (depending on neighborhood) -----

  const Pel*  srcBuf    = recoBuf.buf;
  const int   srcStride = recoBuf.stride;
        Pel*  ptrDst    = refBufUnfiltered;
  const Pel*  ptrSrc;

  // Fill top-left sample(s) if available
  ptrSrc = srcBuf - (1 + multiRefIdx) * srcStride - (1 + multiRefIdx);
  ptrDst = refBufUnfiltered;
#if JVET_Y0116_EXTENDED_MRL_LIST
  if (neighborFlags[totalLeftUnits+leftMrlUnitNum])
#else
  if (neighborFlags[totalLeftUnits])
#endif
  {
    ptrDst[0] = ptrSrc[0];
    ptrDst[predStride] = ptrSrc[0];
#if JVET_Y0116_EXTENDED_MRL_LIST
    for (int i = 1; i <= multiRefIdx-leftMrlUnitNum*unitHeight; i++)
#else
    for (int i = 1; i <= multiRefIdx; i++)
#endif
    {
      ptrDst[i] = ptrSrc[i];
      ptrDst[i + predStride] = ptrSrc[i * srcStride];
    }
  }
    

  if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL)
  {
    // Fill left & below-left samples if available (downwards)
#if JVET_Y0116_EXTENDED_MRL_LIST
    ptrSrc += (1 + multiRefIdx - leftMrlUnitNum * unitHeight) * srcStride;
    ptrDst += (1 + multiRefIdx - leftMrlUnitNum * unitHeight) + predStride;
#else
    ptrSrc += (1 + multiRefIdx) * srcStride;
    ptrDst += (1 + multiRefIdx) + predStride;
#endif
#if JVET_Y0116_EXTENDED_MRL_LIST
    for (int unitIdx = totalLeftUnits + leftMrlUnitNum - 1; unitIdx > 0; unitIdx--)
#else
    for (int unitIdx = totalLeftUnits - 1; unitIdx > 0; unitIdx--)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int i = 0; i < unitHeight; i++)
        {
          ptrDst[i] = ptrSrc[i * srcStride];
        }
      }
      ptrSrc += unitHeight * srcStride;
      ptrDst += unitHeight;
    }
    // Fill last below-left sample(s)
    if (neighborFlags[0])
    {
      int lastSample = (predHSize % unitHeight == 0) ? unitHeight : predHSize % unitHeight;
      for (int i = 0; i < lastSample; i++)
      {
        ptrDst[i] = ptrSrc[i * srcStride];
      }
    }
  }

  if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL)
  {
    // Fill above & above-right samples if available (left-to-right)
#if JVET_Y0116_EXTENDED_MRL_LIST
    ptrSrc = srcBuf - srcStride * (1 + multiRefIdx) - aboveMrlUnitNum * unitWidth;
    ptrDst = refBufUnfiltered + 1 + multiRefIdx - aboveMrlUnitNum * unitWidth;
#else
    ptrSrc = srcBuf - srcStride * (1 + multiRefIdx);
    ptrDst = refBufUnfiltered + 1 + multiRefIdx;
#endif
#if JVET_Y0116_EXTENDED_MRL_LIST
    for (int unitIdx = totalLeftUnits + leftMrlUnitNum + 1; unitIdx < totalUnits - 1; unitIdx++)
#else
    for (int unitIdx = totalLeftUnits + 1; unitIdx < totalUnits - 1; unitIdx++)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int j = 0; j < unitWidth; j++)
        {
          ptrDst[j] = ptrSrc[j];
        }
      }
      ptrSrc += unitWidth;
      ptrDst += unitWidth;
    }
    // Fill last above-right sample(s)
    if (neighborFlags[totalUnits - 1])
    {
      int lastSample = (predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth;
      for (int j = 0; j < lastSample; j++)
      {
        ptrDst[j] = ptrSrc[j];
      }
    }
  }

  // pad from first available down to the last below-left
  ptrDst = refBufUnfiltered;
  int lastAvailUnit = 0;
  if (!neighborFlags[0])
  {
    int firstAvailUnit = 1;
    while (firstAvailUnit < totalUnits && !neighborFlags[firstAvailUnit])
    {
      firstAvailUnit++;
    }

    // first available sample
    int firstAvailRow = -1;
    int firstAvailCol = 0;

#if JVET_Y0116_EXTENDED_MRL_LIST
    if (firstAvailUnit < totalLeftUnits + leftMrlUnitNum)
    {
      firstAvailRow = (totalLeftUnits + leftMrlUnitNum - firstAvailUnit) * unitHeight + multiRefIdx - leftMrlUnitNum * unitHeight;
    }
    else if (firstAvailUnit == totalLeftUnits + leftMrlUnitNum)
    {
      firstAvailRow = multiRefIdx - leftMrlUnitNum * unitHeight;
    }
    else
    {
      firstAvailCol = (firstAvailUnit - totalLeftUnits - leftMrlUnitNum - 1) * unitWidth + 1 + multiRefIdx - aboveMrlUnitNum * unitWidth;
    }
#else
    if (firstAvailUnit < totalLeftUnits)
    {
      firstAvailRow = (totalLeftUnits - firstAvailUnit) * unitHeight + multiRefIdx;
    }
    else if (firstAvailUnit == totalLeftUnits)
    {
      firstAvailRow = multiRefIdx;
    }
    else
    {
      firstAvailCol = (firstAvailUnit - totalLeftUnits - 1) * unitWidth + 1 + multiRefIdx;
    }
#endif
    const Pel firstAvailSample = ptrDst[firstAvailRow < 0 ? firstAvailCol : firstAvailRow + predStride];

    // last sample below-left (n.a.)
    int lastRow = predHSize + multiRefIdx;

    if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL)
    {
      lastRow = std::min(lastRow, 1);
    }
    else
    {
      firstAvailCol = std::min(firstAvailCol, 1);
    }

    // fill left column
    for (int i = lastRow; i > firstAvailRow; i--)
    {
      ptrDst[i + predStride] = firstAvailSample;
    }
    // fill top row
    if (firstAvailCol > 0)
    {
      for (int j = 0; j < firstAvailCol; j++)
      {
        ptrDst[j] = firstAvailSample;
      }
    }
    lastAvailUnit = firstAvailUnit;
  }

  // pad all other reference samples.
  int currUnit = lastAvailUnit + 1;

  if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL)
  {
    currUnit = std::max(totalLeftUnits+leftMrlUnitNum+1, currUnit);
  }

  while (currUnit < totalUnits)
  {
    if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL && (totalLeftUnits+leftMrlUnitNum+1 < currUnit))
    {
      break;
    }

    if (!neighborFlags[currUnit]) // samples not available
    {
      // last available sample
      int lastAvailRow = -1;
      int lastAvailCol = 0;
#if JVET_Y0116_EXTENDED_MRL_LIST
      if (lastAvailUnit < totalLeftUnits + leftMrlUnitNum)
      {
        lastAvailRow = (totalLeftUnits + leftMrlUnitNum - lastAvailUnit - 1) * unitHeight + multiRefIdx - leftMrlUnitNum * unitHeight + 1;
      }
      else if (lastAvailUnit == totalLeftUnits + leftMrlUnitNum)
      {
        lastAvailCol = multiRefIdx- leftMrlUnitNum * unitHeight;
      }
      else
      {
        lastAvailCol = (lastAvailUnit - totalLeftUnits - leftMrlUnitNum) * unitWidth + multiRefIdx - aboveMrlUnitNum * unitWidth;
      }
#else
      if (lastAvailUnit < totalLeftUnits)
      {
        lastAvailRow = (totalLeftUnits - lastAvailUnit - 1) * unitHeight + multiRefIdx + 1;
      }
      else if (lastAvailUnit == totalLeftUnits)
      {
        lastAvailCol = multiRefIdx;
      }
      else
      {
        lastAvailCol = (lastAvailUnit - totalLeftUnits) * unitWidth + multiRefIdx;
      }
#endif
      const Pel lastAvailSample = ptrDst[lastAvailRow < 0 ? lastAvailCol : lastAvailRow + predStride];

      // fill current unit with last available sample
#if JVET_Y0116_EXTENDED_MRL_LIST
      if (currUnit < totalLeftUnits + leftMrlUnitNum)
      {
        if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL)
        {
          for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
      }
      else if (currUnit == totalLeftUnits + leftMrlUnitNum)
      {
        if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL)
        {
          for (int i = 0; i < multiRefIdx - leftMrlUnitNum * unitHeight + 1; i++)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
        if (m_intraOBMCNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL)
        {
          for (int j = 0; j < multiRefIdx - aboveMrlUnitNum * unitWidth + 1; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
      }
      else
      {
        int numSamplesInUnit = (currUnit == totalUnits - 1) ? ((predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth) : unitWidth;
        for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
        {
          ptrDst[j] = lastAvailSample;
        }
      }
#else
      if (currUnit < totalLeftUnits)
      {
        for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
        {
          ptrDst[i + predStride] = lastAvailSample;
        }
      }
      else if (currUnit == totalLeftUnits)
      {
        for (int i = 0; i < multiRefIdx + 1; i++)
        {
          ptrDst[i + predStride] = lastAvailSample;
        }
        for (int j = 0; j < multiRefIdx + 1; j++)
        {
          ptrDst[j] = lastAvailSample;
        }
      }
      else
      {
        int numSamplesInUnit = (currUnit == totalUnits - 1) ? ((predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth) : unitWidth;
        for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
        {
          ptrDst[j] = lastAvailSample;
        }
      }
#endif
    }
    lastAvailUnit = currUnit;
    currUnit++;
  }
}
#endif

#if JVET_AH0136_CHROMA_REORDERING
void IntraPrediction::xFillReferenceSamplesForCoLuma(const CPelBuf &recoBuf, Pel* refBufUnfiltered, const CompArea &area, const CodingUnit &cu)
{
  const ChannelType      chType = toChannelType(area.compID);
  const CodingStructure &cs = *cu.cs;
  const SPS             &sps = *cs.sps;
  const PreCalcValues   &pcv = *cs.pcv;

#if JVET_AJ0081_CHROMA_TMRL
  const int multiRefIdx = cu.firstPU->multiRefIdx;
#else
  const int multiRefIdx = 0;
#endif

  const int  tuWidth = area.width;
  const int  tuHeight = area.height;
  const int  predSize = m_topRefLength;
  const int  predHSize = m_leftRefLength;
  const int predStride = predSize + 1 + multiRefIdx;
  m_refBufferStride[area.compID] = predStride;

  const bool noShift = pcv.noChroma2x2 && area.width == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth = tuWidth <= 2 && cu.ispMode && isLuma(area.compID) ? tuWidth : pcv.minCUWidth >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight = tuHeight <= 2 && cu.ispMode && isLuma(area.compID) ? tuHeight : pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));

#if JVET_AJ0081_CHROMA_TMRL
  int leftMrlUnitNum = multiRefIdx / unitHeight;
  int aboveMrlUnitNum = multiRefIdx / unitWidth;
#endif

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight;
#if JVET_AJ0081_CHROMA_TMRL
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1 + leftMrlUnitNum + aboveMrlUnitNum; // for top-left and mrl
#else
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
#endif

  const int  numAboveUnits = std::max<int>(tuWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(tuHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  CHECK(numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported");

  // ----- Step 1: analyze neighborhood -----
#if JVET_AJ0081_CHROMA_TMRL
  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + MAX_REF_LINE_IDX + 1];
#else
  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
#endif
  int   numIntraNeighbor = 0;

  memset(neighborFlags, 0, totalUnits);

#if JVET_AJ0081_CHROMA_TMRL
  //top-left
  neighborFlags[totalLeftUnits + leftMrlUnitNum] = (area.x - multiRefIdx) > 0 && (area.y - multiRefIdx) > 0;
  numIntraNeighbor += neighborFlags[totalLeftUnits + leftMrlUnitNum] ? 1 : 0;
  //mrl above
  numIntraNeighbor += ((area.x - aboveMrlUnitNum * unitWidth) > 0 && (area.y - multiRefIdx) > 0) ? aboveMrlUnitNum : 0;
  for (int i = totalLeftUnits + leftMrlUnitNum + 1; i < totalLeftUnits + leftMrlUnitNum + 1 + aboveMrlUnitNum; i++)
  {
    neighborFlags[i] = ((area.x - aboveMrlUnitNum * unitWidth) > 0 && (area.y - multiRefIdx) > 0) ? true : false;
  }
  //above
  numIntraNeighbor += (area.y - multiRefIdx) > 0 ? numAboveUnits : 0;
  for (int i = totalLeftUnits + leftMrlUnitNum + 1 + aboveMrlUnitNum; i < totalLeftUnits + leftMrlUnitNum + 1 + aboveMrlUnitNum + numAboveUnits; i++)
  {
    neighborFlags[i] = (area.y - multiRefIdx) > 0 ? true : false;
  }
  //above right
  int picWidth = sps.getMaxPicWidthInLumaSamples();
  int ctuWidth = sps.getCTUSize();
  int ctuWidthInNum = area.x / ctuWidth;
  int wUnit = std::min((picWidth - area.x - tuWidth) / unitWidth, ((ctuWidthInNum + 1) * ctuWidth - area.x - tuWidth) / unitWidth);
#if JVET_AI0136_ADAPTIVE_DUAL_TREE // to fix chroma ipm reorderding
  if (cu.slice->isIntra())
#endif
  numIntraNeighbor += (area.y - multiRefIdx) > 0 ? std::min(numAboveRightUnits, wUnit) : 0;
  for (int i = totalLeftUnits + leftMrlUnitNum + 1 + aboveMrlUnitNum + numAboveUnits; i < totalLeftUnits + leftMrlUnitNum + 1 + aboveMrlUnitNum + numAboveUnits + numAboveRightUnits; i++)
  {
    neighborFlags[i] = (area.y - multiRefIdx) > 0 ? (i - (totalLeftUnits + 1 + numAboveUnits) < wUnit ? true : false) : false;
#if JVET_AI0136_ADAPTIVE_DUAL_TREE  // to fix chroma ipm reorderding
    if (!cu.slice->isIntra())
    {
      neighborFlags[i] = false;
    }
#endif
  }
  //mrl left
  numIntraNeighbor += ((area.x - multiRefIdx) > 0 && (area.y - leftMrlUnitNum * unitHeight) > 0) ? leftMrlUnitNum : 0;
  for (int i = totalLeftUnits + leftMrlUnitNum - 1; i > totalLeftUnits - 1; i--)
  {
    neighborFlags[i] = ((area.x - multiRefIdx) > 0 && (area.y - leftMrlUnitNum * unitHeight) > 0) ? true : false;
  }
  //left
  numIntraNeighbor += (area.x - multiRefIdx) > 0 ? numLeftUnits : 0;
  for (int i = totalLeftUnits - 1; i > totalLeftUnits - 1 - numLeftUnits; i--)
  {
    neighborFlags[i] = (area.x - multiRefIdx) > 0 ? true : false;
  }
  //left below
  int picHeight = sps.getMaxPicHeightInLumaSamples();
  int ctuHeight = sps.getCTUSize();
  int ctuHeightInNum = area.y / ctuHeight;
  int hUnit = std::min((picHeight - area.y - tuHeight) / unitHeight, ((ctuHeightInNum + 1) * ctuHeight - area.y - tuHeight) / unitHeight);
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if (cu.slice->isIntra())
#endif
  numIntraNeighbor += (area.x - multiRefIdx) > 0 ? std::min(numLeftBelowUnits, hUnit) : 0;
  int y = 0;
  for (int i = totalLeftUnits - 1 - numLeftUnits; i > totalLeftUnits - 1 - numLeftUnits - numLeftBelowUnits; i--)
  {
    neighborFlags[i] = (area.x - multiRefIdx) > 0 ? (y < hUnit ? true : false) : false;
#if JVET_AI0136_ADAPTIVE_DUAL_TREE  // to fix chroma ipm reorderding
    if (!cu.slice->isIntra())
    {
      neighborFlags[i] = false;
    }
#endif
    y++;
  }
#else
  neighborFlags[totalLeftUnits] = area.x > 0 && area.y > 0;
  numIntraNeighbor += neighborFlags[totalLeftUnits] ? 1 : 0;
  numIntraNeighbor += area.y > 0 ? numAboveUnits : 0;
  for (int i = totalLeftUnits + 1; i < totalLeftUnits + 1 + numAboveUnits; i++)
  {
    neighborFlags[i] = area.y > 0 ? true : false;
  }
  int picWidth = sps.getMaxPicWidthInLumaSamples();
  int ctuWidth = sps.getCTUSize();
  int ctuWidthInNum = area.x / ctuWidth;
  int wUnit = std::min((picWidth - area.x - tuWidth) / unitWidth, ((ctuWidthInNum + 1) * ctuWidth - area.x - tuWidth) / unitWidth);
#if JVET_AI0136_ADAPTIVE_DUAL_TREE // to fix chroma ipm reorderding
  if (cu.slice->isIntra())
#endif
    numIntraNeighbor += area.y > 0 ? std::min(numAboveRightUnits, wUnit) : 0;
  for (int i = totalLeftUnits + 1 + numAboveUnits; i < totalLeftUnits + 1 + numAboveUnits + numAboveRightUnits; i++)
  {
    neighborFlags[i] = area.y > 0 ? (i - (totalLeftUnits + 1 + numAboveUnits) < wUnit ? true : false) : false;
#if JVET_AI0136_ADAPTIVE_DUAL_TREE  // to fix chroma ipm reorderding
    if (!cu.slice->isIntra())
    {
      neighborFlags[i] = false;
    }
#endif
  }
  numIntraNeighbor += area.x > 0 ? numLeftUnits : 0;
  for (int i = totalLeftUnits - 1; i > totalLeftUnits - 1 - numLeftUnits; i--)
  {
    neighborFlags[i] = area.x > 0 ? true : false;
  }
  int picHeight = sps.getMaxPicHeightInLumaSamples();
  int ctuHeight = sps.getCTUSize();
  int ctuHeightInNum = area.y / ctuHeight;
  int hUnit = std::min((picHeight - area.y - tuHeight) / unitHeight, ((ctuHeightInNum + 1) * ctuHeight - area.y - tuHeight) / unitHeight);
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if (cu.slice->isIntra())
#endif
    numIntraNeighbor += area.x > 0 ? std::min(numLeftBelowUnits, hUnit) : 0;
  int y = 0;
  for (int i = totalLeftUnits - 1 - numLeftUnits; i > totalLeftUnits - 1 - numLeftUnits - numLeftBelowUnits; i--)
  {
    neighborFlags[i] = area.x > 0 ? (y < hUnit ? true : false) : false;
#if JVET_AI0136_ADAPTIVE_DUAL_TREE  // to fix chroma ipm reorderding
    if (!cu.slice->isIntra())
    {
      neighborFlags[i] = false;
    }
#endif
    y++;
  }
#endif

  // ----- Step 2: fill reference samples (depending on neighborhood) -----

  const Pel*  srcBuf = recoBuf.buf;
  const int   srcStride = recoBuf.stride;
  Pel*  ptrDst = refBufUnfiltered;
  const Pel*  ptrSrc;
  const Pel   valueDC = 1 << (sps.getBitDepth(chType) - 1);

  if (numIntraNeighbor == 0)
  {
    // Fill border with DC value
    for (int j = 0; j <= predSize + multiRefIdx; j++)
    {
      ptrDst[j] = valueDC;
    }
    for (int i = 0; i <= predHSize + multiRefIdx; i++)
    {
      ptrDst[i + predStride] = valueDC;
    }
  }
  else if (numIntraNeighbor == totalUnits)
  {
    // Fill top-left border and top and top right with rec. samples
    ptrSrc = srcBuf - (1 + multiRefIdx) * srcStride - (1 + multiRefIdx);

    std::memcpy(ptrDst, ptrSrc, sizeof(*ptrDst) * (predSize + multiRefIdx + 1));

    for (int i = 0; i <= predHSize + multiRefIdx; i++)
    {
      ptrDst[i + predStride] = ptrSrc[i * srcStride];
    }
  }
  else // reference samples are partially available
  {
    // Fill top-left sample(s) if available
    ptrSrc = srcBuf - (1 + multiRefIdx) * srcStride - (1 + multiRefIdx);
    ptrDst = refBufUnfiltered;
    if (neighborFlags[totalLeftUnits])
    {
      ptrDst[0] = ptrSrc[0];
      ptrDst[predStride] = ptrSrc[0];
      for (int i = 1; i <= multiRefIdx; i++)
      {
        ptrDst[i] = ptrSrc[i];
        ptrDst[i + predStride] = ptrSrc[i * srcStride];
      }
    }

    // Fill left & below-left samples if available (downwards)
#if JVET_AJ0081_CHROMA_TMRL
    ptrSrc += (1 + multiRefIdx - leftMrlUnitNum * unitHeight) * srcStride;
    ptrDst += (1 + multiRefIdx - leftMrlUnitNum * unitHeight) + predStride;
    for (int unitIdx = totalLeftUnits + leftMrlUnitNum - 1; unitIdx > 0; unitIdx--)
#else
    ptrSrc += (1 + multiRefIdx) * srcStride;
    ptrDst += (1 + multiRefIdx) + predStride;
    for (int unitIdx = totalLeftUnits - 1; unitIdx > 0; unitIdx--)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int i = 0; i < unitHeight; i++)
        {
          ptrDst[i] = ptrSrc[i * srcStride];
        }
      }
      ptrSrc += unitHeight * srcStride;
      ptrDst += unitHeight;
    }
    // Fill last below-left sample(s)
    if (neighborFlags[0])
    {
      int lastSample = (predHSize % unitHeight == 0) ? unitHeight : predHSize % unitHeight;
      for (int i = 0; i < lastSample; i++)
      {
        ptrDst[i] = ptrSrc[i * srcStride];
      }
    }

    // Fill above & above-right samples if available (left-to-right)
#if JVET_AJ0081_CHROMA_TMRL
    ptrSrc = srcBuf - srcStride * (1 + multiRefIdx) - aboveMrlUnitNum * unitWidth;
    ptrDst = refBufUnfiltered + 1 + multiRefIdx - aboveMrlUnitNum * unitWidth;
    for (int unitIdx = totalLeftUnits + leftMrlUnitNum + 1; unitIdx < totalUnits - 1; unitIdx++)
#else
    ptrSrc = srcBuf - srcStride * (1 + multiRefIdx);
    ptrDst = refBufUnfiltered + 1 + multiRefIdx;
    for (int unitIdx = totalLeftUnits + 1; unitIdx < totalUnits - 1; unitIdx++)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int j = 0; j < unitWidth; j++)
        {
          ptrDst[j] = ptrSrc[j];
        }
      }
      ptrSrc += unitWidth;
      ptrDst += unitWidth;
    }
    // Fill last above-right sample(s)
    if (neighborFlags[totalUnits - 1])
    {
      int lastSample = (predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth;
      for (int j = 0; j < lastSample; j++)
      {
        ptrDst[j] = ptrSrc[j];
      }
    }

    // pad from first available down to the last below-left
    ptrDst = refBufUnfiltered;
    int lastAvailUnit = 0;
    if (!neighborFlags[0])
    {
      int firstAvailUnit = 1;
      while (firstAvailUnit < totalUnits && !neighborFlags[firstAvailUnit])
      {
        firstAvailUnit++;
      }

      // first available sample
      int firstAvailRow = -1;
      int firstAvailCol = 0;

#if JVET_AJ0081_CHROMA_TMRL
      if (firstAvailUnit < totalLeftUnits + leftMrlUnitNum)
      {
        firstAvailRow = (totalLeftUnits + leftMrlUnitNum - firstAvailUnit) * unitHeight + multiRefIdx - leftMrlUnitNum * unitHeight;
      }
      else if (firstAvailUnit == totalLeftUnits + leftMrlUnitNum)
      {
        firstAvailRow = multiRefIdx - leftMrlUnitNum * unitHeight;
      }
      else
      {
        firstAvailCol = (firstAvailUnit - totalLeftUnits - leftMrlUnitNum - 1) * unitWidth + 1 + multiRefIdx - aboveMrlUnitNum * unitWidth;
      }
#else
      if (firstAvailUnit < totalLeftUnits)
      {
        firstAvailRow = (totalLeftUnits - firstAvailUnit) * unitHeight + multiRefIdx;
      }
      else if (firstAvailUnit == totalLeftUnits)
      {
        firstAvailRow = multiRefIdx;
      }
      else
      {
        firstAvailCol = (firstAvailUnit - totalLeftUnits - 1) * unitWidth + 1 + multiRefIdx;
      }
#endif

      const Pel firstAvailSample = ptrDst[firstAvailRow < 0 ? firstAvailCol : firstAvailRow + predStride];

      // last sample below-left (n.a.)
      int lastRow = predHSize + multiRefIdx;

      // fill left column
      for (int i = lastRow; i > firstAvailRow; i--)
      {
        ptrDst[i + predStride] = firstAvailSample;
      }
      // fill top row
      if (firstAvailCol > 0)
      {
        for (int j = 0; j < firstAvailCol; j++)
        {
          ptrDst[j] = firstAvailSample;
        }
      }
      lastAvailUnit = firstAvailUnit;
    }

    // pad all other reference samples.
    int currUnit = lastAvailUnit + 1;
    while (currUnit < totalUnits)
    {
      if (!neighborFlags[currUnit]) // samples not available
      {
        // last available sample
        int lastAvailRow = -1;
        int lastAvailCol = 0;
#if JVET_AJ0081_CHROMA_TMRL
        if (lastAvailUnit < totalLeftUnits + leftMrlUnitNum)
        {
          lastAvailRow = (totalLeftUnits + leftMrlUnitNum - lastAvailUnit - 1) * unitHeight + multiRefIdx - leftMrlUnitNum * unitHeight + 1;
        }
        else if (lastAvailUnit == totalLeftUnits + leftMrlUnitNum)
        {
          lastAvailCol = multiRefIdx - leftMrlUnitNum * unitHeight;
        }
        else
        {
          lastAvailCol = (lastAvailUnit - totalLeftUnits - leftMrlUnitNum) * unitWidth + multiRefIdx - aboveMrlUnitNum * unitWidth;
        }
#else
        if (lastAvailUnit < totalLeftUnits)
        {
          lastAvailRow = (totalLeftUnits - lastAvailUnit - 1) * unitHeight + multiRefIdx + 1;
        }
        else if (lastAvailUnit == totalLeftUnits)
        {
          lastAvailCol = multiRefIdx;
        }
        else
        {
          lastAvailCol = (lastAvailUnit - totalLeftUnits) * unitWidth + multiRefIdx;
        }
#endif
        const Pel lastAvailSample = ptrDst[lastAvailRow < 0 ? lastAvailCol : lastAvailRow + predStride];

        // fill current unit with last available sample
#if JVET_AJ0081_CHROMA_TMRL
        if (currUnit < totalLeftUnits + leftMrlUnitNum)
        {
          for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
        else if (currUnit == totalLeftUnits + leftMrlUnitNum)
        {
          for (int i = 0; i < multiRefIdx - leftMrlUnitNum * unitHeight + 1; i++)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
          for (int j = 0; j < multiRefIdx - aboveMrlUnitNum * unitWidth + 1; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
        else
        {
          int numSamplesInUnit = (currUnit == totalUnits - 1) ? ((predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth) : unitWidth;
          for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
#else
        if (currUnit < totalLeftUnits)
        {
          for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
        else if (currUnit == totalLeftUnits)
        {
          for (int i = 0; i < multiRefIdx + 1; i++)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
          for (int j = 0; j < multiRefIdx + 1; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
        else
        {
          int numSamplesInUnit = (currUnit == totalUnits - 1) ? ((predSize % unitWidth == 0) ? unitWidth : predSize % unitWidth) : unitWidth;
          for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
#endif
      }
      lastAvailUnit = currUnit;
      currUnit++;
    }
  }
}
#endif

void IntraPrediction::xFilterReferenceSamples(const Pel *refBufUnfiltered, Pel *refBufFiltered, const CompArea &area,
                                              const SPS &sps, int multiRefIdx)
{
  if (area.compID != COMPONENT_Y)
  {
    multiRefIdx = 0;
  }
  const int predSize = m_topRefLength + multiRefIdx;
  const int predHSize = m_leftRefLength + multiRefIdx;
  const size_t predStride = m_refBufferStride[area.compID];

  const Pel topLeft =
    (refBufUnfiltered[0] + refBufUnfiltered[1] + refBufUnfiltered[predStride] + refBufUnfiltered[predStride + 1] + 2)
    >> 2;

  refBufFiltered[0] = topLeft;

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
  if (!(m_intraOBMCNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL && m_refSampleForOBMC))
  {
#endif
  for (int i = 1; i < predSize; i++)
  {
    refBufFiltered[i] = (refBufUnfiltered[i - 1] + 2 * refBufUnfiltered[i] + refBufUnfiltered[i + 1] + 2) >> 2;
  }
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
  }
#endif
  refBufFiltered[predSize] = refBufUnfiltered[predSize];

  refBufFiltered += predStride;
  refBufUnfiltered += predStride;

  refBufFiltered[0] = topLeft;

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
  if (!(m_intraOBMCNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL && m_refSampleForOBMC))
  {
#endif
  for (int i = 1; i < predHSize; i++)
  {
    refBufFiltered[i] = (refBufUnfiltered[i - 1] + 2 * refBufUnfiltered[i] + refBufUnfiltered[i + 1] + 2) >> 2;
  }
#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
  }
#endif
  refBufFiltered[predHSize] = refBufUnfiltered[predHSize];
}

#if JVET_AJ0249_NEURAL_NETWORK_BASED
void IntraPrediction::xPredIntraPnn(const CPelBuf& recoBuf, PelBuf& pDst, const CPelBuf& srcBuf, CodingUnit& cu, const ComponentID compID
#if JVET_AK0118_BF_FOR_INTRA_PRED
 , bool applyBf
#endif
  )
{
  const CompArea& area = cu.block(compID);
  const ChannelType chType = toChannelType(compID);
  const CodingStructure& cs = *cu.cs;
  const SPS& sps = *cs.sps;
  m_intraPredNN.collectContextWidthHeightMasksInPixels(area, recoBuf.buf, recoBuf.stride, sps.getBitDepth(chType), cu, compID);
  bool isPredictionRun = false;
  m_intraPredNN.predictPnn(pDst, srcBuf, sps.getBitDepth(chType), area, isPredictionRun);
#if JVET_AK0118_BF_FOR_INTRA_PRED
  PelBuf predictedBuf( m_intraPredNN.getNnIntraPredPtr(), pDst.width, pDst.height);
  if( applyBf && isPredictionRun )
  {
    int blkWidth = pDst.width;
    int blkHeight = pDst.height;
    int blkQp = cu.qp;
    CodingStructure &cs = *cu.cs;
    const ClpRng& clpRng(cs.slice->clpRng(compID));

    bilateralFilterPredDiamond5x5Clip(cs, toChannelType(compID), predictedBuf, blkWidth, blkHeight, blkQp, clpRng, true, cu );
  }
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
  pDst.copyFrom(predictedBuf);
#endif
  if (isPredictionRun)
  {
#if JVET_AI0050_INTER_MTSS
    int secondDimdIntraDir = DC_IDX;
#endif
    const int pnnDimdMode = deriveIpmForTransform(pDst, cu
#if JVET_AI0050_INTER_MTSS
                                                  , secondDimdIntraDir
#endif
                                                  );
    m_intraPredNN.setEquivalentIntraDir(compID, pnnDimdMode, secondDimdIntraDir);
  }
  cu.indicesRepresentationPnn[compID] = m_intraPredNN.getEquivalentIntraDir(compID);
}
#endif

#if JVET_W0123_TIMD_FUSION
Pel IntraPrediction::xGetPredTimdValDc( const CPelBuf &pSrc, const Size &dstSize, TemplateType eTempType, int iTempHeight, int iTempWidth )
{
  int idx, sum = 0;
  Pel dcVal;
  const int width  = dstSize.width;
  const int height = dstSize.height;
  auto denom     = (width == height) ? (width << 1) : std::max(width,height);
  auto divShift  = floorLog2(denom);
  auto divOffset = (denom >> 1);

  if (eTempType == LEFT_NEIGHBOR)
  {
    denom = height;
    divShift = floorLog2(denom);
    divOffset = (denom >> 1);
    for(idx = 0; idx < height; idx++)
      sum += pSrc.at(1 + idx, 1);
    dcVal = (sum + divOffset) >> divShift;
    return dcVal;
  }
  else if (eTempType == ABOVE_NEIGHBOR)
  {
    denom = width;
    divShift = floorLog2(denom);
    divOffset = (denom >> 1);
    for(idx = 0; idx < width; idx++)
      sum += pSrc.at( 1 + idx, 0);
    dcVal = (sum + divOffset) >> divShift;
    return dcVal;
  }

  if ( width >= height )
  {
    for( idx = 0; idx < width; idx++ )
    {
      sum += pSrc.at(iTempWidth + 1 + idx, 0);
    }
  }
  if ( width <= height )
  {
    for( idx = 0; idx < height; idx++ )
    {
      sum += pSrc.at(iTempHeight + 1 + idx, 1);
    }
  }
  dcVal = (sum + divOffset) >> divShift;
  return dcVal;
}

#if (JVET_AG0146_DIMD_ITMP_IBC || JVET_AG0152_SGPM_ITMP_IBC || JVET_AG0151_INTRA_TMP_MERGE_MODE)
void IntraPrediction::predUsingBv(Pel* piPred, unsigned int uiStride, Mv Bv, CodingUnit cu
#if JVET_AH0200_INTRA_TMP_BV_REORDER
  , bool isIntBv
#endif
)
{
#if JVET_AH0200_INTRA_TMP_BV_REORDER
  bool isFracMv = !isIntBv && Bv.isFracMv();
  if(isFracMv)
  {
    PelUnitBuf tempPUBuf(cu.firstPU->chromaFormat, PelBuf(piPred, uiStride, cu.lwidth(), cu.lheight()));
    m_pcInterPred->getPredIBCBlk(*cu.firstPU, COMPONENT_Y, cu.cs->picture, Bv, tempPUBuf, false, true);
    return;
  }
  if(!isIntBv)
  {
    Bv.set(Bv.hor >> MV_FRACTIONAL_BITS_INTERNAL, Bv.ver >> MV_FRACTIONAL_BITS_INTERNAL);
  }
#else
  CHECK(!PU::validItmpBv(*cu.firstPU, Bv.hor, Bv.ver), "wrong bv");
#endif
  const int uiHeight = cu.lheight();
  const int uiWidth = cu.lwidth();
  const Pel* ref = cu.cs->picture->getRecoBuf(cu.Y()).buf;
  const int  picStride = cu.cs->picture->getRecoBuf(cu.Y()).stride;

  const int iOffsetY = Bv.ver;
  const int iOffsetX = Bv.hor;
  const Pel* refTarget = ref + iOffsetY * picStride + iOffsetX;   // refTarget
  for (unsigned int uiY = 0; uiY < uiHeight; uiY++)
  {
    memcpy(piPred, refTarget, uiWidth * sizeof(Pel));
    refTarget += picStride;
    piPred += uiStride;
  }
}

void IntraPrediction::predTimdIbcItmp(const ComponentID compId, const PredictionUnit& pu, Mv Bv, Pel* pPred, uint32_t uiStride, uint32_t iWidth, uint32_t iHeight, TemplateType eTempType, int32_t iTemplateWidth, int32_t iTemplateHeight, Pel* piOrg, int picStride)
{

#if JVET_AH0200_INTRA_TMP_BV_REORDER
  piOrg += Bv.hor + Bv.ver * picStride;
#endif
  for (int y = 0; y < iHeight; y++, pPred += uiStride, piOrg += picStride)
  {
    Pel* org = piOrg;
    Pel* prd = pPred;
    for (int x = 0; x < iWidth; x++)
    {
      if (x >= iTemplateWidth && y >= iTemplateHeight)
      {
        org++;
        prd++;
#if JVET_AH0200_INTRA_TMP_BV_REORDER        
        break;
#endif
        continue;
      }
      // speed up
      if (x < iTemplateWidth && y < iTemplateHeight)
      {
        org++;
        prd++;
        continue; // keeping only up and left
      }

#if JVET_AH0200_INTRA_TMP_BV_REORDER
      *prd = *org;
#else
      int bvx = Bv.hor;
      int bvy = Bv.ver;
      *prd = org[bvx + bvy * picStride];
#endif
      org++;
      prd++;
    }
  }

}
#endif
void IntraPrediction::predTimdIntraAng( const ComponentID compId, const PredictionUnit &pu, uint32_t uiDirMode, Pel* pPred, uint32_t uiStride, uint32_t iWidth, uint32_t iHeight, TemplateType eTempType, int32_t iTemplateWidth, int32_t iTemplateHeight)
{
  const ComponentID compID       = MAP_CHROMA( compId );

  const int srcStride  = m_refBufferStride[compID];
  const int srcHStride = 2;

  const CPelBuf & srcBuf = CPelBuf(getPredictorPtr(compID), srcStride, srcHStride);
  const ClpRng& clpRng(pu.cu->cs->slice->clpRng(compID));

  switch (uiDirMode)
  {
    case(PLANAR_IDX): xPredTimdIntraPlanar(srcBuf, pPred, uiStride, iWidth, iHeight, eTempType, iTemplateWidth, iTemplateHeight); break;
    case(DC_IDX):     xPredTimdIntraDc(pu, srcBuf, pPred, uiStride, iWidth, iHeight, eTempType, iTemplateWidth, iTemplateHeight); break;
#if JVET_AC0119_LM_CHROMA_FUSION
    default:          xPredTimdIntraAng(srcBuf, clpRng, pPred, uiStride, iWidth, iHeight, eTempType, iTemplateWidth, iTemplateHeight, uiDirMode, toChannelType(compID)); break;
#else
    default:          xPredTimdIntraAng(srcBuf, clpRng, pPred, uiStride, iWidth, iHeight, eTempType, iTemplateWidth, iTemplateHeight, uiDirMode); break;
#endif
  }

  if (m_ipaParam.applyPDPC && (uiDirMode == PLANAR_IDX || uiDirMode == DC_IDX))
  {
    xIntraPredTimdPlanarDcPdpc(srcBuf, pPred, uiStride, iWidth, iHeight, eTempType, iTemplateWidth, iTemplateHeight);
  }
}

void IntraPrediction::xPredTimdIntraPlanar( const CPelBuf &pSrc, Pel* rpDst, int iDstStride, int width, int height, TemplateType eTempType, int iTemplateWidth, int iTemplateHeight )
{
#if JVET_AJ0146_TIMDSAD
  static int leftColumn[MAX_CU_SIZE+TIMDDIFF_MAX_TEMP_SIZE+1] = {0}, topRow[MAX_CU_SIZE+TIMDDIFF_MAX_TEMP_SIZE+1] ={0}, bottomRow[MAX_CU_SIZE+TIMDDIFF_MAX_TEMP_SIZE] = {0}, rightColumn[MAX_CU_SIZE+TIMDDIFF_MAX_TEMP_SIZE]={0};
#else
  static int leftColumn[MAX_CU_SIZE+DIMD_MAX_TEMP_SIZE+1] = {0}, topRow[MAX_CU_SIZE+DIMD_MAX_TEMP_SIZE+1] ={0}, bottomRow[MAX_CU_SIZE+DIMD_MAX_TEMP_SIZE] = {0}, rightColumn[MAX_CU_SIZE+DIMD_MAX_TEMP_SIZE]={0};
#endif
  if(eTempType == LEFT_ABOVE_NEIGHBOR)
  {
    //predict above template
    {
      uint32_t w = width - iTemplateWidth;
      const uint32_t log2W = floorLog2( w );
      const uint32_t log2H = floorLog2( iTemplateHeight );
      const uint32_t offset = 1 << (log2W + log2H);
      for(int k = 0; k < w + 1; k++)
      {
        topRow[k] = pSrc.at( k + iTemplateWidth + 1, 0 );
      }
      for (int k=0; k < iTemplateHeight + 1; k++)
      {
        leftColumn[k] = pSrc.at( k + 1, 1 );
      }

      int bottomLeft = leftColumn[iTemplateHeight];
      int topRight = topRow[w];
      for(int k = 0; k < w; k++)
      {
        bottomRow[k]  = bottomLeft - topRow[k];
        topRow[k]     = topRow[k] << log2H;
      }
      for(int k = 0; k < iTemplateHeight; k++)
      {
        rightColumn[k]  = topRight - leftColumn[k];
        leftColumn[k]   = leftColumn[k] << log2W;
      }

      const uint32_t finalShift = 1 + log2W + log2H;
      for (int y = 0; y < iTemplateHeight; y++)
      {
        int horPred = leftColumn[y];
        for (int x = 0; x < w; x++)
        {
          horPred   += rightColumn[y];
          topRow[x] += bottomRow[x];
          int vertPred = topRow[x];
          rpDst[y*iDstStride+x + iTemplateWidth] = ( ( horPred << log2H ) + ( vertPred << log2W ) + offset ) >> finalShift;
        }
      }
    }

    //predict left template
    {
      uint32_t h = height - iTemplateHeight;
      const uint32_t log2W = floorLog2( iTemplateWidth );
      const uint32_t log2H = floorLog2( h );
      const uint32_t offset = 1 << (log2W + log2H);
      for (int k = 0; k < h + 1; k++)
      {
        leftColumn[k] = pSrc.at( k + iTemplateHeight + 1, 1 );
      }
      for(int k = 0; k < iTemplateWidth + 1; k++)
      {
        topRow[k] = pSrc.at( k + 1, 0 );
      }
      int bottomLeft = leftColumn[h];
      int topRight = topRow[iTemplateWidth];
      for(int k = 0; k < iTemplateWidth; k++)
      {
        bottomRow[k]  = bottomLeft - topRow[k];
        topRow[k]     = topRow[k] << log2H;
      }
      for(int k = 0; k < h; k++)
      {
        rightColumn[k]  = topRight - leftColumn[k];
        leftColumn[k]   = leftColumn[k] << log2W;
      }
      const uint32_t finalShift = 1 + log2W + log2H;
      for (int y = 0; y < height; y++)
      {
        int horPred = leftColumn[y];
        for (int x = 0; x < iTemplateWidth; x++)
        {
          horPred   += rightColumn[y];
          topRow[x] += bottomRow[x];
          int vertPred = topRow[x];
          rpDst[(y + iTemplateHeight)*iDstStride+x] = ( ( horPred << log2H ) + ( vertPred << log2W ) + offset ) >> finalShift;
        }
      }
    }
  }
  else if(eTempType == LEFT_NEIGHBOR)
  {
    const uint32_t log2W = floorLog2( iTemplateWidth );
    const uint32_t log2H = floorLog2( height );
    const uint32_t offset = 1 << (log2W + log2H);
    for (int k = 0; k < height + 1; k++)
    {
      leftColumn[k] = pSrc.at( k + iTemplateHeight + 1, 1 );
    }
    for(int k = 0; k < iTemplateWidth + 1; k++)
    {
      topRow[k] = pSrc.at( k + 1, 0 );
    }

    int bottomLeft = leftColumn[height];
    int topRight = topRow[iTemplateWidth];
    for(int k = 0; k < iTemplateWidth; k++)
    {
      bottomRow[k]  = bottomLeft - topRow[k];
      topRow[k]     = topRow[k] << log2H;
    }
    for(int k = 0; k < height; k++)
    {
      rightColumn[k]  = topRight - leftColumn[k];
      leftColumn[k]   = leftColumn[k] << log2W;
    }

    const uint32_t finalShift = 1 + log2W + log2H;
    for (int y = 0; y < height; y++)
    {
      int horPred = leftColumn[y];
      for (int x = 0; x < iTemplateWidth; x++)
      {
        horPred   += rightColumn[y];
        topRow[x] += bottomRow[x];
        int vertPred = topRow[x];
        rpDst[y*iDstStride+x] = ( ( horPred << log2H ) + ( vertPred << log2W ) + offset ) >> finalShift;
      }
    }
  }
  else if(eTempType == ABOVE_NEIGHBOR)
  {
    const uint32_t log2W = floorLog2( width );
    const uint32_t log2H = floorLog2( iTemplateHeight );
    const uint32_t offset = 1 << (log2W + log2H);
    for(int k = 0; k < width + 1; k++)
    {
      topRow[k] = pSrc.at( k + iTemplateWidth + 1, 0 );
    }
    for (int k=0; k < iTemplateHeight + 1; k++)
    {
      leftColumn[k] = pSrc.at( k + 1, 1 );
    }

    int bottomLeft = leftColumn[iTemplateHeight];
    int topRight = topRow[width];
    for(int k=0;k<width;k++)
    {
      bottomRow[k]  = bottomLeft - topRow[k];
      topRow[k]     = topRow[k] << log2H;
    }
    for(int k = 0; k < iTemplateHeight; k++)
    {
      rightColumn[k]  = topRight - leftColumn[k];
      leftColumn[k]   = leftColumn[k] << log2W;
    }

    const uint32_t finalShift = 1 + log2W + log2H;
    for (int y = 0; y < iTemplateHeight; y++)
    {
      int horPred = leftColumn[y];
      for (int x = 0; x < width; x++)
      {
        horPred   += rightColumn[y];
        topRow[x] += bottomRow[x];
        int vertPred = topRow[x];
        rpDst[y*iDstStride+x] = ( ( horPred << log2H ) + ( vertPred << log2W ) + offset ) >> finalShift;
      }
    }
  }
  else
  {
    CHECK(true, "wrong case");
  }
}

void IntraPrediction::xPredTimdIntraDc( const PredictionUnit &pu, const CPelBuf &pSrc, Pel* pDst, int iDstStride, int iWidth, int iHeight, TemplateType eTempType, int iTemplateWidth, int iTemplateHeight )
{
#if JVET_AC0119_LM_CHROMA_FUSION
  const Size& dstSize = Size(iWidth - iTemplateWidth, iHeight - iTemplateHeight);
#else
  const Size &dstSize = Size(pu.lwidth(), pu.lheight());
#endif
  const Pel dcval = xGetPredTimdValDc( pSrc, dstSize, eTempType, iTemplateHeight, iTemplateWidth );
  if(eTempType == LEFT_ABOVE_NEIGHBOR)
  {
    for (int y = 0; y < iHeight; y++,pDst += iDstStride)
    {
      if(y < iTemplateHeight)
      {
        for (int x = iTemplateWidth; x < iWidth; x++)
        {
          pDst[x] = dcval;
        }
      }
      else
      {
        for (int x = 0; x < iTemplateWidth; x++)
        {
          pDst[x] = dcval;
        }
      }
    }
  }
  else if(eTempType == LEFT_NEIGHBOR)
  {
    for (int y = 0; y < iHeight; y++, pDst += iDstStride)
    {
      for (int x = 0; x < iTemplateWidth; x++)
      {
        pDst[x] = dcval;
      }
    }
  }
  else if(eTempType == ABOVE_NEIGHBOR)
  {
    for (int y = 0; y < iTemplateHeight; y++, pDst+=iDstStride)
    {
      for (int x = 0; x < iWidth; x++)
      {
        pDst[x] = dcval;
      }
    }
  }
  else
  {
    CHECK( true, "wrong case" );
  }
}

#if JVET_AB0155_SGPM
void IntraPrediction::initPredTimdIntraParams(const PredictionUnit &pu, const CompArea area, int dirMode, bool bSgpm
#if JVET_AC0094_REF_SAMPLES_OPT
                                              , bool checkWideAngle
#endif
)
#else
void IntraPrediction::initPredTimdIntraParams(const PredictionUnit & pu, const CompArea area, int dirMode)
#endif
{
  const Size   puSize    = Size( area.width, area.height );
  const Size&  blockSize = puSize;
#if JVET_AB0155_SGPM
#if JVET_AC0094_REF_SAMPLES_OPT
  const int predMode = checkWideAngle ? getWideAngleExt(blockSize.width, blockSize.height, dirMode, bSgpm)
                                      : getTimdWideAngleExt(blockSize.width, blockSize.height, dirMode);
#else
  const int predMode = getWideAngleExt(blockSize.width, blockSize.height, dirMode, bSgpm);
#endif
#else
  const int     predMode = getWideAngleExt( blockSize.width, blockSize.height, dirMode );
#endif
  m_ipaParam.isModeVer            = predMode >= EXT_DIA_IDX;
  m_ipaParam.refFilterFlag        = false;
  m_ipaParam.interpolationFlag    = false;
  m_ipaParam.applyPDPC            = puSize.width >= MIN_TB_SIZEY && puSize.height >= MIN_TB_SIZEY;
  const int    intraPredAngleMode = (m_ipaParam.isModeVer) ? predMode - EXT_VER_IDX : -(predMode - EXT_HOR_IDX);

  int absAng = 0;
  static const int extAngTable[64]    = { 0, 1, 2, 3, 4, 5, 6,7, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 43, 46, 49, 52, 55, 58, 61, 64, 67, 70, 74, 78, 84, 90, 96, 102, 108, 114, 121, 128, 137, 146, 159, 172, 188, 204, 230, 256, 299, 342, 427, 512, 597, 682, 853, 1024, 1536, 2048, 3072 };
  static const int extInvAngTable[64] = { 0, 32768, 16384, 10923, 8192, 6554, 5461, 4681, 4096, 3277, 2731, 2341, 2048, 1820, 1638, 1489, 1365, 1260, 1170, 1092, 1024, 964, 910, 862, 819, 762, 712, 669, 630, 596, 565, 537, 512, 489, 468, 443, 420, 390, 364, 341, 321, 303, 287, 271, 256, 239, 224, 206, 191, 174, 161, 142, 128, 110, 96, 77, 64, 55, 48, 38, 32, 21, 16, 11 }; // (512 * 64) / Angle

  const int     absAngMode         = abs(intraPredAngleMode);
  const int     signAng            = intraPredAngleMode < 0 ? -1 : 1;
                absAng             = extAngTable  [absAngMode];

  m_ipaParam.absInvAngle              = extInvAngTable[absAngMode];
  m_ipaParam.intraPredAngle        = signAng * absAng;

  if (dirMode > 1)
  {
    if (intraPredAngleMode < 0)
    {
      m_ipaParam.applyPDPC = false;
    }
    else if (intraPredAngleMode > 0)
    {
      const int sideSize = m_ipaParam.isModeVer ? puSize.height : puSize.width;
      const int maxScale = 2;
#if GRAD_PDPC
      m_ipaParam.useGradPDPC = false;
#endif
      m_ipaParam.angularScale = std::min(maxScale, floorLog2(sideSize) - (floorLog2(3 * m_ipaParam.absInvAngle - 2) - 8));
#if GRAD_PDPC
      if (m_ipaParam.angularScale < 0)
      {
        m_ipaParam.angularScale = (floorLog2(puSize.width) + floorLog2(puSize.height) - 2) >> 2;
        m_ipaParam.useGradPDPC = true;
      }
#endif
      m_ipaParam.applyPDPC &= m_ipaParam.angularScale >= 0;
    }
  }
#if JVET_AJ0057_HL_INTRA_METHOD_CONTROL
  if (pu.cu->cs->sps->getDisablePdpc())
  {
    m_ipaParam.applyPDPC = false;
    m_ipaParam.useGradPDPC = false;
  }
  if (pu.cu->cs->sps->getDisableRefFilter())
  {
    m_ipaParam.refFilterFlag = false;
  }
#endif
}

void IntraPrediction::xPredTimdIntraAng( const CPelBuf &pSrc, const ClpRng& clpRng, Pel* pTrueDst, int iDstStride, int iWidth, int iHeight, TemplateType eTempType, int iTemplateWidth , int iTemplateHeight, uint32_t dirMode
#if JVET_AC0119_LM_CHROMA_FUSION
  , const ChannelType channelType
#endif
)
{
  int width = iWidth;
  int height = iHeight;
  const bool bIsModeVer     = m_ipaParam.isModeVer;
  const int  intraPredAngle = m_ipaParam.intraPredAngle;
  const int  invAngle       = m_ipaParam.absInvAngle;
  Pel* refMain;
  Pel* refSide;
#if JVET_AC0094_REF_SAMPLES_OPT
  Pel * refAbove = m_tempRefAbove;
  Pel * refLeft  = m_tempRefLeft;
#else
  static Pel  refAbove[2 * MAX_CU_SIZE + 5 + 33 * MAX_REF_LINE_IDX];
  static Pel  refLeft[2 * MAX_CU_SIZE + 5 + 33 * MAX_REF_LINE_IDX];
#endif

  // Initialize the Main and Left reference array.
  if (intraPredAngle < 0)
  {
    for (int x = 0; x <= width + 1; x++)
    {
      refAbove[x + height] = pSrc.at(x, 0);
    }
    for (int y = 0; y <= height + 1; y++)
    {
      refLeft[y + width] = pSrc.at(y, 1);
    }
    refMain = bIsModeVer ? refAbove + height : refLeft + width;
    refSide = bIsModeVer ? refLeft + width : refAbove + height;
    // Extend the Main reference to the left.
    int sizeSide = bIsModeVer ? height : width;
    for (int k = -sizeSide; k <= -1; k++)
    {
      refMain[k] = refSide[std::min((-k * invAngle + 256) >> 9, sizeSide)];
    }
  }
  else
  {
    for (int x = 0; x <= m_topRefLength; x++)
    {
      refAbove[x] = pSrc.at(x, 0);
    }
    for (int y = 0; y <= m_leftRefLength; y++)
    {
      refLeft[y] = pSrc.at(y, 1);
    }
    refMain = bIsModeVer ? refAbove : refLeft;
    refSide = bIsModeVer ? refLeft : refAbove;
    // Extend main reference to right using replication
    const int log2Ratio = floorLog2(width - iTemplateWidth) - floorLog2(height - iTemplateHeight);
    const int s         = std::max<int>(0, bIsModeVer ? log2Ratio : -log2Ratio);
    const int maxIndex  = (std::max(iTemplateWidth, iTemplateHeight) << s) + 2 + std::max(iTemplateWidth, iTemplateHeight);
    const int refLength = bIsModeVer ? m_topRefLength : m_leftRefLength;
    const Pel val       = refMain[refLength];
    for (int z = 1; z <= maxIndex; z++)
    {
      refMain[refLength + z] = val;
    }
  }

  // swap width/height if we are doing a horizontal mode:
#if JVET_AJ0146_TIMDSAD
  static Pel tempArray[(MAX_CU_SIZE+TIMDDIFF_MAX_TEMP_SIZE)*(MAX_CU_SIZE+TIMDDIFF_MAX_TEMP_SIZE)];  ///< buffer size may not be big enough
  const int dstStride = bIsModeVer ? iDstStride : (MAX_CU_SIZE+TIMDDIFF_MAX_TEMP_SIZE);
#else
  static Pel tempArray[(MAX_CU_SIZE+DIMD_MAX_TEMP_SIZE)*(MAX_CU_SIZE+DIMD_MAX_TEMP_SIZE)];  ///< buffer size may not be big enough
  const int dstStride = bIsModeVer ? iDstStride : (MAX_CU_SIZE+DIMD_MAX_TEMP_SIZE);
#endif
  Pel *pDst = bIsModeVer ? pTrueDst : tempArray;
  if (!bIsModeVer)
  {
    std::swap(width, height);
    std::swap(iTemplateWidth, iTemplateHeight);
  }

  if( intraPredAngle == 0 )  // pure vertical or pure horizontal
  {
    if(eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      if (m_ipaParam.applyPDPC)
      {
        int scale = (floorLog2(width) + floorLog2(height) - 2) >> 2;
        xIntraPredTimdHorVerPdpc(pDst, dstStride, refSide, width, iTemplateHeight, iTemplateWidth, 0, scale, refMain, clpRng);
        xIntraPredTimdHorVerPdpc(pDst+iTemplateHeight*dstStride, dstStride, refSide, iTemplateWidth, height, 0, iTemplateHeight, scale, refMain, clpRng);
      }
      else
      {
        for (int y = 0; y < iTemplateHeight; y++)
        {
          memcpy(pDst + y * dstStride + iTemplateWidth, &refMain[iTemplateWidth + 1], (width - iTemplateWidth) * sizeof(Pel));
        }
        for (int y = iTemplateHeight; y < height; y++)
        {
          memcpy(pDst + y * dstStride, &refMain[1], iTemplateWidth * sizeof(Pel));
        }
      }
    }
    else if(eTempType == LEFT_NEIGHBOR || eTempType == ABOVE_NEIGHBOR)
    {
      if((eTempType == LEFT_NEIGHBOR && bIsModeVer)||(eTempType == ABOVE_NEIGHBOR && !bIsModeVer))
      {
        if (m_ipaParam.applyPDPC)
        {
          const int scale   = (floorLog2(width) + floorLog2(height) - 2) >> 2;
          xIntraPredTimdHorVerPdpc(pDst, dstStride, refSide, iTemplateWidth, height, 0, 0, scale, refMain, clpRng);
        }
        else
        {
          for (int y = 0; y < height; y++)
          {
            for (int x = 0; x < iTemplateWidth; x++)
            {
              pDst[y * dstStride+x] = refMain[x + 1];
            }
          }
        }
      }
      else
      {
        if (m_ipaParam.applyPDPC)
        {
          const int scale   = (floorLog2(width) + floorLog2(height) - 2) >> 2;
          xIntraPredTimdHorVerPdpc(pDst, dstStride, refSide, width, iTemplateHeight, 0, 0, scale, refMain, clpRng);
        }
        else
        {
          for (int y = 0; y < iTemplateHeight; y++)
          {
            memcpy(pDst + y * dstStride, &refMain[1], width * sizeof(Pel));
          }
        }
      }
    }
    else
    {
      CHECK( true, "wrong case" );
    }
  }
  else
  {
    Pel *pDsty=pDst;
#if JVET_AC0119_LM_CHROMA_FUSION
    bool bExtIntraDir = isLuma(channelType);
    bool bIntSlope = isLuma(channelType) ? isIntegerSlopeExt(abs(intraPredAngle)) : isIntegerSlope(abs(intraPredAngle));
    if (!bIntSlope)
#else
    if (!isIntegerSlopeExt(abs(intraPredAngle)))
#endif
    {
      int deltaPos = intraPredAngle;
      if (eTempType == LEFT_ABOVE_NEIGHBOR)
      {
        Pel *pDsty=pDst;
        // Above template
#if JVET_AC0119_LM_CHROMA_FUSION
        if (isLuma(channelType))
        {
#endif
        xIntraPredTimdAngLuma(pDsty, dstStride, refMain, width, iTemplateHeight, deltaPos, intraPredAngle, clpRng, iTemplateWidth, 0);
        // Left template
        for (int y = 0; y < iTemplateHeight; y++)
        {
          deltaPos += intraPredAngle;
        }
        xIntraPredTimdAngLuma(pDsty, dstStride, refMain, iTemplateWidth, height, deltaPos, intraPredAngle, clpRng, 0, iTemplateHeight);
#if JVET_AC0119_LM_CHROMA_FUSION
        }
        else
        {
          xIntraPredTimdAngChroma(pDsty, dstStride, refMain, width, iTemplateHeight, deltaPos, intraPredAngle, clpRng, iTemplateWidth, 0);
          // Left template
          for (int y = 0; y < iTemplateHeight; y++)
          {
            deltaPos += intraPredAngle;
          }
          xIntraPredTimdAngChroma(pDsty, dstStride, refMain, iTemplateWidth, height, deltaPos, intraPredAngle, clpRng, 0, iTemplateHeight);
        }
#endif
#if GRAD_PDPC
        if (m_ipaParam.applyPDPC && m_ipaParam.useGradPDPC)
        {
          int deltaPos2 = intraPredAngle;
          const int scale = m_ipaParam.angularScale;
          xIntraPredTimdAngGradPdpc(pDst, dstStride, refMain, refSide, width, iTemplateHeight, iTemplateWidth, 0, scale, deltaPos2, intraPredAngle, clpRng
#if JVET_AC0119_LM_CHROMA_FUSION
            , bExtIntraDir
#endif
          );
          for (int y = 0; y < iTemplateHeight; y++)
            deltaPos2 += intraPredAngle;
          xIntraPredTimdAngGradPdpc(pDst+iTemplateHeight*dstStride, dstStride, refMain, refSide, iTemplateWidth, height, 0, iTemplateHeight, scale, deltaPos2, intraPredAngle, clpRng
#if JVET_AC0119_LM_CHROMA_FUSION
            , bExtIntraDir
#endif
          );
        }
        else
#endif
        if (m_ipaParam.applyPDPC)
        {
          const int scale = m_ipaParam.angularScale;
          xIntraPredTimdAngPdpc(pDst, dstStride, refSide, width, iTemplateHeight, iTemplateWidth, 0, scale, invAngle);
          xIntraPredTimdAngPdpc(pDst+iTemplateHeight*dstStride, dstStride, refSide, iTemplateWidth, height, 0, iTemplateHeight, scale, invAngle);
        }
      }
      else if (eTempType == LEFT_NEIGHBOR || eTempType == ABOVE_NEIGHBOR)
      {
        int iRegionWidth, iRegionHeight;
        if((eTempType == LEFT_NEIGHBOR && bIsModeVer)||(eTempType == ABOVE_NEIGHBOR && !bIsModeVer))
        {
          iRegionWidth  = iTemplateWidth;
          iRegionHeight = height;
        }
        else
        {
          iRegionWidth  = width;
          iRegionHeight = iTemplateHeight;
        }
#if JVET_AC0119_LM_CHROMA_FUSION
        if (isLuma(channelType))
        {
#endif
        xIntraPredTimdAngLuma(pDsty, dstStride, refMain, iRegionWidth, iRegionHeight, deltaPos, intraPredAngle, clpRng, 0, 0);
#if JVET_AC0119_LM_CHROMA_FUSION
        }
        else
        {
          xIntraPredTimdAngChroma(pDsty, dstStride, refMain, iRegionWidth, iRegionHeight, deltaPos, intraPredAngle, clpRng, 0, 0);
        }
#endif
#if GRAD_PDPC
        if (m_ipaParam.applyPDPC && m_ipaParam.useGradPDPC)
        {
          int deltaPos2 = intraPredAngle;
          const int scale = m_ipaParam.angularScale;
          xIntraPredTimdAngGradPdpc(pDst, dstStride, refMain, refSide, iRegionWidth, iRegionHeight, 0, 0, scale, deltaPos2, intraPredAngle, clpRng
#if JVET_AC0119_LM_CHROMA_FUSION
            , bExtIntraDir
#endif
          );
        }
        else
#endif
        if (m_ipaParam.applyPDPC)
        {
          const int scale = m_ipaParam.angularScale;
          xIntraPredTimdAngPdpc(pDst, dstStride, refSide, iRegionWidth, iRegionHeight, 0, 0, scale, invAngle);
        }
      }
    }
    else
    {
      if(eTempType == LEFT_ABOVE_NEIGHBOR)
      {
        Pel *pDsty=pDst;
        for (int y = 0, deltaPos = intraPredAngle; y<height; y++, deltaPos += intraPredAngle, pDsty += dstStride)
        {
#if JVET_AC0119_LM_CHROMA_FUSION
          const int deltaInt = isLuma(channelType) ? deltaPos >> 6 : deltaPos >> 5;
#else
          const int deltaInt = deltaPos >> 6;
#endif
          int iStartIdx, iEndIdx;
          if(y < iTemplateHeight)
          {
            iStartIdx = iTemplateWidth;
            iEndIdx   = width - 1;
          }
          else
          {
            iStartIdx = 0;
            iEndIdx   = iTemplateWidth - 1;
          }
          memcpy(pDsty + iStartIdx, &refMain[iStartIdx + deltaInt + 1], (iEndIdx - iStartIdx + 1) * sizeof(Pel));
        }
#if GRAD_PDPC
        if (m_ipaParam.applyPDPC && m_ipaParam.useGradPDPC)
        {
          int deltaPos2 = intraPredAngle;
          const int scale = m_ipaParam.angularScale;
          xIntraPredTimdAngGradPdpc(pDst, dstStride, refMain, refSide, width, iTemplateHeight, iTemplateWidth, 0, scale, deltaPos2, intraPredAngle, clpRng
#if JVET_AC0119_LM_CHROMA_FUSION
            , bExtIntraDir
#endif
          );
          for (int y = 0; y < iTemplateHeight; y++)
            deltaPos2 += intraPredAngle;
          xIntraPredTimdAngGradPdpc(pDst+iTemplateHeight*dstStride, dstStride, refMain, refSide, iTemplateWidth, height, 0, iTemplateHeight, scale, deltaPos2, intraPredAngle, clpRng
#if JVET_AC0119_LM_CHROMA_FUSION
            , bExtIntraDir
#endif
          );
        }
        else
#endif
        if (m_ipaParam.applyPDPC)
        {
          const int scale = m_ipaParam.angularScale;
          xIntraPredTimdAngPdpc(pDst, dstStride, refSide, width, iTemplateHeight, iTemplateWidth, 0, scale, invAngle);
          xIntraPredTimdAngPdpc(pDst+iTemplateHeight*dstStride, dstStride, refSide, iTemplateWidth, height, 0, iTemplateHeight, scale, invAngle);
        }
      }
      else // if (eTempType == LEFT_NEIGHBOR || eTempType == ABOVE_NEIGHBOR)
      {
        Pel *pDsty=pDst;
        CHECK(eTempType != LEFT_NEIGHBOR && eTempType != ABOVE_NEIGHBOR, "Wrong template type");
        int iRegionWidth, iRegionHeight;
        if((eTempType == LEFT_NEIGHBOR && bIsModeVer)||(eTempType == ABOVE_NEIGHBOR && !bIsModeVer))
        {
          iRegionWidth  = iTemplateWidth;
          iRegionHeight = height;
        }
        else
        {
          iRegionWidth  = width;
          iRegionHeight = iTemplateHeight;
        }
        for (int y = 0, deltaPos = intraPredAngle; y<iRegionHeight; y++, deltaPos += intraPredAngle, pDsty += dstStride)
        {
#if JVET_AC0119_LM_CHROMA_FUSION
          const int deltaInt = isLuma(channelType) ? deltaPos >> 6 : deltaPos >> 5;
#else
          const int deltaInt = deltaPos >> 6;
#endif
          memcpy(pDsty, &refMain[deltaInt + 1], iRegionWidth * sizeof(Pel));
        }
#if GRAD_PDPC
        if (m_ipaParam.applyPDPC && m_ipaParam.useGradPDPC)
        {
          int deltaPos2 = intraPredAngle;
          const int scale = m_ipaParam.angularScale;
          xIntraPredTimdAngGradPdpc(pDst, dstStride, refMain, refSide, iRegionWidth, iRegionHeight, 0, 0, scale, deltaPos2, intraPredAngle, clpRng
#if JVET_AC0119_LM_CHROMA_FUSION
            , bExtIntraDir
#endif
          );
        }
        else
#endif
        if (m_ipaParam.applyPDPC)
        {
          const int scale   = m_ipaParam.angularScale;
          xIntraPredTimdAngPdpc(pDst, dstStride, refSide, iRegionWidth, iRegionHeight, 0, 0, scale, invAngle);
        }
      }
    }
  }

  // Flip the block if this is the horizontal mode
  if (!bIsModeVer)
  {
    if(eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      for (int y = 0; y < height; y++)
      {
        int iStartIdx, iEndIdx;
        if(y < iTemplateHeight)
        {
          iStartIdx = iTemplateWidth;
          iEndIdx   = width - 1;
        }
        else
        {
          iStartIdx = 0;
          iEndIdx   = iTemplateWidth - 1;
        }
        for (int x = iStartIdx; x <= iEndIdx; x++)
        {
          pTrueDst[x*iDstStride+y] = pDst[y*dstStride+x];
        }
      }
    }
    else if(eTempType == LEFT_NEIGHBOR)
    {
      for (int y = 0; y < iTemplateHeight; y++)
      {
        for (int x = 0; x < width; x++)
        {
          pTrueDst[x*iDstStride+y] = pDst[y*dstStride+x];
        }
      }
    }
    else if(eTempType == ABOVE_NEIGHBOR)
    {
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < iTemplateWidth; x++)
        {
          pTrueDst[x*iDstStride+y] = pDst[y*dstStride+x];
        }
      }
    }
    else
    {
      CHECK( true, "wrong case" );
    }
  }
}

void IntraPrediction::initTimdIntraPatternLuma(const CodingUnit &cu, const CompArea &area, int iTemplateWidth, int iTemplateHeight, uint32_t uiRefWidth, uint32_t uiRefHeight)
{
  const CodingStructure& cs   = *cu.cs;
  Pel *refBufUnfiltered = m_refBuffer[area.compID][PRED_BUF_UNFILTERED];
#if JVET_AC0094_REF_SAMPLES_OPT
  bool bLeftAbove = iTemplateHeight > 0 && iTemplateWidth > 0;
  m_leftRefLength = bLeftAbove ? (uiRefHeight << 3) : ((uiRefHeight + iTemplateHeight) << 3);
  m_topRefLength  = bLeftAbove ? (uiRefWidth << 3) : ((uiRefWidth + iTemplateWidth) << 3);
#else
  bool bLeftAbove = iTemplateHeight > 0 && iTemplateWidth > 0;
  m_leftRefLength     = bLeftAbove ? (uiRefHeight << 1) : ((uiRefHeight + iTemplateHeight) << 1);
  m_topRefLength      = bLeftAbove ? (uiRefWidth << 1) : ((uiRefWidth + iTemplateWidth) << 1);
#endif
  xFillTimdReferenceSamples(cs.picture->getRecoBuf(area), refBufUnfiltered, area, cu, iTemplateWidth, iTemplateHeight);
}

void IntraPrediction::xFillTimdReferenceSamples(const CPelBuf &recoBuf, Pel* refBufUnfiltered, const CompArea &area, const CodingUnit &cu, int iTemplateWidth, int iTemplateHeight)
{
  const ChannelType      chType = toChannelType( area.compID );
  const CodingStructure &cs     = *cu.cs;
  const SPS             &sps    = *cs.sps;
  const PreCalcValues   &pcv    = *cs.pcv;

  const int  tuWidth            = area.width;
  const int  tuHeight           = area.height;
  const int  predSize           = m_topRefLength;
  const int  predHSize          = m_leftRefLength;
  const int predStride = predSize + 1;
  m_refBufferStride[area.compID] = predStride;

  const bool noShift            = pcv.noChroma2x2 && area.width == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth          = tuWidth  <= 2 && cu.ispMode && isLuma(area.compID) ? tuWidth  : pcv.minCUWidth  >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight         = tuHeight <= 2 && cu.ispMode && isLuma(area.compID) ? tuHeight : pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));
  int leftTempUnitNum = 0;
  int aboveTempUnitNum = 0;
  if (iTemplateHeight >= 4)
  {
    leftTempUnitNum = iTemplateHeight / unitHeight;
  }
  if (iTemplateWidth >= 4)
  {
    aboveTempUnitNum = iTemplateWidth / unitWidth;
  }

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth - aboveTempUnitNum;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight - leftTempUnitNum;
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1 + aboveTempUnitNum + leftTempUnitNum; //+1 for top-left
  const int  numAboveUnits      = std::max<int>( tuWidth / unitWidth, 1 );
  const int  numLeftUnits       = std::max<int>( tuHeight / unitHeight, 1 );
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits  = totalLeftUnits - numLeftUnits;

  // ----- Step 1: analyze neighborhood -----
  const Position posLT          = area;
  const Position posRT          = area.topRight();
  const Position posLB          = area.bottomLeft();

#if JVET_AC0094_REF_SAMPLES_OPT
  bool neighborFlags[4 * (MAX_NUM_PART_IDXS_IN_CTU_WIDTH << 2) + 1];
#else
  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
#endif
  int   numIntraNeighbor = 0;

  memset( neighborFlags, 0, totalUnits );

#if JVET_AJ0146_TIMDSAD
  neighborFlags[totalLeftUnits + leftTempUnitNum] = isAboveLeftAvailable( cu, chType, posLT.offset(-iTemplateWidth, -iTemplateHeight) );
  numIntraNeighbor += neighborFlags[totalLeftUnits + leftTempUnitNum] ? 1 : 0;
  numIntraNeighbor += isLeftAvailable      ( cu, chType, posLT.offset(-iTemplateWidth,-leftTempUnitNum*unitHeight), leftTempUnitNum,        unitHeight, (neighborFlags + totalLeftUnits  + leftTempUnitNum - 1) );
  numIntraNeighbor += isAboveAvailable     ( cu, chType, posLT.offset(-aboveTempUnitNum*unitWidth, -iTemplateHeight), aboveTempUnitNum,     unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftTempUnitNum) );
  numIntraNeighbor += isAboveAvailable     ( cu, chType, posLT.offset(0, -iTemplateHeight), numAboveUnits,      unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftTempUnitNum + aboveTempUnitNum) );
  numIntraNeighbor += isAboveRightAvailable( cu, chType, posRT.offset(0, -iTemplateHeight), numAboveRightUnits, unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftTempUnitNum + aboveTempUnitNum + numAboveUnits) );
  numIntraNeighbor += isLeftAvailable      ( cu, chType, posLT.offset(-iTemplateWidth, 0), numLeftUnits,       unitHeight, (neighborFlags + totalLeftUnits - 1) );
  numIntraNeighbor += isBelowLeftAvailable ( cu, chType, posLB.offset(-iTemplateWidth, 0), numLeftBelowUnits,  unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits) );
#else
  neighborFlags[totalLeftUnits] = isAboveLeftAvailable( cu, chType, posLT.offset(-iTemplateWidth, -iTemplateHeight) );
  neighborFlags[totalLeftUnits + leftTempUnitNum] = neighborFlags[totalLeftUnits];
  neighborFlags[totalLeftUnits + leftTempUnitNum + aboveTempUnitNum] = neighborFlags[totalLeftUnits];
  numIntraNeighbor += neighborFlags[totalLeftUnits] ? 1 : 0;
  numIntraNeighbor += leftTempUnitNum > 0 && neighborFlags[totalLeftUnits] ? 1 : 0;
  numIntraNeighbor += aboveTempUnitNum > 0 && neighborFlags[totalLeftUnits] ? 1 : 0;
  numIntraNeighbor += isAboveAvailable     ( cu, chType, posLT.offset(0, -iTemplateHeight), numAboveUnits,      unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftTempUnitNum + aboveTempUnitNum) );
  numIntraNeighbor += isAboveRightAvailable( cu, chType, posRT.offset(0, -iTemplateHeight), numAboveRightUnits, unitWidth,  (neighborFlags + totalLeftUnits + 1 + leftTempUnitNum + aboveTempUnitNum + numAboveUnits) );
  numIntraNeighbor += isLeftAvailable      ( cu, chType, posLT.offset(-iTemplateWidth, 0), numLeftUnits,       unitHeight, (neighborFlags + totalLeftUnits - 1) );
  numIntraNeighbor += isBelowLeftAvailable ( cu, chType, posLB.offset(-iTemplateWidth, 0), numLeftBelowUnits,  unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits) );
#endif

  // ----- Step 2: fill reference samples (depending on neighborhood) -----

  const Pel*  srcBuf    = recoBuf.buf;
  const int   srcStride = recoBuf.stride;
        Pel*  ptrDst    = refBufUnfiltered;
  const Pel*  ptrSrc;
  const Pel   valueDC   = 1 << (sps.getBitDepth( chType ) - 1);


  if( numIntraNeighbor == 0 )
  {
    // Fill border with DC value
    for (int j = 0; j <= predSize; j++)
    {
      ptrDst[j] = valueDC;
    }
    for (int i = 0; i <= predHSize; i++)
    {
      ptrDst[i + predStride] = valueDC;
    }
  }
  else if( numIntraNeighbor == totalUnits )
  {
    // Fill top-left border and top and top right with rec. samples
    ptrSrc = srcBuf - (1 + iTemplateHeight) * srcStride - (1 + iTemplateWidth);
    for (int j = 0; j <= predSize; j++)
    {
      ptrDst[j] = ptrSrc[j];
    }
    for (int i = 0; i <= predHSize; i++)
    {
      ptrDst[i + predStride] = ptrSrc[i * srcStride];
    }
  }
  else // reference samples are partially available
  {
    // Fill top-left sample(s) if available
    ptrSrc = srcBuf - (1 + iTemplateHeight) * srcStride - (1 + iTemplateWidth);
    ptrDst = refBufUnfiltered;
#if JVET_AJ0146_TIMDSAD
    if (neighborFlags[totalLeftUnits + leftTempUnitNum])
#else
    if (neighborFlags[totalLeftUnits])
#endif
    {
#if JVET_AJ0146_TIMDSAD
      for (int i = 0; i <= iTemplateWidth - aboveTempUnitNum*unitWidth; i++)
#else
      for (int i = 0; i <= iTemplateWidth; i++)
#endif
      {
        ptrDst[i] = ptrSrc[i];
      }
#if JVET_AJ0146_TIMDSAD
      for (int i = 0; i <= iTemplateHeight - leftTempUnitNum*unitHeight; i++)
#else
      for (int i = 0; i <= iTemplateHeight; i++)
#endif
      {
        ptrDst[i + predStride] = ptrSrc[i * srcStride];
      }
    }

    // Fill left & below-left samples if available (downwards)
#if JVET_AJ0146_TIMDSAD
    ptrSrc += (1 + iTemplateHeight - leftTempUnitNum*unitHeight) * srcStride;
    ptrDst += (1 + iTemplateHeight - leftTempUnitNum*unitHeight) + predStride;
#else
    ptrSrc += (1 + iTemplateHeight) * srcStride;
    ptrDst += (1 + iTemplateHeight) + predStride;
#endif
#if JVET_AJ0146_TIMDSAD
    for (int unitIdx = totalLeftUnits + leftTempUnitNum - 1; unitIdx > 0; unitIdx--)
#else
    for (int unitIdx = totalLeftUnits - 1; unitIdx > 0; unitIdx--)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int i = 0; i < unitHeight; i++)
        {
          ptrDst[i] = ptrSrc[i * srcStride];
        }
      }
      ptrSrc += unitHeight * srcStride;
      ptrDst += unitHeight;
    }
    // Fill last below-left sample(s)
    if (neighborFlags[0])
    {
      int lastSample = ((predHSize - iTemplateHeight) % unitHeight == 0) ? unitHeight : (predHSize - iTemplateHeight) % unitHeight;
      for (int i = 0; i < lastSample; i++)
      {
        ptrDst[i] = ptrSrc[i * srcStride];
      }
    }

    // Fill above & above-right samples if available (left-to-right)
#if JVET_AJ0146_TIMDSAD
    ptrSrc = srcBuf - srcStride * (1 + iTemplateHeight) - aboveTempUnitNum*unitWidth;
    ptrDst = refBufUnfiltered + 1 + iTemplateWidth - aboveTempUnitNum*unitWidth;
#else
    ptrSrc = srcBuf - srcStride * (1 + iTemplateHeight);
    ptrDst = refBufUnfiltered + 1 + iTemplateWidth;
#endif
#if JVET_AJ0146_TIMDSAD
    for (int unitIdx = totalLeftUnits + 1 + leftTempUnitNum; unitIdx < totalUnits - 1; unitIdx++)
#else
    for (int unitIdx = totalLeftUnits + 1 + leftTempUnitNum + aboveTempUnitNum; unitIdx < totalUnits - 1; unitIdx++)
#endif
    {
      if (neighborFlags[unitIdx])
      {
        for (int j = 0; j < unitWidth; j++)
        {
          ptrDst[j] = ptrSrc[j];
        }
      }
      ptrSrc += unitWidth;
      ptrDst += unitWidth;
    }
    // Fill last above-right sample(s)
    if (neighborFlags[totalUnits - 1])
    {
      int lastSample = ((predSize - iTemplateWidth) % unitWidth == 0) ? unitWidth : (predSize - iTemplateWidth) % unitWidth;
      for (int j = 0; j < lastSample; j++)
      {
        ptrDst[j] = ptrSrc[j];
      }
    }

    // pad from first available down to the last below-left
    ptrDst = refBufUnfiltered;
    int lastAvailUnit = 0;
    if (!neighborFlags[0])
    {
      int firstAvailUnit = 1;
      while (firstAvailUnit < totalUnits && !neighborFlags[firstAvailUnit])
      {
        firstAvailUnit++;
      }

      // first available sample
      int firstAvailRow = -1;
      int firstAvailCol = 0;
#if JVET_AJ0146_TIMDSAD
      if (firstAvailUnit < totalLeftUnits + leftTempUnitNum)
#else
      if (firstAvailUnit < totalLeftUnits)
#endif
      {
#if JVET_AJ0146_TIMDSAD
        firstAvailRow = (totalLeftUnits + leftTempUnitNum - firstAvailUnit) * unitHeight + iTemplateHeight - leftTempUnitNum*unitHeight;
#else
        firstAvailRow = (totalLeftUnits - firstAvailUnit) * unitHeight + iTemplateHeight;
#endif
      }
#if JVET_AJ0146_TIMDSAD
      else if (firstAvailUnit == totalLeftUnits + leftTempUnitNum)
#else
      else if (firstAvailUnit == totalLeftUnits)
#endif
      {
#if JVET_AJ0146_TIMDSAD
        firstAvailRow = iTemplateHeight - leftTempUnitNum*unitHeight;
#else
        firstAvailRow = iTemplateHeight;
#endif
      }
      else
      {
#if JVET_AJ0146_TIMDSAD
        firstAvailCol = (firstAvailUnit - totalLeftUnits - leftTempUnitNum - 1) * unitWidth + 1 + iTemplateWidth - aboveTempUnitNum * unitWidth;
#else
        firstAvailCol = (firstAvailUnit - (totalLeftUnits + leftTempUnitNum + aboveTempUnitNum) - 1) * unitWidth + 1 + iTemplateWidth;
#endif
      }
      const Pel firstAvailSample = ptrDst[firstAvailRow < 0 ? firstAvailCol : firstAvailRow + predStride];

      // last sample below-left (n.a.)
      int lastRow = predHSize;

      // fill left column
      for (int i = lastRow; i > firstAvailRow; i--)
      {
        ptrDst[i + predStride] = firstAvailSample;
      }
      // fill top row
      if (firstAvailCol > 0)
      {
        for (int j = 0; j < firstAvailCol; j++)
        {
          ptrDst[j] = firstAvailSample;
        }
      }
      lastAvailUnit = firstAvailUnit;
    }

    // pad all other reference samples.
    int currUnit = lastAvailUnit + 1;
    while (currUnit < totalUnits)
    {
      if (!neighborFlags[currUnit]) // samples not available
      {
        // last available sample
        int lastAvailRow = -1;
        int lastAvailCol = 0;
#if JVET_AJ0146_TIMDSAD
        if (lastAvailUnit < totalLeftUnits + leftTempUnitNum)
        {
          lastAvailRow = (totalLeftUnits + leftTempUnitNum - lastAvailUnit - 1) * unitHeight + iTemplateHeight - leftTempUnitNum * unitHeight + 1;
        }
        else if (lastAvailUnit == totalLeftUnits + leftTempUnitNum)
        {
          lastAvailCol = iTemplateWidth - aboveTempUnitNum * unitWidth;
        }
        else
        {
          lastAvailCol = (lastAvailUnit - totalLeftUnits - leftTempUnitNum) * unitWidth + iTemplateWidth - aboveTempUnitNum * unitWidth;
        }
#else
        if (lastAvailUnit < totalLeftUnits)
        {
          lastAvailRow = (totalLeftUnits - lastAvailUnit - 1) * unitHeight + iTemplateHeight + 1;
        }
        else if (lastAvailUnit == totalLeftUnits)
        {
          lastAvailCol = iTemplateWidth;
        }
        else
        {
          lastAvailCol = (lastAvailUnit - (totalLeftUnits + leftTempUnitNum + aboveTempUnitNum)) * unitWidth + iTemplateWidth;
        }
#endif
        const Pel lastAvailSample = ptrDst[lastAvailRow < 0 ? lastAvailCol : lastAvailRow + predStride];

        // fill current unit with last available sample
#if JVET_AJ0146_TIMDSAD
        if (currUnit < totalLeftUnits + leftTempUnitNum)
        {
          for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
        else if (currUnit == totalLeftUnits + leftTempUnitNum)
        {
          for (int i = 0; i < iTemplateHeight - leftTempUnitNum * unitHeight + 1; i++)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
          for (int j = 0; j < iTemplateWidth - aboveTempUnitNum * unitWidth + 1; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
        else
        {
          int numSamplesInUnit = (currUnit == totalUnits - 1) ? (((predSize - iTemplateWidth) % unitWidth == 0) ? unitWidth : (predSize - iTemplateWidth) % unitWidth) : unitWidth;
          for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
#else
        if (currUnit < totalLeftUnits)
        {
          for (int i = lastAvailRow - 1; i >= lastAvailRow - unitHeight; i--)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
        }
        else if (currUnit == totalLeftUnits)
        {
          for (int i = 0; i < iTemplateHeight + 1; i++)
          {
            ptrDst[i + predStride] = lastAvailSample;
          }
          for (int j = 0; j < iTemplateWidth + 1; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
        else
        {
          int numSamplesInUnit = (currUnit == totalUnits - 1) ? (((predSize - iTemplateWidth) % unitWidth == 0) ? unitWidth : (predSize - iTemplateWidth) % unitWidth) : unitWidth;
          for (int j = lastAvailCol + 1; j <= lastAvailCol + numSamplesInUnit; j++)
          {
            ptrDst[j] = lastAvailSample;
          }
        }
#endif
      }
      lastAvailUnit = currUnit;
      currUnit++;
    }
  }
}

#if JVET_AB0155_SGPM
void IntraPrediction::deriveSgpmModeOrdered(const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu,
                                            static_vector<SgpmInfo, SGPM_NUM> &candModeList,
                                            static_vector<double, SGPM_NUM> &  candCostList)
{
  SizeType uiWidth         = cu.lwidth();
  SizeType uiHeight        = cu.lheight();

  int      iCurX = cu.lx();
  int      iCurY = cu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;

  const int iTempWidth = SGPM_TEMPLATE_SIZE, iTempHeight = SGPM_TEMPLATE_SIZE;

  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
                                                  iRefY, uiRefWidth, uiRefHeight);
  auto &        pu        = *cu.firstPU;
  uint32_t      uiRealW   = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t      uiRealH   = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);

  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, uiRealW, uiRealH));
  uint32_t       uiPredStride = m_sgpmBuffer[0].getBuf(localUnitArea.Y()).stride;
  CHECK(eTempType != LEFT_ABOVE_NEIGHBOR, "left and above both should exist");
  
  const CodingStructure &cs = *cu.cs;
  m_ipaParam.multiRefIndex  = iTempWidth;

  initTimdIntraPatternLuma(cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0,
                           eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);

#if JVET_AG0152_SGPM_ITMP_IBC
  Distortion sadWholeTM[NUM_LUMA_MODE + SGPM_NUM_BVS];
#if JVET_AJ0107_GPM_SHAPE_ADAPT
  Distortion sadPartsTM[NUM_LUMA_MODE + SGPM_NUM_BVS][SGPM_TOTAL_NUM_PARTITIONS];
#else
  Distortion sadPartsTM[NUM_LUMA_MODE + SGPM_NUM_BVS][GEO_NUM_PARTITION_MODE];
#endif
  uint8_t    ipmList[GEO_NUM_PARTITION_MODE][2][SGPM_NUM_MPM + SGPM_NUM_BVS];
#if JVET_AJ0107_GPM_SHAPE_ADAPT
  bool       sadPartsNeeded[NUM_LUMA_MODE + SGPM_NUM_BVS][SGPM_TOTAL_NUM_PARTITIONS] = {};
#else
  bool       sadPartsNeeded[NUM_LUMA_MODE + SGPM_NUM_BVS][GEO_NUM_PARTITION_MODE] = {};
#endif
  bool       ipmNeeded[NUM_LUMA_MODE + SGPM_NUM_BVS] = {};
#if JVET_AJ0112_REGRESSION_SGPM
  bool       ipmNeededforRsgpm[NUM_LUMA_MODE + SGPM_NUM_BVS] = {};
  int        ipmIdxInList[NUM_LUMA_MODE];
  memset(ipmIdxInList, 0, NUM_LUMA_MODE * sizeof(int));
#endif

#if JVET_AH0200_INTRA_TMP_BV_REORDER
  int numBVs = (int)m_sgpmMvBasedMergeCandidates.size();
#else
  int numBVs = (int)m_bvBasedMergeCandidates.size();
#endif
  int numItmpIbc = std::min(numBVs, SGPM_NUM_BVS);
  
  std::vector<std::pair<Mv, Distortion>> BVCostVec(numBVs);
#if JVET_AH0200_INTRA_TMP_BV_REORDER
  PelUnitBuf tempPUTopBuf(pu.chromaFormat, PelBuf(m_sgpmBuffer[0].getBuf(localUnitArea.Y()).buf+iTempWidth, uiPredStride, uiRealW-iTempWidth, iTempHeight));
  PelUnitBuf tempPULeftBuf(pu.chromaFormat, PelBuf(m_sgpmBuffer[0].getBuf(localUnitArea.Y()).buf+iTempHeight*uiPredStride, uiPredStride, iTempWidth, uiRealH-iTempHeight));
#endif
  for (int i = 0; i < numBVs; i++)
  {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
    Mv curBv = m_sgpmMvBasedMergeCandidates[i];
#else
    Mv curBv = m_bvBasedMergeCandidates[i];

    Pel* tempPred = m_sgpmBuffer[0].getBuf(localUnitArea.Y()).buf;
    Pel* piOrg = cs.picture->getRecoBuf(area).buf;
    int  iOrgStride = cs.picture->getRecoBuf(area).stride;
    piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
#endif
    PelBuf predBuf = m_sgpmBuffer[0].getBuf(localUnitArea.Y());
    PelBuf recBuf = cs.picture->getRecoBuf(area);
    PelBuf adBuf = m_sgpmBuffer[0].getBuf(localUnitArea.Y());

#if JVET_AH0200_INTRA_TMP_BV_REORDER
    Mv tempMv(curBv);
    Mv mvTop(0, -iTempHeight);
    mvTop.changePrecision(MV_PRECISION_INT, MV_PRECISION_INTERNAL);
    mvTop += tempMv;
    m_pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, pu.cs->picture, mvTop, tempPUTopBuf, true, true);

    Mv mvLeft(-iTempWidth, 0);
    mvLeft.changePrecision(MV_PRECISION_INT, MV_PRECISION_INTERNAL);
    mvLeft += tempMv;
    m_pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, pu.cs->picture, mvLeft, tempPULeftBuf, true,true);
#else
    predTimdIbcItmp(COMPONENT_Y, pu, curBv, tempPred, uiPredStride, uiRealW, uiRealH, eTempType, iTempWidth, iTempHeight, piOrg, iOrgStride);
#endif
    Distortion uiCurCost = m_if.m_sadTM(pu, uiWidth, uiHeight, iTempWidth, iTempHeight, COMPONENT_Y, predBuf, recBuf, adBuf);
    BVCostVec[i] = { curBv, uiCurCost };
  }
  std::stable_sort(BVCostVec.begin(), BVCostVec.end(), [](const std::pair<Mv, Distortion>& l, const std::pair<Mv, Distortion>& r) {return l.second < r.second; });
#else
  Distortion sadWholeTM[NUM_LUMA_MODE];
  Distortion sadPartsTM[NUM_LUMA_MODE][GEO_NUM_PARTITION_MODE];
  uint8_t    ipmList[GEO_NUM_PARTITION_MODE][2][SGPM_NUM_MPM];
  bool       sadPartsNeeded[NUM_LUMA_MODE][GEO_NUM_PARTITION_MODE] = {};
  bool       ipmNeeded[NUM_LUMA_MODE]                                 = {};
#endif

#if JVET_AJ0107_GPM_SHAPE_ADAPT
  for (int splitDirIdx = 0; splitDirIdx < SGPM_TOTAL_NUM_PARTITIONS; splitDirIdx++)
  {
#else
  for (int splitDir = 0; splitDir < GEO_NUM_PARTITION_MODE; splitDir++)
  {
#endif
#if JVET_AJ0112_REGRESSION_SGPM
    if (!pu.cs->pcv->isEncoder && PU::isRegressionSgpm(pu))
    {
      break;
    }
#endif
#if JVET_AJ0107_GPM_SHAPE_ADAPT
#else
    if (!g_sgpmSplitDir[splitDir])
    {
      continue;
    }
#endif

#if JVET_AJ0107_GPM_SHAPE_ADAPT
    int splitDir = g_sgpmSplitDir[splitDirIdx];
#endif
    int16_t angle = g_geoParams[splitDir][0];
    for (int partIdx = 0; partIdx < 2; partIdx++)
    {
#if JVET_AJ0107_GPM_SHAPE_ADAPT
      PU::getSgpmIntraMPMs(pu, ipmList[splitDirIdx][partIdx], splitDir, g_geoTmShape[partIdx][angle]);
#else
      PU::getSgpmIntraMPMs(pu, ipmList[splitDir][partIdx], splitDir, g_geoTmShape[partIdx][angle]);
#endif
      for (int modeIdx = 0; modeIdx < SGPM_NUM_MPM; modeIdx++)
      {
#if JVET_AJ0107_GPM_SHAPE_ADAPT
        int ipmIdx                       = ipmList[splitDirIdx][partIdx][modeIdx];
#else
        int ipmIdx                       = ipmList[splitDir][partIdx][modeIdx];
#endif
        ipmNeeded[ipmIdx]                = true;
#if JVET_AJ0107_GPM_SHAPE_ADAPT
        sadPartsNeeded[ipmIdx][splitDirIdx] = true;
#else
        sadPartsNeeded[ipmIdx][splitDir] = true;
#endif
      }
#if JVET_AG0152_SGPM_ITMP_IBC
      for (int modeIdx = 0; modeIdx < numItmpIbc; modeIdx++)
      {
        int ipmIdx = SGPM_BV_START_IDX + modeIdx;
#if JVET_AJ0107_GPM_SHAPE_ADAPT
        ipmList[splitDirIdx][partIdx][modeIdx + SGPM_NUM_MPM] = ipmIdx;
#else
        ipmList[splitDir][partIdx][modeIdx + SGPM_NUM_MPM] = ipmIdx;
#endif
        ipmNeeded[ipmIdx] = true;
#if JVET_AJ0107_GPM_SHAPE_ADAPT
        sadPartsNeeded[ipmIdx][splitDirIdx] = true;
#else
        sadPartsNeeded[ipmIdx][splitDir] = true;
#endif
      }
#endif
    }
  }

#if JVET_AJ0112_REGRESSION_SGPM
  const int numRegularMode = NUM_PRIMARY_MOST_PROBABLE_MODES;
  uint8_t mpmList[numRegularMode];
  if (PU::isRegressionSgpmAllow(pu) && (pu.cs->pcv->isEncoder || PU::isRegressionSgpm(pu)))
  {
#if JVET_AK0059_MDIP
    cu.isModeExcluded = false;
#endif
    int numCand = 0;
    mpmList[numCand++] = PLANAR_IDX;
    numCand += getSpatialIpm(pu, mpmList + 1, numRegularMode - 1
#if JVET_AC0094_REF_SAMPLES_OPT
      , true
#endif
#if JVET_AK0061_PDP_MPM
      ,false, false ,false
#endif

    );
    fillMPMList(pu, mpmList, numRegularMode, numCand, false
#if JVET_AK0061_PDP_MPM
      , false 
#endif
    );
#if JVET_AK0059_MDIP
    cu.isModeExcluded = true;
#endif
    for (int modeIdx = 0; modeIdx < numRegularMode; modeIdx++)
    {
      ipmNeededforRsgpm[mpmList[modeIdx]] = true;
      ipmIdxInList[mpmList[modeIdx]] = modeIdx + 1;
    }
#if JVET_AG0152_SGPM_ITMP_IBC
    for (int modeIdx = 0; modeIdx < numItmpIbc; modeIdx++)
    {
      ipmNeededforRsgpm[SGPM_BV_START_IDX + modeIdx] = true;
    }
#endif
  }
#endif

  for (int ipmIdx = 0; ipmIdx < NUM_LUMA_MODE; ipmIdx++)
  {
#if JVET_AJ0112_REGRESSION_SGPM
    if (ipmNeeded[ipmIdx] || ipmNeededforRsgpm[ipmIdx])
#else
    if (ipmNeeded[ipmIdx])
#endif
    {
      int iMode = MAP67TO131(ipmIdx);
      initPredTimdIntraParams(pu, area, iMode, true);
#if JVET_AJ0112_REGRESSION_SGPM
      Pel *tempPred = m_sgpmBuffer[ipmIdxInList[ipmIdx]].getBuf(localUnitArea.Y()).buf;
#else
      Pel *tempPred = m_sgpmBuffer[0].getBuf(localUnitArea.Y()).buf;
#endif
      predTimdIntraAng(COMPONENT_Y, pu, iMode, tempPred, uiPredStride, uiRealW, uiRealH, eTempType,
                       (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth, (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);

#if JVET_AJ0112_REGRESSION_SGPM
      if (!ipmNeeded[ipmIdx])
      {
        continue;
      }
      PelBuf predBuf = m_sgpmBuffer[ipmIdxInList[ipmIdx]].getBuf(localUnitArea.Y());
#else
      PelBuf predBuf = m_sgpmBuffer[0].getBuf(localUnitArea.Y());
#endif
      PelBuf recBuf  = cs.picture->getRecoBuf(area);
      PelBuf adBuf   = m_sgpmBuffer[0].getBuf(localUnitArea.Y());

      sadWholeTM[ipmIdx] =
        m_if.m_sadTM(pu, uiWidth, uiHeight, iTempWidth, iTempHeight, COMPONENT_Y, predBuf, recBuf, adBuf);

#if JVET_AJ0107_GPM_SHAPE_ADAPT
      for (int splitDirIdx = 0; splitDirIdx < SGPM_TOTAL_NUM_PARTITIONS; splitDirIdx++)
      {
        int splitDir = g_sgpmSplitDir[splitDirIdx];
#else
      for (int splitDir = 0; splitDir < GEO_NUM_PARTITION_MODE; splitDir++)
      {
#endif
#if JVET_AJ0107_GPM_SHAPE_ADAPT
        if (sadPartsNeeded[ipmIdx][splitDirIdx])
        {
          sadPartsTM[ipmIdx][splitDirIdx] =
#else
        if (sadPartsNeeded[ipmIdx][splitDir])
        {
          sadPartsTM[ipmIdx][splitDir] =
#endif
            m_if.m_sgpmSadTM(pu, uiWidth, uiHeight, iTempWidth, iTempHeight, COMPONENT_Y, splitDir, adBuf);
        }
      }
    }
  }
#if JVET_AG0152_SGPM_ITMP_IBC
  for (int i = 0; i < numItmpIbc; i++)
  { 
    int ipmIdx = SGPM_BV_START_IDX + i;
#if JVET_AJ0112_REGRESSION_SGPM
    if (ipmNeeded[ipmIdx] || ipmNeededforRsgpm[ipmIdx])
#else
    if (ipmNeeded[ipmIdx])
#endif
    {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
#if JVET_AJ0112_REGRESSION_SGPM
      PelUnitBuf tempPUTopBufWithIdx(pu.chromaFormat, PelBuf(m_sgpmBuffer[NUM_PRIMARY_MOST_PROBABLE_MODES + 1 + i].getBuf(localUnitArea.Y()).buf + iTempWidth, uiPredStride, uiRealW - iTempWidth, iTempHeight));
      PelUnitBuf tempPULeftBufWithIdx(pu.chromaFormat, PelBuf(m_sgpmBuffer[NUM_PRIMARY_MOST_PROBABLE_MODES + 1 + i].getBuf(localUnitArea.Y()).buf + iTempHeight * uiPredStride, uiPredStride, iTempWidth, uiRealH - iTempHeight));
#endif
      Mv tempMv(BVCostVec[i].first);
      Mv mvTop(0, -iTempHeight);
      mvTop.changePrecision(MV_PRECISION_INT, MV_PRECISION_INTERNAL);
      mvTop += tempMv;
#if JVET_AJ0112_REGRESSION_SGPM
      m_pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, pu.cs->picture, mvTop, tempPUTopBufWithIdx, true, true);
#else
      m_pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, pu.cs->picture, mvTop, tempPUTopBuf, true, true);
#endif

      Mv mvLeft(-iTempWidth, 0);
      mvLeft.changePrecision(MV_PRECISION_INT, MV_PRECISION_INTERNAL);
      mvLeft += tempMv;
#if JVET_AJ0112_REGRESSION_SGPM
      m_pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, pu.cs->picture, mvLeft, tempPULeftBufWithIdx, true, true);
#else
      m_pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, pu.cs->picture, mvLeft, tempPULeftBuf, true,true);
#endif
#else
#if JVET_AJ0112_REGRESSION_SGPM
      Pel* tempPred = m_sgpmBuffer[NUM_PRIMARY_MOST_PROBABLE_MODES + 1 + i].getBuf(localUnitArea.Y()).buf;
#else
      Pel* tempPred = m_sgpmBuffer[0].getBuf(localUnitArea.Y()).buf;
#endif
      Pel* piOrg = cs.picture->getRecoBuf(area).buf;
      int  iOrgStride = cs.picture->getRecoBuf(area).stride;
      piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
      predTimdIbcItmp(COMPONENT_Y, pu, BVCostVec[i].first, tempPred, uiPredStride, uiRealW, uiRealH, eTempType, iTempWidth, iTempHeight, piOrg, iOrgStride);
#endif
#if JVET_AJ0112_REGRESSION_SGPM
      if (!ipmNeeded[ipmIdx])
      {
        continue;
      }
      PelBuf predBuf = m_sgpmBuffer[NUM_PRIMARY_MOST_PROBABLE_MODES + 1 + i].getBuf(localUnitArea.Y());
#else
      PelBuf predBuf = m_sgpmBuffer[0].getBuf(localUnitArea.Y());
#endif
      PelBuf recBuf = cs.picture->getRecoBuf(area);
      PelBuf adBuf = m_sgpmBuffer[0].getBuf(localUnitArea.Y());

      sadWholeTM[ipmIdx] =
        m_if.m_sadTM(pu, uiWidth, uiHeight, iTempWidth, iTempHeight, COMPONENT_Y, predBuf, recBuf, adBuf);

#if JVET_AJ0107_GPM_SHAPE_ADAPT
      for (int splitDirIdx = 0; splitDirIdx < SGPM_TOTAL_NUM_PARTITIONS; splitDirIdx++)
      {
        int splitDir = g_sgpmSplitDir[splitDirIdx];
#else
      for (int splitDir = 0; splitDir < GEO_NUM_PARTITION_MODE; splitDir++)
      {
#endif
#if JVET_AJ0107_GPM_SHAPE_ADAPT
        if (sadPartsNeeded[ipmIdx][splitDirIdx])
        {
          sadPartsTM[ipmIdx][splitDirIdx] =
#else
        if (sadPartsNeeded[ipmIdx][splitDir])
        {
          sadPartsTM[ipmIdx][splitDir] =
#endif
            m_if.m_sgpmSadTM(pu, uiWidth, uiHeight, iTempWidth, iTempHeight, COMPONENT_Y, splitDir, adBuf);
        }
      }
    }
  }
#endif
  // check every possible combination
  uint32_t cntComb = 0;
#if JVET_AJ0112_REGRESSION_SGPM
  static_vector<SgpmInfo, SGPM_CAND_NUM> tmpModeList;
  static_vector<double, SGPM_CAND_NUM> tmpCostList;
  const int bcwBlendingLog2WeightBase = 5;  // BCW is 3, GEO is 5
  int min = 1;
  int max = (1 << bcwBlendingLog2WeightBase) - 1;
  AffineBlendingModel blendModel;
  blendModel = AffineBlendingModel(bcwBlendingLog2WeightBase, min, max); // only positive weights
  bool skipRsgpm = (!PU::isRegressionSgpmAllow(pu) || (!pu.cs->pcv->isEncoder && !PU::isRegressionSgpm(pu)));
  if (!skipRsgpm)
  {
    for (int mode0Idx = 0; mode0Idx < numRegularMode + numItmpIbc - 1; mode0Idx++)
    {
      for (int mode1Idx = mode0Idx + 1; mode1Idx < numRegularMode + numItmpIbc; mode1Idx++)
      {
        if (mode0Idx == mode1Idx)
        {
          continue;
        }

        int ipm0Idx = 0;
        int ipm1Idx = 0;
        Mv sgpmBv0 = Mv(0, 0);
        Mv sgpmBv1 = Mv(0, 0);
        PelBuf tempPred0;
        PelBuf tempPred1;

        if (mode0Idx < numRegularMode)
        {
          ipm0Idx = mpmList[mode0Idx];
          tempPred0 = m_sgpmBuffer[mode0Idx + 1].getBuf(localUnitArea.Y());
        }
        else
        {
          ipm0Idx = SGPM_BV_START_IDX + mode0Idx - numRegularMode;
          sgpmBv0 = BVCostVec[ipm0Idx - SGPM_BV_START_IDX].first;
          tempPred0 = m_sgpmBuffer[mode0Idx + 1].getBuf(localUnitArea.Y());
        }
        if (mode1Idx < numRegularMode)
        {
          ipm1Idx = mpmList[mode1Idx];
          tempPred1 = m_sgpmBuffer[mode1Idx + 1].getBuf(localUnitArea.Y());
        }
        else
        {
          ipm1Idx = SGPM_BV_START_IDX + mode1Idx - numRegularMode;
          sgpmBv1 = BVCostVec[ipm1Idx - SGPM_BV_START_IDX].first;
          tempPred1 = m_sgpmBuffer[mode1Idx + 1].getBuf(localUnitArea.Y());
        }

        PelBuf recBuf = cs.picture->getRecoBuf(area);
        PelBuf adBuf = m_sgpmBuffer[0].getBuf(localUnitArea.Y());
        // derive weights
        blendModel = AffineBlendingModel(bcwBlendingLog2WeightBase, min, max); // only positive weights
        double cost = (double)deriveSgpmBlending(pu, tempPred0, tempPred1, recBuf, adBuf, blendModel);

        cntComb++;

        if ((cntComb > RSGPM_CAND_NUM && cost < candCostList[RSGPM_CAND_NUM - 1]) || cntComb <= RSGPM_CAND_NUM)
        {
          updateCandList(SgpmInfo(0, ipm0Idx, ipm1Idx, sgpmBv0, sgpmBv1, true, blendModel), cost, candModeList, candCostList, RSGPM_CAND_NUM);
        }
      }
    }
    cntComb = 0;
  }
#endif
#if JVET_AJ0107_GPM_SHAPE_ADAPT
  for (int splitDir = 0; splitDir < SGPM_TOTAL_NUM_PARTITIONS; splitDir++)
#else
  for (int splitDir = 0; splitDir < GEO_NUM_PARTITION_MODE; splitDir++)
#endif
  {
#if JVET_AJ0112_REGRESSION_SGPM
    if (!pu.cs->pcv->isEncoder && PU::isRegressionSgpm(pu))
    {
      break;
    }
#endif
#if JVET_AJ0107_GPM_SHAPE_ADAPT
#else
    if (!g_sgpmSplitDir[splitDir])
    {
      continue;
    }
#endif

#if JVET_AG0152_SGPM_ITMP_IBC
    for (int mode0Idx = 0; mode0Idx < SGPM_NUM_MPM + numItmpIbc; mode0Idx++)
    {
      for (int mode1Idx = 0; mode1Idx < SGPM_NUM_MPM + numItmpIbc; mode1Idx++)
#else
    for (int mode0Idx = 0; mode0Idx < SGPM_NUM_MPM; mode0Idx++)
    {
      for (int mode1Idx = 0; mode1Idx < SGPM_NUM_MPM; mode1Idx++)
#endif
      {
        int ipm0Idx = ipmList[splitDir][0][mode0Idx];
        int ipm1Idx = ipmList[splitDir][1][mode1Idx];
        if (ipm0Idx == ipm1Idx)
        {
          continue;
        }

#if JVET_AG0152_SGPM_ITMP_IBC 
        Mv sgpmBv0 = Mv(0, 0);
        Mv sgpmBv1 = Mv(0, 0);
        if (ipm0Idx >= SGPM_BV_START_IDX)
        {
          sgpmBv0 = BVCostVec[ipm0Idx - SGPM_BV_START_IDX].first;
        }
        if (ipm1Idx >= SGPM_BV_START_IDX)
        {
          sgpmBv1 = BVCostVec[ipm1Idx - SGPM_BV_START_IDX].first;
        }
#endif
        double cost = static_cast<double>(sadPartsTM[ipm0Idx][splitDir]) + static_cast<double>(sadWholeTM[ipm1Idx])
                      - static_cast<double>(sadPartsTM[ipm1Idx][splitDir]);

        cntComb++;

#if JVET_AJ0112_REGRESSION_SGPM
        if (!PU::isRegressionSgpmAllow(pu))
        {
          if ((cntComb > SGPM_NUM && cost < candCostList[SGPM_NUM - 1]) || cntComb <= SGPM_NUM)
          {
            updateCandList(SgpmInfo(splitDir, ipm0Idx, ipm1Idx, sgpmBv0, sgpmBv1, false, blendModel), cost, candModeList, candCostList, SGPM_NUM);
          }
        }
        else
        {
          if ((cntComb > SGPM_CAND_NUM && cost < tmpCostList[SGPM_CAND_NUM - 1]) || cntComb <= SGPM_CAND_NUM)
          {
            updateCandList(SgpmInfo(splitDir, ipm0Idx, ipm1Idx, sgpmBv0, sgpmBv1, false, blendModel), cost, tmpModeList, tmpCostList, SGPM_CAND_NUM);
          }
        }
#else
        if ((cntComb > SGPM_NUM && cost < candCostList[SGPM_NUM - 1]) || cntComb <= SGPM_NUM)
        {
#if JVET_AG0152_SGPM_ITMP_IBC 
          updateCandList(SgpmInfo(splitDir, ipm0Idx, ipm1Idx, sgpmBv0, sgpmBv1), cost, candModeList, candCostList, SGPM_NUM);
#else
          updateCandList(SgpmInfo(splitDir, ipm0Idx, ipm1Idx), cost, candModeList, candCostList, SGPM_NUM);
#endif
        }
#endif
      }
    }
  }

#if JVET_AJ0112_REGRESSION_SGPM
  if (PU::isRegressionSgpmAllow(pu))
  {
    SgpmInfo sgpmInfo = SgpmInfo();
    if (!pu.cs->pcv->isEncoder && !PU::isRegressionSgpm(pu))
    {
      for (int i = 0; i < RSGPM_CAND_NUM; i++)
      {
        candModeList.push_back(sgpmInfo);
        candCostList.push_back(0);
      }
    }
    if (pu.cs->pcv->isEncoder || !PU::isRegressionSgpm(pu))
    {
      for (int i = 0; i < SGPM_CAND_NUM; i++)
      {
        candModeList.push_back(tmpModeList[i]);
        candCostList.push_back(tmpCostList[i]);
      }
    }
  }
#endif
}
#if JVET_AJ0112_REGRESSION_SGPM
int IntraPrediction::deriveSgpmBlending(PredictionUnit& pu, PelBuf &predBuf0, PelBuf &predBuf1, PelBuf &recBuf, PelBuf &adBuf, AffineBlendingModel &blendModel)
{
  int width = pu.lumaSize().width;
  int height = pu.lumaSize().height;
  const int channelBitDepth = pu.cs->sps->getBitDepth(CHANNEL_TYPE_LUMA);

  Pel(*A)[CCCM_REF_SAMPLES_MAX] = m_a;
  static Pel Y[BCW_MAX_REF_SAMPLES];

  int sampleNum = 0;
  const int iTempWidth = SGPM_TEMPLATE_SIZE, iTempHeight = SGPM_TEMPLATE_SIZE;

  // top template
  Pel *piPred0 = predBuf0.buf + iTempWidth;
  Pel *piPred1 = predBuf1.buf + iTempWidth;
  Pel *piRec = recBuf.buf - iTempHeight * recBuf.stride;

  for (int y = 0; y < iTempHeight; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int posX = x;
      int posY = y - iTempHeight;
      A[0][sampleNum] = ((piPred1[x + y * predBuf1.stride] - piPred0[x + y * predBuf0.stride]) * posX);
      A[1][sampleNum] = ((piPred1[x + y * predBuf1.stride] - piPred0[x + y * predBuf0.stride]) * posY);
      A[2][sampleNum] = (piPred1[x + y * predBuf1.stride] - piPred0[x + y * predBuf0.stride]);
      Y[sampleNum++] = (piRec[x + y * recBuf.stride] - piPred0[x + y * predBuf0.stride]);
    }
  }

  // left template
  piPred0 = predBuf0.buf + iTempHeight * predBuf0.stride;
  piPred1 = predBuf1.buf + iTempHeight * predBuf1.stride;
  piRec = recBuf.buf - iTempWidth;

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < iTempWidth; x++)
    {
      int posX = x - iTempWidth;
      int posY = y;
      A[0][sampleNum] = ((piPred1[x + y * predBuf1.stride] - piPred0[x + y * predBuf0.stride]) * posX);
      A[1][sampleNum] = ((piPred1[x + y * predBuf1.stride] - piPred0[x + y * predBuf0.stride]) * posY);
      A[2][sampleNum] = (piPred1[x + y * predBuf1.stride] - piPred0[x + y * predBuf0.stride]);
      Y[sampleNum++] = (piRec[x + y * recBuf.stride] - piPred0[x + y * predBuf0.stride]);
    }
  }
  CccmModel       bcwModel(3, channelBitDepth);
  CccmCovariance  bcwSolver;

  if (!sampleNum) // should never happen
  {
    bcwModel.clearModel();
  }
  else
  {
#if JVET_AB0174_CCCM_DIV_FREE
    bcwSolver.solve1(A, Y, sampleNum, 0, bcwModel);
#else
    bcwSolver.solve2(A, Y, Y, sampleNum, bcwModel, bcwModel);
#endif
  }

  const int bcwBlendingLog2WeightBase = 5;

  uint64_t  maxParam = blendModel.params[0] > blendModel.params[1] ? blendModel.params[0] : blendModel.params[1];
  maxParam = blendModel.params[2] > maxParam ? blendModel.params[2] : maxParam;
  int shiftA = floorLog2Uint64(maxParam) - 31;
  shiftA = shiftA < 0 ? 0 : shiftA;

  int offsetA = shiftA ? 1 << (shiftA - 1) : 0;
  blendModel.params[0] = (int)((bcwModel.params[0] + offsetA) >> shiftA);
  blendModel.params[1] = (int)((bcwModel.params[1] + offsetA) >> shiftA);
  blendModel.params[2] = (int)((bcwModel.params[2] + offsetA) >> shiftA);

  blendModel.shift = CCCM_DECIM_BITS - shiftA - bcwBlendingLog2WeightBase;
  blendModel.offset = blendModel.shift ? (1 << (blendModel.shift - 1)) : 0;
  if (blendModel.shift < 0)
  {
    printf("deriveRegressionSgpmBlending() failed.\n");
    exit(0);
  }

  blendModel.valid = true;

  const int shiftBlend = bcwBlendingLog2WeightBase;
  const int iOne = 1 << shiftBlend;
  const int offBlend = 1 << (shiftBlend - 1);

  // check validity :
  int cornerWeight[4];
  cornerWeight[0] = blendModel.compute(0, 0);
  cornerWeight[1] = blendModel.compute(width - 1, 0);
  cornerWeight[2] = blendModel.compute(0, height - 1);
  cornerWeight[3] = blendModel.compute(width - 1, height - 1);
  int minWeight = cornerWeight[0];
  int maxWeight = cornerWeight[0];
  for (int i = 0; i < 4; i++)
  {
    minWeight = std::min(minWeight, cornerWeight[i]);
    maxWeight = std::max(maxWeight, cornerWeight[i]);
  }
  bool unvalid = abs(minWeight - maxWeight) <= 4;
  if (unvalid)
  {
    blendModel.params[0] = (int)(0);
    blendModel.params[1] = (int)(0);
    blendModel.params[2] = (int)(16);
    blendModel.shift = 0;
    blendModel.offset = 0;
  }

  // calculate SAD
  // top template
  piPred0 = predBuf0.buf + iTempWidth;
  piPred1 = predBuf1.buf + iTempWidth;
  piRec = recBuf.buf - iTempHeight * recBuf.stride;
  Pel *piFinal = adBuf.buf + iTempWidth;

  int sad = 0;

  for (int y = 0; y < iTempHeight; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int posX = x;
      int posY = y - iTempHeight;
      int iWeight = blendModel.compute(posX, posY);
      piFinal[x + y * adBuf.stride] = ((iOne - iWeight) * piPred0[x + y * predBuf0.stride] + iWeight * piPred1[x + y * predBuf1.stride] + offBlend) >> shiftBlend;
      sad += abs(piFinal[x + y * adBuf.stride] - piRec[x + y * recBuf.stride]);
    }
  }

  // left template
  piPred0 = predBuf0.buf + iTempHeight * predBuf0.stride;
  piPred1 = predBuf1.buf + iTempHeight * predBuf1.stride;
  piRec = recBuf.buf - iTempWidth;
  piFinal = adBuf.buf + iTempHeight * adBuf.stride;

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < iTempWidth; x++)
    {
      int posX = x - iTempWidth;
      int posY = y;
      int iWeight = blendModel.compute(posX, posY);
      piFinal[x + y * adBuf.stride] = ((iOne - iWeight) * piPred0[x + y * predBuf0.stride] + iWeight * piPred1[x + y * predBuf1.stride] + offBlend) >> shiftBlend;
      sad += abs(piFinal[x + y * adBuf.stride] - piRec[x + y * recBuf.stride]);
    }
  }

  return sad;
}
#endif
#endif

#if JVET_AK0061_PDP_MPM
bool IntraPrediction::determinePDPEnable(const ComponentID compId, const PredictionUnit& pu, const uint32_t uiDirMode) 
{
  if (!m_refAvailable) 
  {
    return false;
  }
  const uint32_t width = pu.lwidth();
  const uint32_t height = pu.lheight();
  const int sizeKey = (width << 8) + height;
  const int sizeIdx = g_size[sizeKey];
  if (uiDirMode != BDPCM_IDX && pu.cu->cs->sps->getUsePDP() && g_pdpFilters[uiDirMode][sizeIdx])
  {
    return true;
  }

  return false;
}
void IntraPrediction::xFillPDPTempReferenceSamples2(const CPelBuf& recoBuf, const CompArea& area, const CodingUnit& cu) {

  m_refAvailable = true;
  const CodingStructure& cs = *cu.cs;
  const PreCalcValues& pcv = *cs.pcv;
  const int unitWidth = pcv.minCUWidth;
  const int unitHeight = pcv.minCUHeight;

  const int sizeKey = (area.width << 8) + area.height;
  const int sizeIdx = g_size[sizeKey];
  int numMRLLeft = g_sizeData[sizeIdx][5];
  int numMRLTop = g_sizeData[sizeIdx][6];
  int len = g_sizeData[sizeIdx][7];
  ::memset(m_ref, 0, sizeof(Pel) * len);
  ::memset(m_leftRef, 0, sizeof(Pel) * len);
  len = g_sizeData[sizeIdx][10];
  ::memset(m_refShort, 0, sizeof(Pel) * len);
  ::memset(m_leftRefShort, 0, sizeof(Pel) * len);

  // Top
  
  int sizeW = area.width * 2;
  int sizeH = area.height * 2;

  int padW = sizeW - area.width;
  Position posRT = cu.Y().topRight().offset(0, -MPM_SORT_TEMPLATE_SIZE);
  for (int x = 0; x < area.width; x += unitWidth)
  {
    Position refPos = posRT.offset(x + unitWidth, -1);
    if (!(cs.isDecomp(refPos, CHANNEL_TYPE_LUMA) && cs.getCURestricted(refPos, cu, CHANNEL_TYPE_LUMA)))
    {
      break;
    }
    padW -= unitWidth;
  }
  int padH = sizeH - area.height;
  Position posLB = cu.Y().bottomLeft().offset(0, -MPM_SORT_TEMPLATE_SIZE);
  for (int y = 0; y < area.height; y += unitHeight)
  {
    Position refPos = posLB.offset(-1, y + unitHeight);
    if (!(cs.isDecomp(refPos, CHANNEL_TYPE_LUMA) && cs.getCURestricted(refPos, cu, CHANNEL_TYPE_LUMA)))
    {
      break;
    }
    padH -= unitHeight;
  }


  const int srcStride = recoBuf.stride;

  CPelBuf refBuf = CPelBuf(recoBuf.buf - (numMRLTop + MPM_SORT_TEMPLATE_SIZE) * srcStride - numMRLLeft, srcStride, Size(sizeW + numMRLLeft, sizeH + numMRLTop));
  xFillReferenceSamplesL(refBuf, m_ref, numMRLTop, sizeW, sizeH, padW, padH);
  xFillReferenceSamplesL(refBuf, m_refShort, numMRLTop, area.width, area.height, 0, 0);
  

  // Left
  
  padW = sizeW - area.width;
  posRT = cu.Y().topRight().offset(-MPM_SORT_TEMPLATE_SIZE, 0);
  for (int x = 0; x < area.width; x += unitWidth)
  {
    Position refPos = posRT.offset(x + unitWidth, -1);
    if (!(cs.isDecomp(refPos, CHANNEL_TYPE_LUMA) && cs.getCURestricted(refPos, cu, CHANNEL_TYPE_LUMA)))
    {
      break;
    }
    padW -= unitWidth;
  }

  padH = sizeH - area.height;
  posLB = cu.Y().bottomLeft().offset(-MPM_SORT_TEMPLATE_SIZE, 0);
  for (int y = 0; y < area.height; y += unitHeight)
  {
    Position refPos = posLB.offset(-1, y + unitHeight);
    if (!(cs.isDecomp(refPos, CHANNEL_TYPE_LUMA) && cs.getCURestricted(refPos, cu, CHANNEL_TYPE_LUMA)))
    {
      break;
    }
    padH -= unitHeight;
  }

  refBuf = CPelBuf(recoBuf.buf - numMRLTop * srcStride - (numMRLLeft + MPM_SORT_TEMPLATE_SIZE), srcStride, Size(sizeW + numMRLLeft, sizeH + numMRLTop));
  xFillReferenceSamplesL(refBuf, m_leftRef, numMRLTop, sizeW, sizeH, padW, padH);
  xFillReferenceSamplesL(refBuf, m_leftRefShort, numMRLTop, area.width, area.height, 0, 0);
  

}
#endif

#if JVET_AD0085_MPM_SORTING
void IntraPrediction::deriveMPMSorted(const PredictionUnit& pu, uint8_t* mpm, int& sortedSize, int iStartIdx
#if JVET_AK0061_PDP_MPM
  , const bool& pdpRefAvailable, const bool& allPDPMode
#endif
)
{
  SizeType uiWidth = pu.lwidth();
  SizeType uiHeight = pu.lheight();
  const CompArea area = pu.Y();
  int channelBitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);

  int      iCurX = pu.lx();
  int      iCurY = pu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;
  int      iTempWidth = 1, iTempHeight = 1;

  static_vector<uint8_t, NUM_MOST_PROBABLE_MODES> uiModeList;
  static_vector<uint64_t, NUM_MOST_PROBABLE_MODES> uiCostList;
#if JVET_AK0061_PDP_MPM
  int iBestN = std::min(pdpRefAvailable ? NUM_PRIMARY_MOST_PROBABLE_MODES : (NUM_PRIMARY_MOST_PROBABLE_MODES - 1), sortedSize);
#else
  int iBestN = std::min(NUM_PRIMARY_MOST_PROBABLE_MODES - 1, sortedSize);
#endif

  if (!pu.cs->pcv->isEncoder && pu.mpmFlag && pu.ipredIdx < iBestN)
  {
#if JVET_AK0061_PDP_MPM
    if (pdpRefAvailable) 
    {
      iBestN = pu.ipredIdx + 1;
    }
    else 
    {
      iBestN = pu.ipredIdx;
    }
#else
    iBestN = pu.ipredIdx;
#endif

  }

  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
    iRefY, uiRefWidth, uiRefHeight);

  uint32_t      uiRealW2   = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t      uiRealH2   = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, uiRealW2, uiRealH2));
  uint32_t       uiPredStride = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).stride;
  Pel *piPred = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).buf;

  if (eTempType == NO_NEIGHBOR)
  {
    return;
  }

  const CodingStructure& cs = *pu.cs;
  m_ipaParam.multiRefIndex = iTempWidth;
  Pel* piOrg = cs.picture->getRecoBuf(area).buf;
  int  iOrgStride = cs.picture->getRecoBuf(area).stride;
  piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
  DistParam distParamSad[2];   // above, left
  distParamSad[0].applyWeight = false;
  distParamSad[0].useMR = false;
  distParamSad[1].applyWeight = false;
  distParamSad[1].useMR = false;
  if (eTempType == LEFT_ABOVE_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
      uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
      piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
      COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
      uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, false);   // Use HAD (SATD) cost
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
      piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
      COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false);
#endif
  }
  else if (eTempType == LEFT_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
      COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
      COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false);
#endif
  }
  else if (eTempType == ABOVE_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
      COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
      COMPONENT_Y, uiWidth, iTempHeight, 0, 1, false);
#endif
  }

#if JVET_AK0061_PDP_MPM
  if (!(pdpRefAvailable && allPDPMode))
  {
#endif
    initTimdIntraPatternLuma(*pu.cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0,
      eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);
#if JVET_AK0061_PDP_MPM
  }
#endif
  uint32_t uiRealW = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t uiRealH = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);

#if JVET_AK0061_PDP_MPM
  const ClpRng& clpRng(pu.cu->cs->slice->clpRng(COMPONENT_Y));
  const UnitArea localTopPDPUnitArea(pu.chromaFormat, Area(iTempWidth, 0, uiWidth, iTempHeight));
  const UnitArea localLeftPDPUnitArea(pu.chromaFormat, Area(0, iTempHeight, iTempWidth, uiHeight));
  m_refAvailable = false;
  if (pdpRefAvailable) 
  {
    xFillPDPTempReferenceSamples2(cs.picture->getRecoBuf(area), area, *pu.cu);
  }
  auto backupMode = pu.cu->mipFlag;
  pu.cu->mipFlag = false;
#endif  
  for (int i = iStartIdx; i < sortedSize; i++)
  {
    uint64_t uiCost = 0;
    int      iMode = mpm[i];
#if JVET_AK0061_PDP_MPM
    if (eTempType == LEFT_ABOVE_NEIGHBOR && determinePDPEnable(COMPONENT_Y, pu, iMode)) 
    {
      const uint32_t       uiDirMode = iMode;
      PelBuf tmrlPDPIntraPred = m_intraPredBuffer[0].getBuf(localTopPDPUnitArea.Y());

      m_xPredIntraOpt(tmrlPDPIntraPred, pu, uiDirMode, clpRng, m_ref, m_refShort);

      uiCost += distParamSad[0].distFunc(distParamSad[0]);
      if (uiCostList.size() >= iBestN)
      {
        uint64_t uiCostMax = uiCostList[iBestN - 1];
        if (uiCost > uiCostMax)
        {
          continue;
        }
      }
      tmrlPDPIntraPred = m_intraPredBuffer[0].getBuf(localLeftPDPUnitArea.Y());
      m_xPredIntraOpt(tmrlPDPIntraPred, pu, uiDirMode, clpRng, m_leftRef, m_leftRefShort);
      uiCost += distParamSad[1].distFunc(distParamSad[1]);
    }
    else 
    {
#endif
    if (iMode > DC_IDX)
    {
      iMode = MAP67TO131(iMode);
    }
#if JVET_AK0059_MDIP && !JVET_AK0061_PDP_MPM
    if(g_intraModeCost[iMode] != MAX_UINT64)
    {
      uiCost = g_intraModeCost[iMode];
    }
    else
    {
#endif
    initPredTimdIntraParams(pu, area, iMode);
    predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
      (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
      (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
    if (eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      uiCost += distParamSad[0].distFunc(distParamSad[0]);
      if (uiCostList.size() >= iBestN)
      {
        uint64_t uiCostMax = uiCostList[iBestN - 1];
        if (uiCost > uiCostMax)
        {
          continue;
        }
      }
      uiCost += distParamSad[1].distFunc(distParamSad[1]);
    }
    else if (eTempType == LEFT_NEIGHBOR)
    {
      uiCost = distParamSad[1].distFunc(distParamSad[1]);
    }
    else if (eTempType == ABOVE_NEIGHBOR)
    {
      uiCost += distParamSad[0].distFunc(distParamSad[0]);
    }
    else
    {
      CHECK( true, "wrong case" );
    }
#if JVET_AK0059_MDIP && !JVET_AK0061_PDP_MPM
    }
#endif
#if JVET_AK0061_PDP_MPM
    }
#endif
#if JVET_AJ0061_TIMD_MERGE && !JVET_AK0061_PDP_MPM
    g_timdMrgCost[iMode] = uiCost;
#endif    
    if (uiCostList.size() < iBestN || (uiCostList.size() >= iBestN && uiCost < uiCostList.back()))
    {
      updateCandList(mpm[i], uiCost, uiModeList, uiCostList, iBestN);
    }
  }
#if JVET_AK0061_PDP_MPM
  pu.cu->mipFlag = backupMode;
#endif
  sortedSize = int(uiModeList.size()) + iStartIdx;
  for (int i = 0; i < uiModeList.size(); i++)
  {
    mpm[i + iStartIdx] = uiModeList[i];
  }
}
#endif

#if JVET_AK0059_MDIP
void IntraPrediction::deriveMdipSorted(const PredictionUnit& pu, int* list, int& sortedSize, int iStartIdx)
{
  SizeType uiWidth = pu.lwidth();
  SizeType uiHeight = pu.lheight();
  const CompArea area = pu.Y();
  int channelBitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);

  int      iCurX = pu.lx();
  int      iCurY = pu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;
  int      iTempWidth = 1, iTempHeight = 1;

  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
    iRefY, uiRefWidth, uiRefHeight);

  uint32_t      uiRealW2   = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t      uiRealH2   = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, uiRealW2, uiRealH2));
  uint32_t       uiPredStride = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).stride;
  Pel *piPred = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).buf;

  if (eTempType == NO_NEIGHBOR)
  {
    return;
  }

  const CodingStructure& cs = *pu.cs;
  m_ipaParam.multiRefIndex = iTempWidth;
  Pel* piOrg = cs.picture->getRecoBuf(area).buf;
  int  iOrgStride = cs.picture->getRecoBuf(area).stride;
  piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
  DistParam distParamSad[2];   // above, left
  distParamSad[0].applyWeight = false;
  distParamSad[0].useMR = false;
  distParamSad[1].applyWeight = false;
  distParamSad[1].useMR = false;
  if (eTempType == LEFT_ABOVE_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
                                    uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
                                    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
                                    piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
                                    COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
                                     uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1,
                                     false);   // Use HAD (SATD) cost
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
                                     piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false);   // Use HAD (SATD) cost
#endif
  }
  else if (eTempType == LEFT_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA    
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false);
#endif      
  }
  else if (eTempType == ABOVE_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA    
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, uiWidth, iTempHeight, 0, 1, false);
#endif      
  }
  initTimdIntraPatternLuma(*pu.cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0,
    eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);

  uint32_t uiRealW = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t uiRealH = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);

  uint64_t uiBestCost = MAX_UINT64;
  int      iBestMode = list[0];

  for (int i = iStartIdx; i < sortedSize; i++)
  {
    uint64_t uiCost = 0;
    int      iMode = list[i];

    if (eTempType == LEFT_NEIGHBOR && iMode > 34)
    {
      continue;
    }
    else if (eTempType == ABOVE_NEIGHBOR && iMode < 34)
    {
      continue;
    }

    if (iMode > DC_IDX)
    {
      iMode = MAP67TO131(iMode);
    }
    initPredTimdIntraParams(pu, area, iMode);
    predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
      (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
      (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);

    if (eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      uiCost += distParamSad[0].distFunc(distParamSad[0]);
      uiCost += distParamSad[1].distFunc(distParamSad[1]);
    }
    else if (eTempType == LEFT_NEIGHBOR)
    {
      uiCost = distParamSad[1].distFunc(distParamSad[1]);
    }
    else if (eTempType == ABOVE_NEIGHBOR)
    {
      uiCost += distParamSad[0].distFunc(distParamSad[0]);
    }
    else
    {
      CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
    }

#if !JVET_AK0061_PDP_MPM
    g_intraModeCost[iMode] = uiCost;
#else
    const bool isEncoder = pu.cu->cs->pcv->isEncoder;
    if (isEncoder)
    {
      g_intraModeCost[iMode] = uiCost;
    }
#endif

    if (uiCost < uiBestCost)
    {
      iBestMode = list[i];
      uiBestCost = uiCost;
      
      if(uiBestCost == 0)
      {
        break;
      }
    }
  }
  list[0] = iBestMode;
}
#endif

#if JVET_AG0146_DIMD_ITMP_IBC 
int IntraPrediction::getBestNonAnglularMode(const CPelBuf& recoBuf, const CompArea& area, CodingUnit& cu, std::vector<Mv> BVs)
{
  cu.isBvDimd = 0;
  if (BVs.empty())
  {
    return 0;
  }
  int      channelBitDepth = cu.slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  SizeType uiWidth = cu.lwidth();
  SizeType uiHeight = cu.lheight();

  static Pel predLuma[(MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE) * (MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE)];
  memset(predLuma, 0, (MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE) * (MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE) * sizeof(Pel));
  Pel* piPred = predLuma;
  uint32_t uiPredStride = MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE;

  int      iCurX = cu.lx();
  int      iCurY = cu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;

  int iTempWidth = 4, iTempHeight = 4;
  if (uiWidth <= 8)
  {
    iTempWidth = 2;
  }
  if (uiHeight <= 8)
  {
    iTempHeight = 2;
  }

  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
    iRefY, uiRefWidth, uiRefHeight);

  if (eTempType == LEFT_ABOVE_NEIGHBOR)
  {
    const CodingStructure& cs = *cu.cs;
    m_ipaParam.multiRefIndex = iTempWidth;
    Pel* piOrg = cs.picture->getRecoBuf(area).buf;
    int  iOrgStride = cs.picture->getRecoBuf(area).stride;
    piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
    DistParam distParamSad[2];   // above, left
    distParamSad[0].applyWeight = false;
    distParamSad[0].useMR = false;
    distParamSad[1].applyWeight = false;
    distParamSad[1].useMR = false;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    DistParam distParamSadItmp[2];
    distParamSadItmp[0].applyWeight = false;
    distParamSadItmp[0].useMR = false;
    distParamSadItmp[1].applyWeight = false;
    distParamSadItmp[1].useMR = false;
#endif
    if (eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
        uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1,
        true);   // Use HAD (SATD) cost
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
        piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
        COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);   // Use HAD (SATD) cost
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      m_itmpSatdCost->setTimdDistParam(distParamSadItmp[0], piOrg + iTempWidth, piOrg + iTempWidth, iOrgStride, iOrgStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
      m_itmpSatdCost->setTimdDistParam(distParamSadItmp[1], piOrg + iTempHeight * iOrgStride, piOrg + iTempHeight * uiPredStride, iOrgStride, iOrgStride, channelBitDepth, COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#endif
    }
    else if (eTempType == LEFT_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
        COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      m_itmpSatdCost->setTimdDistParam(distParamSadItmp[1], piOrg, piPred, iOrgStride, iOrgStride, channelBitDepth, COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#endif
    }
    else if (eTempType == ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
        COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      m_itmpSatdCost->setTimdDistParam(distParamSadItmp[0], piOrg, piOrg, iOrgStride, iOrgStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
#endif
    }
    initTimdIntraPatternLuma(cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0,
      eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);


    bool     includedMode[EXT_VDIA_IDX + 1];
    memset(includedMode, false, (EXT_VDIA_IDX + 1) * sizeof(bool));
    auto& pu = *cu.firstPU;
    uint32_t uiRealW = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
    uint32_t uiRealH = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);

    uint64_t uiBestCost = MAX_UINT64;
    int      iBestMode = PLANAR_IDX;


    const int maxModes = (int)BVs.size() + 1;

    for (int i = 0; i < maxModes; i++)
    {
      uint64_t uiCost = 0;
      uint64_t tmpCost0 = 0;
      uint64_t tmpCost1 = 0;

      if (i == 0)
      {
        initPredTimdIntraParams(pu, area, i);
        predTimdIntraAng(COMPONENT_Y, pu, i, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
          (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth, (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        uiCost = tmpCost0 + tmpCost1;
#endif
      }
      else
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        distParamSadItmp[0].cur.buf = piOrg + BVs[i - 1].hor + BVs[i - 1].ver * iOrgStride + iTempWidth;
        tmpCost0 = distParamSadItmp[0].distFunc(distParamSadItmp[0]);
        distParamSadItmp[1].cur.buf = piOrg + BVs[i - 1].hor + (BVs[i - 1].ver + iTempHeight) * iOrgStride;
        tmpCost1 = distParamSadItmp[1].distFunc(distParamSadItmp[1]);
        uiCost = tmpCost0 + tmpCost1;
#else
        predTimdIbcItmp(COMPONENT_Y, pu, BVs[i - 1], piPred, uiPredStride, uiRealW, uiRealH, eTempType,
          (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth, (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight, piOrg, iOrgStride);
#endif
      }

#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
      tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);



      uiCost = tmpCost0 + tmpCost1;
#endif
      if (uiCost < uiBestCost)
      {
        uiBestCost = uiCost;
        iBestMode = i;
      }
    }
    if (iBestMode > 0)
    {
      cu.isBvDimd = 1;
      cu.bvDimd = BVs[iBestMode - 1];
    }
    else
    {
      cu.isBvDimd = 0;
    }
  }
  return 0;
}
#endif
  
#if JVET_AJ0061_TIMD_MERGE
void IntraPrediction::searchTimdMrgCus(const CodingUnit &cu, static_vector<const CodingUnit*, NUM_TIMD_MERGE_CUS> &cuNeighbours)
{
  /* -----------------------------------------------------------------
   ----------- Collect adjacent neighbour cands ----------------------
   ----------------------------------------------------------------- */
  const int numCUs = NUM_TIMD_MERGE_CUS;
  const int step = 4;
  const CodingUnit *cuLeft = NULL;
  for (int i = 0; i <= cu.lheight(); i += step)
  {
    cuLeft = cu.cs->getCURestricted(cu.lumaPos().offset(-1, i), cu, CH_L);
    if (cuLeft && CU::isIntra(*cuLeft) && cuLeft->timd && cuNeighbours.size() < numCUs - 1)
    {
      cuNeighbours.push_back(cuLeft);
    }
  }
  const CodingUnit *cuTop = NULL;
  for (int i = 0; i <= cu.lwidth(); i += step)
  {
    cuTop = cu.cs->getCURestricted(cu.lumaPos().offset(i, -1), cu, CH_L);
    if (cuTop && CU::isIntra(*cuTop) && cuTop->timd && cuNeighbours.size() < numCUs - 1)
    {
      cuNeighbours.push_back(cuTop);
    }
  }
  const CodingUnit* cuNeighbour = cu.cs->getCURestricted(cu.lumaPos().offset(-1, -1), cu, CH_L);
  if (cuNeighbour && CU::isIntra(*cuNeighbour) && cuNeighbour->timd && cuNeighbours.size() < numCUs - 1)
  {
    cuNeighbours.push_back(cuNeighbour);
  }
  const CodingUnit *cuLeft2 = cuLeft ? cu.cs->getCURestricted(cuLeft->lumaPos().offset(cuLeft->lwidth() - 1, cuLeft->lheight()), cu, CH_L) : NULL;
  const CodingUnit *cuTop2 = cuTop ? cu.cs->getCURestricted(cuTop->lumaPos().offset(cuTop->lwidth(), cuTop->lheight() - 1), cu, CH_L) : NULL;
  cuNeighbour = cuLeft2;
  if (cuNeighbour && CU::isIntra(*cuNeighbour) && cuNeighbour->timd && cuNeighbours.size() < numCUs - 1)
  {
    cuNeighbours.push_back(cuNeighbour);
  }
  cuNeighbour = cuTop2;
  if (cuNeighbour && CU::isIntra(*cuNeighbour) && cuNeighbour->timd && cuNeighbours.size() < numCUs - 1)
  {
    cuNeighbours.push_back(cuNeighbour);
  }
  cuNeighbour = cuLeft2 ? cu.cs->getCURestricted(cuLeft2->lumaPos().offset(cuLeft2->lwidth() - 1, cuLeft2->lheight()), cu, CH_L) : NULL;
  if (cuNeighbour && CU::isIntra(*cuNeighbour) && cuNeighbour->timd && cuNeighbours.size() < numCUs - 1)
  {
    cuNeighbours.push_back(cuNeighbour);
  }
  cuNeighbour = cuTop2 ? cu.cs->getCURestricted(cuTop2->lumaPos().offset(cuTop2->lwidth(), cuTop2->lheight() - 1), cu, CH_L) : NULL;
  if (cuNeighbour && CU::isIntra(*cuNeighbour) && cuNeighbour->timd && cuNeighbours.size() < numCUs - 1)
  {
    cuNeighbours.push_back(cuNeighbour);
  }

  /* -----------------------------------------------------------------
   ---------- Collect non-adjacent neighbour cands-------------
   ----------------------------------------------------------------- */
  for (const CodingUnit *nonAdjacentNeighbour : PU::timdMergeNonAdjacentNeighbours(*cu.firstPU))
  {
    if (nonAdjacentNeighbour && CU::isIntra(*nonAdjacentNeighbour) && nonAdjacentNeighbour->timd && cuNeighbours.size() < numCUs)
    {
      cuNeighbours.push_back(nonAdjacentNeighbour);
    }
  }

  // Deduplicate candidates
  static_vector<const CodingUnit *, numCUs> cuNeighboursFiltered;
  for (int i = 0; i < cuNeighbours.size(); i++)
  {
    bool useNeighbour = true;
    for (int j = i-1; j >= 0; j--)
    {
      if (cuNeighbours[i]->lx() == cuNeighbours[j]->lx() && cuNeighbours[i]->ly() == cuNeighbours[j]->ly())
      {
        useNeighbour = false;
        break;
      }
    }
    if (useNeighbour)
    {
      cuNeighboursFiltered.push_back(cuNeighbours[i]);
    }
  }
  cuNeighbours = std::move(cuNeighboursFiltered);

  /* -----------------------------------------------------------------
  ---------------- Sort neighbours by distance -----------------------
  ----------------------------------------------------------------- */
  size_t limitMaxNeigh = 5;
  static_vector<size_t, numCUs> neighboursInDistOrder;
  // Calculate the distance to each neighbour and store in dists.
  static_vector<int, numCUs> dists;
  for (size_t i = 0; i < cuNeighbours.size(); i++)
  {
    const int dx = abs((int)(cu.lx()) - (int)(cuNeighbours[i]->lx()));
    const int dy = abs((int)(cu.ly()) - (int)(cuNeighbours[i]->ly()));
    const int d = dx + dy;
    dists.push_back(d);
  }
  
  // Sort neighbours in ascending order of distance.
  auto neighbourComp = [&](size_t a, size_t b)
  {
    return dists[a] < dists[b]
    || (dists[a] == dists[b] && a < b);
  };
  for (size_t i = 0; i < cuNeighbours.size(); i++)
  {
    neighboursInDistOrder.push_back(i);
  }
  std::sort(neighboursInDistOrder.begin(), neighboursInDistOrder.end(), neighbourComp);
  CHECK(cuNeighbours.size() != neighboursInDistOrder.size(),
        "cuNeighbours and neighboursInDistOrder not correctly associated");

  // Discard all but the nearest limitMaxNeigh neighbours.
  cuNeighboursFiltered.clear();
  const size_t numToMix = std::min(cuNeighbours.size(), limitMaxNeigh);
  for (int i = 0; i < cuNeighbours.size() && cuNeighboursFiltered.size() < numToMix; i++)
  {
    for (int j = 0; j < numToMix; j++)
    {
      if (neighboursInDistOrder[j] == i)
      {
        cuNeighboursFiltered.push_back(cuNeighbours[i]);
      }
    }
  }
  cuNeighbours = std::move(cuNeighboursFiltered);
  
  return;
}

template<typename T, size_t N>
void IntraPrediction::calcTimdMrgCandCosts(
    const CodingUnit &cu,
    static_vector<TimdMergeInfo, NUM_TIMD_MERGE_CUS> &timdMrgList,
    static_vector<T, N>& uiModeList,
    static_vector<uint64_t, N>& candCostList)
{
  const CompArea &area = cu.Y();
  SizeType uiWidth         = cu.lwidth();
  SizeType uiHeight        = cu.lheight();
  int      iCurX = cu.lx();
  int      iCurY = cu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;
  int      iTempWidth = 1, iTempHeight = 1;
  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
                                                 iRefY, uiRefWidth, uiRefHeight);
  
  int      channelBitDepth = cu.slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  auto &   pu      = *cu.firstPU;
  uint32_t uiRealW = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t uiRealH = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
  uint32_t      uiRealW2   = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t      uiRealH2   = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, uiRealW2, uiRealH2));
  uint32_t       uiPredStride = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).stride;
  Pel *piPred = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).buf;
  const CodingStructure &cs = *cu.cs;
  m_ipaParam.multiRefIndex  = iTempWidth;
  Pel *piOrg                = cs.picture->getRecoBuf(area).buf;
  int  iOrgStride           = cs.picture->getRecoBuf(area).stride;
  piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
  DistParam distParamSad[2];   // above, left
  distParamSad[0].applyWeight = false;
  distParamSad[0].useMR       = false;
  distParamSad[1].applyWeight = false;
  distParamSad[1].useMR       = false;
  if (eTempType == LEFT_ABOVE_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
                                    uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
                                    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
                                    piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
                                    COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
                                     uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1,
                                     false);   // Use HAD (SATD) cost
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
                                     piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false);   // Use HAD (SATD) cost
#endif
  }
  else if (eTempType == LEFT_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false);
#endif
  }
  else if (eTempType == ABOVE_NEIGHBOR)
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                     COMPONENT_Y, uiWidth, iTempHeight, 0, 1, false);
#endif
  }
  initTimdIntraPatternLuma(cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0,
                           eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);
  
  int iNum = (int)timdMrgList.size();

  // create and store all predictions
  std::array<bool, EXT_VDIA_IDX + 1> predDone;
  predDone.fill(false);
  std::array<uint64_t, EXT_VDIA_IDX + 1> predCost;
  predCost.fill(MAX_UINT64);

  auto calculateCost = [&](int mode)
  {
    uint64_t uiCostTmp;
    initPredTimdIntraParams(pu, area, mode);
    predTimdIntraAng(COMPONENT_Y, pu, mode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
                     (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
                     (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
    if (eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      uiCostTmp = distParamSad[0].distFunc(distParamSad[0])
                + distParamSad[1].distFunc(distParamSad[1]);
    }
    else if (eTempType == LEFT_NEIGHBOR)
    {
      uiCostTmp = distParamSad[1].distFunc(distParamSad[1]);
    }
    else if (eTempType == ABOVE_NEIGHBOR)
    {
      uiCostTmp = distParamSad[0].distFunc(distParamSad[0]);
    }
    else
    {
      CHECK(true, "At least one template side must be available.");
    }
    return uiCostTmp;
  };

  const bool isEncoder = cu.cs->pcv->isEncoder;
  auto getCost = [&](int mode)
  {
    uint64_t cost;
    if (isEncoder && g_timdMrgCost[mode] != MAX_UINT64)
    {
      cost = g_timdMrgCost[mode];
    }
#if JVET_AK0059_MDIP
    else if (isEncoder && g_intraModeCost[mode] != MAX_UINT64)
    {
      cost = g_intraModeCost[mode];
    }
#endif
    else
    {
      cost = calculateCost(mode);
    }

    predCost[mode] = cost;
    predDone[mode] = true;
  };

  for (int iMode = 0; iMode < iNum; iMode++)
  {
    const int (&modes)[TIMD_FUSION_NUM] = timdMrgList[iMode].timdMode;
    if (!predDone[modes[0]])
    {
      getCost(modes[0]);
    }
  }

  /* -----------------------------------------------------------------
   ----------- Sort neighbour cands by weighted sum -----------
   ------------- of their individual modes' template cost -------------
   ----------------------------------------------------------------- */
  for (int iMode = 0; iMode < iNum; iMode++)
  {
    int mode1 = timdMrgList[iMode].timdMode[0];
    const uint64_t uiCost = predCost[mode1];
    updateCandList(iMode, uiCost, uiModeList, candCostList, NUM_TIMD_MERGE_MODES + 1);
  }
  if (uiModeList.size() > 1 && candCostList.size() > 1 && uiModeList[0] >= 0 && uiModeList[1] >= 0 && candCostList[1] < 1.1 * candCostList[0])
  {
    std::swap(uiModeList[0], uiModeList[1]);
    std::swap(candCostList[0], candCostList[1]);
  }
  return;
}
void IntraPrediction::genTimdMrgList(
    const CodingUnit &cu,
    const static_vector<const CodingUnit*, NUM_TIMD_MERGE_CUS> &cuNeighbours,
    static_vector<TimdMergeInfo, NUM_TIMD_MERGE_CUS> &timdMrgList)
{
  /* -----------------------------------------------------------------
   ------------------- Build Timd-Merge list     ------------------
   --------------------- from remaining neighbours --------------------
   ----------------------------------------------------------------- */
  for (int i = 0; i < cuNeighbours.size(); i++)
  {
    if (cuNeighbours[i]->timdMrg)
    {
      for (int k = 0; k < NUM_TIMD_MERGE_MODES; k++)
      {
        bool isThere = false;
        for (int idx = 0; idx < timdMrgList.size(); idx++)
        {
          if (timdMrgList[idx].timdMode[0] == cuNeighbours[i]->timdMrgList[k][0] && timdMrgList[idx].timdMode[1] == cuNeighbours[i]->timdMrgList[k][1])
          {
            isThere = true;
            break;
          }
        }
        if (!isThere && cuNeighbours[i]->timdMrgList[k][0] != INVALID_TIMD_IDX)
        {
          TimdMergeInfo m = TimdMergeInfo();
          m.timdMode[0] = cuNeighbours[i]->timdMrgList[k][0];
          m.timdMode[1] = cuNeighbours[i]->timdMrgList[k][1];
          m.timdMode[2] = cuNeighbours[i]->timdMrgList[k][2];
          m.timdFusionWeight[0] = cuNeighbours[i]->timdMrgFusionWeight[k][0];
          m.timdFusionWeight[1] = cuNeighbours[i]->timdMrgFusionWeight[k][1];
          m.timdFusionWeight[2] = cuNeighbours[i]->timdMrgFusionWeight[k][2];
          m.timdModeCheckWA[0] = true;
          m.timdModeCheckWA[1] = true;
          m.timdModeCheckWA[2] = true;
          m.timdIsBlended = cuNeighbours[i]->timdMrgIsBlended[k];
          m.timdLocDep[0] = cuNeighbours[i]->timdMrgLocDep[k][0];
          m.timdLocDep[1] = cuNeighbours[i]->timdMrgLocDep[k][1];
          m.timdLocDep[2] = cuNeighbours[i]->timdMrgLocDep[k][2];
          m.timdmTrType[0] = !CS::isDualITree(*cu.cs) ? TransType::DCT2 : cuNeighbours[i]->timdmTrType[k][0];
          m.timdmTrType[1] = !CS::isDualITree(*cu.cs) ? TransType::DCT2 : cuNeighbours[i]->timdmTrType[k][1];
          timdMrgList.push_back(m);
        }
      }
    }
#if JVET_AJ0146_TIMDSAD
    else if (cuNeighbours[i]->timdSad)
    {
      bool isThere = false;
      for (int idx = 0; idx < timdMrgList.size(); idx++)
      {
        if (timdMrgList[idx].timdMode[0] == cuNeighbours[i]->timdModeSad && timdMrgList[idx].timdMode[1] == cuNeighbours[i]->timdModeSecondarySad)
        {
          isThere = true;
          break;
        }
      }
      if (!isThere && cuNeighbours[i]->timdModeSad != INVALID_TIMD_IDX)
      {
        TimdMergeInfo m = TimdMergeInfo();
        m.timdMode[0] = cuNeighbours[i]->timdModeSad;
        m.timdMode[1] = cuNeighbours[i]->timdModeSecondarySad;
        m.timdMode[2] = cuNeighbours[i]->timdModeNonAngSad;
        m.timdFusionWeight[0] = cuNeighbours[i]->timdFusionWeightSad[0];
        m.timdFusionWeight[1] = cuNeighbours[i]->timdFusionWeightSad[1];
        m.timdFusionWeight[2] = cuNeighbours[i]->timdFusionWeightSad[2];
        m.timdModeCheckWA[0] = true;
        m.timdModeCheckWA[1] = true;
        m.timdModeCheckWA[2] = true;
        m.timdLocDep[0] = cuNeighbours[i]->timdLocDepSad[0];
        m.timdLocDep[1] = cuNeighbours[i]->timdLocDepSad[1];
        m.timdLocDep[2] = cuNeighbours[i]->timdLocDepSad[2];
        m.timdIsBlended = cuNeighbours[i]->timdIsBlendedSad;
        m.timdmTrType[0] = !CS::isDualITree(*cu.cs) ? TransType::DCT2 : cuNeighbours[i]->timdmTrType[NUM_TIMD_MERGE_MODES][0];
        m.timdmTrType[1] = !CS::isDualITree(*cu.cs) ? TransType::DCT2 : cuNeighbours[i]->timdmTrType[NUM_TIMD_MERGE_MODES][1];
        timdMrgList.push_back(m);
      }
    }
#endif
    else
    {
      bool isThere = false;
      for (int idx = 0; idx < timdMrgList.size(); idx++)
      {
        if (timdMrgList[idx].timdMode[0] == cuNeighbours[i]->timdMode && timdMrgList[idx].timdMode[1] == cuNeighbours[i]->timdModeSecondary)
        {
          isThere = true;
          break;
        }
      }
      if (!isThere)
      {
        TimdMergeInfo m = TimdMergeInfo();
        m.timdMode[0] = cuNeighbours[i]->timdMode;
        m.timdMode[1] = cuNeighbours[i]->timdModeSecondary;
        m.timdMode[2] = cuNeighbours[i]->timdModeNonAng;
        m.timdFusionWeight[0] = cuNeighbours[i]->timdFusionWeight[0];
        m.timdFusionWeight[1] = cuNeighbours[i]->timdFusionWeight[1];
        m.timdFusionWeight[2] = cuNeighbours[i]->timdFusionWeight[2];
        m.timdModeCheckWA[0] = true;
        m.timdModeCheckWA[1] = true;
        m.timdModeCheckWA[2] = true;
        m.timdLocDep[0] = cuNeighbours[i]->timdLocDep[0];
        m.timdLocDep[1] = cuNeighbours[i]->timdLocDep[1];
        m.timdLocDep[2] = cuNeighbours[i]->timdLocDep[2];
        m.timdIsBlended = cuNeighbours[i]->timdIsBlended;
        m.timdmTrType[0] = !CS::isDualITree(*cu.cs) ? TransType::DCT2 : cuNeighbours[i]->timdmTrType[NUM_TIMD_MERGE_MODES][0];
        m.timdmTrType[1] = !CS::isDualITree(*cu.cs) ? TransType::DCT2 : cuNeighbours[i]->timdmTrType[NUM_TIMD_MERGE_MODES][1];
        timdMrgList.push_back(m);
      }
    }
  }
  return;
}
void IntraPrediction::deriveTimdMergeModes(const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu)
{
  /* -----------------------------------------------------------------------------------
  Step 1: Collect adjacent neighbour cands
  Step 2: Collect non-adjacent neighbour cands
  Step 3: Sort neighbours by distance
  Step 4: Build Timd-Merge list from remaining neighbours
  Step 5: Compute template cost of individual modes in the merge list
  Step 6: Sort neighbour cands by weighted sum of their individual modes' template cost
  Step 7: Store best neighbour cands in CU
  ------------------------------------------------------------------------------------ */
  cu.timdMrgCand = 0;
  for (int i = 0; i < NUM_TIMD_MERGE_MODES; i++)
  {
    cu.timdMrgIsBlended[i] = false;
    for (int j = 0; j < TIMD_FUSION_NUM; j++)
    {
      cu.timdMrgList[i][j] = INVALID_TIMD_IDX;
      cu.timdMrgFusionWeight[i][j] = -1;
      cu.timdMrgModeCheckWA[i][j] = true;
      cu.timdMrgLocDep[i][j] = 0;
    }
  }
  if (!cu.slice->getSPS()->getUseTimd())
  {
    return;
  }
  
  SizeType uiWidth         = cu.lwidth();
  SizeType uiHeight        = cu.lheight();
  int      iCurX = cu.lx();
  int      iCurY = cu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;
  int      iTempWidth = 1, iTempHeight = 1;
  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
                                                                 iRefY, uiRefWidth, uiRefHeight);
  if (eTempType == NO_NEIGHBOR)
  {
    return;
  }
  static_vector<const CodingUnit*, NUM_TIMD_MERGE_CUS> cuNeighbours;
  static_vector<TimdMergeInfo, NUM_TIMD_MERGE_CUS> timdMrgList;
  searchTimdMrgCus(cu, cuNeighbours);
  cu.timdMrgCand = (int)cuNeighbours.size();
  genTimdMrgList(cu, cuNeighbours, timdMrgList);

  if (!timdMrgList.size())
  {
    return;
  }
  if (timdMrgList.size() == 1)
  {
    std::memcpy(cu.timdMrgList[0], timdMrgList[0].timdMode, TIMD_FUSION_NUM * sizeof(int));
    std::memcpy(cu.timdMrgFusionWeight[0], timdMrgList[0].timdFusionWeight, TIMD_FUSION_NUM * sizeof(int));
    std::memcpy(cu.timdMrgLocDep[0], timdMrgList[0].timdLocDep, TIMD_FUSION_NUM * sizeof(int8_t));
    std::memcpy(cu.timdmTrType[0], timdMrgList[0].timdmTrType, 2 * sizeof(int));
    std::memcpy(cu.timdMrgModeCheckWA[0], timdMrgList[0].timdModeCheckWA, TIMD_FUSION_NUM * sizeof(bool));
    cu.timdMrgIsBlended[0] = timdMrgList[0].timdIsBlended;
    return;
  }
  /* -----------------------------------------------------------------
  ------------------- Compute template cost  -----------------
  ----------------- individual modes in the merge list ---------------
  ----------------------------------------------------------------- */
  static_vector<int, NUM_TIMD_MERGE_MODES + 1> uiModeList;
  static_vector<uint64_t, NUM_TIMD_MERGE_MODES + 1> uiCostList;
  calcTimdMrgCandCosts(cu, timdMrgList, uiModeList, uiCostList);
  
  /* -----------------------------------------------------------------
  -------------- Store best neighbour cands in CU ------------
  ----------------------------------------------------------------- */
  for (int i = 0; i < NUM_TIMD_MERGE_MODES; i++)
  {
    if (uiModeList[i] < 0)
    {
      break;
    }
    std::memcpy(cu.timdMrgList[i], timdMrgList[uiModeList[i]].timdMode, TIMD_FUSION_NUM * sizeof(int));
    std::memcpy(cu.timdMrgFusionWeight[i], timdMrgList[uiModeList[i]].timdFusionWeight, TIMD_FUSION_NUM * sizeof(int));
    std::memcpy(cu.timdMrgLocDep[i], timdMrgList[uiModeList[i]].timdLocDep, TIMD_FUSION_NUM * sizeof(int8_t));
    std::memcpy(cu.timdmTrType[i], timdMrgList[uiModeList[i]].timdmTrType, 2 * sizeof(int));
    std::memcpy(cu.timdMrgModeCheckWA[i], timdMrgList[uiModeList[i]].timdModeCheckWA, TIMD_FUSION_NUM * sizeof(bool));
    cu.timdMrgIsBlended[i] = timdMrgList[uiModeList[i]].timdIsBlended;
  }
}
#endif

#if JVET_AH0076_OBIC
  void IntraPrediction::deriveObicMode( const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu )
  {
    /* -------------------------------------------------------------------
    Step 1: Collect adjacent neighbour cands
    Step 2: Collect non-adjacent neighbour cands
    Step 3: Sort neighbours by distance
    Step 4: Build Histogram of oCcurrence (HoC) from remaining neighbours
    Step 5: Get top 6 amplitudes from the HoC
    Step 6: Compute the fusion weights from amplitudes and store in CU
    ---------------------------------------------------------------------- */

    cu.obicIsBlended = false;
    for (int i = 0; i < OBIC_FUSION_NUM; i++)
    {
      cu.obicMode[i] = -1;
      cu.obicFusionWeight[i] = 0;
    }
    
    int histogram[NUM_LUMA_MODE];
#if JVET_AK0056_WEIGHTED_OBIC
    int histoLocDep[NUM_LUMA_MODE][3];
#endif
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      histogram[i] = 0;
#if JVET_AK0056_WEIGHTED_OBIC
      for(int j=0 ; j<3 ; j++)
      {
        histoLocDep[i][j] = 0;
      }
#endif
    }
    const int step = 4;
    const int numCUs = NUM_OBIC_CUS;
    const CodingUnit* cuNeighbours[numCUs];

    /* -----------------------------------------------------------------
    ----------- Step 1: Collect adjacent neighbour cands ---------------
    ----------------------------------------------------------------- */

    cuNeighbours[0] = cu.cs->getCURestricted(cu.lumaPos().offset(-1, 0), cu, CH_L);
    cuNeighbours[1] = cu.cs->getCURestricted(cu.lumaPos().offset(0, -1), cu, CH_L);
    cuNeighbours[2] = cu.cs->getCURestricted(cu.lumaPos().offset(-1, -1), cu, CH_L);
    
    const CodingUnit* cuTemp;
    for (int i = 0; i <= cu.lheight(); i += step)
    {
      cuTemp = cu.cs->getCURestricted(cu.lumaPos().offset(-1, i), cu, CH_L);
      if (cuTemp && CU::isIntra(*cuTemp))
      {
        cuNeighbours[0] = cuTemp;
        break;
      }
    }
    for (int i = 0; i <= cu.lwidth(); i += step)
    {
      cuTemp = cu.cs->getCURestricted(cu.lumaPos().offset(i, -1), cu, CH_L);
      if (cuTemp && CU::isIntra(*cuTemp))
      {
        cuNeighbours[1] = cuTemp;
        break;
      }
    }
    
    const CodingUnit* cuLeft = cu.cs->getCURestricted(cu.lumaPos().offset(-1, 0), cu, CH_L);
    const CodingUnit* cuTop  = cu.cs->getCURestricted(cu.lumaPos().offset(0, -1), cu, CH_L);
    cuNeighbours[3] = cuLeft ? cu.cs->getCURestricted(cuLeft->lumaPos().offset(cuLeft->lwidth()-1, cuLeft->lheight()), cu, CH_L) : NULL;
    cuNeighbours[4] = cuTop ? cu.cs->getCURestricted(cuTop->lumaPos().offset(cuTop->lwidth(), cuTop->lheight() - 1), cu, CH_L) : NULL;
    cuNeighbours[5] = cuNeighbours[3] ? cu.cs->getCURestricted(cuNeighbours[3]->lumaPos().offset(cuNeighbours[3]->lwidth()-1, cuNeighbours[3]->lheight()), cu, CH_L) : NULL;
    cuNeighbours[6] = cuNeighbours[4] ? cu.cs->getCURestricted(cuNeighbours[4]->lumaPos().offset(cuNeighbours[4]->lwidth(), cuNeighbours[4]->lheight() - 1), cu, CH_L) : NULL;
    cuNeighbours[7] = cuLeft ? cu.cs->getCURestricted(cuLeft->lumaPos().offset(-1, 0), cu, CH_L) : NULL;
    cuNeighbours[8] = cuTop ? cu.cs->getCURestricted(cuTop->lumaPos().offset(0, -1), cu, CH_L) : NULL;
    cuNeighbours[9] = cuNeighbours[3] ? cu.cs->getCURestricted(cuNeighbours[3]->lumaPos().offset(-1, 0), cu, CH_L) : NULL;
    cuNeighbours[10] = cuNeighbours[4] ? cu.cs->getCURestricted(cuNeighbours[4]->lumaPos().offset(0, -1), cu, CH_L) : NULL;
    cuNeighbours[11] = cuNeighbours[5] ? cu.cs->getCURestricted(cuNeighbours[5]->lumaPos().offset(-1, 0), cu, CH_L) : NULL;
    cuNeighbours[12] = cuNeighbours[6] ? cu.cs->getCURestricted(cuNeighbours[6]->lumaPos().offset(0, -1), cu, CH_L) : NULL;
    
    if ((!cuNeighbours[9]) && cuNeighbours[2])
    {
      cuNeighbours[9] = cu.cs->getCURestricted(cuNeighbours[2]->lumaPos().offset(-1, cuNeighbours[2]->lheight()-1), cu, CH_L);
    }
    if ((!cuNeighbours[10]) && cuNeighbours[2])
    {
      cuNeighbours[10] = cu.cs->getCURestricted(cuNeighbours[2]->lumaPos().offset(cuNeighbours[2]->lwidth()-1, -1), cu, CH_L);
    }
    if ((!cuNeighbours[11]) && cuLeft && cuNeighbours[7])
    {
      cuNeighbours[11] = cu.cs->getCURestricted(cuNeighbours[7]->lumaPos().offset(-1, 0), cu, CH_L);
    }
    if ((!cuNeighbours[12]) && cuTop && cuNeighbours[8])
    {
      cuNeighbours[12] = cu.cs->getCURestricted(cuNeighbours[8]->lumaPos().offset(0, -1), cu, CH_L);
    }
    
    /* -----------------------------------------------------------------
    ---------- Step 2: Collect non-adjacent neighbour cands-------------
    ----------------------------------------------------------------- */

    const Position  topLeft = area.topLeft();
    int       offsetX           = 0;
    int       offsetY           = 0;
    int       cout              = 13;
    const int numNACandidate[4] = { 3, 5, 5, 5 };
    const int idxMap[4][5]      = { { 0, 1, 4 }, { 0, 1, 2, 3, 4 }, { 0, 1, 2, 3, 4 }, { 0, 1, 2, 3, 4 } };
    for (int iDistanceIndex = 0; iDistanceIndex < NADISTANCE_LEVEL; iDistanceIndex++)
    {
      const int iNADistanceHor = cu.Y().width * (iDistanceIndex + 1);
      const int iNADistanceVer = cu.Y().height * (iDistanceIndex + 1);
      for (int iNASPIdx = 0; iNASPIdx < numNACandidate[iDistanceIndex]; iNASPIdx++)
      {
        switch (idxMap[iDistanceIndex][iNASPIdx])
        {
          case 0: offsetX = -iNADistanceHor - 1; offsetY = cu.Y().height + iNADistanceVer - 1; break;
          case 1: offsetX = cu.Y().width + iNADistanceHor - 1; offsetY = -iNADistanceVer - 1; break;
          case 2: offsetX = cu.Y().width >> 1; offsetY = -iNADistanceVer - 1; break;
          case 3: offsetX = -iNADistanceHor - 1; offsetY = cu.Y().height >> 1; break;
          case 4: offsetX = -iNADistanceHor - 1; offsetY = -iNADistanceVer - 1; break;
          default: printf("error!"); exit(0); break;
        }
        cuNeighbours[cout++] = cu.cs->getCURestricted(topLeft.offset(offsetX, offsetY), cu, CH_L);
      }
    }

    /* -----------------------------------------------------------------
    ---------------- Step 3: Sort neighbours by distance ---------------
    ----------------------------------------------------------------- */

    int limitMaxNeigh = 20;
    bool useNeighbour[numCUs];
    int  neighboursInDistOrder[numCUs];
    int  dists[numCUs];
    for (int i = 0; i < numCUs; i++)
    {
      useNeighbour[i] = false;
      neighboursInDistOrder[i] = 0;
      dists[i] = 0;
    }
    for (int i = 0; i < numCUs; i++)
    {
      dists[i] = MAX_INT;
    }
    int numToMix = 0;
    for (int i = 0; i < numCUs; i++)
    {
#if JVET_AK0056_WEIGHTED_OBIC
      useNeighbour[i] = (cuNeighbours[i] && (CU::isIntra(*cuNeighbours[i])|| CU::isInter(*cuNeighbours[i])));
      bool useInter = false;
      if (cuNeighbours[i] && (CU::isInter(*cuNeighbours[i])))
      {
        if (cuNeighbours[i]->geoFlag)
        {
          int ipm = g_geoAngle2IntraAng[g_geoParams[cuNeighbours[i]->firstPU->geoSplitDir][0]];
          if (ipm > PLANAR_IDX && ipm < NUM_LUMA_MODE)
          {
            useInter = true;
          }
        }
        else
        {
          int step = 4;
          for (int m = 0; m < cuNeighbours[i]->lwidth(); m += step)
          {
            for (int n = 0; n < cuNeighbours[i]->lheight(); n += step)
            {
              int ipm = cuNeighbours[i]->firstPU->getIpmInfo(cuNeighbours[i]->Y().offset(m, n));
              if (ipm > PLANAR_IDX && ipm < NUM_LUMA_MODE)
              {
                useInter = true;
                break;
              }
            }
            if (useInter == true)
            {
              break;
            }
          }
        }
        useNeighbour[i] &= useInter;
      }
#else
      useNeighbour[i] = (cuNeighbours[i] && CU::isIntra(*cuNeighbours[i]));
#endif
      if (useNeighbour[i])
      {
        for (int j = i-1; j >= 0; j--)
        {
          if (!useNeighbour[j])
          {
            continue;
          }
          useNeighbour[i] &= (cuNeighbours[i]->lx() != cuNeighbours[j]->lx() || cuNeighbours[i]->ly() != cuNeighbours[j]->ly());
        }
      }
      int curNeigh = i;
      int curDist = (useNeighbour[i] ? abs( (int)(cu.lx()) - (int)(cuNeighbours[i]->lx())) + abs( (int)(cu.ly()) - (int)(cuNeighbours[i]->ly())) : 0);
      
      for (int j = 0; j < numCUs; j++)
      {
        if (curDist < dists[j])
        {
          for (int k = numCUs - 1; k > j; k--)
          {
            dists[k] = dists[k - 1];
            neighboursInDistOrder[k] = neighboursInDistOrder[k - 1];
          }
          dists[j] = curDist;
          neighboursInDistOrder[j] = curNeigh;
          break;
        }
      }
    }
    for (int i = 0; i < numCUs; i++)
    {
      int j = neighboursInDistOrder[i];
      if (limitMaxNeigh > 0 && numToMix >= limitMaxNeigh)
      {
        useNeighbour[j] = false;
        continue;
      }
      if (useNeighbour[j])
      {
        numToMix ++;
      }
    }
    

     /* -----------------------------------------------------------------
     --------------------------- Step 4: --------------------------------
     ---------------- Build Histogram of oCcurrence (HoC) ---------------
     --------------------- from remaining neighbours --------------------
     ----------------------------------------------------------------- */


    for (int i = 0; i < numCUs; i++)
    {
      if (!useNeighbour[i])
      {
        continue;
      }
#if JVET_AK0056_WEIGHTED_OBIC
      const int weight[NUM_OBIC_CUS]={4, 4, 4, 4, 4,   4, 4, 4, 4, 4,  4, 4, 4, 2, 2, 2,2, 2, 2, 2, 2,1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
      const int numSamples = (weight[i]*(cuNeighbours[i]->lumaSize().width * cuNeighbours[i]->lumaSize().height)+2)/4;
#else
      int numSamples = cuNeighbours[i]->lumaSize().width * cuNeighbours[i]->lumaSize().height;
#endif
      if (cuNeighbours[i]->timd
#if JVET_AJ0061_TIMD_MERGE
          && !cuNeighbours[i]->timdMrg
#endif
#if JVET_AJ0146_TIMDSAD
          && !cuNeighbours[i]->timdSad
#endif
          )
      {
        int m = MAP131TO67(cuNeighbours[i]->timdMode);
#if JVET_AK0056_WEIGHTED_OBIC
        int w[3] = {0};
        w[0] = cuNeighbours[i]->timdFusionWeight[0];
        w[1] = (cuNeighbours[i]->timdIsBlended && (cuNeighbours[i]->timdFusionWeight[1] > 0)) ? cuNeighbours[i]->timdFusionWeight[1] : 0;
        w[2] = (cuNeighbours[i]->timdIsBlended && (cuNeighbours[i]->timdFusionWeight[2] > 0)) ? cuNeighbours[i]->timdFusionWeight[2] : 0;
        histoLocDep[m][cuNeighbours[i]->timdLocDep[0]] += numSamples;
#else
        histogram[m] += numSamples;
#endif

#if JVET_AK0056_WEIGHTED_OBIC
      if (cuNeighbours[i]->timdIsBlended && cuNeighbours[i]->timdFusionWeight[1] > 0 && (cuNeighbours[i]->timdMode != cuNeighbours[i]->timdModeSecondary) )
#else
        if (cuNeighbours[i]->timdIsBlended && cuNeighbours[i]->timdFusionWeight[1] > 0)
#endif
        {
          int m = MAP131TO67(cuNeighbours[i]->timdModeSecondary);
#if JVET_AK0056_WEIGHTED_OBIC
          CHECK(!w[0], "Division by zero!");
          histoLocDep[m][cuNeighbours[i]->timdLocDep[1]] += numSamples * w[1] / w[0];
#else
          histogram[m] += numSamples;
#endif
          if (cuNeighbours[i]->timdFusionWeight[2] > 0)
          {
            int m = MAP131TO67(cuNeighbours[i]->timdModeNonAng);
#if JVET_AK0056_WEIGHTED_OBIC
            histoLocDep[m][cuNeighbours[i]->timdLocDep[2]] += numSamples * w[2] / w[0];
#else
            histogram[m] += numSamples;
#endif
          }
        }
      }
#if JVET_AJ0061_TIMD_MERGE
      else if (cuNeighbours[i]->timdMrg)
      {
        int m = MAP131TO67(cuNeighbours[i]->timdMrgList[cuNeighbours[i]->timdMrg - 1][0]);
#if JVET_AK0056_WEIGHTED_OBIC
        int w[3] = {0};
        w[0] = cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][0];
        w[1] = (cuNeighbours[i]->timdMrgIsBlended[cuNeighbours[i]->timdMrg - 1] && (cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][1] > 0)) ? cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][1] : 0;
        w[2] = (cuNeighbours[i]->timdMrgIsBlended[cuNeighbours[i]->timdMrg - 1] && (cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][2] > 0)) ? cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][2] : 0;
        histoLocDep[m][cuNeighbours[i]->timdMrgLocDep[cuNeighbours[i]->timdMrg - 1][0]] += numSamples;
#else
        histogram[m] += numSamples;
#endif
#if JVET_AK0056_WEIGHTED_OBIC
        if (cuNeighbours[i]->timdMrgIsBlended[cuNeighbours[i]->timdMrg - 1] && cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][1] > 0 && (cuNeighbours[i]->timdMrgList[cuNeighbours[i]->timdMrg - 1][0] != cuNeighbours[i]->timdMrgList[cuNeighbours[i]->timdMrg - 1][1]))
#else
        if (cuNeighbours[i]->timdMrgIsBlended[cuNeighbours[i]->timdMrg - 1] && cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][1] > 0)
#endif
        {
          int m = MAP131TO67(cuNeighbours[i]->timdMrgList[cuNeighbours[i]->timdMrg - 1][1]);
#if JVET_AK0056_WEIGHTED_OBIC
          CHECK(!w[0], "Division by zero!");
          histoLocDep[m][cuNeighbours[i]->timdMrgLocDep[cuNeighbours[i]->timdMrg - 1][1]] += numSamples * w[1] / w[0];
#else
          histogram[m] += numSamples;
#endif
          if (cuNeighbours[i]->timdMrgFusionWeight[cuNeighbours[i]->timdMrg - 1][2] > 0)
          {
            int m = MAP131TO67(cuNeighbours[i]->timdMrgList[cuNeighbours[i]->timdMrg - 1][2]);
#if JVET_AK0056_WEIGHTED_OBIC
            histoLocDep[m][cuNeighbours[i]->timdMrgLocDep[cuNeighbours[i]->timdMrg - 1][2]] += numSamples * w[2] / w[0];
#else
            histogram[m] += numSamples;
#endif
          }
        }
      }
#endif
#if JVET_AJ0146_TIMDSAD
      else if (cuNeighbours[i]->timdSad)
      {
        int m = MAP131TO67(cuNeighbours[i]->timdModeSad);
#if JVET_AK0056_WEIGHTED_OBIC
        int w[3] = {0};
        w[0] = cuNeighbours[i]->timdFusionWeightSad[0];
        w[1] = (cuNeighbours[i]->timdIsBlendedSad && (cuNeighbours[i]->timdFusionWeightSad[1] > 0)) ? cuNeighbours[i]->timdFusionWeightSad[1] : 0;
        w[2] = (cuNeighbours[i]->timdIsBlendedSad && (cuNeighbours[i]->timdFusionWeightSad[2] > 0)) ? cuNeighbours[i]->timdFusionWeightSad[2] : 0;
        histoLocDep[m][cuNeighbours[i]->timdLocDepSad[0]] += numSamples;
#else
        histogram[m] += numSamples;
#endif
#if JVET_AK0056_WEIGHTED_OBIC
        if (cuNeighbours[i]->timdIsBlendedSad && cuNeighbours[i]->timdFusionWeightSad[1] > 0 && (cuNeighbours[i]->timdModeSad != cuNeighbours[i]->timdModeSecondarySad) )
#else
        if (cuNeighbours[i]->timdIsBlendedSad && cuNeighbours[i]->timdFusionWeightSad[1] > 0)
#endif
        {
          int m = MAP131TO67(cuNeighbours[i]->timdModeSecondarySad);
#if JVET_AK0056_WEIGHTED_OBIC
          CHECK(!w[0], "Division by zero!");
          histoLocDep[m][cuNeighbours[i]->timdLocDepSad[1]] += numSamples * w[1] / w[0];
#else
          histogram[m] += numSamples;
#endif
          if (cuNeighbours[i]->timdFusionWeightSad[2] > 0)
          {
            int m = MAP131TO67(cuNeighbours[i]->timdModeNonAngSad);
#if JVET_AK0056_WEIGHTED_OBIC
            histoLocDep[m][cuNeighbours[i]->timdLocDepSad[2]] += numSamples * w[2] / w[0];
#else
            histogram[m] += numSamples;
#endif
          }
        }
      }
#endif
      else if (cuNeighbours[i]->dimd && !cuNeighbours[i]->obicFlag)
      {
        int m = cuNeighbours[i]->dimdMode;
#if JVET_AK0056_WEIGHTED_OBIC
        int w[DIMD_FUSION_NUM] = {0};
        w[0] = cuNeighbours[i]->dimdRelWeight[0];
        w[1] = (cuNeighbours[i]->dimdRelWeight[1] > 0) ? cuNeighbours[i]->dimdRelWeight[1] : 0;
        for(int j = 2; j < DIMD_FUSION_NUM ; j++)
        {
          w[j] = (cuNeighbours[i]->dimdBlending && (cuNeighbours[i]->dimdRelWeight[j] > 0)) ? cuNeighbours[i]->dimdRelWeight[j] : 0;
        }
#endif
        if (m >= 0 && m < NUM_LUMA_MODE)
        {
#if JVET_AK0056_WEIGHTED_OBIC
          histoLocDep[m][cuNeighbours[i]->dimdLocDep[0]] += numSamples;
#else
          histogram[m] += numSamples;
#endif
        }
#if JVET_AK0056_WEIGHTED_OBIC
        if (cuNeighbours[i]->dimdRelWeight[1] > 0)
        {
          CHECK(!w[0], "Division by zero!");
          histoLocDep[0][0] += numSamples * w[1] / w[0];
        }
#endif
        if (cuNeighbours[i]->dimdBlending)
        {
#if JVET_AK0056_WEIGHTED_OBIC
          for (int idx = 0; idx < DIMD_FUSION_NUM - 2; idx++)
          {
            m = cuNeighbours[i]->dimdBlendMode[idx];
            if (m >= 0 && m < NUM_LUMA_MODE && cuNeighbours[i]->dimdRelWeight[idx + 2] > 0)
            {
              CHECK(!w[0], "Division by zero!");
              histoLocDep[m][cuNeighbours[i]->dimdLocDep[idx+1]] += numSamples * w[idx + 2] / w[0];
#else
          for (int idx = 0; idx < DIMD_FUSION_NUM - 1; idx++)
          {
            m = cuNeighbours[i]->dimdBlendMode[idx];
            if (m >= 0 && m < NUM_LUMA_MODE && cuNeighbours[i]->dimdRelWeight[idx + 1] > 0)
            {
              histogram[m] += numSamples;
#endif
            }
          }
        }
      }
      else if (cuNeighbours[i]->dimd && cuNeighbours[i]->obicFlag)
      {
        int m = cuNeighbours[i]->obicMode[0];
#if JVET_AK0056_WEIGHTED_OBIC
        histoLocDep[m][cuNeighbours[i]->obicLocDep[0]] += numSamples;
#else
        histogram[m] += numSamples;
#endif
        if (cuNeighbours[i]->obicIsBlended)
        {
          for (int idx = 1; idx < OBIC_FUSION_NUM; idx++)
          {
            m = cuNeighbours[i]->obicMode[idx];
            if (m >= 0 && cuNeighbours[i]->obicFusionWeight[idx] > 0)
            {
#if JVET_AK0056_WEIGHTED_OBIC
              histoLocDep[m][cuNeighbours[i]->obicLocDep[idx]] += numSamples;
#else
              histogram[m] += numSamples;
#endif
            }
          }
        }
      }
      else if (cuNeighbours[i]->sgpm)
      {
        int m1 = cuNeighbours[i]->sgpmMode0;
        int m2 = cuNeighbours[i]->sgpmMode1;
        if (m1 >= 0 && m1 < NUM_LUMA_MODE)
        {
#if JVET_AK0056_WEIGHTED_OBIC
          histoLocDep[m1][0] += numSamples;
#else
          histogram[m1] += numSamples;
#endif
        }
        if (m2 >= 0 && m2 < NUM_LUMA_MODE)
        {
#if JVET_AK0056_WEIGHTED_OBIC
          histoLocDep[m2][0] += numSamples;
#else
          histogram[m2] += numSamples;
#endif
        }
      }
      else if (cuNeighbours[i]->tmrlFlag)
      {
        int m = MAP131TO67(cuNeighbours[i]->firstPU->intraDir[0]);
#if JVET_AK0056_WEIGHTED_OBIC
        histoLocDep[m][0] += numSamples;
#else
        histogram[m] += numSamples;
#endif
      }
#if JVET_AG0058_EIP
      else if (cuNeighbours[i]->eipFlag && cu.slice->getSliceType() != I_SLICE)
      {
        int m = cuNeighbours[i]->eipModel.eipDimdMode;
#if JVET_AK0056_WEIGHTED_OBIC
        histoLocDep[m][0] += numSamples;
#else
        histogram[m] += numSamples;
#endif
      }
#endif
#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
      else if (cuNeighbours[i]->tmpFlag && cu.slice->getSliceType() != I_SLICE)
      {
        int m = cuNeighbours[i]->intraTmpDimdMode;
#if JVET_AK0056_WEIGHTED_OBIC
        histoLocDep[m][0] += numSamples;
#else
        histogram[m] += numSamples;
#endif
      }
#endif
#if JVET_AB0067_MIP_DIMD_LFNST
      else if (cuNeighbours[i]->mipFlag && cu.slice->getSliceType() != I_SLICE)
      {
        int m = cuNeighbours[i]->mipDimdMode;
#if JVET_AK0056_WEIGHTED_OBIC
        histoLocDep[m][0] += numSamples;
#else
        histogram[m] += numSamples;
#endif
      }
#endif
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      else if (cuNeighbours[i]->firstPU->intraDir[0] == PNN_IDX)
      {
        const int m = cuNeighbours[i]->indicesRepresentationPnn[COMPONENT_Y][0];
#if JVET_AK0056_WEIGHTED_OBIC
        histoLocDep[m][0] += numSamples;
#else
        histogram[m] += numSamples;
#endif
      }
#endif
      else if (CU::isIntra(*cuNeighbours[i]) && !cuNeighbours[i]->tmpFlag && !cuNeighbours[i]->mipFlag && !cuNeighbours[i]->eipFlag && !CU::isIBC(*cuNeighbours[i]) && !CU::isPLT(*cuNeighbours[i]))
      {
        int m = cuNeighbours[i]->firstPU->intraDir[0];
#if JVET_AK0056_WEIGHTED_OBIC
        histoLocDep[m][0] += numSamples;
#else
        histogram[m] += numSamples;
#endif
      }
#if JVET_AK0056_WEIGHTED_OBIC
      else if (cuNeighbours[i] && (CU::isInter(*cuNeighbours[i])))
      {
        const int step = 4;
        for (int m = 0; m < cuNeighbours[i]->lwidth(); m += step)
        {
          for (int n = 0; n < cuNeighbours[i]->lheight(); n += step)
          {
            int ipm = cuNeighbours[i]->firstPU->getIpmInfo(cuNeighbours[i]->Y().offset(m, n));
            if (cuNeighbours[i]->geoFlag)
            {
              ipm = g_geoAngle2IntraAng[g_geoParams[cuNeighbours[i]->firstPU->geoSplitDir][0]];
            }
            if (ipm >= DC_IDX && ipm < NUM_LUMA_MODE)
            {
              histoLocDep[ipm][0] += (step*step);
            }
          }
        }
      }
#endif
    }
#if JVET_AK0056_WEIGHTED_OBIC
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      for(int j=0 ; j<3 ; j++)
      {
        histogram[i] += histoLocDep[i][j];
      }
    }
#endif
    // Penalize Dimd modes to impose diversity between OBIC and DIMD
    if (cu.dimdMode >= 0 && cu.dimdMode < NUM_LUMA_MODE)
    {
      histogram[cu.dimdMode] >>= 1;
    }
    if (cu.dimdBlending && cu.dimdBlendMode[0] >= 0 && cu.dimdBlendMode[0] < NUM_LUMA_MODE && cu.dimdRelWeight[1] > 0)
    {
      histogram[cu.dimdBlendMode[0]] >>= 1;
    }
    
  /* -----------------------------------------------------------------
  ------------------- Step 5: Get top 6 amplitudes -------------------
  -------------------------- from the HoC ----------------------------
  ----------------------------------------------------------------- */

    int bestModes[OBIC_FUSION_NUM], bestAmps[OBIC_FUSION_NUM];
    for (int i = 0; i < OBIC_FUSION_NUM; i++)
    {
      bestModes[i] = -1;
      bestAmps[i] = 0;
    }
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      int curMode = i;
      if (curMode == PLANAR_IDX)
      {
        continue;
      }
      if (histogram[curMode] > bestAmps[0])
      {
        bestAmps[5] = bestAmps[4];
        bestAmps[4] = bestAmps[3];
        bestAmps[3] = bestAmps[2];
        bestAmps[2] = bestAmps[1];
        bestAmps[1] = bestAmps[0];
        bestAmps[0] = histogram[curMode];
        bestModes[5] = bestModes[4];
        bestModes[4] = bestModes[3];
        bestModes[3] = bestModes[2];
        bestModes[2] = bestModes[1];
        bestModes[1] = bestModes[0];
        bestModes[0] = curMode;
      }
      else if (histogram[curMode] > bestAmps[1])
      {
        bestAmps[5] = bestAmps[4];
        bestAmps[4] = bestAmps[3];
        bestAmps[3] = bestAmps[2];
        bestAmps[2] = bestAmps[1];
        bestAmps[1] = histogram[curMode];
        bestModes[5] = bestModes[4];
        bestModes[4] = bestModes[3];
        bestModes[3] = bestModes[2];
        bestModes[2] = bestModes[1];
        bestModes[1] = curMode;
      }
      else if (histogram[curMode] > bestAmps[2])
      {
        bestAmps[5] = bestAmps[4];
        bestAmps[4] = bestAmps[3];
        bestAmps[3] = bestAmps[2];
        bestAmps[2] = histogram[curMode];
        bestModes[5] = bestModes[4];
        bestModes[4] = bestModes[3];
        bestModes[3] = bestModes[2];
        bestModes[2] = curMode;
      }
      else if (histogram[curMode] > bestAmps[3])
      {
        bestAmps[5] = bestAmps[4];
        bestAmps[4] = bestAmps[3];
        bestAmps[3] = histogram[curMode];
        bestModes[5] = bestModes[4];
        bestModes[4] = bestModes[3];
        bestModes[3] = curMode;
      }
      else if (histogram[curMode] > bestAmps[4])
      {
        bestAmps[5] = bestAmps[4];
        bestAmps[4] = histogram[curMode];
        bestModes[5] = bestModes[4];
        bestModes[4] = curMode;
      }
      else if (histogram[curMode] > bestAmps[5])
      {
        bestAmps[5] = histogram[curMode];
        bestModes[5] = curMode;
      }
    }
    if (bestModes[0] < 0)
    {
      return;
    }

    int count = 0;
    for (int i = 0; i < OBIC_FUSION_NUM; i++)
    {
      count += bestModes[i] >= 0 ? 1 : 0;
    }

#if JVET_AK0056_WEIGHTED_OBIC
//For each selected IPM in the generation of OBIC predictor, associate the dominant LocDep
  for(int i = 0; i < OBIC_FUSION_NUM; i++)
  {
    int secondMode = bestModes[i];
    int bestLocDep[3];
    int bestLocDepAmp[3];
    for(int i = 0; i < 3; i++)
    {
      bestLocDep[i] = -1;
      bestLocDepAmp[i] = 0;
    }
    cu.obicLocDep[i] = 0;
    
    if (secondMode > DC_IDX)
    {
      for(int j=0 ; j<3 ; j++)
      {
        if(histoLocDep[secondMode][j] > bestLocDepAmp[0] )
        {
          bestLocDepAmp[2] = bestLocDepAmp[1];
          bestLocDepAmp[1] = bestLocDepAmp[0];
          bestLocDepAmp[0] = histoLocDep[secondMode][j];
          bestLocDep[2] = bestLocDep[1];
          bestLocDep[1] = bestLocDep[0];
          bestLocDep[0] = j;
        }
        else if(histoLocDep[secondMode][j] > bestLocDepAmp[1] )
        {
          bestLocDepAmp[2] = bestLocDepAmp[1];
          bestLocDepAmp[1] = histoLocDep[secondMode][j];
          bestLocDep[2] = bestLocDep[1];
          bestLocDep[1] = j;
        }
        else if (histoLocDep[secondMode][j] > bestLocDepAmp[2] )
        {
          bestLocDepAmp[2] = histoLocDep[secondMode][j];
          bestLocDep[2] = j;
        }
      }
      cu.obicLocDep[i] = bestLocDep[0];
    }
  }
#endif
    /* -----------------------------------------------------------------
    -------------- Step 6: Compute the fusion weights ------------------
    ---------------- from amplitudes and store in CU -------------------
    ----------------------------------------------------------------- */

    int planarWeight = count == 1 ? 21 : 64/4;
    int log2BlendWeight = 6;
    int sumWeight = (1 << log2BlendWeight);
    if (bestModes[1] < 0)
    {
      cu.obicMode[0] = bestModes[0];
      cu.obicIsBlended = false;
      cu.obicFusionWeight[0] = sumWeight;
      for (int i = 1; i < OBIC_FUSION_NUM; i++)
      {
        cu.obicMode[i] = -1;
        cu.obicFusionWeight[i] = 0;
      }
      cu.obicIsBlended = true;
      cu.obicMode[1] = PLANAR_IDX;
      cu.obicFusionWeight[0] = sumWeight - planarWeight;
      cu.obicFusionWeight[1] = planarWeight;
#if JVET_AK0056_WEIGHTED_OBIC
      cu.obicLocDep[1] = 0;
#endif
    }
    else
    {
      sumWeight = sumWeight - planarWeight;
      if (count == OBIC_FUSION_NUM)
      {
        bestAmps[count - 1] = 0;
      }
      
      int s1 = 0;
      for (int i = 0; i < OBIC_FUSION_NUM; i++)
      {
        bestAmps[i] = 10 * bestAmps[i];
      }
      for (int i = 0; i < OBIC_FUSION_NUM; i++)
      {
        s1 = s1 + bestAmps[i];
      }
      int x = floorLog2(s1);
      CHECK(x < 0, "floor log2 value should be no negative");
      int normS1 = (s1 << 4 >> x) & 15;
      int v = g_gradDivTable[normS1] | 8;
      x += (normS1 != 0);
      int shift = x + 3;
      int add = (1 << (shift - 1));
      int iRatio[OBIC_FUSION_NUM] = { 0 };
      for (int i = 0; i < OBIC_FUSION_NUM; i++)
      {
#if JVET_AK0056_WEIGHTED_OBIC
        iRatio[i] = (int)(( ((uint64_t)bestAmps[i] * (uint64_t) v * (uint64_t) sumWeight + (uint64_t)add)) >> (uint64_t)shift);
#else
        iRatio[i] = (bestAmps[i] * v * sumWeight + add) >> shift;
#endif
        if (bestAmps[i] == 0)
        {
          iRatio[i] = 0;
        }
        if( iRatio[i] > sumWeight )
        {
          iRatio[i] = sumWeight;
        }
        CHECK( iRatio[i] > sumWeight, "Wrong ratio in OBIC" );
      }
      int sumTmp = 0;
      for (int i = 0; i < OBIC_FUSION_NUM; i++)
      {
        sumTmp += iRatio[i];
        cu.obicMode[i] = bestModes[i];
        cu.obicFusionWeight[i] = iRatio[i];
      }
      if (sumTmp != sumWeight)
      {
        int d = sumTmp - sumWeight;
        if (d > 0)
        {
          for (int i = OBIC_FUSION_NUM - 1; i >= 0; i--)
          {
            int diff = d;
            for (int k = 0; k < diff; k++)
            {
              if (cu.obicFusionWeight[i] > 0)
              {
                cu.obicFusionWeight[i] -= 1;
                d -= 1;
              }
            }
          }
        }
        else
        {
          for (int i = 0; i < OBIC_FUSION_NUM; i++)
          {
            int diff = d;
            if (cu.obicFusionWeight[i] > 0 && (cu.obicFusionWeight[i] + d) < sumWeight)
            {
              for (int k = 0; k < abs(diff); k++)
              {
                if (d == 0)
                {
                  break;
                }
                if (cu.obicFusionWeight[i] > 0)
                {
                  cu.obicFusionWeight[i] += 1;
                  d += 1;
                }
              }
            }
          }
        }
      }
      sumTmp = 0;
      for (int i = 0; i < OBIC_FUSION_NUM; i++)
      {
        sumTmp += cu.obicFusionWeight[i];
      }
      CHECK( sumTmp != sumWeight, "Wrong sum!" );
      if (count == OBIC_FUSION_NUM)
      {
        cu.obicMode[count - 1] = PLANAR_IDX;
        cu.obicFusionWeight[count - 1] = planarWeight;
#if JVET_AK0056_WEIGHTED_OBIC
        cu.obicLocDep[count - 1] = 0;
#endif
      }
      else
      {
        cu.obicMode[count] = PLANAR_IDX;
        cu.obicFusionWeight[count] = planarWeight;
#if JVET_AK0056_WEIGHTED_OBIC
        cu.obicLocDep[count] = 0;
#endif
      }
      cu.obicIsBlended = true;
    }
  }
#endif
  
#if JVET_AB0155_SGPM
int IntraPrediction::deriveTimdMode(const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu, bool bFull, bool bHorVer
#if JVET_AJ0146_TIMDSAD
  , bool createList
#endif
)
{
  int      channelBitDepth = cu.slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  SizeType uiWidth         = cu.lwidth();
  SizeType uiHeight        = cu.lheight();

  int      iCurX = cu.lx();
  int      iCurY = cu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;

  int iTempWidth = 4, iTempHeight = 4;
  if (uiWidth <= 8)
  {
    iTempWidth = 2;
  }
  if (uiHeight <= 8)
  {
    iTempHeight = 2;
  }

  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
                                                  iRefY, uiRefWidth, uiRefHeight);
  auto &        pu        = *cu.firstPU;
  uint32_t      uiRealW   = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t      uiRealH   = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, uiRealW, uiRealH));
  uint32_t       uiPredStride = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).stride;
  Pel *piPred = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).buf;
#if JVET_AJ0146_TIMDSAD
  bool isModeAdded[NUM_LUMA_MODE] = { 0 };
#endif
  if (eTempType != NO_NEIGHBOR)
  {
    const CodingStructure &cs = *cu.cs;
    m_ipaParam.multiRefIndex  = iTempWidth;
    Pel *piOrg                = cs.picture->getRecoBuf(area).buf;
    int  iOrgStride           = cs.picture->getRecoBuf(area).stride;
    piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
    DistParam distParamSad[2];   // above, left
    distParamSad[0].applyWeight = false;
    distParamSad[0].useMR       = false;
    distParamSad[1].applyWeight = false;
    distParamSad[1].useMR       = false;
    if (eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
                                       uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1,
                                       true);   // Use HAD (SATD) cost
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
                                       piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
                                       COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);   // Use HAD (SATD) cost
    }
    else if (eTempType == LEFT_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                       COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
    }
    else if (eTempType == ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
                                       COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
    }
    initTimdIntraPatternLuma(cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0,
                             eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);

    uint32_t uiIntraDirNeighbor[5] = { 0 }, modeIdx = 0;

    bool     includedMode[EXT_VDIA_IDX + 1];
    memset(includedMode, false, (EXT_VDIA_IDX + 1) * sizeof(bool));
    auto &   pu      = *cu.firstPU;
    uint32_t uiRealW = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
    uint32_t uiRealH = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
    uint64_t maxCost = (uint64_t)(iTempWidth * cu.lheight() + iTempHeight * cu.lwidth());

    uint64_t uiBestCost      = MAX_UINT64;
    int      iBestMode       = PLANAR_IDX;
    uint64_t uiSecondaryCost = MAX_UINT64;
    int      iSecondaryMode  = PLANAR_IDX;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    uint64_t uiNonAngCost    = MAX_UINT64;
    int      iNonAngMode     = PLANAR_IDX;
    const uint32_t log2A     = floorLog2(iTempHeight) + floorLog2(cu.lwidth());
    const uint32_t log2L     = floorLog2(iTempWidth) + floorLog2(cu.lheight());
#endif
#if JVET_AC0094_REF_SAMPLES_OPT
    bool bBestModeCheckWA      = true;
    bool bSecondaryModeCheckWA = true;
#endif

    uint64_t uiBestCostHor = MAX_UINT64;
    uint64_t uiBestCostVer = MAX_UINT64;
    int      iBestModeHor  = PLANAR_IDX;
    int      iBestModeVer  = PLANAR_IDX;

    const Position posLTx = pu.Y().topLeft();
    const Position posRTx = pu.Y().topRight();
    const Position posLBx = pu.Y().bottomLeft();
#if JVET_AC0094_REF_SAMPLES_OPT
    bool increaseMaxClose = true;
    bool decreaseMinClose = true;
    bool increaseMaxFar   = true;
    bool decreaseMinFar   = true;
#endif

    // left
    const PredictionUnit *puLeftx = pu.cs->getPURestricted(posLBx.offset(-1, 0), pu, pu.chType);
    if (puLeftx && CU::isIntra(*puLeftx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puLeftx);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puLeftx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puLeftx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }

    // above
    const PredictionUnit *puAbovex = pu.cs->getPURestricted(posRTx.offset(0, -1), pu, pu.chType);
    if (puAbovex && CU::isIntra(*puAbovex->cu) && CU::isSameCtu(*pu.cu, *puAbovex->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puAbovex);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puAbovex->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puAbovex->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }

    // below left
    const PredictionUnit *puLeftBottomx = cs.getPURestricted(posLBx.offset(-1, 1), pu, pu.chType);
    if (puLeftBottomx && CU::isIntra(*puLeftBottomx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puLeftBottomx);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puLeftBottomx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puLeftBottomx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }

#if JVET_AC0094_REF_SAMPLES_OPT
    if (!puLeftx)
    {
      decreaseMinClose = false;
    }
    const PredictionUnit *puLeftBottomFarx = cs.getPURestricted(posLBx.offset(-1, uiHeight), pu, pu.chType);
    if (!puLeftBottomFarx)
    {
      decreaseMinFar = false;
    }
#endif

    // above right
    const PredictionUnit *puAboveRightx = cs.getPURestricted(posRTx.offset(1, -1), pu, pu.chType);
    if (puAboveRightx && CU::isIntra(*puAboveRightx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puAboveRightx);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puAboveRightx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puAboveRightx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
#if JVET_AC0094_REF_SAMPLES_OPT
    if (!puAbovex)
    {
      increaseMaxClose = false;
    }
    const PredictionUnit *puAboveRightFarx = cs.getPURestricted(posRTx.offset(uiWidth, -1), pu, pu.chType);
    if (!puAboveRightFarx)
    {
      increaseMaxFar = false;
    }
#endif
    // above left
    const PredictionUnit *puAboveLeftx = cs.getPURestricted(posLTx.offset(-1, -1), pu, pu.chType);
    if (puAboveLeftx && CU::isIntra(*puAboveLeftx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puAboveLeftx);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puAboveLeftx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puAboveLeftx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }

#if JVET_AG0092_ENHANCED_TIMD_FUSION
    if (bFull)
    {
      for (int iMode = 0; iMode <= 1; iMode++)
      {
        uint64_t uiCost = 0;
        uint64_t tmpCost0 = 0;
        uint64_t tmpCost1 = 0;
        initPredTimdIntraParams(pu, area, iMode);
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
                          (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
                          (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
        if (eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else if (eTempType == ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        }
        else if (eTempType == LEFT_NEIGHBOR)
        {
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else
        {
          CHECK( true, "invalid case" );
        }

        uiCost = tmpCost0 + tmpCost1;

        if (uiCost < uiBestCost)
        {
          uiSecondaryCost = uiBestCost;
          iSecondaryMode  = iBestMode;
          uiBestCost      = uiCost;
          iBestMode       = iMode;
          uiNonAngCost    = uiCost;
          iNonAngMode     = iMode;
          cu.timdLocDep[1] = cu.timdLocDep[0];
          cu.timdLocDep[0] = (eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0;
          cu.timdLocDep[TIMD_FUSION_NUM - 1] = cu.timdLocDep[0];
        }
        else if(uiCost < uiSecondaryCost)
        {
          uiSecondaryCost = uiCost;
          iSecondaryMode  = iMode;
          cu.timdLocDep[1] = (eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0;
        }
      }
    }
#else
    bool bNoAngular = false;
    if (modeIdx >= 2)
    {
      bNoAngular = true;
      for (uint32_t i = 0; i < modeIdx; i++)
      {
        if (uiIntraDirNeighbor[i] > DC_IDX)
        {
          bNoAngular = false;
          break;
        }
      }
    }

    if (bNoAngular)
    {
      if (bFull)
      {
        for (int iMode = 0; iMode <= 1; iMode++)
        {
          uint64_t uiCost = 0;
          initPredTimdIntraParams(pu, area, iMode);
          predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
                           (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
                           (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
          if (eTempType == LEFT_ABOVE_NEIGHBOR)
          {
            uiCost += distParamSad[0].distFunc(distParamSad[0]);
            uiCost += distParamSad[1].distFunc(distParamSad[1]);
          }
          else if (eTempType == LEFT_NEIGHBOR)
          {
            uiCost = distParamSad[1].distFunc(distParamSad[1]);
          }
          else if (eTempType == ABOVE_NEIGHBOR)
          {
            uiCost += distParamSad[0].distFunc(distParamSad[0]);
          }
          else
          {
            CHECK( true, "invalid case" );
          }

          if (uiCost < uiBestCost)
          {
            uiBestCost = uiCost;
            iBestMode  = iMode;
          }
          if (uiBestCost <= maxCost)
          {
            break;
          }
        }
        cu.timdMode      = iBestMode;
#if JVET_AC0094_REF_SAMPLES_OPT
        cu.timdModeCheckWA = true;
#endif
        cu.timdIsBlended = false;
      }
      if (bHorVer)
      {
        cu.timdHor = PLANAR_IDX;
        cu.timdVer = PLANAR_IDX;
      }
      return iBestMode;
    }
#endif
#if SECONDARY_MPM
    uint8_t mpmList[NUM_MOST_PROBABLE_MODES];
#if JVET_AK0059_MDIP
    uint8_t intraNonMPM[NUM_LUMA_MODE - NUM_MOST_PROBABLE_MODES];
    cu.isModeExcluded = false;
#else
    uint8_t intraNonMPM[NUM_NON_MPM_MODES];
#endif
    PU::getIntraMPMs(pu, mpmList, intraNonMPM
#if JVET_AC0094_REF_SAMPLES_OPT
                     , true
#endif
#if JVET_AK0061_PDP_MPM
      ,false ,false
#endif
    );
#if JVET_AK0059_MDIP
    cu.isModeExcluded = true;
#endif 
#else
    unsigned mpmList[NUM_MOST_PROBABLE_MODES];
    PU::getIntraMPMs(pu, mpmList);
#endif
    unsigned mpmExtraList[NUM_MOST_PROBABLE_MODES + 3];   // +DC/VER/HOR
    int      maxModeNum      = NUM_MOST_PROBABLE_MODES;
    unsigned modeCandList[3] = { DC_IDX, HOR_IDX, VER_IDX };
    bool     bNotExist[3]    = { true, true, true };
    for (int i = 0; i < NUM_MOST_PROBABLE_MODES; i++)
    {
      mpmExtraList[i] = mpmList[i];
      if (bNotExist[0] && mpmList[i] == DC_IDX)
      {
        bNotExist[0] = false;
      }
      if (bNotExist[1] && mpmList[i] == HOR_IDX)
      {
        bNotExist[1] = false;
      }
      if (bNotExist[2] && mpmList[i] == VER_IDX)
      {
        bNotExist[2] = false;
      }
    }
    for (int i = 0; i < 3; i++)
    {
      if (bNotExist[i])
      {
        mpmExtraList[maxModeNum++] = modeCandList[i];
      }
    }

    bool updateFull = true;
    for (int i = 0; i < maxModeNum; i++)
    {
      uint64_t uiCost    = 0;
      int      iMode     = mpmExtraList[i];
      uint64_t uiCostVer = UINT64_MAX;
      uint64_t uiCostHor = UINT64_MAX;
      uint64_t tmpCost0  = 0;
      uint64_t tmpCost1  = 0;
      if (iMode > DC_IDX)
      {
        iMode = MAP67TO131(iMode);
      }
      else
      {
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
        if (!bFull && bHorVer)
#endif
        {
          continue;
        }
      }
      initPredTimdIntraParams(pu, area, iMode);
      predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
                       (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth, (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
      if (eTempType == LEFT_ABOVE_NEIGHBOR)
      {
        if (bFull && updateFull)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else
        {
          if (iMode > EXT_DIA_IDX)
          {
            tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          }
          else
          {
            tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
          }
        }
      }
      else if (eTempType == ABOVE_NEIGHBOR)
      {
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
      }
      else if (eTempType == LEFT_NEIGHBOR)
      {
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
      }
      else
      {
        CHECK( true, "invalid case" );
      }

      if (bFull && updateFull)
      {
        uiCost = tmpCost0 + tmpCost1;
#if JVET_AJ0146_TIMDSAD
        if (createList)
        {
          if (!isModeAdded[mpmExtraList[i]])
          {
            m_timdModeCostList.push_back(std::pair(uiCost, mpmExtraList[i]));
            isModeAdded[mpmExtraList[i]] = true;
          }
        }
#endif
        if (uiCost < uiBestCost)
        {
          uiSecondaryCost = uiBestCost;
          iSecondaryMode  = iBestMode;
          uiBestCost      = uiCost;
          iBestMode       = iMode;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
          cu.timdLocDep[1] = cu.timdLocDep[0];
          cu.timdLocDep[0] = (eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0;
#endif
        }
        else if (uiCost < uiSecondaryCost)
        {
          uiSecondaryCost = uiCost;
          iSecondaryMode  = iMode;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
          cu.timdLocDep[1] = (eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0;
#endif

        }
        if (uiSecondaryCost <= maxCost)
        {
          updateFull = false;
          if (!bHorVer)
          {
            break;
          }
        }
      }
      if (bHorVer && iMode > DC_IDX)
      {
        if (eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          if (iMode > EXT_DIA_IDX)
          {
            uiCostVer = tmpCost0;
          }
          else
          {
            uiCostHor = tmpCost1;
          }
        }
        else if (eTempType == LEFT_NEIGHBOR)
        {
          uiCostHor = tmpCost1;
        }
        else if (eTempType == ABOVE_NEIGHBOR)
        {
          uiCostVer = tmpCost0;
        }
        if (uiCostHor < uiBestCostHor)
        {
          uiBestCostHor = uiCostHor;
          iBestModeHor  = iMode;
        }
        if (uiCostVer < uiBestCostVer)
        {
          uiBestCostVer = uiCostVer;
          iBestModeVer  = iMode;
        }
      }
    }
#if JVET_AC0094_REF_SAMPLES_OPT
    // Check modes removed due to WAIP
    int modeShiftExt[] = { 0, 11, 19, 23, 27, 29 };
    int deltaSize      = abs(floorLog2(uiWidth) - floorLog2(uiHeight));

    // Compute max allowed mode and min allowed mode to not exceed ref
    int maxModeOrig =
      uiWidth >= uiHeight ? EXT_VDIA_IDX + modeShiftExt[deltaSize] : EXT_VDIA_IDX - modeShiftExt[deltaSize];
    int minModeOrig = uiWidth >= uiHeight ? DC_IDX + 1 + modeShiftExt[deltaSize] : DC_IDX + 1 - modeShiftExt[deltaSize];

    int newMinMode = minModeOrig;
    int newMaxMode = maxModeOrig;

    if (uiWidth >= uiHeight)
    {
      if (increaseMaxFar)
      {
        newMaxMode += modeShiftExt[std::min(deltaSize + 2, 5)] - modeShiftExt[deltaSize];
      }
      else if (increaseMaxClose)
      {
        newMaxMode += modeShiftExt[std::min(deltaSize + 1, 5)] - modeShiftExt[deltaSize];
      }
    }
    if (uiWidth <= uiHeight)
    {
      if (decreaseMinFar)
      {
        newMinMode -= modeShiftExt[std::min(deltaSize + 2, 5)] - modeShiftExt[deltaSize];
      }
      else if (decreaseMinClose)
      {
        newMinMode -= modeShiftExt[std::min(deltaSize + 1, 5)] - modeShiftExt[deltaSize];
      }
    }
    int previous = deltaSize;
    int extRef   = (decreaseMinFar || increaseMaxFar) ? 2 : (decreaseMinClose || increaseMaxClose) ? 1 : 0;
    for (int d = 1; d <= extRef; d++)
    {
      if (uiWidth > uiHeight)
      {
        newMinMode -= abs(modeShiftExt[abs(previous)] - modeShiftExt[std::min(abs(deltaSize - d), 5)]);
      }
      if (uiWidth < uiHeight)
      {
        newMaxMode += abs(modeShiftExt[abs(previous)] - modeShiftExt[std::min(abs(deltaSize - d), 5)]);
      }
      previous = deltaSize - d;
    }
    for (int i = newMinMode + 1; i < newMaxMode; i += 5)
    {
      // Mode is a regular mode (already tested)
      if (i >= minModeOrig && i <= maxModeOrig)
      {
        i = maxModeOrig - 1;
        continue;
      }
      uint64_t uiCost = 0;
      uint64_t tmpCost0 = 0;
      uint64_t tmpCost1 = 0;
      int      iMode  = i;
      iMode           = getTimdRegularAngleExt(uiWidth, uiHeight, iMode);
      initPredTimdIntraParams(pu, area, iMode, false, false);
      iMode = getTimdWideAngleExt(uiWidth, uiHeight, iMode);
      predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
                        (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
                        (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);

      if (eTempType == LEFT_ABOVE_NEIGHBOR)
      {
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
      }
      else if (eTempType == ABOVE_NEIGHBOR)
      {
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
      }
      else if (eTempType == LEFT_NEIGHBOR)
      {
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
      }
      else
      {
        CHECK( true, "wrong case" );
      }

      uiCost = tmpCost0 + tmpCost1;
      if (uiCost < uiBestCost)
      {
        uiSecondaryCost = uiBestCost;
        iSecondaryMode  = iBestMode;
        uiBestCost      = uiCost;
        iBestMode             = iMode;
        bSecondaryModeCheckWA = bBestModeCheckWA;
        bBestModeCheckWA      = false;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
        cu.timdLocDep[1] = cu.timdLocDep[0];
        cu.timdLocDep[0] = (eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0;
#endif
      }
      else if (uiCost < uiSecondaryCost)
      {
        uiSecondaryCost = uiCost;
        iSecondaryMode        = iMode;
        bSecondaryModeCheckWA = false;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
        cu.timdLocDep[1] = (eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0;
#endif
      }
      if (uiSecondaryCost <= maxCost)
      {
        break;
      }
    }
#endif
    if(bFull)
    {
      int midMode = iBestMode;
#if JVET_AC0094_REF_SAMPLES_OPT
      bool checkWideAngle = bBestModeCheckWA;
      if ((midMode > DC_IDX && uiBestCost > maxCost && checkWideAngle) || (uiBestCost > maxCost && !checkWideAngle))
#else
      if (midMode > DC_IDX && uiBestCost > maxCost)
#endif
      {
        for (int i = -1; i <= 1; i += 2)
        {
          int iMode = midMode + i;
#if JVET_AC0094_REF_SAMPLES_OPT
          if (checkWideAngle && (iMode <= DC_IDX || iMode > EXT_VDIA_IDX))
          {
            continue;
          }
          if (!checkWideAngle)
          {
            if (iMode >= minModeOrig && iMode <= maxModeOrig)
            {
              continue;
            }
            iMode = getTimdRegularAngleExt(uiWidth, uiHeight, iMode);
          }
#else
          if (iMode <= DC_IDX || iMode > EXT_VDIA_IDX)
          {
            continue;
          }
#endif
          initPredTimdIntraParams(pu, area, iMode
#if JVET_AC0094_REF_SAMPLES_OPT
              , false, checkWideAngle
#endif
          );
#if JVET_AC0094_REF_SAMPLES_OPT
          if (!checkWideAngle)
          {
            iMode = getTimdWideAngleExt(uiWidth, uiHeight, iMode);
          }
#endif
          predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
                           (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
                           (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
          uint64_t uiCost = 0;
          uint64_t tmpCost0 = 0;
          uint64_t tmpCost1 = 0;
          if (eTempType == LEFT_ABOVE_NEIGHBOR)
          {
            tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
            tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
          }
          else if (eTempType == ABOVE_NEIGHBOR)
          {
            tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          }
          else if (eTempType == LEFT_NEIGHBOR)
          {
            tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
          }
          else
          {
            CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
          }      
          uiCost = tmpCost0 + tmpCost1;
          if (uiCost < uiBestCost)
          {
            uiBestCost = uiCost;
            iBestMode  = iMode;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
            cu.timdLocDep[0] = (eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0;
#endif
          }
          if (uiBestCost <= maxCost)
          {
            break;
          }
        }
      }

      midMode = iSecondaryMode;
#if JVET_AC0094_REF_SAMPLES_OPT
      checkWideAngle = bSecondaryModeCheckWA;
      if ((midMode > DC_IDX && uiBestCost > maxCost && checkWideAngle) || (uiBestCost > maxCost && !checkWideAngle))
#else
      if (midMode > DC_IDX && uiSecondaryCost > maxCost)
#endif
      {
        for (int i = -1; i <= 1; i += 2)
        {
          int iMode = midMode + i;
#if JVET_AC0094_REF_SAMPLES_OPT
          if (checkWideAngle && (iMode <= DC_IDX || iMode > EXT_VDIA_IDX))
#else
          if (iMode <= DC_IDX || iMode > EXT_VDIA_IDX)
#endif
          {
            continue;
          }
#if JVET_AC0094_REF_SAMPLES_OPT
          if (!checkWideAngle)
          {
            if (iMode >= minModeOrig && iMode <= maxModeOrig)
            {
              continue;
            }
            iMode = getTimdRegularAngleExt(uiWidth, uiHeight, iMode);
          }
#endif
          initPredTimdIntraParams(pu, area, iMode
#if JVET_AC0094_REF_SAMPLES_OPT
        , false, checkWideAngle
#endif
        );
#if JVET_AC0094_REF_SAMPLES_OPT
          if (!checkWideAngle)
          {
            iMode = getTimdWideAngleExt(uiWidth, uiHeight, iMode);
          }
#endif
          predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
                           (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
                           (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
          uint64_t uiCost = 0;
          uint64_t tmpCost0 = 0;
          uint64_t tmpCost1 = 0;
          if (eTempType == LEFT_ABOVE_NEIGHBOR)
          {
            tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
            tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
          }
          else if (eTempType == ABOVE_NEIGHBOR)
          {
            tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          }
          else if (eTempType == LEFT_NEIGHBOR)
          {
            tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
          }
          else
          {
            CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
          }          
          uiCost = tmpCost0 + tmpCost1;
          if (uiCost < uiSecondaryCost)
          {
            uiSecondaryCost = uiCost;
            iSecondaryMode  = iMode;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
            cu.timdLocDep[1] = ((eTempType != LEFT_ABOVE_NEIGHBOR) ? ((eTempType == LEFT_NEIGHBOR) ? 2 : 1) : (tmpCost0 >> log2A < (tmpCost1 >> (log2L + 1))) ? 1 : (tmpCost1 >> log2L < (tmpCost0 >> (log2A + 1))) ? 2 : 0);
#endif
          }
          if (uiSecondaryCost <= maxCost)
          {
            break;
          }
        }
      }

#if JVET_AC0094_REF_SAMPLES_OPT
      if (!bBestModeCheckWA)
      {
        iBestMode = getTimdRegularAngleExt(uiWidth, uiHeight, iBestMode);
      }
      if (!bSecondaryModeCheckWA)
      {
        iSecondaryMode = getTimdRegularAngleExt(uiWidth, uiHeight, iSecondaryMode);
      }
#endif

      if (uiSecondaryCost < uiBestCost)
      {
        std::swap(cu.timdLocDep[1], cu.timdLocDep[0]);
        std::swap(uiSecondaryCost, uiBestCost);
        std::swap(iSecondaryMode, iBestMode);
        std::swap(bSecondaryModeCheckWA, bBestModeCheckWA);
      }

      // if( uiSecondaryCost < 2 * uiBestCost ), 2 * uiBestCost can overflow uint64_t
#if JVET_AG0092_ENHANCED_TIMD_FUSION
      if( !( (uiSecondaryCost < uiBestCost || (uiSecondaryCost - uiBestCost < uiBestCost)) ) && (iBestMode > DC_IDX) )
      {
        uiSecondaryCost = uiBestCost;
        iSecondaryMode  = iBestMode;
#if JVET_AC0094_REF_SAMPLES_OPT
        bSecondaryModeCheckWA = bBestModeCheckWA;
#endif
      }
#endif
      if (uiSecondaryCost < uiBestCost || (uiSecondaryCost - uiBestCost < uiBestCost))
      {
        cu.timdMode          = iBestMode;
        cu.timdIsBlended     = true;
        cu.timdModeSecondary = iSecondaryMode;
#if JVET_AC0094_REF_SAMPLES_OPT
        cu.timdModeCheckWA          = bBestModeCheckWA;
        cu.timdModeSecondaryCheckWA = bSecondaryModeCheckWA;
#endif

        const int blend_sum_weight = 6;
        int       sum_weight       = 1 << blend_sum_weight;

#if JVET_AG0092_ENHANCED_TIMD_FUSION
        if ( ((iBestMode != iNonAngMode) && (iSecondaryMode != iNonAngMode)) && ( (uiNonAngCost < uiBestCost) || (uiNonAngCost - uiBestCost < (uiBestCost>>1)) ) )
        {
          cu.timdModeNonAng = iNonAngMode;

          double dCost[3] = {0};
          dCost[0] = (double) uiBestCost;
          dCost[1] = (double) uiSecondaryCost;
          dCost[2] = (double) uiNonAngCost;
          double sum = dCost[0] + dCost[1] + dCost[2];
          double dRatio[2] = {0.0};
          int    iRatio[2] = {0};
          for(int i = 0; i<2 ; i++)
          {
            dRatio[i] = (sum - dCost[i]) / (2 * sum);
            iRatio[i] = static_cast<int>(dRatio[i] * sum_weight + 0.5);     
          }

          cu.timdFusionWeight[0] = iRatio[0];
          cu.timdFusionWeight[1] = iRatio[1];
          cu.timdFusionWeight[2] = sum_weight - iRatio[0] - iRatio[1];
        }
        else
        {
#endif

#if JVET_X0149_TIMD_DIMD_LUT
        int      g_gradDivTable[16] = { 0, 7, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 1, 1, 0 };
        uint64_t s0                 = uiSecondaryCost;
        // uiBestCost + uiSecondaryCost can overlow uint64_t
        uint64_t s1 = (MAX_UINT64 - uiSecondaryCost < uiBestCost) ? MAX_UINT64 : (uiBestCost + uiSecondaryCost);
        int      x  = floorLog2Uint64(s1);
        CHECK(x < 0, "floor log2 value should be no negative");
        int normS1 = int(s1 << 4 >> x) & 15;
        int v       = g_gradDivTable[normS1] | 8;
        x += (normS1 != 0);
        int shift  = x + 3;
        int add    = (1 << (shift - 1));
        int iRatio = int((s0 * v * sum_weight + add) >> shift);

        if (iRatio > sum_weight)
        {
          iRatio = sum_weight;
        }

        CHECK(iRatio > sum_weight, "Wrong DIMD ratio");
#else
        double dRatio = 0.0;
        dRatio        = (double) uiSecondaryCost / (double) (uiBestCost + uiSecondaryCost);
        int iRatio    = static_cast<int>(dRatio * sum_weight + 0.5);
#endif
        cu.timdFusionWeight[0] = iRatio;
        cu.timdFusionWeight[1] = sum_weight - iRatio;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
        cu.timdFusionWeight[TIMD_FUSION_NUM - 1] = 0;
        }
#endif
      }
      else
      {
#if JVET_AC0094_REF_SAMPLES_OPT
        cu.timdModeCheckWA          = bBestModeCheckWA;
        cu.timdModeSecondaryCheckWA = true;
#endif
        cu.timdMode      = iBestMode;
        cu.timdIsBlended = false;
      }
    }
    if (bHorVer)
    {
      cu.timdHor = iBestModeHor;
      cu.timdVer = iBestModeVer;
    }

    return iBestMode;
  }
  else
  {
#if JVET_AC0094_REF_SAMPLES_OPT
    cu.timdModeCheckWA          = true;
    cu.timdModeSecondaryCheckWA = true;
#endif
    if (bFull)
    {
      cu.timdMode      = PLANAR_IDX;
      cu.timdIsBlended = false;
    }
    if (bHorVer)
    {
      cu.timdHor = PLANAR_IDX;
      cu.timdVer = PLANAR_IDX;
    }
    return PLANAR_IDX;
  }
}
#else   // SGPM

int IntraPrediction::deriveTimdMode( const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu )
{
  int channelBitDepth = cu.slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  SizeType uiWidth = cu.lwidth();
  SizeType uiHeight = cu.lheight();

  static Pel predLuma[(MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE) * (MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE)];
  memset(predLuma, 0, (MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE) * (MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE) * sizeof(Pel));
  Pel* piPred = predLuma;
  uint32_t uiPredStride = MAX_CU_SIZE + DIMD_MAX_TEMP_SIZE;

  int  iCurX  = cu.lx();
  int  iCurY  = cu.ly();
  int  iRefX  = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;

  int iTempWidth = 4, iTempHeight = 4;
  if(uiWidth <= 8)
  {
    iTempWidth = 2;
  }
  if(uiHeight <= 8)
  {
    iTempHeight = 2;
  }

  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX, iRefY, uiRefWidth, uiRefHeight);

  if (eTempType != NO_NEIGHBOR)
  {
    const CodingStructure& cs   = *cu.cs;
    m_ipaParam.multiRefIndex        = iTempWidth;
    Pel* piOrg = cs.picture->getRecoBuf( area ).buf;
    int iOrgStride = cs.picture->getRecoBuf( area ).stride;
    piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
    DistParam distParamSad[2]; // above, left
    distParamSad[0].applyWeight = false;
    distParamSad[0].useMR = false;
    distParamSad[1].applyWeight = false;
    distParamSad[1].useMR = false;
    if(eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride, uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true); // Use HAD (SATD) cost
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride, piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth, COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true); // Use HAD (SATD) cost
    }
    else if(eTempType == LEFT_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth, COMPONENT_Y, iTempWidth, uiHeight, 0, 1, true);
    }
    else if(eTempType == ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, true);
    }
    initTimdIntraPatternLuma(cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0, eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);

    uint32_t uiIntraDirNeighbor[5] = {0}, modeIdx = 0;
    bool includedMode[EXT_VDIA_IDX + 1];
    memset(includedMode, false, (EXT_VDIA_IDX + 1) * sizeof(bool));
    auto &pu = *cu.firstPU;
    uint32_t uiRealW = uiRefWidth + (eTempType == LEFT_NEIGHBOR? iTempWidth : 0);
    uint32_t uiRealH = uiRefHeight + (eTempType == ABOVE_NEIGHBOR? iTempHeight : 0);
    uint64_t maxCost = (uint64_t)(iTempWidth * cu.lheight() + iTempHeight * cu.lwidth());

    uint64_t uiBestCost = MAX_UINT64;
    int iBestMode = PLANAR_IDX;
    uint64_t uiSecondaryCost = MAX_UINT64;
    int iSecondaryMode = PLANAR_IDX;

    const Position posLTx = pu.Y().topLeft();
    const Position posRTx = pu.Y().topRight();
    const Position posLBx = pu.Y().bottomLeft();

    // left
    const PredictionUnit *puLeftx = pu.cs->getPURestricted(posLBx.offset(-1, 0), pu, pu.chType);
    if (puLeftx && CU::isIntra(*puLeftx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma( *puLeftx );
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puLeftx->cu->timd)
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if( !includedMode[uiIntraDirNeighbor[modeIdx]] )
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
    // above
    const PredictionUnit *puAbovex = pu.cs->getPURestricted(posRTx.offset(0, -1), pu, pu.chType);
    if (puAbovex && CU::isIntra(*puAbovex->cu) && CU::isSameCtu(*pu.cu, *puAbovex->cu))
    {
      uiIntraDirNeighbor[modeIdx] =PU::getIntraDirLuma( *puAbovex );
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puAbovex->cu->timd)
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if( !includedMode[uiIntraDirNeighbor[modeIdx]] )
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
    // below left
    const PredictionUnit *puLeftBottomx = cs.getPURestricted( posLBx.offset( -1, 1 ), pu, pu.chType );
    if (puLeftBottomx && CU::isIntra(*puLeftBottomx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma( *puLeftBottomx );
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puLeftBottomx->cu->timd)
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if( !includedMode[uiIntraDirNeighbor[modeIdx]] )
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
    // above right
    const PredictionUnit *puAboveRightx = cs.getPURestricted( posRTx.offset( 1, -1 ), pu, pu.chType );
    if (puAboveRightx && CU::isIntra(*puAboveRightx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma( *puAboveRightx );
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puAboveRightx->cu->timd)
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if( !includedMode[uiIntraDirNeighbor[modeIdx]] )
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
    //above left
    const PredictionUnit *puAboveLeftx = cs.getPURestricted( posLTx.offset( -1, -1 ), pu, pu.chType );
    if( puAboveLeftx && CU::isIntra(*puAboveLeftx->cu) )
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma( *puAboveLeftx );
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (uiIntraDirNeighbor[modeIdx] == PNN_IDX)
      {
        uiIntraDirNeighbor[modeIdx] = PLANAR_IDX;
      }
#endif
      if (!puAboveLeftx->cu->timd)
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if( !includedMode[uiIntraDirNeighbor[modeIdx]] )
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
    bool bNoAngular = false;
    if(modeIdx >= 2)
    {
      bNoAngular = true;
      for(uint32_t i = 0; i < modeIdx; i++)
      {
        if(uiIntraDirNeighbor[i] > DC_IDX)
        {
          bNoAngular = false;
          break;
        }
      }
    }

    if (bNoAngular)
    {
      for(int iMode = 0; iMode <= 1; iMode ++)
      {
        uint64_t uiCost = 0;
        initPredTimdIntraParams(pu, area, iMode);
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType, (eTempType == ABOVE_NEIGHBOR)? 0: iTempWidth, (eTempType == LEFT_NEIGHBOR)? 0: iTempHeight);
        if(eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
          uiCost += distParamSad[1].distFunc(distParamSad[1]);
        }
        else if(eTempType == LEFT_NEIGHBOR)
        {
          uiCost = distParamSad[1].distFunc(distParamSad[1]);
        }
        else if(eTempType == ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
        }
        else
        {
          CHECK( true, "wrong case" );
        }

        if(uiCost < uiBestCost)
        {
          uiBestCost = uiCost;
          iBestMode = iMode;
        }
        if(uiBestCost <= maxCost)
        {
          break;
        }
      }
      cu.timdMode = iBestMode;
      cu.timdIsBlended = false;

      return iBestMode;
    }
#if SECONDARY_MPM
    uint8_t mpmList[NUM_MOST_PROBABLE_MODES];
    uint8_t intraNonMPM[NUM_NON_MPM_MODES];
    PU::getIntraMPMs(pu, mpmList, intraNonMPM);
#else
    unsigned mpmList[NUM_MOST_PROBABLE_MODES];
    PU::getIntraMPMs(pu, mpmList);
#endif
    unsigned mpmExtraList[NUM_MOST_PROBABLE_MODES + 3]; // +DC/VER/HOR
    int maxModeNum = NUM_MOST_PROBABLE_MODES;
    unsigned modeCandList[3] = {DC_IDX, HOR_IDX, VER_IDX};
    bool bNotExist[3] = {true, true, true};
    for (int i = 0; i < NUM_MOST_PROBABLE_MODES; i++)
    {
      mpmExtraList[i] = mpmList[i];
      if (bNotExist[0] && mpmList[i] == DC_IDX)
      {
        bNotExist[0] = false;
      }
      if (bNotExist[1] && mpmList[i] == HOR_IDX)
      {
        bNotExist[1] = false;
      }
      if (bNotExist[2] && mpmList[i] == VER_IDX)
      {
        bNotExist[2] = false;
      }
    }
    for (int i = 0; i < 3; i++)
    {
      if (bNotExist[i])
      {
        mpmExtraList[maxModeNum++] = modeCandList[i];
      }
    }
    for(int i = 0; i < maxModeNum; i ++)
    {
      uint64_t uiCost = 0;
      int iMode = mpmExtraList[i];
      if (iMode > DC_IDX)
      {
        iMode = MAP67TO131(iMode);
      }
      initPredTimdIntraParams(pu, area, iMode);
      predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType, (eTempType == ABOVE_NEIGHBOR)? 0: iTempWidth, (eTempType == LEFT_NEIGHBOR)? 0: iTempHeight);
      if(eTempType == LEFT_ABOVE_NEIGHBOR)
      {
        uiCost += distParamSad[0].distFunc(distParamSad[0]);
        uiCost += distParamSad[1].distFunc(distParamSad[1]);
      }
      else if(eTempType == LEFT_NEIGHBOR)
      {
        uiCost = distParamSad[1].distFunc(distParamSad[1]);
      }
      else if(eTempType == ABOVE_NEIGHBOR)
      {
        uiCost += distParamSad[0].distFunc(distParamSad[0]);
      }
      else
      {
        CHECK( true, "wrong case" );
      }

      if( uiCost < uiBestCost )
      {
        uiSecondaryCost = uiBestCost;
        iSecondaryMode  = iBestMode;
        uiBestCost  = uiCost;
        iBestMode = iMode;
      }
      else if (uiCost < uiSecondaryCost)
      {
        uiSecondaryCost = uiCost;
        iSecondaryMode  = iMode;
      }
      if (uiSecondaryCost <= maxCost)
      {
        break;
      }
    }

    int midMode = iBestMode;
    if (midMode > DC_IDX && uiBestCost > maxCost)
    {
      for (int i = -1; i <= 1; i+=2)
      {
        int iMode = midMode + i;
        if (iMode <= DC_IDX || iMode > EXT_VDIA_IDX)
        {
          continue;
        }
        initPredTimdIntraParams(pu, area, iMode);
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType, (eTempType == ABOVE_NEIGHBOR)? 0: iTempWidth, (eTempType == LEFT_NEIGHBOR)? 0: iTempHeight);
        uint64_t uiCost = 0;
        if(eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
          uiCost += distParamSad[1].distFunc(distParamSad[1]);
        }
        else if(eTempType == LEFT_NEIGHBOR)
        {
          uiCost = distParamSad[1].distFunc(distParamSad[1]);
        }
        else if(eTempType == ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
        }
        else
        {
          CHECK( true, "wrong case" );
        }

        if(uiCost < uiBestCost)
        {
          uiBestCost  = uiCost;
          iBestMode = iMode;
        }
        if(uiBestCost <= maxCost)
        {
          break;
        }
      }
    }

    midMode = iSecondaryMode;
    if (midMode > DC_IDX && uiSecondaryCost > maxCost)
    {
      for (int i = -1; i <= 1; i+=2)
      {
        int iMode = midMode + i;
        if (iMode <= DC_IDX || iMode > EXT_VDIA_IDX)
        {
          continue;
        }
        initPredTimdIntraParams(pu, area, iMode);
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType, (eTempType == ABOVE_NEIGHBOR)? 0: iTempWidth, (eTempType == LEFT_NEIGHBOR)? 0: iTempHeight);
        uint64_t uiCost = 0;
        if(eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
          uiCost += distParamSad[1].distFunc(distParamSad[1]);
        }
        else if(eTempType == LEFT_NEIGHBOR)
        {
          uiCost = distParamSad[1].distFunc(distParamSad[1]);
        }
        else if(eTempType == ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
        }
        else
        {
          CHECK( true, "wrong case" );
        }

        if(uiCost < uiSecondaryCost)
        {
          uiSecondaryCost  = uiCost;
          iSecondaryMode = iMode;
        }
        if(uiSecondaryCost <= maxCost)
        {
          break;
        }
      }
    }

    // if( uiSecondaryCost < 2 * uiBestCost ), 2 * uiBestCost can overflow uint64_t
    if( uiSecondaryCost < uiBestCost || (uiSecondaryCost - uiBestCost < uiBestCost) )
  {
    cu.timdMode         = iBestMode;
    cu.timdIsBlended    = true;
    cu.timdModeSecondary = iSecondaryMode;

    const int blend_sum_weight = 6;
    int       sum_weight       = 1 << blend_sum_weight;

#if JVET_X0149_TIMD_DIMD_LUT
    int g_gradDivTable[16] = { 0, 7, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 1, 1, 0 };
    uint64_t s0 = uiSecondaryCost;
    // uiBestCost + uiSecondaryCost can overlow uint64_t
    uint64_t s1 = (MAX_UINT64 - uiSecondaryCost < uiBestCost) ? MAX_UINT64 : (uiBestCost + uiSecondaryCost);
    int x = floorLog2Uint64(s1);
    CHECK(x < 0, "floor log2 value should be no negative");
    int normS1 = int(s1 << 4 >> x) & 15;
    int v = g_gradDivTable[normS1] | 8;
    x += (normS1 != 0);
    int shift = x + 3;
    int add = (1 << (shift - 1));
    int iRatio = int((s0 * v * sum_weight + add) >> shift);

    if( iRatio > sum_weight )
    {
      iRatio = sum_weight;
    }

    CHECK( iRatio > sum_weight, "Wrong DIMD ratio" );
#else
    double dRatio       = 0.0;
    dRatio              = (double) uiSecondaryCost / (double) (uiBestCost + uiSecondaryCost);
    int iRatio          = static_cast<int>(dRatio * sum_weight + 0.5);
#endif
    cu.timdFusionWeight[0] = iRatio;
    cu.timdFusionWeight[1] = sum_weight - iRatio;
  }
  else
  {
    cu.timdMode      = iBestMode;
    cu.timdIsBlended = false;
  }

    return iBestMode;
  }
  else
  {
    cu.timdMode = PLANAR_IDX;
    cu.timdIsBlended = false;

    return PLANAR_IDX;
  }
}
#endif
#if JVET_AJ0146_TIMDSAD
int IntraPrediction::deriveTimdModeSad(const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu)
{
  int      channelBitDepth = cu.slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  SizeType uiWidth         = cu.lwidth();
  SizeType uiHeight        = cu.lheight();

  int      iCurX = cu.lx();
  int      iCurY = cu.ly();
  int      iRefX = -1, iRefY = -1;
  uint32_t uiRefWidth = 0, uiRefHeight = 0;

  int iTempWidth = 4, iTempHeight = 4;
  if (uiWidth <= 8)
  {
    iTempWidth = 2;
  }
  if (uiHeight <= 8)
  {
    iTempHeight = 2;
  }

  iTempWidth  *= 2;
  iTempHeight *= 2;

  //clip templates:
  iTempWidth = std::min(std::max(iCurX,2), iTempWidth);
  iTempHeight = std::min(std::max(iCurY,2), iTempHeight);
  const CodingStructure &cs = *cu.cs;

  int maxTempHeight = std::min(iTempHeight, TIMDDIFF_MAX_TEMP_SIZE);

  for (iTempHeight = maxTempHeight; iTempHeight > 4; iTempHeight -=4)
  {
    const Position refPosL = cu.Y().offset(0, -iTempHeight);
    const Position refPosR = cu.Y().offset(uiWidth - 1, -iTempHeight);
    if ( !cs.isDecomp(refPosL, CH_L) )
    {
      continue;
    }
    if (cs.getCURestricted(refPosL, cu, CH_L) == NULL)
    {
      continue;
    }
    if ( !cs.isDecomp(refPosR, CH_L) )
    {
      continue;
    }
    if (cs.getCURestricted(refPosR, cu, CH_L) == NULL)
    {
      continue;
    }
    break;
  }
  int maxTempWidth = std::min(iTempWidth, TIMDDIFF_MAX_TEMP_SIZE);
  for (iTempWidth = maxTempWidth; iTempWidth > 4; iTempWidth -=4)
  {
    const Position refPosT = cu.Y().offset(-iTempWidth, 0);
    const Position refPosB = cu.Y().offset(-iTempWidth, uiHeight - 1);
    if ( !cs.isDecomp(refPosT, CH_L) )
    {
      continue;
    }
    if (cs.getCURestricted(refPosT, cu, CH_L) == NULL)
    {
      continue;
    }
    if ( !cs.isDecomp(refPosB, CH_L) )
    {
      continue;
    }
    if (cs.getCURestricted(refPosB, cu, CH_L) == NULL)
    {
      continue;
    }
    break;
  }

  TemplateType eTempType = CU::deriveTimdRefType(iCurX, iCurY, uiWidth, uiHeight, iTempWidth, iTempHeight, iRefX,
    iRefY, uiRefWidth, uiRefHeight);
  auto &        pu        = *cu.firstPU;
  uint32_t      uiRealW   = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
  uint32_t      uiRealH   = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, uiRealW, uiRealH));
  uint32_t       uiPredStride = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).stride;
  Pel *piPred = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).buf;

  if (eTempType != NO_NEIGHBOR)
  {
    const CodingStructure& cs = *cu.cs;
    m_ipaParam.multiRefIndex = iTempWidth;
    Pel* piOrg = cs.picture->getRecoBuf(area).buf;
    int  iOrgStride = cs.picture->getRecoBuf(area).stride;
    piOrg += (iRefY - iCurY) * iOrgStride + (iRefX - iCurX);
    DistParam distParamSad[2];   // above, left
    distParamSad[0].applyWeight = false;
    distParamSad[1].applyWeight = false;
    distParamSad[0].useMR = true;
    distParamSad[1].useMR = true;

    if (eTempType == LEFT_ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + iTempWidth, piPred + iTempWidth, iOrgStride,
        uiPredStride, channelBitDepth, COMPONENT_Y, uiWidth, iTempHeight, 0, 1, false
      );
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + iTempHeight * iOrgStride,
        piPred + iTempHeight * uiPredStride, iOrgStride, uiPredStride, channelBitDepth,
        COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false
      );
    }
    else if (eTempType == LEFT_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
        COMPONENT_Y, iTempWidth, uiHeight, 0, 1, false
      );
    }
    else if (eTempType == ABOVE_NEIGHBOR)
    {
      m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg, piPred, iOrgStride, uiPredStride, channelBitDepth,
        COMPONENT_Y, uiWidth, iTempHeight, 0, 1, false
      );
    }
    initTimdIntraPatternLuma(cu, area, eTempType != ABOVE_NEIGHBOR ? iTempWidth : 0,
      eTempType != LEFT_NEIGHBOR ? iTempHeight : 0, uiRefWidth, uiRefHeight);

#if !JVET_AG0092_ENHANCED_TIMD_FUSION
    uint32_t uiIntraDirNeighbor[5] = { 0 }, modeIdx = 0;

    bool     includedMode[EXT_VDIA_IDX + 1];
    memset(includedMode, false, (EXT_VDIA_IDX + 1) * sizeof(bool));
#endif
    auto& pu = *cu.firstPU;
    uint32_t uiRealW = uiRefWidth + (eTempType == LEFT_NEIGHBOR ? iTempWidth : 0);
    uint32_t uiRealH = uiRefHeight + (eTempType == ABOVE_NEIGHBOR ? iTempHeight : 0);
    uint64_t maxCost = (uint64_t)(iTempWidth * cu.lheight() + iTempHeight * cu.lwidth());

    uint64_t uiBestCost = MAX_UINT64;
    int      iBestMode = PLANAR_IDX;
    uint64_t uiSecondaryCost = MAX_UINT64;
    int      iSecondaryMode = PLANAR_IDX;

#if JVET_AG0092_ENHANCED_TIMD_FUSION
    uint64_t uiNonAngCost = MAX_UINT64;
    int      iNonAngMode = PLANAR_IDX;
#endif
#if JVET_AC0094_REF_SAMPLES_OPT
    bool bBestModeCheckWA = true;
    bool bSecondaryModeCheckWA = true;
#endif
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
    const Position posLTx = pu.Y().topLeft();
#endif
    const Position posRTx = pu.Y().topRight();
    const Position posLBx = pu.Y().bottomLeft();
#if JVET_AC0094_REF_SAMPLES_OPT
    bool increaseMaxClose = true;
    bool decreaseMinClose = true;
    bool increaseMaxFar = true;
    bool decreaseMinFar = true;
#endif


    // left
    const PredictionUnit* puLeftx = pu.cs->getPURestricted(posLBx.offset(-1, 0), pu, pu.chType);
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
    if (puLeftx && CU::isIntra(*puLeftx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puLeftx);
      if (!puLeftx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puLeftx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
#endif
    // above
    const PredictionUnit* puAbovex = pu.cs->getPURestricted(posRTx.offset(0, -1), pu, pu.chType);
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
    if (puAbovex && CU::isIntra(*puAbovex->cu) && CU::isSameCtu(*pu.cu, *puAbovex->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puAbovex);
      if (!puAbovex->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puAbovex->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
#endif
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
    // below left
    const PredictionUnit* puLeftBottomx = cs.getPURestricted(posLBx.offset(-1, 1), pu, pu.chType);
    if (puLeftBottomx && CU::isIntra(*puLeftBottomx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puLeftBottomx);
      if (!puLeftBottomx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puLeftBottomx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
#endif
#if JVET_AC0094_REF_SAMPLES_OPT
    if (!puLeftx)
    {
      decreaseMinClose = false;
    }
    const PredictionUnit* puLeftBottomFarx = cs.getPURestricted(posLBx.offset(-1, uiHeight), pu, pu.chType);
    if (!puLeftBottomFarx)
    {
      decreaseMinFar = false;
    }
#endif
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
    // above right
    const PredictionUnit* puAboveRightx = cs.getPURestricted(posRTx.offset(1, -1), pu, pu.chType);
    if (puAboveRightx && CU::isIntra(*puAboveRightx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puAboveRightx);
      if (!puAboveRightx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puAboveRightx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
#endif
#if JVET_AC0094_REF_SAMPLES_OPT
    if (!puAbovex)
    {
      increaseMaxClose = false;
    }
    const PredictionUnit* puAboveRightFarx = cs.getPURestricted(posRTx.offset(uiWidth, -1), pu, pu.chType);
    if (!puAboveRightFarx)
    {
      increaseMaxFar = false;
    }
#endif
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
    // above left
    const PredictionUnit* puAboveLeftx = cs.getPURestricted(posLTx.offset(-1, -1), pu, pu.chType);
    if (puAboveLeftx && CU::isIntra(*puAboveLeftx->cu))
    {
      uiIntraDirNeighbor[modeIdx] = PU::getIntraDirLuma(*puAboveLeftx);
      if (!puAboveLeftx->cu->timd
#if JVET_AD0085_TMRL_EXTENSION
        && !puAboveLeftx->cu->tmrlFlag
#endif
        )
      {
        uiIntraDirNeighbor[modeIdx] = MAP67TO131(uiIntraDirNeighbor[modeIdx]);
      }
      if (!includedMode[uiIntraDirNeighbor[modeIdx]])
      {
        includedMode[uiIntraDirNeighbor[modeIdx]] = true;
        modeIdx++;
      }
    }
#endif
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    cu.timdLocDepSad[0] = 0;
    cu.timdLocDepSad[1] = 0;
    cu.timdLocDepSad[TIMD_FUSION_NUM - 1] = 0;
    {
      for (int iMode = 0; iMode <= 1; iMode++)
      {
        uint64_t uiCost = 0;
        uint64_t tmpCost0 = 0;
        uint64_t tmpCost1 = 0;
        initPredTimdIntraParams(pu, area, iMode);
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
          (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
          (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);

        if (eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else if (eTempType == ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        }
        else if (eTempType == LEFT_NEIGHBOR)
        {
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else
        {
          CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
        }

        uiCost = tmpCost0 + tmpCost1;

        if (uiCost < uiBestCost)
        {
          uiSecondaryCost = uiBestCost;
          iSecondaryMode = iBestMode;
          uiBestCost = uiCost;
          iBestMode = iMode;
          uiNonAngCost = uiCost;
          iNonAngMode = iMode;
        }
        else if (uiCost < uiSecondaryCost)
        {
          uiSecondaryCost = uiCost;
          iSecondaryMode = iMode;
        }
      }
    }
#else
    bool bNoAngular = false;
    if (modeIdx >= 2)
    {
      bNoAngular = true;
      for (uint32_t i = 0; i < modeIdx; i++)
      {
        if (uiIntraDirNeighbor[i] > DC_IDX)
        {
          bNoAngular = false;
          break;
        }
      }
    }

    if (bNoAngular)

    {
      for (int iMode = 0; iMode <= 1; iMode++)
      {
        uint64_t uiCost = 0;
        initPredTimdIntraParams(pu, area, iMode);
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
          (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
          (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
        if (eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
          uiCost += distParamSad[1].distFunc(distParamSad[1]);
        }
        else if (eTempType == LEFT_NEIGHBOR)
        {
          uiCost = distParamSad[1].distFunc(distParamSad[1]);
        }
        else if (eTempType == ABOVE_NEIGHBOR)
        {
          uiCost += distParamSad[0].distFunc(distParamSad[0]);
        }
        else
        {
          CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
        } 
        if (uiCost < uiBestCost)
        {
          uiBestCost = uiCost;
          iBestMode = iMode;
        }
        if (uiBestCost <= maxCost)
        {
          break;
        }
      }
      cu.timdModeSad = iBestMode;
#if JVET_AC0094_REF_SAMPLES_OPT
      cu.timdModeCheckWASad = true;
#endif
      cu.timdIsBlendedSad = false;

      return iBestMode;
    }
#endif
    int maxModeNum = (int) m_timdModeCostList.size();
    int vectorSize = maxModeNum;
    if (maxModeNum > TIMD_NUM_MODES_SORTED)
    {
      maxModeNum = TIMD_NUM_MODES_SORTED;
    }
    int numCand = TIMD_NUM_MODES_SORTED + 10;
    unsigned mpmExtraList[NUM_MOST_PROBABLE_MODES + 3];
    bool modeUsed[NUM_LUMA_MODE] = {0};
    int modeCnt = 0;
    for (int  i=0; i<vectorSize; i++)
    {
      int iMode = m_timdModeCostList.at(i).second;
      if (modeCnt == maxModeNum)
      {
        break;
      }
      if ( MAP67TO131(iMode) == cu.timdMode || (cu.timdIsBlended &&  MAP67TO131(iMode) == cu.timdModeSecondary ) )
      {
        continue;
      }
      else if (iMode <= DC_IDX)
      {
        continue;
      }
      else
      {
        mpmExtraList[modeCnt++] = iMode;
        modeUsed[iMode] = true;
      }
    }
    maxModeNum = modeCnt;

    for (int i = 0; i < DIMD_FUSION_NUM; i++)
    {
      if (maxModeNum == numCand)
      {
        break;
      }
      int iMode = (i == 0 ? cu.dimdMode : cu.dimdBlendMode[i - 1]);
      if (iMode < 0 || iMode >= NUM_LUMA_MODE)
      {
        continue;
      }
      if (iMode <= DC_IDX)
      {
        continue;
      }
      if ( MAP67TO131(iMode) == cu.timdMode || (cu.timdIsBlended &&  MAP67TO131(iMode) == cu.timdModeSecondary ) )
      {
        modeUsed[iMode] = true;
      }
      if (!modeUsed[iMode])
      {
        mpmExtraList[maxModeNum++] = iMode;
        modeUsed[iMode] = true;
      }
    }
    int modeCandList[2] = {  HOR_IDX, VER_IDX };
    for (int i = 0; i < 2; i++)
    {
      if (maxModeNum == numCand)
      {
        break;
      }
      int iMode = modeCandList[i];
      if ( MAP67TO131(iMode) == cu.timdMode || (cu.timdIsBlended &&  MAP67TO131(iMode) == cu.timdModeSecondary ) )
      {
        modeUsed[iMode] = true;
      }
      if (!modeUsed[iMode])
      {
        mpmExtraList[maxModeNum++] = iMode;
        modeUsed[iMode] = true;
      }
    }
    const int numRefine = 12;
    int refinedList[numRefine] =     { MAP131TO67(cu.timdMode) + 1, MAP131TO67(cu.timdMode) - 1, MAP131TO67(cu.timdModeSecondary) + 1, MAP131TO67(cu.timdModeSecondary) - 1, 
      cu.dimdMode + 1, cu.dimdMode - 1, (cu.dimdBlending ? cu.dimdBlendMode[0] + 1 : cu.dimdMode + 2), (cu.dimdBlending ? cu.dimdBlendMode[0] -  1 : cu.dimdMode - 2),
      MAP131TO67(cu.timdMode) + 2, MAP131TO67(cu.timdMode) - 2, MAP131TO67(cu.timdModeSecondary) + 2, MAP131TO67(cu.timdModeSecondary) - 2};
    for (int i = 0; i < numRefine; i++)
    {
      if (maxModeNum == numCand)
      {
        break;
      }
      int iMode = refinedList[i];
      if (iMode < 0 || iMode >= NUM_LUMA_MODE)
      {
        continue;
      }
      if (iMode <= DC_IDX)
      {
        continue;
      }
      if ( MAP67TO131(iMode) == cu.timdMode || (cu.timdIsBlended &&  MAP67TO131(iMode) == cu.timdModeSecondary ) )
      {
        modeUsed[iMode] = true;
      }
      if (!modeUsed[iMode])
      {
        mpmExtraList[maxModeNum++] = iMode;
        modeUsed[iMode] = true;
      }
    }

    for (int i = 0; i < maxModeNum; i++)
    {
      uint64_t uiCost    = 0;
      int      iMode     = mpmExtraList[i];
      uint64_t tmpCost0  = 0;
      uint64_t tmpCost1  = 0;
      if (iMode > DC_IDX)
      {
        iMode = MAP67TO131(iMode);
      }
      else
      {
#if !JVET_AG0092_ENHANCED_TIMD_FUSION
        if (!bFull && bHorVer)
#endif
        {
          continue;
        }
      }
      initPredTimdIntraParams(pu, area, iMode);
      predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
        (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth, (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
      if (eTempType == LEFT_ABOVE_NEIGHBOR)
      {
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);

      }
      else if (eTempType == ABOVE_NEIGHBOR)
      {
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
      }
      else if (eTempType == LEFT_NEIGHBOR)
      {
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
      }
      else
      {
        CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
      } 
      uiCost = tmpCost0 + tmpCost1;
      if (uiCost < uiBestCost)
      {
        uiSecondaryCost = uiBestCost;
        iSecondaryMode  = iBestMode;
        uiBestCost      = uiCost;
        iBestMode       = iMode;
      }
      else if (uiCost < uiSecondaryCost)
      {
        uiSecondaryCost = uiCost;
        iSecondaryMode  = iMode;
      }
      if (uiSecondaryCost <= maxCost)
      {
        break;
      }
    }
#if JVET_AC0094_REF_SAMPLES_OPT
    // Check modes removed due to WAIP
    int modeShiftExt[] = { 0, 11, 19, 23, 27, 29 };
    int deltaSize      = abs(floorLog2(uiWidth) - floorLog2(uiHeight));

    // Compute max allowed mode and min allowed mode to not exceed ref
    int maxModeOrig =
      uiWidth >= uiHeight ? EXT_VDIA_IDX + modeShiftExt[deltaSize] : EXT_VDIA_IDX - modeShiftExt[deltaSize];
    int minModeOrig = uiWidth >= uiHeight ? DC_IDX + 1 + modeShiftExt[deltaSize] : DC_IDX + 1 - modeShiftExt[deltaSize];

    int newMinMode = minModeOrig;
    int newMaxMode = maxModeOrig;

    if (uiWidth >= uiHeight)
    {
      if (increaseMaxFar)
      {
        newMaxMode += modeShiftExt[std::min(deltaSize + 2, 5)] - modeShiftExt[deltaSize];
      }
      else if (increaseMaxClose)
      {
        newMaxMode += modeShiftExt[std::min(deltaSize + 1, 5)] - modeShiftExt[deltaSize];
      }
    }
    if (uiWidth <= uiHeight)
    {
      if (decreaseMinFar)
      {
        newMinMode -= modeShiftExt[std::min(deltaSize + 2, 5)] - modeShiftExt[deltaSize];
      }
      else if (decreaseMinClose)
      {
        newMinMode -= modeShiftExt[std::min(deltaSize + 1, 5)] - modeShiftExt[deltaSize];
      }
    }
    int previous = deltaSize;
    int extRef   = (decreaseMinFar || increaseMaxFar) ? 2 : (decreaseMinClose || increaseMaxClose) ? 1 : 0;
    for (int d = 1; d <= extRef; d++)
    {
      if (uiWidth > uiHeight)
      {
        newMinMode -= abs(modeShiftExt[abs(previous)] - modeShiftExt[std::min(abs(deltaSize - d), 5)]);
      }
      if (uiWidth < uiHeight)
      {
        newMaxMode += abs(modeShiftExt[abs(previous)] - modeShiftExt[std::min(abs(deltaSize - d), 5)]);
      }
      previous = deltaSize - d;
    }
    for (int i = newMinMode + 1; i < newMaxMode; i += 5)
    {
      // Mode is a regular mode (already tested)
      if (i >= minModeOrig && i <= maxModeOrig)
      {
        i = maxModeOrig - 1;
        continue;
      }
      uint64_t uiCost = 0;
      uint64_t tmpCost0 = 0;
      uint64_t tmpCost1 = 0;
      int      iMode  = i;
      iMode           = getTimdRegularAngleExt(uiWidth, uiHeight, iMode);
      initPredTimdIntraParams(pu, area, iMode, false, false);
      iMode = getTimdWideAngleExt(uiWidth, uiHeight, iMode);
      predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
        (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
        (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);

      if (eTempType == LEFT_ABOVE_NEIGHBOR)
      {
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
      }
      else if (eTempType == ABOVE_NEIGHBOR)
      {
        tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
      }
      else if (eTempType == LEFT_NEIGHBOR)
      {
        tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
      }
      else
      {
        CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
      }

      uiCost = tmpCost0 + tmpCost1;
      if (uiCost < uiBestCost)
      {

        uiSecondaryCost = uiBestCost;
        iSecondaryMode  = iBestMode;
        uiBestCost      = uiCost;
        iBestMode             = iMode;
        bSecondaryModeCheckWA = bBestModeCheckWA;
        bBestModeCheckWA      = false;
      }
      else if (uiCost < uiSecondaryCost)
      {

        uiSecondaryCost = uiCost;
        iSecondaryMode        = iMode;

        bSecondaryModeCheckWA = false;
      }
      if (uiSecondaryCost <= maxCost)
      {
        break;
      }
    }
#endif
    int midMode = iBestMode;
#if JVET_AC0094_REF_SAMPLES_OPT
    bool checkWideAngle = bBestModeCheckWA;
    if ((midMode > DC_IDX && uiBestCost > maxCost && checkWideAngle) || (uiBestCost > maxCost && !checkWideAngle))
#else
    if (midMode > DC_IDX && uiBestCost > maxCost)
#endif
    {
      for (int i = -1; i <= 1; i += 2)
      {
        int iMode = midMode + i;
#if JVET_AC0094_REF_SAMPLES_OPT
        if (checkWideAngle && (iMode <= DC_IDX || iMode > EXT_VDIA_IDX))
        {
          continue;
        }
        if (!checkWideAngle)
        {
          if (iMode >= minModeOrig && iMode <= maxModeOrig)
          {
            continue;
          }
          iMode = getTimdRegularAngleExt(uiWidth, uiHeight, iMode);
        }
#else
        if (iMode <= DC_IDX || iMode > EXT_VDIA_IDX)
        {
          continue;
        }
#endif
        initPredTimdIntraParams(pu, area, iMode
#if JVET_AC0094_REF_SAMPLES_OPT
          , false, checkWideAngle
#endif
        );
#if JVET_AC0094_REF_SAMPLES_OPT
        if (!checkWideAngle)
        {
          iMode = getTimdWideAngleExt(uiWidth, uiHeight, iMode);
        }
#endif
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
          (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
          (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
        uint64_t uiCost = 0;
        uint64_t tmpCost0 = 0;
        uint64_t tmpCost1 = 0;
        if (eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);


        }
        else if (eTempType == ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        }
        else if (eTempType == LEFT_NEIGHBOR)
        {
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else
        {
          CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
        }

        uiCost = tmpCost0 + tmpCost1;
        if (uiCost < uiBestCost)
        {
          uiBestCost = uiCost;
          iBestMode  = iMode;
        }
        if (uiBestCost <= maxCost)
        {
          break;
        }
      }
    }

    midMode = iSecondaryMode;
#if JVET_AC0094_REF_SAMPLES_OPT
    checkWideAngle = bSecondaryModeCheckWA;
    if ((midMode > DC_IDX && uiBestCost > maxCost && checkWideAngle) || (uiBestCost > maxCost && !checkWideAngle))
#else
    if (midMode > DC_IDX && uiSecondaryCost > maxCost)
#endif
    {
      for (int i = -1; i <= 1; i += 2)
      {
        int iMode = midMode + i;
#if JVET_AC0094_REF_SAMPLES_OPT
        if (checkWideAngle && (iMode <= DC_IDX || iMode > EXT_VDIA_IDX))
#else
        if (iMode <= DC_IDX || iMode > EXT_VDIA_IDX)
#endif
        {
          continue;
        }
#if JVET_AC0094_REF_SAMPLES_OPT
        if (!checkWideAngle)
        {
          if (iMode >= minModeOrig && iMode <= maxModeOrig)
          {
            continue;
          }
          iMode = getTimdRegularAngleExt(uiWidth, uiHeight, iMode);
        }
#endif
        initPredTimdIntraParams(pu, area, iMode
#if JVET_AC0094_REF_SAMPLES_OPT
          , false, checkWideAngle
#endif
        );
#if JVET_AC0094_REF_SAMPLES_OPT
        if (!checkWideAngle)
        {
          iMode = getTimdWideAngleExt(uiWidth, uiHeight, iMode);
        }
#endif
        predTimdIntraAng(COMPONENT_Y, pu, iMode, piPred, uiPredStride, uiRealW, uiRealH, eTempType,
          (eTempType == ABOVE_NEIGHBOR) ? 0 : iTempWidth,
          (eTempType == LEFT_NEIGHBOR) ? 0 : iTempHeight);
        uint64_t uiCost = 0;
        uint64_t tmpCost0 = 0;
        uint64_t tmpCost1 = 0;
        if (eTempType == LEFT_ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else if (eTempType == ABOVE_NEIGHBOR)
        {
          tmpCost0 = distParamSad[0].distFunc(distParamSad[0]);
        }
        else if (eTempType == LEFT_NEIGHBOR)
        {
          tmpCost1 = distParamSad[1].distFunc(distParamSad[1]);
        }
        else
        {
          CHECK((eTempType <= NO_NEIGHBOR) || (eTempType >LEFT_ABOVE_NEIGHBOR),"Wrong template type" );
        }

        uiCost = tmpCost0 + tmpCost1;
        if (uiCost < uiSecondaryCost)
        {
          uiSecondaryCost = uiCost;
          iSecondaryMode  = iMode;
        }
        if (uiSecondaryCost <= maxCost)
        {
          break;
        }
      }
    }

#if JVET_AC0094_REF_SAMPLES_OPT
    if (!bBestModeCheckWA)
    {
      iBestMode = getTimdRegularAngleExt(uiWidth, uiHeight, iBestMode);
    }
    if (!bSecondaryModeCheckWA)
    {
      iSecondaryMode = getTimdRegularAngleExt(uiWidth, uiHeight, iSecondaryMode);
    }
#endif

    if (uiSecondaryCost < uiBestCost)
    {
      std::swap(uiSecondaryCost, uiBestCost);
      std::swap(iSecondaryMode, iBestMode);
      std::swap(bSecondaryModeCheckWA, bBestModeCheckWA);
    }

    // if( uiSecondaryCost < 2 * uiBestCost ), 2 * uiBestCost can overflow uint64_t
#if JVET_AG0092_ENHANCED_TIMD_FUSION
    if( !( (uiSecondaryCost < uiBestCost || (uiSecondaryCost - uiBestCost < uiBestCost)) ) && (iBestMode > DC_IDX) )
    {
      uiSecondaryCost = uiBestCost;
      iSecondaryMode  = iBestMode;
#if JVET_AC0094_REF_SAMPLES_OPT
      bSecondaryModeCheckWA = bBestModeCheckWA;
#endif
    }
#endif

    // if( uiSecondaryCost < 2 * uiBestCost ), 2 * uiBestCost can overflow uint64_t
    if (uiSecondaryCost < uiBestCost || (uiSecondaryCost - uiBestCost < uiBestCost))
    {
      cu.timdModeSad          = iBestMode;
      cu.timdIsBlendedSad     = true;
      cu.timdModeSecondarySad = iSecondaryMode;
#if JVET_AC0094_REF_SAMPLES_OPT
      cu.timdModeCheckWASad          = bBestModeCheckWA;
      cu.timdModeSecondaryCheckWASad = bSecondaryModeCheckWA;
#endif

      const int blend_sum_weight = 6;
      int       sum_weight       = 1 << blend_sum_weight;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
      if ( ((iBestMode != iNonAngMode) && (iSecondaryMode != iNonAngMode)) && ( (uiNonAngCost < uiBestCost) || (uiNonAngCost - uiBestCost < (uiBestCost>>1)) ) )
      {
        cu.timdModeNonAngSad = iNonAngMode;

        double dCost[3] = {0};
        dCost[0] = (double) uiBestCost;
        dCost[1] = (double) uiSecondaryCost;
        dCost[2] = (double) uiNonAngCost;
        double sum = dCost[0] + dCost[1] + dCost[2];
        double dRatio[2] = {0.0};
        int    iRatio[2] = {0};
        for(int i = 0; i<2 ; i++)
        {
          dRatio[i] = (sum - dCost[i]) / (2 * sum);
          iRatio[i] = static_cast<int>(dRatio[i] * sum_weight + 0.5);     
        }

        cu.timdFusionWeightSad[0] = iRatio[0];
        cu.timdFusionWeightSad[1] = iRatio[1];
        cu.timdFusionWeightSad[2] = sum_weight - iRatio[0] - iRatio[1];
      }
      else
      {
#endif

#if JVET_X0149_TIMD_DIMD_LUT
        int      g_gradDivTable[16] = { 0, 7, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 1, 1, 0 };
        uint64_t s0                 = uiSecondaryCost;
        // uiBestCost + uiSecondaryCost can overlow uint64_t
        uint64_t s1 = (MAX_UINT64 - uiSecondaryCost < uiBestCost) ? MAX_UINT64 : (uiBestCost + uiSecondaryCost);
        int      x  = floorLog2Uint64(s1);
        CHECK(x < 0, "floor log2 value should be no negative");
        int normS1 = int(s1 << 4 >> x) & 15;
        int v       = g_gradDivTable[normS1] | 8;
        x += (normS1 != 0);
        int shift  = x + 3;
        int add    = (1 << (shift - 1));
        int iRatio = int((s0 * v * sum_weight + add) >> shift);

        if (iRatio > sum_weight)
        {
          iRatio = sum_weight;
        }

        CHECK(iRatio > sum_weight, "Wrong DIMD ratio");
#else
        double dRatio = 0.0;
        dRatio        = (double) uiSecondaryCost / (double) (uiBestCost + uiSecondaryCost);
        int iRatio    = static_cast<int>(dRatio * sum_weight + 0.5);
#endif
        cu.timdFusionWeightSad[0] = iRatio;
        cu.timdFusionWeightSad[1] = sum_weight - iRatio;
#if JVET_AG0092_ENHANCED_TIMD_FUSION
        cu.timdFusionWeightSad[TIMD_FUSION_NUM - 1] = 0;
      }
#endif
    }
    else
    {
#if JVET_AC0094_REF_SAMPLES_OPT
      cu.timdModeCheckWASad          = bBestModeCheckWA;
      cu.timdModeSecondaryCheckWASad = true;
#endif
      cu.timdModeSad      = iBestMode;
      cu.timdIsBlendedSad = false;
    }
    return iBestMode;
  }
  else
  {
#if JVET_AC0094_REF_SAMPLES_OPT
    cu.timdModeCheckWASad          = true;
    cu.timdModeSecondaryCheckWASad = true;
#endif

    cu.timdModeSad      = PLANAR_IDX;
    cu.timdIsBlendedSad = false;
    return PLANAR_IDX;
  }
}
#endif
#if INTRA_TRANS_ENC_OPT
void IntraPrediction::timdBlending(Pel *pDst, int strideDst, Pel *pSrc, int strideSrc, int w0, int w1, int width, int height)
{
  const int log2WeightSum = 6;
  Pel *pelPred = pDst;
  Pel *pelPredFusion = pSrc;

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int blend = pelPred[x] * w0;
      blend += pelPredFusion[x] * w1;
      pelPred[x] = (Pel)(blend >> log2WeightSum);
    }

    pelPred += strideDst;
    pelPredFusion += strideSrc;
  }
}
#endif
#endif

#if JVET_AC0112_IBC_CIIP
void IntraPrediction::ibcCiipBlending(Pel *pDst, int strideDst, const Pel *pSrc0, int strideSrc0, Pel *pSrc1, int strideSrc1, int w0, int w1, int shift, int width, int height)
{
  Pel *pelPred = pDst;
  const Pel *pelPlanar = pSrc0;
  Pel *pelPredAng = pSrc1;
  int offset = 1 << (shift - 1);
  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int blend = pelPlanar[x] * w0;
      blend += pelPredAng[x] * w1;
      pelPred[x] = (Pel)((blend + offset) >> shift);
    }
    pelPred += strideDst;
    pelPlanar += strideSrc0;
    pelPredAng += strideSrc1;
  }
}
#endif

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
bool IntraPrediction::getGradForOBMC(const PredictionUnit pu, const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu, const bool isAbove, const int blkSize, int* modeBuf)
{
#if JVET_AK0076_EXTENDED_OBMC_IBC
  if ((CU::isIBC(*pu.cu) || PU::isTmp(pu)) && !cu.slice->getSPS()->getUseDimd())
  {
    return false;
  }
#endif

  const int templateSize = 1;
  
  const CodingStructure  &cs = *cu.cs;

  const Pel *pReco = recoBuf.buf;
  const uint32_t uiWidth = area.width;
  const uint32_t uiHeight = area.height;
  const int iStride = recoBuf.stride;
  
  int totalUnits;
  if (isAbove)
  {
    const Position posNeighbor(pu.lumaPos().offset(1, -1));

    PredictionUnit* tmpPu = pu.cs->getPU(posNeighbor, pu.chType);
    if (tmpPu == nullptr)
    {
      return false;
    }
    
    totalUnits = uiWidth / blkSize;
  }
  else
  {
    const Position posNeighbor(pu.lumaPos().offset(-1, 1));

    PredictionUnit* tmpPu = pu.cs->getPU(posNeighbor, pu.chType);
    if (tmpPu == nullptr)
    {
      return false;
    }

    totalUnits = uiHeight / blkSize;
  }
  memset(modeBuf, -1, sizeof(int) * totalUnits);

  const Position posLT = cu.Y().topLeft().offset(-1, -1);
  const Position posLB = cu.Y().bottomLeft().offset(-1, 1);
  const Position posRT = cu.Y().topRight().offset(1, -1);

  if (isAbove)
  {
    const bool isExistFirst = (cs.getCURestricted(posLT, cu, cu.chType) != nullptr);
    const bool isExistLast = (cs.getCURestricted(posRT, cu, cu.chType) != nullptr);
    const Pel *pRecoAbove = pReco - 2 * iStride;

    calcGradForOBMC(pu, pRecoAbove, iStride, totalUnits, templateSize, blkSize, modeBuf, isAbove, isExistFirst, isExistLast);
  }
  else
  {
    const bool isExistFirst = (cs.getCURestricted(posLT, cu, cu.chType) != nullptr);
    const bool isExistLast = (cs.getCURestricted(posLB, cu, cu.chType) != nullptr);
    const Pel *pRecoLeft = pReco - 2;

    calcGradForOBMC(pu, pRecoLeft, iStride, totalUnits, templateSize, blkSize, modeBuf, isAbove, isExistFirst, isExistLast);
  }

  return true;
}
#endif

#if ENABLE_DIMD
void IntraPrediction::deriveDimdMode(const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu
#if JVET_AK0059_MDIP
  , bool useExcludingMode
#endif
)
{
  if( !cu.slice->getSPS()->getUseDimd() )
  {
    return;
  }
#if JVET_AJ0267_ADAPTIVE_HOG
  bool useAdaptive = ((cu.cs->slice->getSliceType() != I_SLICE) || (cu.lwidth() * cu.lheight()) >= 128) ? true : false;
  if (useAdaptive)
  {
#if JVET_AK0059_MDIP
    deriveDimdModeAdaptive(recoBuf, area, cu, useExcludingMode);
#else
    deriveDimdModeAdaptive(recoBuf, area, cu);
#endif
    return;
  }
#endif

  const CodingStructure  &cs = *cu.cs;
  const SPS             &sps = *cs.sps;
  const PreCalcValues   &pcv = *cs.pcv;
  const ChannelType   chType = toChannelType(area.compID);

  const Pel *pReco = recoBuf.buf;
  const uint32_t uiWidth = area.width;
  const uint32_t uiHeight = area.height;
  const int iStride = recoBuf.stride;
#if JVET_AC0098_LOC_DEP_DIMD
  const int predSize = uiWidth + 1;
  const int predHSize = uiHeight + 1;
#else
  const int predSize = (uiWidth << 1);
  const int predHSize = (uiHeight << 1);
#endif

  const bool noShift = pcv.noChroma2x2 && uiWidth == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight;
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
  const int  numAboveUnits = std::max<int>(uiWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(uiHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  CHECK(numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported");

  // ----- Step 1: analyze neighborhood -----
  const Position posLT = area;

  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(neighborFlags, 0, totalUnits);

  int numIntraAbove = isAboveAvailable(cu, chType, posLT, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1));
  int numIntraLeft = isLeftAvailable(cu, chType, posLT, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));
#if JVET_AC0094_REF_SAMPLES_OPT || JVET_AC0098_LOC_DEP_DIMD
  const int numIntraAboveRight = isAboveRightAvailable(cu, chType, area.topRight(), numAboveRightUnits, unitWidth, neighborFlags + totalLeftUnits + 1 + numAboveUnits);
  const int numIntraBottomLeft = isBelowLeftAvailable(cu, chType, area.bottomLeft(), numLeftBelowUnits, unitHeight, neighborFlags + totalLeftUnits - 1 - numLeftUnits);
#endif

  // ----- Step 2: build histogram of gradients -----
#if JVET_AC0098_LOC_DEP_DIMD
  int histogramTop[NUM_LUMA_MODE] = { 0 };
  int histogramLeft[NUM_LUMA_MODE] = { 0 };

  int histogramTopLeft[NUM_LUMA_MODE] = { 0 };
#endif
  int histogram[NUM_LUMA_MODE] = { 0 };

#if JVET_AJ0203_DIMD_2X2_EDGE_OP
  const int edgeOperatorSizeIdx = static_cast<int>(use2x2EdgeOperator(area));
  const int recoLineOffset      = edgeOperatorSizeIdx == 1 ? 0 : 1;
#endif 

  if (numIntraLeft)
  {
#if JVET_AC0094_REF_SAMPLES_OPT || JVET_AC0098_LOC_DEP_DIMD
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    const uint32_t uiHeightLeft = (numIntraLeft + numIntraBottomLeft) * unitHeight - recoLineOffset - (!numIntraAbove ? 1 : 0);
#else 
    const uint32_t uiHeightLeft = (numIntraLeft + numIntraBottomLeft) * unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#endif 
#else
    uint32_t uiHeightLeft = numIntraLeft * unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    const Pel *pRecoLeft = pReco - 1 - recoLineOffset + iStride * (!numIntraAbove ? 1 : 0);
#else 
    const Pel *pRecoLeft = pReco - 2 + iStride * (!numIntraAbove ? 1 : 0);
#endif 
#if JVET_AC0098_LOC_DEP_DIMD
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    buildHistogram(pRecoLeft, iStride, uiHeightLeft, 1, histogramLeft, 1, uiWidth, uiHeight, edgeOperatorSizeIdx);
#else 
    buildHistogram(pRecoLeft, iStride, uiHeightLeft, 1, histogramLeft, 1, uiWidth, uiHeight);
#endif 
#else
    buildHistogram(pRecoLeft, iStride, uiHeightLeft, 1, histogram, 1, uiWidth, uiHeight);
#endif
  }

  if (numIntraAbove)
  {
#if JVET_AC0094_REF_SAMPLES_OPT || JVET_AC0098_LOC_DEP_DIMD
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    const uint32_t uiWidthAbove = (numIntraAbove + numIntraAboveRight)*unitWidth - recoLineOffset - (!numIntraLeft ? 1 : 0);
#else 
    const uint32_t uiWidthAbove = (numIntraAbove + numIntraAboveRight)*unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#endif 
#else
    uint32_t uiWidthAbove = numIntraAbove * unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    const Pel *pRecoAbove = pReco - iStride * (1 + recoLineOffset) + (!numIntraLeft ? 1 : 0);
#else 
    const Pel *pRecoAbove = pReco - iStride * 2 + (!numIntraLeft ? 1 : 0);
#endif 
#if JVET_AC0098_LOC_DEP_DIMD
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    buildHistogram(pRecoAbove, iStride, 1, uiWidthAbove, histogramTop, 2, uiWidth, uiHeight, edgeOperatorSizeIdx);
#else 
    buildHistogram(pRecoAbove, iStride, 1, uiWidthAbove, histogramTop, 2, uiWidth, uiHeight);
#endif 
#else
    buildHistogram(pRecoAbove, iStride, 1, uiWidthAbove, histogram, 2, uiWidth, uiHeight);
#endif
  }

  if (numIntraLeft && numIntraAbove)
  {
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    const Pel* pRecoAboveLeft = pReco - 1 - recoLineOffset - iStride * (1 + recoLineOffset);
#else 
    const Pel* pRecoAboveLeft = pReco - 2 - iStride * 2;
#endif 
#if JVET_AC0098_LOC_DEP_DIMD
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    if (edgeOperatorSizeIdx == 1)
    {
      buildHistogram(pRecoAboveLeft, iStride, 1, 1, histogramTopLeft, 0, uiWidth, uiHeight, edgeOperatorSizeIdx);
    }
    else
    {
      buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogramTopLeft, 3, uiWidth, uiHeight, edgeOperatorSizeIdx);
    }
#else 
    buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogramTopLeft, 3, uiWidth, uiHeight);
#endif 
#else
    buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogram, 3, uiWidth, uiHeight);
#endif
  }
#if JVET_AC0098_LOC_DEP_DIMD
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    histogram[i] = histogramTop[i] + histogramLeft[i] + histogramTopLeft[i];
  }
#endif
#if JVET_AK0059_MDIP
  if(useExcludingMode && !CU::allowMdip(cu) && cu.cs->sps->getUseMdip())
  {
    bool includedMode[NUM_LUMA_MODE]{ false };
    buildExcludingMode(cu, histogram, includedMode);
  }
#endif

#if JVET_AB0157_INTRA_FUSION
  int amp[DIMD_FUSION_NUM-1] = { 0 };
  int curAmp         = 0;
  int mode[DIMD_FUSION_NUM-1] = { 0 };
  int curMode         = 0;
#if JVET_AJ0267_ADAPTIVE_HOG
  int numPred = (((cu.lwidth() * cu.lheight()) >= 128) ? DIMD_FUSION_NUM : DIMD_FUSION_NUM_SMALL);
#endif
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = histogram[i];
    curMode = i;
#if JVET_AJ0267_ADAPTIVE_HOG
    for (int j = 0; j < numPred - 1; j++)
#else
    for (int j = 0; j < DIMD_FUSION_NUM - 1; j++)
#endif
    {
      if (curAmp > amp[j])
      {
#if JVET_AJ0267_ADAPTIVE_HOG
        for (int k = numPred - 2; k > j; k--)
#else
        for (int k = DIMD_FUSION_NUM - 2; k > j; k--)
#endif
        {
          amp[k] = amp[k - 1];
          mode[k] = mode[k - 1];
        }
        amp[j] = curAmp;
        mode[j] = curMode;
        break;
      }
    }
  }

#if JVET_AC0098_LOC_DEP_DIMD
  for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
  {
    cu.dimdLocDep[i] = 0;
  }
  for(int i = 0; i < DIMD_FUSION_NUM - 1; i++)
  {
    int secondMode = mode[i];
    if (secondMode > DC_IDX)
    {
      cu.dimdLocDep[i] = 0;

      int ampSecond = histogram[secondMode];
      int ampSecondLeft = histogramLeft[secondMode];
      int ampSecondAbove = histogramTop[secondMode];
        
      if (ampSecondLeft < (ampSecond / 3))
      {
        cu.dimdLocDep[i] = 1;
      }
      else if (ampSecondAbove < (ampSecond / 3))
      {
        cu.dimdLocDep[i] = 2;
      }
    }
  }
#endif
#if JVET_AK0187_IMPLICIT_MTS_LUT_EXTENSION
  cu.candModeListForTransform[0] = mode[0];
  cu.candModeListForTransform[1] = mode[1];
#endif

  cu.dimdMode = mode[0];

  cu.dimdBlending = true;
  cu.dimdBlending &= amp[1] > 0;
  cu.dimdBlending &= mode[1] > DC_IDX;
  cu.dimdBlending &= mode[0] > DC_IDX;

#if JVET_AC0098_LOC_DEP_DIMD
  if (cu.dimdLocDep[0] != 0 && amp[1] == 0)
  {
    cu.dimdBlending = true;
    cu.dimdBlending &= mode[0] > DC_IDX;
    mode[1] = 0;
    CHECK( mode[2] != 0, "Wrong logic" );
  } 
#endif

  int countBlendMode = 2;

  if( cu.dimdBlending )
  {
    for (int i = 0; i < DIMD_FUSION_NUM - 2; i++)
    {
      cu.dimdBlendMode[i] = mode[i+1];
      if (cu.dimdBlendMode[i] != PLANAR_IDX)
      {
        countBlendMode++;
      }
    }
  }

#if JVET_X0149_TIMD_DIMD_LUT
  int log2BlendWeight = 6;
  int dimdPlanarWeight = 64/4;
  int sumWeight = (1 << log2BlendWeight);
#else
  const int blendSumWeight = 6;
  int sumWeight = 1 << blendSumWeight;
#endif
  if (cu.dimdBlending)
  {
#if JVET_X0149_TIMD_DIMD_LUT
    int g_gradDivTable[16] = { 0, 7, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 1, 1, 0 };
#if JVET_AC0098_LOC_DEP_DIMD
    if (mode[1] == 0)
    {    
      CHECK( cu.dimdLocDep[0] == 0, "Wrong logic" );
      cu.dimdRelWeight[0] = sumWeight - 21;
      cu.dimdRelWeight[1] = 21;
      cu.dimdRelWeight[2] = 0;
      cu.dimdRelWeight[3] = 0;
      cu.dimdRelWeight[4] = 0;
      cu.dimdRelWeight[5] = 0;
    }
    else
    {
#endif
    sumWeight = sumWeight - dimdPlanarWeight;
    int s1 = 0;
    for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
    {
      s1 = s1 + amp[i];
    }
    int x = floorLog2(s1);
    CHECK(x < 0, "floor log2 value should be no negative");
    int normS1 = (s1 << 4 >> x) & 15;
    int v = g_gradDivTable[normS1] | 8;
    x += (normS1 != 0);
    int shift = x + 3;
    int add = (1 << (shift - 1));
    int iRatio[DIMD_FUSION_NUM - 1] = { 0 };
    for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
    {
      iRatio[i] = (amp[i] * v * sumWeight + add) >> shift;
      if (amp[i] == 0)
      {
        iRatio[i] = 0;
      }
      if( iRatio[i] > sumWeight )
      {
        iRatio[i] = sumWeight;
      }
      CHECK( iRatio[i] > sumWeight, "Wrong DIMD ratio" );
    }
#else
    double dRatio = 0.0;
    sumWeight -= static_cast<int>((double)sumWeight / 3);
    dRatio = (double)firstAmp / (double)(firstAmp + secondAmp);
    int iRatio = static_cast<int>(dRatio * sumWeight);
#endif
    cu.dimdRelWeight[0] = iRatio[0];
#if JVET_AC0098_LOC_DEP_DIMD
    int sumWeightReal = iRatio[0];
    int countBlendModeNew = countBlendMode;
    int lastFilled = 0;
#endif
    for (int i = 1; i < countBlendMode - 2; i++)
    {
      cu.dimdRelWeight[i+1] = iRatio[i];
#if JVET_AC0098_LOC_DEP_DIMD
      sumWeightReal += iRatio[i];
      if(sumWeightReal > sumWeight)
      {
        lastFilled = i;
        break;
      }
#endif
    }
#if JVET_AC0098_LOC_DEP_DIMD
    if(sumWeightReal > sumWeight)
    {
      for (int i = lastFilled + 1; i <= countBlendMode - 2; i++)
      {
        iRatio[i] = 0;
        cu.dimdRelWeight[i + 1] = 0;
        cu.dimdBlendMode[i - 1] = 0;
        countBlendModeNew--;  
      }
    }
    countBlendMode = countBlendModeNew;
    if (sumWeightReal > sumWeight)
    {
      int diff = sumWeightReal - sumWeight;
      for (int j = 0; j < sumWeight; j++)
      {
        for (int i = lastFilled; i >= 1; i--)
        {
          CHECK( i < 0, "Wrong index" );
          CHECK( i >= DIMD_FUSION_NUM - 1, "Wrong index" );

          iRatio[i] -=1;
          cu.dimdRelWeight[i+1] = iRatio[i];

          if (cu.dimdRelWeight[i+1] == 0)
          {
            CHECK( i < 1, "Wrong index" );
            cu.dimdBlendMode[i-1] = 0;
            countBlendMode--;
          }
          diff--;
          if(diff == 0)
          {
            break;
          }
        }
        if(diff == 0)
        {
          break;
        }
      }
    }
#endif
    cu.dimdRelWeight[countBlendMode-1] = sumWeight;
    for (int i = 0; i < countBlendMode - 2; i++)
    {
      cu.dimdRelWeight[countBlendMode-1] = cu.dimdRelWeight[countBlendMode-1] - iRatio[i];
#if JVET_AC0098_LOC_DEP_DIMD
      if (cu.dimdRelWeight[countBlendMode-1] == 0)
      {
        cu.dimdBlendMode[countBlendMode-3] = 0;
      }
#endif
    }
#if JVET_X0149_TIMD_DIMD_LUT
    cu.dimdRelWeight[1] = dimdPlanarWeight;
#else
    cu.dimdRelWeight[1] = (1 << blendSumWeight) - sumWeight;
#endif
#if JVET_AC0098_LOC_DEP_DIMD
    }
#endif
  }
  else
  {
    cu.dimdRelWeight[0] = sumWeight;
    for (int i = 1; i < DIMD_FUSION_NUM; i++)
    {
      cu.dimdRelWeight[i] = 0;
    }
  }
#else
  int firstAmp = 0, secondAmp = 0, curAmp = 0;
  int firstMode = 0, secondMode = 0, curMode = 0;

  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = histogram[i];
    curMode = i;
    if (curAmp > firstAmp)
    {
      secondAmp = firstAmp;
      secondMode = firstMode;
      firstAmp = curAmp;
      firstMode = curMode;
    }
    else
    {
      if (curAmp > secondAmp)
      {
        secondAmp = curAmp;
        secondMode = curMode;
      }
    }
  }

#if JVET_AC0098_LOC_DEP_DIMD
  cu.dimdLocDep[0] = 0;
  cu.dimdLocDep[1] = 0;

  if (firstMode > DC_IDX)
  {
    cu.dimdLocDep[0] = 0;

    int ampFirst = histogram[firstMode];
    int ampFirstLeft = histogramLeft[firstMode];
    int ampFirstAbove = histogramTop[firstMode];

    if (ampFirstLeft == 0)
    {
      cu.dimdLocDep[0] = 1;
    }  
    else if (ampFirstAbove == 0)
    {
      cu.dimdLocDep[0] = 2;
    }
    else if (ampFirstLeft < (ampFirst / 3))
    {
      cu.dimdLocDep[0] = 3;
    }
    else if (ampFirstAbove < (ampFirst / 3))
    {
      cu.dimdLocDep[0] = 4;
    }
  }

  if (secondMode > DC_IDX)
  {
    cu.dimdLocDep[1] = 0;

    int ampSecond = histogram[secondMode];
    int ampSecondLeft = histogramLeft[secondMode];
    int ampSecondAbove = histogramTop[secondMode];

    if  (ampSecondLeft < (ampSecond / 3))
    {
      cu.dimdLocDep[1] = 1;
    }
    else if (ampSecondAbove < (ampSecond / 3))
    {
      cu.dimdLocDep[1] = 2;
    }
  }
#endif

  // ----- Step 3: derive best mode from histogram of gradients -----
  cu.dimdMode = firstMode;

  cu.dimdBlending = true;
  cu.dimdBlending &= secondAmp > 0;
  cu.dimdBlending &= secondMode > DC_IDX;
  cu.dimdBlending &= firstMode > DC_IDX;

#if JVET_AC0098_LOC_DEP_DIMD
  if (cu.dimdLocDep[0] != 0 && secondMode == 0)
  {
    cu.dimdBlending = true;
    cu.dimdBlending &= firstMode > DC_IDX;
    secondAmp = 0;
  } 
#endif

  if( cu.dimdBlending )
  {
    cu.dimdBlendMode[0] = secondMode;
  }

#if JVET_X0149_TIMD_DIMD_LUT
  const int log2BlendWeight = 6;
  const int planarWeight = 21;
  int sumWeight = 1 << log2BlendWeight;
#else
  const int blendSumWeight = 6;
  int sumWeight = 1 << blend_sum_weight;
#endif
  if (cu.dimdBlending)
  {
#if JVET_AC0098_LOC_DEP_DIMD
    if (secondMode == 0)
    {
      cu.dimdRelWeight[0] = sumWeight - planarWeight;
      cu.dimdRelWeight[2] = 0;
      cu.dimdRelWeight[1] = planarWeight;
    }
    else
    {
#endif
#if JVET_X0149_TIMD_DIMD_LUT
    sumWeight = sumWeight - planarWeight;
    int s0 = firstAmp;
    int s1 = firstAmp + secondAmp;
    int x = floorLog2(s1);

    CHECK(x < 0, "floor log2 value should be no negative");

    int norm = (s1 << 4 >> x) & 15;
    int v = g_gradDivTable[norm] | 8;
    x += (norm != 0);
    int shift = x + 3;
    int add = (1 << (shift - 1));
    int ratio = (s0 * v * sumWeight + add) >> shift;

    if( ratio > sumWeight )
    {
      ratio = sumWeight;
    }

    CHECK( ratio > sumWeight, "Wrong DIMD ratio" );
#else
    double dRatio = 0.0;
    sum_weight -= static_cast<int>((double)sumWeight / 3); // ~ 1/3 of the weight to be reserved for planar
    dRatio = (double)firstAmp / (double)(firstAmp + secondAmp);
    int ratio = static_cast<int>(dRatio * sumWeight);
#endif
    cu.dimdRelWeight[0] = ratio;
    cu.dimdRelWeight[2] = sumWeight - ratio;
#if JVET_X0149_TIMD_DIMD_LUT
    cu.dimdRelWeight[1] = planarWeight;
#else
    cu.dimdRelWeight[1] = (1 << blendSumWeight) - sumWeight;
#endif
#if JVET_AC0098_LOC_DEP_DIMD
    }
#endif
  }
  else
  {
    cu.dimdRelWeight[0] = sumWeight;
    cu.dimdRelWeight[1] = 0;
    cu.dimdRelWeight[2] = 0;
  }
#endif
}

#if JVET_AJ0267_ADAPTIVE_HOG
void IntraPrediction::deriveDimdModeAdaptive(const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu
#if JVET_AK0059_MDIP
  , bool useExcludingMode
#endif
)
{
  if( !cu.slice->getSPS()->getUseDimd() )
  {
    return;
  }

  const CodingStructure  &cs = *cu.cs;
  const SPS             &sps = *cs.sps;
  const PreCalcValues   &pcv = *cs.pcv;
  const ChannelType   chType = toChannelType(area.compID);

  const Pel *pReco = recoBuf.buf;
  const uint32_t uiWidth = area.width;
  const uint32_t uiHeight = area.height;
  const int iStride = recoBuf.stride;
  const int predSize = uiWidth + 1;
  const int predHSize = uiHeight + 1;

  const bool noShift = pcv.noChroma2x2 && uiWidth == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight;
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
  const int  numAboveUnits = std::max<int>(uiWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(uiHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  CHECK(numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported");

  // ----- Step 1: analyze neighborhood -----
  const Position posLT = area;

  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(neighborFlags, 0, totalUnits);
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
  const int edgeOperatorSizeIdx = static_cast<int>(use2x2EdgeOperator(area));
#endif 

  int numIntraAbove = isAboveAvailable(cu, chType, posLT, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1));
  int numIntraLeft = isLeftAvailable(cu, chType, posLT, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));
  const int numIntraAboveRight = isAboveRightAvailable(cu, chType, area.topRight(), numAboveRightUnits, unitWidth, neighborFlags + totalLeftUnits + 1 + numAboveUnits);
  const int numIntraBottomLeft = isBelowLeftAvailable(cu, chType, area.bottomLeft(), numLeftBelowUnits, unitHeight, neighborFlags + totalLeftUnits - 1 - numLeftUnits);

  int templateSizeLeft  = numIntraLeft  ? ((numIntraLeft  + numIntraBottomLeft) * unitHeight - 1 - (!numIntraAbove ? 1 : 0)) : 0;
  int templateSizeAbove = numIntraAbove ? ((numIntraAbove + numIntraAboveRight) * unitWidth  - 1 - (!numIntraLeft  ? 1 : 0)) : 0;
  int numIntraAboveExt[MAX_DIMD_TEMPLATE_SIZE >> 2];
  int numIntraLeftExt[MAX_DIMD_TEMPLATE_SIZE >> 2];

  int numIntraAboveRightExt[MAX_DIMD_TEMPLATE_SIZE >> 2];
  int numIntraBottomLeftExt[MAX_DIMD_TEMPLATE_SIZE >> 2];

  bool isAboveLeft[MAX_DIMD_TEMPLATE_SIZE >> 2];
  bool isLeftAbove[MAX_DIMD_TEMPLATE_SIZE >> 2];
  for (int i = 0; i < MAX_DIMD_TEMPLATE_SIZE >> 2; i++)
  {
    numIntraAboveExt[i] = isAboveAvailable(cu, chType, posLT.offset(0, -4*(i)), numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1));
    numIntraLeftExt[i] = isLeftAvailable(cu, chType, posLT.offset(-4*(i), 0), numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));

    numIntraAboveRightExt[i] = (i > 0 ? 0 : isAboveRightAvailable(cu, chType, area.topRight().offset(0, -4*(i)), numAboveRightUnits, unitWidth, neighborFlags + totalLeftUnits + 1 + numAboveUnits));
    numIntraBottomLeftExt[i] = (i > 0 ? 0 : isBelowLeftAvailable(cu, chType, area.bottomLeft().offset(-4*(i), 0), numLeftBelowUnits, unitHeight, neighborFlags + totalLeftUnits - 1 - numLeftUnits));

    isAboveLeft[i] = isAboveAvailable(cu, chType, posLT.offset(-4*(i) - 1, 0), 1, unitWidth, (neighborFlags + totalLeftUnits + 1));
    isLeftAbove[i] = isLeftAvailable(cu, chType, posLT.offset(0, -4*(i) - 1), 1, unitHeight, (neighborFlags + totalLeftUnits - 1));
  }

  int numIntraAboveLarger = isAboveAvailable(cu, chType, posLT.offset(0, -4), numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1));
  int numIntraLeftLarger = isLeftAvailable(cu, chType, posLT.offset(-4, 0), numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));
  bool isAboveLeftAvailLargerABV = isAboveLeftAvailable(cu, chType, posLT.offset(0, -4));
  bool isAboveLeftAvailLargerLFT = isAboveLeftAvailable(cu, chType, posLT.offset(-4, 0));
  bool isAboveLeftAvailLargerAL = isAboveLeftAvailable(cu, chType, posLT.offset(-4, -4));
  bool useLargerTmp = cu.lwidth() * cu.lheight() >= 512;

  // ----- Step 2: build histogram of gradients -----
  int histogramTop[NUM_LUMA_MODE] = { 0 };
  int histogramLeft[NUM_LUMA_MODE] = { 0 };

  int histogramTopLeft[NUM_LUMA_MODE] = { 0 };
  int histogram[NUM_LUMA_MODE] = { 0 };
  if (numIntraLeft)
  {
    bool* isExtraAvailable = isAboveLeft;
    uint32_t uiHeightLeftExt[MAX_DIMD_TEMPLATE_SIZE >> 2] = {0};
    int maxLeftTemplate = 0;
    int maxHeightLeft = 0;
    for (int i = 0; i < MAX_DIMD_TEMPLATE_SIZE >> 2; i++)
    {
      if (numIntraLeftExt[i] != 0)
      {
        uiHeightLeftExt[i] = (numIntraLeftExt[i] + numIntraBottomLeftExt[i]) * unitHeight;
        if (uiHeightLeftExt[i] > maxHeightLeft)
        {
          maxHeightLeft = uiHeightLeftExt[i];
        }
        maxLeftTemplate += 4;
      }
      else
      {
        break;
      }
    }
    uint64_t maxAmp = templateSizeLeft * DIMD_MAX_AMP;
    const CodingUnit* cuNeigh = cu.cs->getCURestricted(cu.lumaPos().offset(-1, 0), cu, CH_L);
    if (cuNeigh->lheight() >= cu.lheight() && cuNeigh->lwidth() > 8)
    {
      maxAmp  = maxAmp + (templateSizeLeft * 500);
    }
    const Pel *pRecoLeft = pReco - maxLeftTemplate;
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    buildHistogramAdaptive(pRecoLeft, iStride, maxHeightLeft, maxLeftTemplate, uiHeightLeftExt, histogramLeft, 1,  cu.lheight(),cu.lwidth(), templateSizeLeft, isExtraAvailable, maxAmp, edgeOperatorSizeIdx);
#else
    buildHistogramAdaptive(pRecoLeft, iStride, maxHeightLeft, maxLeftTemplate, uiHeightLeftExt, histogramLeft, 1,  cu.lheight(),cu.lwidth(), templateSizeLeft, isExtraAvailable, maxAmp);
#endif  
  }

  if (numIntraAbove)
  {
    bool* isExtraAvailable = isLeftAbove;
    uint32_t uiWidthAboveExt[MAX_DIMD_TEMPLATE_SIZE >> 2] = {0};
    int maxAboveTemplate = 0;
    int maxWidthAbove = 0;
    for (int i = 0; i < MAX_DIMD_TEMPLATE_SIZE >> 2; i++)
    {
      if (numIntraAboveExt[i] != 0)
      {
        uiWidthAboveExt[i] = (numIntraAboveExt[i] + numIntraAboveRightExt[i]) * unitWidth;
        if (uiWidthAboveExt[i] > maxWidthAbove)
        {
          maxWidthAbove = uiWidthAboveExt[i];
        }
        maxAboveTemplate += 4;
      }
      else
      {
        break;
      }
    }
    uint64_t maxAmp = templateSizeAbove * DIMD_MAX_AMP;
    const CodingUnit* cuNeigh = cu.cs->getCURestricted(cu.lumaPos().offset(0, -1), cu, CH_L);
    if (cuNeigh->lwidth() >= cu.lwidth() && cuNeigh->lheight() > 8)
    {
      maxAmp  = maxAmp + (templateSizeAbove * 500);
    }
    const Pel *pRecoAbove = pReco - iStride * (maxAboveTemplate);
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
    buildHistogramAdaptive(pRecoAbove, iStride, maxAboveTemplate, maxWidthAbove ,uiWidthAboveExt, histogramTop, 2,  cu.lheight(),cu.lwidth(), templateSizeAbove, isExtraAvailable, maxAmp, edgeOperatorSizeIdx);
#else
    buildHistogramAdaptive(pRecoAbove, iStride, maxAboveTemplate, maxWidthAbove ,uiWidthAboveExt, histogramTop, 2,  cu.lheight(),cu.lwidth(), templateSizeAbove, isExtraAvailable, maxAmp);
#endif
  }

  bool useAL = (numIntraLeft && numIntraAbove);
  if (useLargerTmp)
  {
    useAL = (isAboveLeftAvailLargerABV && isAboveLeftAvailLargerLFT && isAboveLeftAvailLargerAL && numIntraAboveLarger && numIntraLeftLarger);
  }
  if (useAL)
  {
    const int offst = useLargerTmp ? 3 : 1;
    const Pel *pRecoAboveLeft = pReco - 1 - offst - iStride * (1 + offst);
    buildHistogram(pRecoAboveLeft, iStride, (1 + offst), (1 + offst), histogramTopLeft, 3, uiWidth, uiHeight);
  }
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    histogram[i] = histogramTop[i] + histogramLeft[i] + histogramTopLeft[i];
  }
#if JVET_AK0059_MDIP
  if(useExcludingMode && !CU::allowMdip(cu) && cu.cs->sps->getUseMdip())
  {
    bool includedMode[NUM_LUMA_MODE]{ false };
    buildExcludingMode(cu, histogram, includedMode);
  }
#endif

  int amp[DIMD_FUSION_NUM-1] = { 0 };
  int curAmp         = 0;
  int mode[DIMD_FUSION_NUM-1] = { 0 };
  int curMode         = 0;
  int numPred = (((cu.lwidth() * cu.lheight()) >= 128) ? DIMD_FUSION_NUM : DIMD_FUSION_NUM_SMALL);
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = histogram[i];
    curMode = i;
    for (int j = 0; j < numPred - 1; j++)
    {
      if (curAmp > amp[j])
      {
        for (int k = numPred - 2; k > j; k--)
        {
          amp[k] = amp[k - 1];
          mode[k] = mode[k - 1];
        }
        amp[j] = curAmp;
        mode[j] = curMode;
        break;
      }
    }
  }

  for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
  {
    cu.dimdLocDep[i] = 0;
  }
  for(int i = 0; i < DIMD_FUSION_NUM - 1; i++)
  {
    int secondMode = mode[i];
    if (secondMode > DC_IDX)
    {
      cu.dimdLocDep[i] = 0;

      int ampSecond = histogram[secondMode];
      int ampSecondLeft = histogramLeft[secondMode];
      int ampSecondAbove = histogramTop[secondMode];
        
      if (ampSecondLeft < (ampSecond / 3))
      {
        cu.dimdLocDep[i] = 1;
      }
      else if (ampSecondAbove < (ampSecond / 3))
      {
        cu.dimdLocDep[i] = 2;
      }
    }
  }
#if JVET_AK0187_IMPLICIT_MTS_LUT_EXTENSION
  cu.candModeListForTransform[0] = mode[0];
  cu.candModeListForTransform[1] = mode[1];
#endif
  cu.dimdMode = mode[0];

  cu.dimdBlending = true;
  cu.dimdBlending &= amp[1] > 0;
  cu.dimdBlending &= mode[1] > DC_IDX;
  cu.dimdBlending &= mode[0] > DC_IDX;

  if (cu.dimdLocDep[0] != 0 && amp[1] == 0)
  {
    cu.dimdBlending = true;
    cu.dimdBlending &= mode[0] > DC_IDX;
    mode[1] = 0;
    CHECK( mode[2] != 0, "Wrong logic" );
  } 

  int countBlendMode = 2;

  if( cu.dimdBlending )
  {
    for (int i = 0; i < DIMD_FUSION_NUM - 2; i++)
    {
      cu.dimdBlendMode[i] = mode[i+1];
      if (cu.dimdBlendMode[i] != PLANAR_IDX)
      {
        countBlendMode++;
      }
    }
  }

  int log2BlendWeight = 6;
  int dimdPlanarWeight = 64/4;
  int sumWeight = (1 << log2BlendWeight);

  if (cu.dimdBlending)
  {
    int g_gradDivTable[16] = { 0, 7, 6, 5, 5, 4, 4, 3, 3, 2, 2, 1, 1, 1, 1, 0 };
    if (mode[1] == 0)
    {    
      CHECK( cu.dimdLocDep[0] == 0, "Wrong logic" );
      cu.dimdRelWeight[0] = sumWeight - 21;
      cu.dimdRelWeight[1] = 21;
      cu.dimdRelWeight[2] = 0;
      cu.dimdRelWeight[3] = 0;
      cu.dimdRelWeight[4] = 0;
      cu.dimdRelWeight[5] = 0;
    }
    else
    {
    sumWeight = sumWeight - dimdPlanarWeight;
    int s1 = 0;
    for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
    {
      s1 = s1 + amp[i];
    }
    int x = floorLog2(s1);
    CHECK(x < 0, "floor log2 value should be no negative");
    int normS1 = (s1 << 4 >> x) & 15;
    int v = g_gradDivTable[normS1] | 8;
    x += (normS1 != 0);
    int shift = x + 3;
    int add = (1 << (shift - 1));
    int iRatio[DIMD_FUSION_NUM - 1] = { 0 };
    for (int i = 0; i < DIMD_FUSION_NUM - 1; i++)
    {
      iRatio[i] = (amp[i] * v * sumWeight + add) >> shift;
      if (amp[i] == 0)
      {
        iRatio[i] = 0;
      }
      if( iRatio[i] > sumWeight )
      {
        iRatio[i] = sumWeight;
      }
      CHECK( iRatio[i] > sumWeight, "Wrong DIMD ratio" );
    }
    cu.dimdRelWeight[0] = iRatio[0];
    int sumWeightReal = iRatio[0];
    int countBlendModeNew = countBlendMode;
    int lastFilled = 0;
    for (int i = 1; i < countBlendMode - 2; i++)
    {
      cu.dimdRelWeight[i+1] = iRatio[i];
      sumWeightReal += iRatio[i];
      if(sumWeightReal > sumWeight)
      {
        lastFilled = i;
        break;
      }
    }
    if(sumWeightReal > sumWeight)
    {
      for (int i = lastFilled + 1; i <= countBlendMode - 2; i++)
      {
        iRatio[i] = 0;
        cu.dimdRelWeight[i + 1] = 0;
        cu.dimdBlendMode[i - 1] = 0;
        countBlendModeNew--;  
      }
    }
    countBlendMode = countBlendModeNew;
    if (sumWeightReal > sumWeight)
    {
      int diff = sumWeightReal - sumWeight;
      for (int j = 0; j < sumWeight; j++)
      {
        for (int i = lastFilled; i >= 1; i--)
        {
          CHECK( i < 0, "Wrong index" );
          CHECK( i >= DIMD_FUSION_NUM - 1, "Wrong index" );

          iRatio[i] -=1;
          cu.dimdRelWeight[i+1] = iRatio[i];

          if (cu.dimdRelWeight[i+1] == 0)
          {
            CHECK( i < 1, "Wrong index" );
            cu.dimdBlendMode[i-1] = 0;
            countBlendMode--;
          }
          diff--;
          if(diff == 0)
          {
            break;
          }
        }
        if(diff == 0)
        {
          break;
        }
      }
    }
    cu.dimdRelWeight[countBlendMode-1] = sumWeight;
    for (int i = 0; i < countBlendMode - 2; i++)
    {
      cu.dimdRelWeight[countBlendMode-1] = cu.dimdRelWeight[countBlendMode-1] - iRatio[i];
      if (cu.dimdRelWeight[countBlendMode-1] == 0)
      {
        cu.dimdBlendMode[countBlendMode-3] = 0;
      }
    }
    cu.dimdRelWeight[1] = dimdPlanarWeight;
    }
  }
  else
  {
    cu.dimdRelWeight[0] = sumWeight;
    for (int i = 1; i < DIMD_FUSION_NUM; i++)
    {
      cu.dimdRelWeight[i] = 0;
    }
  }
}
#endif

#if JVET_Z0050_DIMD_CHROMA_FUSION && ENABLE_DIMD
void IntraPrediction::deriveDimdChromaMode(const CPelBuf &recoBufY, const CPelBuf &recoBufCb, const CPelBuf &recoBufCr, const CompArea &areaY, const CompArea &areaCb, const CompArea &areaCr, CodingUnit &cu)
{
  if (!cu.slice->getSPS()->getUseDimd())
  {
    return;
  }

  const CodingStructure  &cs = *cu.cs;
  const SPS             &sps = *cs.sps;
  const PreCalcValues   &pcv = *cs.pcv;

  const Pel *pRecoY = recoBufY.buf;
  const uint32_t uiWidthY = areaY.width;
  const uint32_t uiHeightY = areaY.height;
  const int iStrideY = recoBufY.stride;

  const Pel *pRecoCb = recoBufCb.buf;
  const uint32_t uiWidthCb = areaCb.width;
  const uint32_t uiHeightCb = areaCb.height;
  const int iStrideCb = recoBufCb.stride;

  const Pel *pRecoCr = recoBufCr.buf;
  const uint32_t uiWidthCr = areaCr.width;
  const uint32_t uiHeightCr = areaCr.height;
  const int iStrideCr = recoBufCr.stride;

  // get the availability of the neighboring chroma samples
  const int predSize = (uiWidthCb << 1);
  const int predHSize = (uiHeightCb << 1);

  const bool noShift = pcv.noChroma2x2 && uiWidthCb == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : getComponentScaleX(areaCb.compID, sps.getChromaFormatIdc()));
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(areaCb.compID, sps.getChromaFormatIdc()));

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight;
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
  const int  numAboveUnits = std::max<int>(uiWidthCb / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(uiHeightCb / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  CHECK(numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported");

  const Position posLT = areaCb;

  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(neighborFlags, 0, totalUnits);

  Position pos = posLT.offset(0, -2); // get the availability of the third neighboring row
  int numIntraAbove = isAboveAvailable(cu, CHANNEL_TYPE_CHROMA, pos, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1));
  pos = posLT.offset(-2, 0); // get the availability of the third neighboring column
  int numIntraLeft = isLeftAvailable(cu, CHANNEL_TYPE_CHROMA, pos, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));
#if JVET_AC0094_REF_SAMPLES_OPT
  const int numIntraAboveRight = std::min( isAboveRightAvailable(cu, CHANNEL_TYPE_CHROMA, areaCb.topRight().offset(0, -2), numAboveRightUnits, unitWidth, neighborFlags + totalLeftUnits + 1 + numAboveUnits)
    , isAboveRightAvailable(cu, CHANNEL_TYPE_CHROMA, areaCb.topRight(), numAboveRightUnits, unitWidth, neighborFlags + totalLeftUnits + 1 + numAboveUnits) );
  const int numIntraBottomLeft = std::min( isBelowLeftAvailable(cu, CHANNEL_TYPE_CHROMA, areaCb.bottomLeft().offset(-2, 0), numLeftBelowUnits, unitHeight, neighborFlags + totalLeftUnits - 1 - numLeftUnits)
    , isBelowLeftAvailable(cu, CHANNEL_TYPE_CHROMA, areaCb.bottomLeft(), numLeftBelowUnits, unitHeight, neighborFlags + totalLeftUnits - 1 - numLeftUnits) );
#endif

  int piHistogram[NUM_LUMA_MODE] = { 0 };
#if JVET_AC0094_REF_SAMPLES_OPT
  const uint32_t uiHeightLeftY = (numLeftUnits*unitHeight << getChannelTypeScaleY(CHANNEL_TYPE_CHROMA, sps.getChromaFormatIdc())) - 2;
  const Pel* const pRecoLeftY = pRecoY + 1 + iStrideY;
  buildHistogram(pRecoLeftY, iStrideY, uiHeightLeftY, 2, piHistogram, 1, uiWidthY, uiHeightY);
#endif
  if (numIntraLeft)
  {
#if JVET_AC0094_REF_SAMPLES_OPT
    const uint32_t uiHeightLeftC = (numIntraLeft + numIntraBottomLeft)*unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#else
    uint32_t uiHeightLeftY = ((numIntraLeft * unitHeight) << getChannelTypeScaleY(CHANNEL_TYPE_CHROMA, sps.getChromaFormatIdc())) - 1 - (!numIntraAbove ? 1 : 0);
    uint32_t uiHeightLeftC = numIntraLeft * unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#endif
#if !JVET_AC0094_REF_SAMPLES_OPT
    const Pel *pRecoLeftY = pRecoY - 2 + iStrideY * (!numIntraAbove ? 1 : 0);
#endif
    const Pel *pRecoLeftCb = pRecoCb - 2 + iStrideCb * (!numIntraAbove ? 1 : 0);
    const Pel *pRecoLeftCr = pRecoCr - 2 + iStrideCr * (!numIntraAbove ? 1 : 0);
#if !JVET_AC0094_REF_SAMPLES_OPT
    buildHistogram(pRecoLeftY, iStrideY, uiHeightLeftY, 1, piHistogram, 1, uiWidthY, uiHeightY);
#endif
    buildHistogram(pRecoLeftCb, iStrideCb, uiHeightLeftC, 1, piHistogram, 1, uiWidthCb, uiHeightCb);
    buildHistogram(pRecoLeftCr, iStrideCr, uiHeightLeftC, 1, piHistogram, 1, uiWidthCr, uiHeightCr);
  }
#if JVET_AC0094_REF_SAMPLES_OPT
  const uint32_t uiWidthAboveY = (numAboveUnits*unitWidth << getChannelTypeScaleX(CHANNEL_TYPE_CHROMA, sps.getChromaFormatIdc())) - 4;
  const Pel* const pRecoAboveY = pRecoY + 3 + iStrideY;
  buildHistogram(pRecoAboveY, iStrideY, 2, uiWidthAboveY, piHistogram, 2, uiWidthY, uiHeightY);
#endif
  if (numIntraAbove)
  {
#if JVET_AC0094_REF_SAMPLES_OPT
    const uint32_t uiWidthAboveC = (numIntraAbove + numIntraAboveRight)*unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#else
    uint32_t uiWidthAboveY = ((numIntraAbove * unitWidth) << getChannelTypeScaleX(CHANNEL_TYPE_CHROMA, sps.getChromaFormatIdc())) - 1 - (!numIntraLeft ? 1 : 0);
    uint32_t uiWidthAboveC = numIntraAbove * unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#endif
#if !JVET_AC0094_REF_SAMPLES_OPT
    const Pel *pRecoAboveY = pRecoY - iStrideY * 2 + (!numIntraLeft ? 1 : 0);
#endif
    const Pel *pRecoAboveCb = pRecoCb - iStrideCb * 2 + (!numIntraLeft ? 1 : 0);
    const Pel *pRecoAboveCr = pRecoCr - iStrideCr * 2 + (!numIntraLeft ? 1 : 0);
#if !JVET_AC0094_REF_SAMPLES_OPT
    buildHistogram(pRecoAboveY, iStrideY, 1, uiWidthAboveY, piHistogram, 2, uiWidthY, uiHeightY);
#endif
    buildHistogram(pRecoAboveCb, iStrideCb, 1, uiWidthAboveC, piHistogram, 2, uiWidthCb, uiHeightCb);
    buildHistogram(pRecoAboveCr, iStrideCr, 1, uiWidthAboveC, piHistogram, 2, uiWidthCr, uiHeightCr);
  }
  if (numIntraLeft && numIntraAbove)
  {
#if !JVET_AC0094_REF_SAMPLES_OPT
    const Pel *pRecoAboveLeftY = pRecoY - 2 - iStrideY * 2;
#endif
    const Pel *pRecoAboveLeftCb = pRecoCb - 2 - iStrideCb * 2;
    const Pel *pRecoAboveLeftCr = pRecoCr - 2 - iStrideCr * 2;
#if !JVET_AC0094_REF_SAMPLES_OPT
    buildHistogram(pRecoAboveLeftY, iStrideY, 2, 2, piHistogram, 3, uiWidthY, uiHeightY);
#endif
    buildHistogram(pRecoAboveLeftCb, iStrideCb, 2, 2, piHistogram, 3, uiWidthCb, uiHeightCb);
    buildHistogram(pRecoAboveLeftCr, iStrideCr, 2, 2, piHistogram, 3, uiWidthCr, uiHeightCr);
  }

  int firstAmp = 0, secondAmp = 0, curAmp = 0;
  int firstMode = 0, secondMode = 0, curMode = 0;

  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = piHistogram[i];
    curMode = i;
    if (curAmp > firstAmp)
    {
      secondAmp = firstAmp;
      secondMode = firstMode;
      firstAmp = curAmp;
      firstMode = curMode;
    }
    else
    {
      if (curAmp > secondAmp)
      {
        secondAmp = curAmp;
        secondMode = curMode;
      }
    }
  }

  cu.dimdChromaMode = firstMode;
#if JVET_AC0094_REF_SAMPLES_OPT
  cu.dimdChromaModeSecond = secondMode;
#else
  int dmMode = PU::getCoLocatedIntraLumaMode(*cu.firstPU);
  if (dmMode == firstMode)
  {
    cu.dimdChromaMode = secondMode;
    if (firstMode == secondMode)
    {
      cu.dimdChromaMode = DC_IDX;
    }
  }
#endif

#if JVET_AH0136_CHROMA_REORDERING
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if ( ( CS::isDualITree(*cu.cs) || (cu.isSST && cu.separateTree) ) && cu.cs->sps->getUseChromaReordering() && cu.slice->isIntra() )
#else
  if (CS::isDualITree(*cu.cs) && cu.cs->sps->getUseChromaReordering())
#endif
  {
    int amp[DIMD_FUSION_NUM - 1] = { 0 };
    curAmp = 0;
    int mode[DIMD_FUSION_NUM - 1] = { 0 };
    curMode = 0;
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      curAmp = piHistogram[i];
      curMode = i;
      for (int j = 0; j < DIMD_FUSION_NUM - 1; j++)
      {
        if (curAmp > amp[j])
        {
          for (int k = DIMD_FUSION_NUM - 2; k > j; k--)
          {
            amp[k] = amp[k - 1];
            mode[k] = mode[k - 1];
          }
          amp[j] = curAmp;
          mode[j] = curMode;
          break;
        }
      }
    }

    for (int i = 0; i < 5; i++)
    {
      cu.dimdBlendModeChroma[i] = mode[i];
    }
  }
#endif
}
#endif
#if JVET_AK0217_INTRA_MTSS
void IntraPrediction::deriveDimdModeList(const CPelBuf& recoBuf, const CompArea& area, CodingUnit& cu, static_vector<int, MTSS_LIST_SIZE>& candModeList, static_vector<int, MTSS_LIST_SIZE>& candCostList)
{
  if (!cu.slice->getSPS()->getUseDimd())
  {
    return;
  }

  const CodingStructure& cs = *cu.cs;
  const SPS& sps = *cs.sps;
  const PreCalcValues& pcv = *cs.pcv;
  const ChannelType   chType = toChannelType(area.compID);

  const Pel* pReco = recoBuf.buf;
  const uint32_t uiWidth = area.width;
  const uint32_t uiHeight = area.height;
  const int iStride = recoBuf.stride;
#if JVET_AC0098_LOC_DEP_DIMD
  const int predSize = uiWidth + 1;
  const int predHSize = uiHeight + 1;
#else
  const int predSize = (uiWidth << 1);
  const int predHSize = (uiHeight << 1);
#endif

  const bool noShift = pcv.noChroma2x2 && uiWidth == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight;
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
  const int  numAboveUnits = std::max<int>(uiWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(uiHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  CHECK(numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported");

  // ----- Step 1: analyze neighborhood -----
  const Position posLT = area;

  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(neighborFlags, 0, totalUnits);

  int numIntraAbove = isAboveAvailable(cu, chType, posLT, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1));
  int numIntraLeft = isLeftAvailable(cu, chType, posLT, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));
#if JVET_AC0094_REF_SAMPLES_OPT || JVET_AC0098_LOC_DEP_DIMD
  const int numIntraAboveRight = isAboveRightAvailable(cu, chType, area.topRight(), numAboveRightUnits, unitWidth, neighborFlags + totalLeftUnits + 1 + numAboveUnits);
  const int numIntraBottomLeft = isBelowLeftAvailable(cu, chType, area.bottomLeft(), numLeftBelowUnits, unitHeight, neighborFlags + totalLeftUnits - 1 - numLeftUnits);
#endif

  // ----- Step 2: build histogram of gradients -----
#if JVET_AC0098_LOC_DEP_DIMD
  int histogramTop[NUM_LUMA_MODE] = { 0 };
  int histogramLeft[NUM_LUMA_MODE] = { 0 };

  int histogramTopLeft[NUM_LUMA_MODE] = { 0 };
#endif
  int histogram[NUM_LUMA_MODE] = { 0 };

  if (numIntraLeft)
  {
#if JVET_AC0094_REF_SAMPLES_OPT || JVET_AC0098_LOC_DEP_DIMD
    const uint32_t uiHeightLeft = (numIntraLeft + numIntraBottomLeft) * unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#else
    uint32_t uiHeightLeft = numIntraLeft * unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#endif
    const Pel* pRecoLeft = pReco - 2 + iStride * (!numIntraAbove ? 1 : 0);
#if JVET_AC0098_LOC_DEP_DIMD
    buildHistogram(pRecoLeft, iStride, uiHeightLeft, 1, histogramLeft, 1, uiWidth, uiHeight);
#else
    buildHistogram(pRecoLeft, iStride, uiHeightLeft, 1, histogram, 1, uiWidth, uiHeight);
#endif
  }

  if (numIntraAbove)
  {
#if JVET_AC0094_REF_SAMPLES_OPT || JVET_AC0098_LOC_DEP_DIMD
    const uint32_t uiWidthAbove = (numIntraAbove + numIntraAboveRight) * unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#else
    uint32_t uiWidthAbove = numIntraAbove * unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#endif
    const Pel* pRecoAbove = pReco - iStride * 2 + (!numIntraLeft ? 1 : 0);
#if JVET_AC0098_LOC_DEP_DIMD
    buildHistogram(pRecoAbove, iStride, 1, uiWidthAbove, histogramTop, 2, uiWidth, uiHeight);
#else
    buildHistogram(pRecoAbove, iStride, 1, uiWidthAbove, histogram, 2, uiWidth, uiHeight);
#endif
  }

  if (numIntraLeft && numIntraAbove)
  {
    const Pel* pRecoAboveLeft = pReco - 2 - iStride * 2;
#if JVET_AC0098_LOC_DEP_DIMD
    buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogramTopLeft, 3, uiWidth, uiHeight);
#else
    buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogram, 3, uiWidth, uiHeight);
#endif
  }
  candModeList.clear();
  candCostList.clear();
#if JVET_AC0098_LOC_DEP_DIMD
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    histogram[i] = histogramTop[i] + histogramLeft[i] + histogramTopLeft[i];
    updateCandListB2S(i, histogram[i], candModeList, candCostList, MTSS_LIST_SIZE);
  }
#endif
}

#endif
#if JVET_AH0136_CHROMA_REORDERING
void IntraPrediction::deriveNonCcpChromaModes(const CPelBuf &recoBufY, const CPelBuf &recoBufCb, const CPelBuf &recoBufCr, const CompArea &areaY, const CompArea &areaCb, const CompArea &areaCr, CodingUnit &cu, PredictionUnit &pu, InterPrediction *pcInterPred)
{
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if (!( CS::isDualITree(*pu.cs) || (pu.cu->isSST && pu.cu->separateTree) ) || !pu.cs->sps->getUseChromaReordering() || !pu.cs->slice->isIntra())
#else
  if (!CS::isDualITree(*pu.cs) || !pu.cs->sps->getUseChromaReordering())
#endif
  {
    return;
  }

  // save original info
  int intraDir = pu.intraDir[1];

  // construct collocated luma area
  UnitArea area(CHROMA_420, areaY);
  CodingUnit lumaCU(area);
  PredictionUnit lumaPU(area);
  lumaPU.cu = &lumaCU;
  lumaCU.firstPU = &lumaPU;
  lumaCU.cs = cu.cs;
  lumaPU.cs = pu.cs;
  lumaCU.slice = cu.slice;
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  lumaCU.isSST = cu.isSST;
  lumaCU.separateTree = cu.separateTree;
#endif
  // derive DBV info
#if JVET_AC0071_DBV
  PU::deriveChromaBv(pu);
#endif

  // build input list
  static_vector<uint8_t, NUM_CHROMA_LIST_MODE> uiModeList;
  static_vector<Distortion, NUM_CHROMA_LIST_MODE> uiCostList;
  uint8_t chromaList[NUM_CHROMA_LIST_MODE];
  int existNum = 0;
  bool hasDBV = false;

  buildChromaModeList(areaCb, cu, pu, chromaList, existNum, hasDBV);

  // prepare luma pred indfo
  int width = areaY.width;
  int height = areaY.height;
  const UnitArea localUnitAreaLuma(CHROMA_420, Area(0, 0, width, height));
  PelBuf predY = m_tempBuffer[0].getBuf(localUnitAreaLuma.Y());
  DistParam cDistParamSatd;
  m_timdSatdCost->setDistParam(cDistParamSatd, recoBufY, predY, pu.cs->sps->getBitDepth(CHANNEL_TYPE_LUMA), COMPONENT_Y, true);
  cDistParamSatd.applyWeight = false;
  cDistParamSatd.useMR = false;

  // prepare chroma pred info
  int line = NUM_CHROMA_TM_LINES_IN_REORDERING;
  const UnitArea localUnitAreaChroma(CHROMA_420, Area(0, 0, width + line * 2, height + line * 2));
  PelBuf predCb = m_tempBuffer[0].getBuf(localUnitAreaChroma.Cb());
  PelBuf predCr = m_tempBuffer[0].getBuf(localUnitAreaChroma.Cr());
  int iRefX = 0;
  int iRefY = 0;
  uint32_t uiRefWidth = 0;
  uint32_t uiRefHeight = 0;
  TemplateType eTplType = CU::deriveTimdRefType(areaCb.x, areaCb.y, areaCb.width, areaCb.height, line, line, iRefX, iRefY, uiRefWidth, uiRefHeight);
  const Pel* piCb = recoBufCb.buf;
  int  iCbStride = recoBufCb.stride;
  piCb += (iRefY - areaCb.y) * iCbStride + (iRefX - areaCb.x);
  const Pel* piCr = recoBufCr.buf;
  int  iCrStride = recoBufCr.stride;
  piCr += (iRefY - areaCr.y) * iCrStride + (iRefX - areaCr.x);
  const int channelBitDepth = pu.cu->cs->sps->getBitDepth(toChannelType(COMPONENT_Cb));
  DistParam distParamSatd[2][2];   // above, left
  distParamSatd[0][0].applyWeight = false;
  distParamSatd[0][0].useMR = false;
  distParamSatd[0][1].applyWeight = false;
  distParamSatd[0][1].useMR = false;
  distParamSatd[1][0].applyWeight = false;
  distParamSatd[1][0].useMR = false;
  distParamSatd[1][1].applyWeight = false;
  distParamSatd[1][1].useMR = false;
  if (eTplType == LEFT_ABOVE_NEIGHBOR)
  {
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][0], piCb + line, predCb.buf + line, iCbStride, predCb.stride, channelBitDepth, COMPONENT_Cb, areaCb.width, line, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][1], piCb + line * iCbStride, predCb.buf + line * predCb.stride, iCbStride, predCb.stride, channelBitDepth, COMPONENT_Cb, line, areaCb.height, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][0], piCr + line, predCr.buf + line, iCrStride, predCr.stride, channelBitDepth, COMPONENT_Cr, areaCr.width, line, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][1], piCr + line * iCrStride, predCr.buf + line * predCr.stride, iCrStride, predCr.stride, channelBitDepth, COMPONENT_Cr, line, areaCr.height, 0, 1, false);
  }
  else if (eTplType == LEFT_NEIGHBOR)
  {
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][1], piCb, predCb.buf, iCbStride, predCb.stride, channelBitDepth, COMPONENT_Cb, line, areaCb.height, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][1], piCr, predCr.buf, iCrStride, predCr.stride, channelBitDepth, COMPONENT_Cr, line, areaCr.height, 0, 1, false);
  }
  else if (eTplType == ABOVE_NEIGHBOR)
  {
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][0], piCb, predCb.buf, iCbStride, predCb.stride, channelBitDepth, COMPONENT_Cb, areaCb.width, line, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][0], piCr, predCr.buf, iCrStride, predCr.stride, channelBitDepth, COMPONENT_Cr, areaCr.width, line, 0, 1, false);
  }

  // early termination based on the first two costs
  Distortion costPre[2] = { 0 };
  int modePre[2] = { PLANAR_IDX };
  int logW = floorLog2(areaCb.width);
  int logH = floorLog2(areaCb.height);
  int logN = floorLog2(NUM_CHROMA_TM_LINES_IN_REORDERING);

  for (int i = 0; i < 2; i++)
  {
    int x = i;
    if (hasDBV)
    {
      x = i == 0 ? 16 : 0;
    }
#if JVET_AC0071_DBV
    if (PU::isDbvMode(chromaList[x]) && cu.mvs[chromaList[x] - DBV_CHROMA_IDX] == Mv())
    {
      costPre[i] = UINT64_MAX;
      modePre[i] = chromaList[x];
      continue;
    }
#endif

    Distortion cost = 0;
    Distortion costL = 0;
    Distortion costCbA = 0;
    Distortion costCbL = 0;
    Distortion costCrA = 0;
    Distortion costCrL = 0;

    // pred co-located luma area
    predCoLuma(areaY, recoBufY, lumaPU, chromaList[x], predY, pcInterPred, cu);

    costL += cDistParamSatd.distFunc(cDistParamSatd);

    pu.intraDir[1] = chromaList[x];

    if (eTplType != NO_NEIGHBOR)
    {
      // pred chroma TM
      predChromaTM(areaCb, areaCr, pu, chromaList[x], predCb, predCr, eTplType, pcInterPred);

      if (eTplType == LEFT_ABOVE_NEIGHBOR)
      {
        costCbA += distParamSatd[0][0].distFunc(distParamSatd[0][0]);
        costCbL += distParamSatd[0][1].distFunc(distParamSatd[0][1]);
        costCrA += distParamSatd[1][0].distFunc(distParamSatd[1][0]);
        costCrL += distParamSatd[1][1].distFunc(distParamSatd[1][1]);

        cost = 8 * costL + ((costCbA + costCrA) << (logH + 2 - logN)) + ((costCbL + costCrL) << (logW + 2 - logN));
      }
      else if (eTplType == LEFT_NEIGHBOR)
      {
        costCbL += distParamSatd[0][1].distFunc(distParamSatd[0][1]);
        costCrL += distParamSatd[1][1].distFunc(distParamSatd[1][1]);
        cost = 8 * costL + ((costCbL + costCrL) << (logW + 2 - logN));
      }
      else if (eTplType == ABOVE_NEIGHBOR)
      {
        costCbA += distParamSatd[0][0].distFunc(distParamSatd[0][0]);
        costCrA += distParamSatd[1][0].distFunc(distParamSatd[1][0]);
        cost = 8 * costL + ((costCbA + costCrA) << (logH + 2 - logN));
      }
      else
      {
        CHECK( true, "wrong case" );
      }
    }
    else
    {
      cost = costL;
    }

    pu.intraDir[1] = intraDir;

    costPre[i] = cost;
    modePre[i] = chromaList[x];
  }
  if (costPre[0] < costPre[1])
  {
#if JVET_AC0071_DBV
    if (hasDBV)
    {
      for (uint32_t i = existNum - 1; i > 0; i--)
      {
        chromaList[i] = chromaList[i - 1];
      }
      chromaList[0] = DBV_CHROMA_IDX;
    }
#endif
    for (uint32_t i = 0; i < existNum; i++)
    {
      cu.chromaList[i] = chromaList[i];
    }

    return;
  }

  for (int x = 0; x < NUM_CHROMA_LIST_MODE; x++)
  {
    if (chromaList[x] > DM_CHROMA_IDX)
    {
      continue;
    }
    if (chromaList[x] == modePre[0] || chromaList[x] == modePre[1])
    {
      updateCandList(chromaList[x], chromaList[x] == modePre[0] ? costPre[0] : costPre[1], uiModeList, uiCostList, existNum);
      continue;
    }
#if JVET_AC0071_DBV
    if (PU::isDbvMode(chromaList[x]) && cu.mvs[chromaList[x] - DBV_CHROMA_IDX] == Mv())
    {
      updateCandList(chromaList[x], UINT64_MAX, uiModeList, uiCostList, existNum);
      continue;
    }
#endif

    Distortion cost = 0;
    Distortion costL = 0;
    Distortion costCbA = 0;
    Distortion costCbL = 0;
    Distortion costCrA = 0;
    Distortion costCrL = 0;

    // pred co-located luma area
    predCoLuma(areaY, recoBufY, lumaPU, chromaList[x], predY, pcInterPred, cu);

    costL += cDistParamSatd.distFunc(cDistParamSatd);

    pu.intraDir[1] = chromaList[x];
    if (eTplType != NO_NEIGHBOR)
    {
      // pred chroma TM
      predChromaTM(areaCb, areaCr, pu, chromaList[x], predCb, predCr, eTplType, pcInterPred);

      if (eTplType == LEFT_ABOVE_NEIGHBOR)
      {
        costCbA += distParamSatd[0][0].distFunc(distParamSatd[0][0]);
        costCbL += distParamSatd[0][1].distFunc(distParamSatd[0][1]);

        costCrA += distParamSatd[1][0].distFunc(distParamSatd[1][0]);
        costCrL += distParamSatd[1][1].distFunc(distParamSatd[1][1]);
        cost = 8 * costL + ((costCbA + costCrA) << (logH + 2 - logN)) + ((costCbL + costCrL) << (logW + 2 - logN));
      }
      else if (eTplType == LEFT_NEIGHBOR)
      {
        costCbL += distParamSatd[0][1].distFunc(distParamSatd[0][1]);
        costCrL += distParamSatd[1][1].distFunc(distParamSatd[1][1]);
        cost = 8 * costL + ((costCbL + costCrL) << (logW + 2 - logN));
      }
      else if (eTplType == ABOVE_NEIGHBOR)
      {
        costCbA += distParamSatd[0][0].distFunc(distParamSatd[0][0]);
        costCrA += distParamSatd[1][0].distFunc(distParamSatd[1][0]);
        cost = 8 * costL + ((costCbA + costCrA) << (logH + 2 - logN));
      }
      else
      {
        CHECK( true, "wrong case" );
      }
    }
    else
    {
      cost = costL;
    }

    pu.intraDir[1] = intraDir;
    updateCandList(chromaList[x], cost, uiModeList, uiCostList, existNum);
  }

  for (uint32_t i = 0; i < existNum; i++)
  {
    cu.chromaList[i] = uiModeList[i];
  }

  // reste chroma mode
  pu.intraDir[1] = intraDir;
}

void IntraPrediction::buildChromaModeList(const CompArea &area, CodingUnit &cu, PredictionUnit &pu, uint8_t chromaList[NUM_CHROMA_LIST_MODE], int &existNum, bool &hasDBV)
{
  // initialization
  for (int i = 0; i < NUM_CHROMA_LIST_MODE; i++)
  {
    chromaList[i] = 255;
  }

  // get the orginal chroma mode list
  int dmMode = PU::getCoLocatedIntraLumaMode(pu);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  if (dmMode == PNN_IDX)
  {
    dmMode = PU::getCoLocatedIdxRepresentationPnn(pu);
  }
#endif
  int startNum = 0;
#if JVET_Z0050_DIMD_CHROMA_FUSION && ENABLE_DIMD
  if (cu.slice->getSPS()->getUseDimd())
  {
    int dimdMode = cu.dimdChromaMode;
    if (cu.dimdChromaMode == dmMode || cu.dimdChromaMode == HOR_IDX || cu.dimdChromaMode == VER_IDX)
    {
      int i = 1;
      for (; i < 5; i++)
      {
        if (cu.dimdBlendModeChroma[i] == dmMode || cu.dimdBlendModeChroma[i] == HOR_IDX || cu.dimdBlendModeChroma[i] == VER_IDX)
        {
          continue;
        }
        break;
      }
      dimdMode = (i == 5) ? DC_IDX : cu.dimdBlendModeChroma[i];
    }
    chromaList[0] = dmMode;
    chromaList[1] = dimdMode;
    chromaList[2] = PLANAR_IDX;
    chromaList[3] = DC_IDX;
    chromaList[4] = HOR_IDX;
    chromaList[5] = VER_IDX;
    existNum = 6;
    startNum = 2;
  }
  else
#endif
  {
    chromaList[0] = dmMode;
    chromaList[1] = PLANAR_IDX;
    chromaList[2] = DC_IDX;
    chromaList[3] = HOR_IDX;
    chromaList[4] = VER_IDX;
    existNum = 5;
    startNum = 1;
  }
  bool hasMode[NUM_LUMA_MODE] = { false };
  for (int i = startNum; i < existNum; i++)
  {
    if (chromaList[i] == dmMode)
    {
      chromaList[i] = VDIA_IDX;
    }
  }
  for (int i = 0; i < existNum; i++)
  {
    hasMode[chromaList[i]] = true;
  }

  int addNum = 0;
  // get co-located luma modes
  CompArea lumaArea = CompArea(COMPONENT_Y, pu.chromaFormat, pu.Cb().lumaPos(), recalcSize(pu.chromaFormat, CHANNEL_TYPE_CHROMA, CHANNEL_TYPE_LUMA, pu.Cb().size()));
  lumaArea = clipArea(lumaArea, pu.cs->picture->block(COMPONENT_Y));

  Position posList[5] = { lumaArea.center(), lumaArea.topLeft(), lumaArea.topRight(), lumaArea.bottomLeft(), lumaArea.bottomRight() };
  for (int n = 0; n < NUM_DBV_POSITION; n++)
  {
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
    const PredictionUnit *lumaPU    = ( CS::isDualITree(*pu.cs)  || (pu.cu->isSST && pu.cu->separateTree) )
      ? pu.cs->getLumaPU( posList[n], CHANNEL_TYPE_LUMA )
      : pu.cs->getPU(posList[n], CHANNEL_TYPE_LUMA);
#else
    const PredictionUnit *lumaPU = pu.cs->picture->cs->getPU(posList[n], CHANNEL_TYPE_LUMA);
#endif
    int mode;
    if (lumaPU->cu->timd || lumaPU->cu->tmrlFlag)
    {
      mode = MAP131TO67(PU::getIntraDirLuma(*lumaPU, 0));
    }
    else
    {
      mode = PU::getIntraDirLuma(*lumaPU, 0);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
      if (mode == PNN_IDX)
      {
        mode = PLANAR_IDX;
      }
#endif
    }
    if (hasMode[mode] == false)
    {
      chromaList[6 + addNum] = mode;
      hasMode[mode] = true;
      addNum++;
    }
  }

  // get neighboring modes
  const Position posCand[5] =
  {
    pu.chromaPos().offset(-1, area.height - 1),
    pu.chromaPos().offset(area.width - 1, -1),
    pu.chromaPos().offset(-1, area.height),
    pu.chromaPos().offset(area.width, -1),
    pu.chromaPos().offset(-1, -1)
  };

  for (const Position &posLT : posCand)
  {
    const PredictionUnit* puRef = PU::getPUFromPos(pu, CHANNEL_TYPE_CHROMA, posLT);
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
    if (puRef != nullptr && CU::isIntra(*puRef->cu) && !PU::isLMCMode(puRef->intraDir[1]) && !PU::isDbvMode(puRef->intraDir[1])
      && (puRef->intraDir[1]!=DM_CHROMA_IDX || puRef->cu->slice->isIntra())
      && (puRef->intraDir[1]!=DIMD_CHROMA_IDX || puRef->cu->slice->isIntra()))
#else
    if (puRef != nullptr && CU::isIntra(*puRef->cu) && !PU::isLMCMode(puRef->intraDir[1]) && !PU::isDbvMode(puRef->intraDir[1]))
#endif
    {
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
      CHECK(puRef->intraDir[1] >= NUM_LUMA_MODE, "buildChromaList: puRef->intraDir[1] has to be strictly lower than NUM_LUMA_MODE=67");
#endif
      int mode;
      mode = puRef->intraDir[1];
      if (hasMode[mode] == false)
      {
        chromaList[6 + addNum] = mode;
        hasMode[mode] = true;
        addNum++;
      }
    }
  }

#if JVET_AC0071_DBV
  if (PU::hasChromaBvFlag(pu))
  {
    chromaList[16] = DBV_CHROMA_IDX;
    existNum++;
    hasDBV = true;
    if (cu.mvsNum > 1)
    {
      for (int i = NUM_CHROMA_LIST_MODE - 9, j = 0; i < NUM_CHROMA_LIST_MODE && j < cu.mvsNum - 1; i++, j++)
      {
        chromaList[i] = DBV_CHROMA_IDX1 + j;
      }
    }
  }
#endif
}

void IntraPrediction::predCoLuma(const CompArea &area, const CPelBuf &recoBuf, PredictionUnit &pu, uint8_t predMode, PelBuf predBuf, InterPrediction *pcInterPred, CodingUnit &chromaCu)
{
  pu.intraDir[0] = predMode;

#if JVET_AC0071_DBV
  if (PU::isDbvMode(predMode))
  {
    pu.intraDir[1] = predMode;
    int idx = predMode - DBV_CHROMA_IDX;
    pu.mv[0] = chromaCu.mvs[idx];
    pu.bv = chromaCu.bvs[idx];
    pu.cu->rribcFlipType = chromaCu.rribcTypes[idx];
    Mv mv = pu.mv[0];

    bool isFracMv = pu.cs->sps->getIBCFracFlag() && mv.isFracMv<true>(pu.chromaFormat);
    int xFrac = mv.hor & ((1 << MV_FRACTIONAL_BITS_INTERNAL) - 1);
    int yFrac = mv.ver & ((1 << MV_FRACTIONAL_BITS_INTERNAL) - 1);
    int xFilterTap = xFrac == 0 ? 0 : NTAPS_LUMA_IBC;
    int yFilterTap = yFrac == 0 ? 0 : NTAPS_LUMA_IBC;
    const uint32_t ctuSize = pu.cs->slice->getSPS()->getMaxCUWidth();
    const int ctuSizeLog2 = floorLog2(ctuSize);
    const int picWidth = pu.cs->slice->getPPS()->getPicWidthInLumaSamples();
    const int picHeight = pu.cs->slice->getPPS()->getPicHeightInLumaSamples();
    int xLumaBv = mv.hor >> MV_FRACTIONAL_BITS_INTERNAL;
    int yLumaBv = mv.ver >> MV_FRACTIONAL_BITS_INTERNAL;
    if (!PU::searchBv(pu, pu.blocks[COMPONENT_Y].x, pu.blocks[COMPONENT_Y].y, predBuf.width, predBuf.height, picWidth, picHeight, xLumaBv, yLumaBv, ctuSize, xFilterTap, yFilterTap, COMPONENT_Y))
    {
      isFracMv = false;
    }
    if (isFracMv)
    {
      PelUnitBuf pcBuf(pu.chromaFormat, predBuf, PelBuf(), PelBuf());
      pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, pu.cs->picture, mv, pcBuf);
    }
    else
    {
      const int bvShftHor = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleX(COMPONENT_Y, pu.chromaFormat);
      const int bvShftVer = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleY(COMPONENT_Y, pu.chromaFormat);
      int refx = pu.blocks[COMPONENT_Y].x + (mv.hor >> bvShftHor);
      int refy = pu.blocks[COMPONENT_Y].y + (mv.ver >> bvShftVer);
      int refStride = pu.cs->picture->getRecoBuf(COMPONENT_Y).stride;
      Pel *ref = pu.cs->picture->getRecoBuf(COMPONENT_Y).buf;
      Pel *refTarget = ref + refy * refStride + refx;
      int iStride = predBuf.stride;
      Pel *pred = predBuf.buf;
      int iHeight = predBuf.height;
      int iWidth = predBuf.width;
      for (int uiY = 0; uiY < iHeight; uiY++)
      {
        for (int uiX = 0; uiX < iWidth; uiX++)
        {
          pred[uiX] = refTarget[uiX];
        }
        refTarget += refStride;
        pred += iStride;
      }

      // padding
      pred = predBuf.buf;
      // left
      if (refx < 0)
      {
        for (int j = 0; j < iHeight; j++)
        {
          for (int i = 0; i < -refx; i++)
          {
            pred[i + j * predBuf.stride] = pred[i - refx + j * predBuf.stride];
          }
        }
        CHECK(refx != -1, "WRONG");
      }
      // above
      if (refy < 0)
      {
        for (int j = 0; j < -refy; j++)
        {
          for (int i = 0; i < iWidth; i++)
          {
            pred[i + j * iStride] = pred[i + (j - refy) * iStride];
          }
        }
        CHECK(refy != -1, "WRONG");
      }
      // bottom
      bool isBottom = true;
      if (refy + iHeight - 1 >= picHeight)
      {
        isBottom = false;
      }
      if (((refy + iHeight - 1) >> ctuSizeLog2) > (pu.blocks[COMPONENT_Y].y >> ctuSizeLog2)) // CTU
      {
        isBottom = false;
      }
      if ((((refx + iWidth - 1) >> ctuSizeLog2) > (pu.blocks[COMPONENT_Y].x >> ctuSizeLog2)) && (((refy + iHeight - 1) >> ctuSizeLog2) == (pu.blocks[COMPONENT_Y].y >> ctuSizeLog2)))
      {
        isBottom = false;
      }
      if (!isBottom)
      {
        for (int i = 0; i < iWidth; i++)
        {
          pred[i + (iHeight - 1) * predBuf.stride] = pred[i + (iHeight - 2) * predBuf.stride];
        }
      }
      // right
      bool isRight = true;
      if (refx + iWidth - 1 >= picWidth)
      {
        isRight = false;
      }
      if ((((refx + iWidth - 1) >> ctuSizeLog2) > (pu.blocks[COMPONENT_Y].x >> ctuSizeLog2)) && (((refy + iHeight - 1) >> ctuSizeLog2) == (pu.blocks[COMPONENT_Y].y >> ctuSizeLog2)))
      {
        isRight = false;
      }
      if (!isRight)
      {
        for (int j = 0; j < iHeight; j++)
        {
          pred[iWidth - 1 + j * iStride] = pred[iWidth - 2 + j * iStride];
        }
      }

    }
    if (pu.cu->rribcFlipType)
    {
      predBuf.flipSignal(pu.cu->rribcFlipType == 1);
    }

    pu.bv.set(0, 0);
    pu.mv[0].setZero();
    pu.cu->rribcFlipType = 0;
  }
  else
#endif
  {
    initPredIntraParams(pu, area, *pu.cs->sps, 0);
    m_ipaParam.applyFusion = false;
    m_leftRefLength = (area.height << 1);
    m_topRefLength = (area.width << 1);
    Pel *refBufUnfiltered = m_refBuffer[area.compID][PRED_BUF_UNFILTERED];
    Pel *refBufFiltered = m_refBuffer[area.compID][PRED_BUF_FILTERED];
    xFillReferenceSamplesForCoLuma(recoBuf, refBufUnfiltered, area, *pu.cu);
    if (m_ipaParam.refFilterFlag)
    {
      xFilterReferenceSamples(refBufUnfiltered, refBufFiltered, area, *pu.cs->sps, 0);
    }
#if JVET_AH0209_PDP
#if JVET_AK0118_BF_FOR_INTRA_PRED
    predIntraAng(COMPONENT_Y, predBuf, pu, true, false, false );
#else
    predIntraAng( COMPONENT_Y, predBuf, pu, false, false );
#endif
#else
    predIntraAng(COMPONENT_Y, predBuf, pu, false);
#endif
  }
}

void IntraPrediction::predChromaTM(const CompArea &areaCb, const CompArea &areaCr, PredictionUnit &pu, uint8_t predMode, PelBuf predCb, PelBuf predCr, TemplateType eTplType, InterPrediction *pcInterPred)
{
  pu.intraDir[1] = predMode;
  int line = NUM_CHROMA_TM_LINES_IN_REORDERING;
#if JVET_AC0071_DBV
  if (PU::isDbvMode(predMode))
  {
    int idx = predMode - DBV_CHROMA_IDX;
    Mv mv = pu.cu->mvs[idx];
    pu.cu->rribcFlipType = pu.cu->rribcTypes[idx];
    const CodingStructure &cs = *pu.cs;
    Position posRT = pu.blocks[COMPONENT_Cb].topRight();
    const PredictionUnit *puAbove = cs.getPURestricted(posRT.offset(0, -line), pu, CHANNEL_TYPE_CHROMA);
    bool topCanUse = puAbove && pu.cu != puAbove->cu;
    Position posLB = pu.blocks[COMPONENT_Cb].bottomLeft();
    const PredictionUnit *puLeft = cs.getPURestricted(posLB.offset(-line, 0), pu, CHANNEL_TYPE_CHROMA);
    bool leftCanUse = puLeft && pu.cu != puLeft->cu;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
    const int bvShiftHor = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleX(COMPONENT_Cb, pu.chromaFormat);
    const int bvShiftVer = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleY(COMPONENT_Cb, pu.chromaFormat);
#else
    const int shiftSampleHor = ::getComponentScaleX(compId, pu.chromaFormat);
    const int shiftSampleVer = ::getComponentScaleY(compId, pu.chromaFormat);
#endif

    CHECK(topCanUse == false && leftCanUse == false, "wrong type");

    int filterIdx = 0;
    CompArea area = pu.blocks[COMPONENT_Cb];
    int uiHeight = area.height;
    int uiWidth = area.width;

    Pel tempCb[MAX_CU_SIZE * 4];
    memset(tempCb, 0, MAX_CU_SIZE * 4 * sizeof(Pel));
    Pel tempCr[MAX_CU_SIZE * 4];
    memset(tempCr, 0, MAX_CU_SIZE * 4 * sizeof(Pel));
    int stride = MAX_CU_SIZE;
    Pel *refPixCb = tempCb;
    Pel *refPixCr = tempCr;
    Pel *refPixTempCb;
    Pel *refPixTempCr;
    const CPelBuf recBufCb = pu.cs->picture->getRecoBuf(pu.cs->picture->blocks[COMPONENT_Cb]);
    const CPelBuf recBufCr = pu.cs->picture->getRecoBuf(pu.cs->picture->blocks[COMPONENT_Cr]);

    Mv mvCurr = mv;
    if (topCanUse)
    {
      Mv mvTop(0, -line);
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 2)
      {
        mvTop.setVer(uiHeight);
      }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      mvTop <<= bvShiftVer;
#endif
      mvTop += mvCurr;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      if (!PU::checkIsChromaBvCandidateValidChromaTm(pu, mvTop, line, filterIdx, true, true))
      {
#if JVET_AA0070_RRIBC
        if (pu.cu->rribcFlipType == 2)
        {
          mvTop.setVer(mvCurr.getVer() + ((uiHeight - line) << bvShiftVer));
        }
        else
#endif
        {
          mvTop = mvCurr;
        }
      }
#else
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 2)
      {
        if (!PU::checkIsChromaBvCandidateValid(pu, mvTop, true, true))
        {
          mvTop.setVer(mvCurr.getVer() + uiHeight - line);
        }
      }
      else
#endif
        if (!PU::checkIsChromaBvCandidateValid(pu, mvTop, true, true))
        {
          mvTop = mvCurr;
        }
#endif

#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      bool isFracMv = pu.cs->sps->getIBCFracFlag() && mvTop.isFracMv<false>(pu.chromaFormat);
      if (isFracMv)
      {
        PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), PelBuf(refPixCb, uiWidth, line), PelBuf(refPixCr, uiWidth, line));
        pcInterPred->getPredIBCBlk(pu, COMPONENT_Cb, pu.cs->picture, mvTop, pcBuf, filterIdx == 1);
        pcInterPred->getPredIBCBlk(pu, COMPONENT_Cr, pu.cs->picture, mvTop, pcBuf, filterIdx == 1);
#if JVET_AA0070_RRIBC
        pcBuf.bufs[COMPONENT_Cb].flip(pu.cu->rribcFlipType);
        pcBuf.bufs[COMPONENT_Cr].flip(pu.cu->rribcFlipType);
#endif
      }
      else
      {
#endif
        refPixTempCb = refPixCb;
        refPixTempCr = refPixCr;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
        const Pel *recCb = recBufCb.bufAt(pu.blocks[COMPONENT_Cb].pos().offset(mvTop.hor >> bvShiftHor, mvTop.ver >> bvShiftVer));
        const Pel *recCr = recBufCr.bufAt(pu.blocks[COMPONENT_Cr].pos().offset(mvTop.hor >> bvShiftHor, mvTop.ver >> bvShiftVer));
#else
        const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvTop.hor, mvTop.ver));
#endif
        for (int k = 0; k < uiWidth; k++)
        {
          for (int l = 0; l < line; l++)
          {
#if JVET_AA0070_RRIBC
            int recValCb;
            int recValCr;
            if (pu.cu->rribcFlipType == 0)
            {
              recValCb = recCb[k + l * recBufCb.stride];
              recValCr = recCr[k + l * recBufCr.stride];
            }
            else if (pu.cu->rribcFlipType == 1)
            {
              recValCb = recCb[uiWidth - 1 - k + l * recBufCb.stride];
              recValCr = recCr[uiWidth - 1 - k + l * recBufCr.stride];
            }
            else
            {
              recValCb = recCb[k + (line - 1 - l) * recBufCb.stride];
              recValCr = recCr[k + (line - 1 - l) * recBufCr.stride];
            }
#else
            int recVal = rec[k + l * recBuf.stride];
#endif
            refPixTempCb[k + l * uiWidth] = recValCb;
            refPixTempCr[k + l * uiWidth] = recValCr;
          }
        }
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      }
#endif
    }

    if (leftCanUse)
    {
      Mv mvLeft(-line, 0);
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 1)
      {
        mvLeft.setHor(uiWidth);
      }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      mvLeft <<= bvShiftHor;
#endif
      mvLeft += mvCurr;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      if (!PU::checkIsChromaBvCandidateValidChromaTm(pu, mvLeft, line, filterIdx, true, false))
      {
#if JVET_AA0070_RRIBC
        if (pu.cu->rribcFlipType == 1)
        {
          mvLeft.setHor(mvCurr.getHor() + ((uiWidth - line) << bvShiftHor));
        }
        else
#endif
        {
          mvLeft = mvCurr;
        }
      }
#else
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 1)
      {
        if (!PU::checkIsChromaBvCandidateValid(pu, mvLeft, true, false))
        {
          mvLeft.setHor(mvCurr.getHor() + uiWidth - DBV_TEMPLATE_SIZE);
        }
      }
      else
#endif
        if (!PU::checkIsChromaBvCandidateValid(pu, mvLeft, true, false))
        {
          mvLeft = mvCurr;
        }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      bool isFracMv = pu.cs->sps->getIBCFracFlag() && mvLeft.isFracMv<false>(pu.chromaFormat);
      if (isFracMv)
      {
        PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), PelBuf(refPixCb + 2 * stride, line, uiHeight), PelBuf(refPixCr + 2 * stride, line, uiHeight));
        pcInterPred->getPredIBCBlk(pu, COMPONENT_Cb, pu.cs->picture, mvLeft, pcBuf, filterIdx == 1);
        pcInterPred->getPredIBCBlk(pu, COMPONENT_Cr, pu.cs->picture, mvLeft, pcBuf, filterIdx == 1);
#if JVET_AA0070_RRIBC
        pcBuf.bufs[COMPONENT_Cb].flip(pu.cu->rribcFlipType);
        pcBuf.bufs[COMPONENT_Cr].flip(pu.cu->rribcFlipType);
#endif
      }
      else
      {
#endif
        refPixTempCb = refPixCb + 2 * stride;
        refPixTempCr = refPixCr + 2 * stride;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
        const Pel *recCb = recBufCb.bufAt(pu.blocks[COMPONENT_Cb].pos().offset(mvLeft.hor >> bvShiftHor, mvLeft.ver >> bvShiftVer));
        const Pel *recCr = recBufCr.bufAt(pu.blocks[COMPONENT_Cr].pos().offset(mvLeft.hor >> bvShiftHor, mvLeft.ver >> bvShiftVer));
#else
        const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvLeft.hor, mvLeft.ver));
#endif
        for (int k = 0; k < uiHeight; k++)
        {
          for (int l = 0; l < line; l++)
          {
#if JVET_AA0070_RRIBC
            int recValCb;
            int recValCr;
            if (pu.cu->rribcFlipType == 0)
            {
              recValCb = recCb[recBufCb.stride * k + l];
              recValCr = recCr[recBufCr.stride * k + l];
            }
            else if (pu.cu->rribcFlipType == 1)
            {
              recValCb = recCb[recBufCb.stride * k + line - 1 - l];
              recValCr = recCr[recBufCr.stride * k + line - 1 - l];
            }
            else
            {
              recValCb = recCb[recBufCb.stride * (uiHeight - 1 - k) + l];
              recValCr = recCr[recBufCr.stride * (uiHeight - 1 - k) + l];
            }
#else
            int recVal = rec[recBuf.stride * k + l];
#endif
            refPixTempCb[l + k * line] = recValCb;
            refPixTempCr[l + k * line] = recValCr;
          }
        }
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      }
#endif
    }

    if (topCanUse && leftCanUse)
    {
      for (int i = 0; i < uiWidth; i++)
      {
        predCb.at(line + i, 0) = tempCb[i];
        predCr.at(line + i, 0) = tempCr[i];
      }
      for (int j = 0; j < uiHeight; j++)
      {
        predCb.at(0, line + j) = tempCb[2 * stride + j];
        predCr.at(0, line + j) = tempCr[2 * stride + j];
      }
    }

    if (topCanUse)
    {
      //top
      for (int i = 0; i < uiWidth; i++)
      {
        predCb.at(i, 0) = tempCb[i];
        predCr.at(i, 0) = tempCr[i];
      }
    }
    if (leftCanUse)
    {
      for (int j = 0; j < uiHeight; j++)
      {
        predCb.at(0, j) = tempCb[2 * stride + j];
        predCr.at(0, j) = tempCr[2 * stride + j];
      }
    }
  }
  else
#endif
  {
    m_topRefLength = (areaCb.width + line) << 1;
    m_leftRefLength = (areaCb.height + line) << 1;
    xFillTimdReferenceSamples(pu.cs->picture->getRecoBuf(areaCb), m_refBuffer[COMPONENT_Cb][PRED_BUF_UNFILTERED], areaCb, *pu.cu, line, line);
    initPredIntraParams(pu, areaCb, *(pu.cs->sps));
    predTimdIntraAng(COMPONENT_Cb, pu, predMode, predCb.buf, predCb.stride, areaCb.width + line, areaCb.height + line, eTplType, line, line);

    xFillTimdReferenceSamples(pu.cs->picture->getRecoBuf(areaCr), m_refBuffer[COMPONENT_Cr][PRED_BUF_UNFILTERED], areaCr, *pu.cu, line, line);
    initPredIntraParams(pu, areaCr, *(pu.cs->sps));
    predTimdIntraAng(COMPONENT_Cr, pu, predMode, predCr.buf, predCr.stride, areaCr.width + line, areaCr.height + line, eTplType, line, line);
  }
}
#endif

#if ENABLE_DIMD && (JVET_AB0067_MIP_DIMD_LFNST || JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST || JVET_AG0058_EIP || JVET_AG0061_INTER_LFNST_NSPT)
int IntraPrediction::deriveIpmForTransform(CPelBuf predBuf, CodingUnit& cu
#if JVET_AI0050_INTER_MTSS
  , int &secondMode
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
  , const bool enableAlignedDesign
#endif 
)
{
  if (!cu.slice->getSPS()->getUseDimd())
  {
    return PLANAR_IDX;
  }
  const Pel* pPred = predBuf.buf;
  const int iStride = predBuf.stride;
  const int width = predBuf.width;
  const int height = predBuf.height;

  int histogram[NUM_LUMA_MODE] = { 0 };

  pPred = pPred + iStride + 1;
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
  const int edgeOperatorSizeIdx = static_cast<int>(enableAlignedDesign ? use2x2EdgeOperator(predBuf) : false);
  buildHistogram(pPred, iStride, height - 2, width - 2, histogram, 0, width - 2 + edgeOperatorSizeIdx, height - 2 + edgeOperatorSizeIdx, edgeOperatorSizeIdx
#if JVET_AK0217_INTRA_MTSS
, true
#endif
);
#else 
  buildHistogram(pPred, iStride, height - 2, width - 2, histogram, 0, width - 2, height - 2
#if JVET_AK0217_INTRA_MTSS
    , 0, true
#endif 
  );
#endif 
  int firstAmp = 0, curAmp = 0;
  int firstMode = 0, curMode = 0;
#if JVET_AI0050_INTER_MTSS
  int secondAmp = 0;
#endif
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = histogram[i];
    curMode = i;
    if (curAmp > firstAmp)
    {
#if JVET_AI0050_INTER_MTSS
      secondAmp = firstAmp;
      secondMode = firstMode;
#endif
      firstAmp = curAmp;
      firstMode = curMode;
    }
#if JVET_AI0050_INTER_MTSS
    else if (curAmp > secondAmp)
    {
      secondAmp = curAmp;
      secondMode = curMode;
    }
#endif
  }
  return firstMode;
}
#endif

#if JVET_AK0064_CCP_LFNST_NSPT && ENABLE_DIMD
int IntraPrediction::deriveChromaIpmForTransform(CPelBuf predBufCb, CPelBuf predBufCr, CodingUnit& cu)
{
  if (!cu.slice->getSPS()->getUseDimd())
  {
    return PLANAR_IDX;
  }
  const Pel* pPredCb = predBufCb.buf;
  const Pel* pPredCr = predBufCr.buf;
  const int iStride = predBufCb.stride;
  const int width = predBufCb.width;
  const int height = predBufCb.height;

  int histogram[NUM_LUMA_MODE] = { 0 };
  int histogramCb[NUM_LUMA_MODE] = { 0 };
  int histogramCr[NUM_LUMA_MODE] = { 0 };
  int firstAmp = 0, curAmp = 0;
  int firstMode = 0, curMode = 0;
  if (!cu.firstPU->cs->pcv->isEncoder && cu.firstTU->jointCbCr == 1)
  {
    pPredCb = pPredCb + iStride + 1;
    buildHistogram(pPredCb, iStride, height - 2, width - 2, histogramCb, 0, width - 2, height - 2);
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      curAmp = histogramCb[i];
      curMode = i;
      if (curAmp > firstAmp)
      {
        firstAmp = curAmp;
        firstMode = curMode;
      }
    }
    cu.ccpChromaDimdMode[1] = firstMode;
  }
  else if (!cu.firstPU->cs->pcv->isEncoder && cu.firstTU->jointCbCr == 2)
  {
    //Cr
    pPredCr = pPredCr + iStride + 1;
    buildHistogram(pPredCr, iStride, height - 2, width - 2, histogramCr, 0, width - 2, height - 2);
    firstAmp = 0;
    curAmp = 0;
    firstMode = 0;
    curMode = 0;
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      curAmp = histogramCr[i];
      curMode = i;
      if (curAmp > firstAmp)
      {
        firstAmp = curAmp;
        firstMode = curMode;
      }
    }
    cu.ccpChromaDimdMode[2] = firstMode;
  }
  else if (!cu.firstPU->cs->pcv->isEncoder)
  {
    pPredCb = pPredCb + iStride + 1;
    buildHistogram(pPredCb, iStride, height - 2, width - 2, histogram, 0, width - 2, height - 2);
    pPredCr = pPredCr + iStride + 1;
    buildHistogram(pPredCr, iStride, height - 2, width - 2, histogram, 0, width - 2, height - 2);

    int firstAmp = 0, curAmp = 0;
    int firstMode = 0, curMode = 0;
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      curAmp = histogram[i];
      curMode = i;
      if (curAmp > firstAmp)
      {
        firstAmp = curAmp;
        firstMode = curMode;
      }
    }
    cu.ccpChromaDimdMode[0] = cu.ccpChromaDimdMode[3] = firstMode;
  }
  else
  {
    pPredCb = pPredCb + iStride + 1;
    buildHistogram(pPredCb, iStride, height - 2, width - 2, histogramCb, 0, width - 2, height - 2);
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      curAmp = histogramCb[i];
      curMode = i;
      if (curAmp > firstAmp)
      {
        firstAmp = curAmp;
        firstMode = curMode;
      }
    }
    cu.ccpChromaDimdMode[1] = firstMode;

    pPredCr = pPredCr + iStride + 1;
    buildHistogram(pPredCr, iStride, height - 2, width - 2, histogramCr, 0, width - 2, height - 2);

    firstAmp = 0;
    curAmp = 0;
    firstMode = 0;
    curMode = 0;
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      curAmp = histogramCr[i];
      curMode = i;
      if (curAmp > firstAmp)
      {
        firstAmp = curAmp;
        firstMode = curMode;
      }
    }
    cu.ccpChromaDimdMode[2] = firstMode;

    firstAmp = 0;
    curAmp = 0;
    firstMode = 0;
    curMode = 0;
    for (int i = 0; i < NUM_LUMA_MODE; i++)
    {
      curAmp = histogramCb[i] + histogramCr[i];
      curMode = i;
      if (curAmp > firstAmp)
      {
        firstAmp = curAmp;
        firstMode = curMode;
      }
    }
    cu.ccpChromaDimdMode[0] = cu.ccpChromaDimdMode[3] = firstMode;
  }
  return firstMode;
}
#endif

#if !JVET_AG0061_INTER_LFNST_NSPT
int IntraPrediction::buildHistogram(const Pel *pReco, int iStride, uint32_t uiHeight, uint32_t uiWidth, int* piHistogram, int direction, int bw, int bh)
{
  const int wStep = 1, hStep = 1;
  int angTable[17] = { 0, 2048, 4096, 6144, 8192, 12288, 16384, 20480, 24576, 28672, 32768, 36864, 40960, 47104, 53248, 59392, 65536 };
  int offsets[4] = { HOR_IDX, HOR_IDX, VER_IDX, VER_IDX };
  int dirs[4] = { -1, 1, -1, 1 };
  int mapXgrY1[2][2] = { { 1, 0 },{ 0, 1 } };
  int mapXgrY0[2][2] = { { 2, 3 },{ 3, 2 } };

  for (uint32_t y = 0; y < uiHeight; y += hStep)
  {
    for (uint32_t x = 0; x < uiWidth; x += wStep)
    {
      if( (direction == 3) && x == (uiWidth - 1) && y == (uiHeight - 1) )
      {
        continue;
      }

      const Pel *pRec = pReco + y * iStride + x;

      int iDy = pRec[-iStride - 1] + 2 * pRec[-1] + pRec[iStride - 1] - pRec[-iStride + 1] - 2 * pRec[+1] - pRec[iStride + 1];
      int iDx = pRec[iStride - 1] + 2 * pRec[iStride] + pRec[iStride + 1] - pRec[-iStride - 1] - 2 * pRec[-iStride] - pRec[-iStride + 1];

      if( iDy == 0 && iDx == 0 )
      {
        continue;
      }

      int iAmp = (int)(abs(iDx) + abs(iDy));
      int iAngUneven = -1;
      // for determining region
      if (iDx != 0 && iDy != 0) // pure angles are not concerned
      {
        // get the region
        int signx = iDx < 0 ? 1 : 0;
        int signy = iDy < 0 ? 1 : 0;
        int absx = iDx < 0 ? -iDx : iDx;
        int absy = iDy < 0 ? -iDy : iDy;
        int gtY = absx > absy ? 1 : 0;
        int region = gtY ? mapXgrY1[signy][signx] : mapXgrY0[signy][signx];
        //region = (region == 1 ? 2 : (region == 2 ? 1 : (region == 3 ? 4 : 3)));
#if JVET_X0149_TIMD_DIMD_LUT
        int s0 = gtY ? absy : absx;
        int s1 = gtY ? absx : absy;
        int x = floorLog2(s1);
        int norm = (s1 << 4 >> x) & 15;
        int v = g_gradDivTable[norm] | 8;
        x += (norm != 0);
        int shift = 13 - x;
        int ratio;
        if (shift < 0)
        {
          shift = -shift;
          int add = (1 << (shift - 1));
          ratio = (s0 * v + add) >> shift;
        }
        else
        {
          ratio = (s0 * v) << shift;
        }

        // iRatio after integerization can go beyond 2^16
#else
        float fRatio = gtY ? static_cast<float>(absy) / static_cast<float>(absx) : static_cast<float>(absx) / static_cast<float>(absy);
        float fRatioScaled = fRatio * (1 << 16);
        int ratio = static_cast<int>(fRatioScaled);
#endif
        // get ang_idx
        int idx = 16;
        for( int i = 1; i < 17; i++ )
        {
          if( ratio <= angTable[i] )
          {
            idx = ratio - angTable[i - 1] < angTable[i] - ratio ? i - 1 : i;
            break;
          }
        }

        iAngUneven = offsets[region] + dirs[region] * idx;
        //iAngUneven = offsets[region - 1] + dirs[region - 1] * idx;
      }
      else
      {
        iAngUneven = iDx == 0 ? VER_IDX : HOR_IDX;
      }

      CHECK( iAngUneven < 0, "Wrong mode in DIMD histogram" );
      CHECK( iAngUneven >= NUM_LUMA_MODE, "Wrong mode in DIMD histogram" );

      piHistogram[iAngUneven] += iAmp;
    }
  }
  return 0;
}
#endif

#if JVET_AK0059_MDIP
void IntraPrediction::deriveMdipMode(const CPelBuf &recoBuf, const CompArea &area, CodingUnit &cu, bool useExcludingMode)
{
  cu.mdipMode = -1;

  const CodingStructure  &cs = *cu.cs;
  const SPS             &sps = *cs.sps;
  const PreCalcValues   &pcv = *cs.pcv;
  const ChannelType   chType = toChannelType(area.compID);

  const Pel *pReco = recoBuf.buf;
  const uint32_t uiWidth = area.width;
  const uint32_t uiHeight = area.height;
  const int iStride = recoBuf.stride;
  const int predSize = (uiWidth << 1);
  const int predHSize = (uiHeight << 1);

  const bool noShift = pcv.noChroma2x2 && uiWidth == 4; // don't shift on the lowest level (chroma not-split)
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : getComponentScaleX(area.compID, sps.getChromaFormatIdc()));
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : getComponentScaleY(area.compID, sps.getChromaFormatIdc()));

  const int  totalAboveUnits = (predSize + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (predHSize + (unitHeight - 1)) / unitHeight;
  const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
  const int  numAboveUnits = std::max<int>(uiWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(uiHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  CHECK(numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported");

  // ----- Step 1: analyze neighborhood -----
  const Position posLT = area;

  bool  neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(neighborFlags, 0, totalUnits);

  int numIntraAbove = isAboveAvailable(cu, chType, posLT, numAboveUnits, unitWidth, (neighborFlags + totalLeftUnits + 1));
  int numIntraLeft = isLeftAvailable(cu, chType, posLT, numLeftUnits, unitHeight, (neighborFlags + totalLeftUnits - 1));
  int numIntraAboveRight = isAboveRightAvailable(cu, chType, area.topRight(), numAboveRightUnits, unitWidth, neighborFlags + totalLeftUnits + 1 + numAboveUnits);
  int numIntraBottomLeft = isBelowLeftAvailable(cu, chType, area.bottomLeft(), numLeftBelowUnits, unitHeight, neighborFlags + totalLeftUnits - 1 - numLeftUnits);

  // ----- Step 2: build histogram of gradients -----
  int histogram[NUM_LUMA_MODE] = { 0 };
  int histogramTop[NUM_LUMA_MODE] = { 0 };
  int histogramLeft[NUM_LUMA_MODE] = { 0 };
  int histogramTopLeft[NUM_LUMA_MODE] = { 0 };

#if JVET_AJ0203_DIMD_2X2_EDGE_OP
  const int edgeOperatorSizeIdx = static_cast<int>(use2x2EdgeOperator(area));
  const int recoLineOffset      = edgeOperatorSizeIdx == 1 ? 0 : 1;
#endif

  if(uiWidth * uiHeight <= 128)
  {
    if (numIntraLeft)
    {
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const uint32_t uiHeightLeft = (numIntraLeft + numIntraBottomLeft) * unitHeight - recoLineOffset - (!numIntraAbove ? 1 : 0);
#else
      uint32_t uiHeightLeft = (numIntraLeft + numIntraBottomLeft) * unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const Pel *pRecoLeft = pReco - 1 - recoLineOffset + iStride * (!numIntraAbove ? 1 : 0);
#else
      const Pel *pRecoLeft = pReco - 2 + iStride * (!numIntraAbove ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      buildHistogram(pRecoLeft, iStride, uiHeightLeft, 1, histogramLeft, 1, uiWidth, uiHeight, edgeOperatorSizeIdx);
#else
      buildHistogram(pRecoLeft, iStride, uiHeightLeft, 1, histogramLeft, 1, uiWidth, uiHeight);
#endif
    }
    if (numIntraAbove)
    {
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const uint32_t uiWidthAbove = (numIntraAbove + numIntraAboveRight)*unitWidth - recoLineOffset - (!numIntraLeft ? 1 : 0);
#else
      uint32_t uiWidthAbove = (numIntraAbove + numIntraAboveRight) * unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const Pel *pRecoAbove = pReco - iStride * (1 + recoLineOffset) + (!numIntraLeft ? 1 : 0);
#else
      const Pel *pRecoAbove = pReco - iStride * 2 + (!numIntraLeft ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      buildHistogram(pRecoAbove, iStride, 1, uiWidthAbove, histogramTop, 2, uiWidth, uiHeight, edgeOperatorSizeIdx);
#else
      buildHistogram(pRecoAbove, iStride, 1, uiWidthAbove, histogramTop, 2, uiWidth, uiHeight);
#endif
    }
    if (numIntraLeft && numIntraAbove)
    {
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const Pel* pRecoAboveLeft = pReco - 1 - recoLineOffset - iStride * (1 + recoLineOffset);
#else    
      const Pel *pRecoAboveLeft = pReco - 2 - iStride * 2;
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      if (edgeOperatorSizeIdx == 1)
      {
        buildHistogram(pRecoAboveLeft, iStride, 1, 1, histogramTopLeft, 0, uiWidth, uiHeight, edgeOperatorSizeIdx);
      }
      else
      {
        buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogramTopLeft, 3, uiWidth, uiHeight, edgeOperatorSizeIdx);
      }
#else
      buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogramTopLeft, 3, uiWidth, uiHeight);
#endif
    }
  }
  else
  {
    if (numIntraLeft)
    {
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const uint32_t uiHeightLeft = (numIntraLeft + numIntraBottomLeft) * unitHeight - recoLineOffset - (!numIntraAbove ? 1 : 0);
#else
      uint32_t uiHeightLeft = (numIntraLeft + numIntraBottomLeft) * unitHeight - 1 - (!numIntraAbove ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const Pel *pRecoLeft = pReco - 2 - recoLineOffset + iStride * (!numIntraAbove ? 1 : 0);
#else
      const Pel *pRecoLeft = pReco - 3 + iStride * (!numIntraAbove ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      buildHistogram(pRecoLeft, iStride, uiHeightLeft, 2, histogramLeft, 1, uiWidth, uiHeight, edgeOperatorSizeIdx);
#else
      buildHistogram(pRecoLeft, iStride, uiHeightLeft, 2, histogramLeft, 1, uiWidth, uiHeight);
#endif
    }
    if (numIntraAbove)
    {
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const uint32_t uiWidthAbove = (numIntraAbove + numIntraAboveRight)*unitWidth - recoLineOffset - (!numIntraLeft ? 1 : 0);
#else
      uint32_t uiWidthAbove = (numIntraAbove + numIntraAboveRight) * unitWidth - 1 - (!numIntraLeft ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const Pel *pRecoAbove = pReco - iStride * (2 + recoLineOffset) + (!numIntraLeft ? 1 : 0);
#else
      const Pel *pRecoAbove = pReco - iStride * 3 + (!numIntraLeft ? 1 : 0);
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      buildHistogram(pRecoAbove, iStride, 2, uiWidthAbove, histogramTop, 2, uiWidth, uiHeight, edgeOperatorSizeIdx);
#else
      buildHistogram(pRecoAbove, iStride, 2, uiWidthAbove, histogramTop, 2, uiWidth, uiHeight);
#endif
    }
    if (numIntraLeft && numIntraAbove)
    {
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      const Pel* pRecoAboveLeft = pReco - 2 - recoLineOffset - iStride * (2 + recoLineOffset);
#else    
      const Pel *pRecoAboveLeft = pReco - 3 - iStride * 3;
#endif
#if JVET_AJ0203_DIMD_2X2_EDGE_OP
      if (edgeOperatorSizeIdx == 1)
      {
        buildHistogram(pRecoAboveLeft, iStride, 2, 2, histogramTopLeft, 0, uiWidth, uiHeight, edgeOperatorSizeIdx);
      }
      else
      {
        buildHistogram(pRecoAboveLeft, iStride, 3, 3, histogramTopLeft, 3, uiWidth, uiHeight, edgeOperatorSizeIdx);
      }
#else
      buildHistogram(pRecoAboveLeft, iStride, 3, 3, histogramTopLeft, 3, uiWidth, uiHeight);
#endif
    }
  }

  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    histogram[i] = histogramTop[i] + histogramLeft[i] + histogramTopLeft[i];
    histogramTop[i] = histogramTop[i] + histogramTopLeft[i];
    histogramLeft[i] = histogramLeft[i] + histogramTopLeft[i];
  }

  int curAmp = 0, curMode = 0;
  bool includedMode[NUM_LUMA_MODE]{ false };

  int mdipAmp[4] = {0};
  int mdipMode[4] = {0};
  
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = histogram[i];
    curMode = i;
    if (curAmp > mdipAmp[0])
    {
      mdipAmp[3]     = mdipAmp[2];
      mdipMode[3]    = mdipMode[2];
      mdipAmp[2]     = mdipAmp[1];
      mdipMode[2]    = mdipMode[1];
      mdipAmp[1]     = mdipAmp[0];
      mdipMode[1]    = mdipMode[0];
      mdipAmp[0]     = curAmp;
      mdipMode[0]    = curMode;
    }
    else if (curAmp > mdipAmp[1])
    {
      mdipAmp[3]   = mdipAmp[2];
      mdipMode[3]  = mdipMode[2];
      mdipAmp[2]   = mdipAmp[1];
      mdipMode[2]  = mdipMode[1];
      mdipAmp[1]   = curAmp;
      mdipMode[1]  = curMode;
    }
    else if (curAmp > mdipAmp[2])
    {  
      mdipAmp[3]   = mdipAmp[2];
      mdipMode[3]  = mdipMode[2];
      mdipAmp[2]   = curAmp;
      mdipMode[2]  = curMode;
    }
    else if (curAmp > mdipAmp[3])
    {
      mdipAmp[3]  = curAmp;
      mdipMode[3] = curMode;
    }
  }

  // Left mode
  int mdipAmpLeft[2] = {0};
  int mdipModeLeft[2] = {0};
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = histogramLeft[i];
    curMode = i;
    if (curAmp > mdipAmpLeft[0])
    {
      mdipAmpLeft[1]   = mdipAmpLeft[0];
      mdipModeLeft[1]  = mdipModeLeft[0];
      mdipAmpLeft[0]   = curAmp;
      mdipModeLeft[0]  = curMode;
    }
    else if (curAmp > mdipAmpLeft[1])
    {
      mdipAmpLeft[1]   = curAmp;
      mdipAmpLeft[1]   = curMode;
    }
  }

  // Top mode
  int mdipAmpTop[2] = {0};
  int mdipModeTop[2] = {0};
  for (int i = 0; i < NUM_LUMA_MODE; i++)
  {
    curAmp = histogramTop[i];
    curMode = i;
    if (curAmp > mdipAmpTop[0])
    {
      mdipAmpTop[1]   = mdipAmpTop[0];
      mdipModeTop[1]  = mdipModeTop[0];
      mdipAmpTop[0]   = curAmp;
      mdipModeTop[0]  = curMode;
    }
    else if (curAmp > mdipAmpTop[1])
    {
      mdipAmpTop[1]   = curAmp;
      mdipModeTop[1]  = curMode;
    }
  }

  int mdiplist[8] {0};
  int maxCand = 8;
  int numCand = 0;

  for(int i=0; i < 4; i++)
  {
    if(mdipMode[i] != 0 && numCand < maxCand)
    {
      mdiplist[numCand] = mdipMode[i];
      includedMode[mdiplist[numCand++]] = true;
    }
  }
  for(int i=0; i < 2; i++)
  {
    if(mdipModeTop[i] != 0 && !includedMode[mdipModeTop[i]] && numCand < maxCand)
    {
      mdiplist[numCand] = mdipModeTop[i];
      includedMode[mdiplist[numCand++]] = true;
    }
  }
  for(int i=0; i < 2; i++)
  {
    if(mdipModeLeft[i] != 0 && !includedMode[mdipModeLeft[i]] && numCand < maxCand)
    {
      mdiplist[numCand] = mdipModeLeft[i];
      includedMode[mdiplist[numCand++]] = true;
    }
  }

  const int currNumCands = numCand;
  const int offset = NUM_LUMA_MODE - 6;
  const int mod = offset + 3;
  for (int i = 0; i < currNumCands; i++)
  {
    if (mdiplist[i] <= DC_IDX)
    {
      continue;
    }
    for (int deltaAngular = 0; deltaAngular < 2; deltaAngular++)
    {
      if (numCand < maxCand)
      {
        auto mode = ((mdiplist[i] + offset - deltaAngular) % mod) + 2;
        if (!includedMode[mode])
        {
          includedMode[mode] = true;
          mdiplist[numCand++] = mode;
        }
      }

      if (numCand < maxCand)
      {
        auto mode = ((mdiplist[i] - 1 + deltaAngular) % mod) + 2;
        if (!includedMode[mode])
        {
          includedMode[mode] = true;
          mdiplist[numCand++] = mode;
        }
      }
    }
  }

  if(numCand == 0)
  {
    mdiplist[0] = DC_IDX;
    includedMode[DC_IDX] = true;
    numCand++;
  }

  if(numCand >= 2 && uiWidth * uiHeight <= 256)
  {
    deriveMdipSorted(*cu.firstPU, mdiplist, numCand, 0);
  }
  cu.mdipMode = mdiplist[0];

  if(useExcludingMode)
  {
    buildExcludingMode(cu, histogram, includedMode);
  }
}
#endif

#if JVET_W0123_TIMD_FUSION && JVET_AG0092_ENHANCED_TIMD_FUSION
void xLocationdepBlending(Pel *pDst, int strideDst, Pel *pVer, int strideVer, Pel *pHor, int strideHor,Pel *pNonLocDep, int strideNonLocDep, int width, int height, int mode, int wVer, int wHor, int wNonLocDep, int range)
{
  int maxWeight = (1 << 6);
  int weightShift = 6;
  int weightOffset = 1 << (weightShift - 1);
  int sizeThreshold = 64;
  int heightMinusOne = (height - 1);
  int widthMinusOne = (width - 1);

  if (mode == 0) // diagonal blending
  {
    int clipRangeVer = 64;
    int clipRangeHor = 64;
    {
      int totRange = wNonLocDep;
      int totDirWeight = wVer + wHor;
      clipRangeVer = wVer +  (int)(((double)wVer / (double)totDirWeight)* (double)totRange);
      clipRangeHor = wHor +  (int)(((double)wHor / (double)totDirWeight)* (double)totRange);
    }
    int rangeVer = range;
    int rangeHor = range;  

    if(height > sizeThreshold) 
    {
      rangeVer *= 2;
    }
    if(width > sizeThreshold)
    {
      rangeHor *= 2;
    }

    bool needClipVer = (((wVer + rangeVer) > clipRangeVer) || ((wVer - rangeVer) < 0));
    bool needClipHor = (((wHor + rangeHor) > clipRangeHor) || ((wHor - rangeHor) < 0));
    if(needClipVer && needClipHor)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = heightMinusOne ? Clip3(0, clipRangeVer, (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne)) : maxWeight;
        for (int x = 0; x < width; x++)
        {
          int weightHor =  (wNonLocDep && widthMinusOne) ? Clip3(0, clipRangeHor, (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne)) : maxWeight - weightVer;
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else if (needClipVer)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = heightMinusOne ? Clip3(0, clipRangeVer, (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne)) : maxWeight;
        for (int x = 0; x < width; x++)
        {
          int weightHor =  (wNonLocDep && widthMinusOne) ? (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne) : maxWeight - weightVer;
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else if(needClipHor)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer =  heightMinusOne ? (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne) : maxWeight;
        for (int x = 0; x < width; x++)
        {
          int weightHor =  (wNonLocDep && widthMinusOne) ? Clip3(0, clipRangeHor, (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne)) : maxWeight - weightVer;
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer =  heightMinusOne ? (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne) : maxWeight;
        for (int x = 0; x < width; x++)
        {
          int weightHor =  (wNonLocDep && widthMinusOne) ? (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne) : maxWeight - weightVer;
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
  }
  else if(mode == 1) //ver blending
  {
    int clipRangeVer = 64; 
    int rangeVer = range;

    if(height > sizeThreshold)
    {
      rangeVer *= 2;
    }
    bool needClipVer = (((wVer + rangeVer) > clipRangeVer) || ((wVer - rangeVer) < 0));

    if (needClipVer)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = (wNonLocDep && heightMinusOne) ? Clip3(0, clipRangeVer, (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne)) : maxWeight;
        for (int x = 0; x < width; x++)
        {
          int weightNonLocDep =  maxWeight - weightVer;
          int blend = (int)pVer[x]  * weightVer + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pNonLocDep += strideNonLocDep;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = (wNonLocDep && heightMinusOne) ? (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne) : maxWeight;
        for (int x = 0; x < width; x++)
        {
          int weightNonLocDep =  maxWeight - weightVer;
          int blend = (int)pVer[x]  * weightVer + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pNonLocDep += strideNonLocDep;
      }
    }
  }
  else// if(mode == 2) //ver blending
  {
    int clipRangeHor = 64; 
    int rangeHor = range;

    if(width > sizeThreshold)
    {
      rangeHor *= 2;
    }
    bool needClipHor = (((wHor + rangeHor) > clipRangeHor) || ((wHor - rangeHor) < 0));

    if (needClipHor)
    {
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int weightHor = (wNonLocDep && widthMinusOne) ? Clip3(0, clipRangeHor, (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne)) : maxWeight;
          int weightNonLocDep =  maxWeight - weightHor;
          int blend = (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int weightHor = (wNonLocDep && widthMinusOne) ? (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne) : maxWeight;
          int weightNonLocDep =  maxWeight - weightHor;
          int blend = (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
  }
}
#else
#if JVET_AC0098_LOC_DEP_DIMD
#if JVET_AB0157_INTRA_FUSION
void xDimdLocationdepBlending(Pel *pDst, int strideDst, Pel *pVer, int strideVer, Pel *pHor, int strideHor,Pel *pNonLocDep, int strideNonLocDep, int width, int height, int mode, int wVer, int wHor, int wNonLocDep)
{
  int maxWeight = (1 << 6);
  int weightShift = 6;
  int weightOffset = 1 << (weightShift - 1);
  int fixedRange = 10;
  int sizeThreshold = 64;
  int heightMinusOne = (height - 1);
  int widthMinusOne = (width - 1);
  if (mode == 0) // diagonal blending
  {
    int clipRangeVer = 64;
    int clipRangeHor = 64;
    {
      int totRange = wNonLocDep;
      int totDirWeight = wVer + wHor;
      clipRangeVer = wVer +  (int)(((double)wVer / (double)totDirWeight)* (double)totRange);
      clipRangeHor = wHor +  (int)(((double)wHor / (double)totDirWeight)* (double)totRange);
    }
    int rangeVer = fixedRange;
    int rangeHor = fixedRange;  

    if(height > sizeThreshold) 
    {
      rangeVer *= 2;
    }
    if(width > sizeThreshold)
    {
      rangeHor *= 2;
    }

    bool needClipVer = (((wVer + rangeVer) > clipRangeVer) || ((wVer - rangeVer) < 0));
    bool needClipHor = (((wHor + rangeHor) > clipRangeHor) || ((wHor - rangeHor) < 0));
    if(needClipVer && needClipHor)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = Clip3(0, clipRangeVer, (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne));
        for (int x = 0; x < width; x++)
        {
          int weightHor =  Clip3(0, clipRangeHor, (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne));
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else if (needClipVer)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = Clip3(0, clipRangeVer, (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne));
        for (int x = 0; x < width; x++)
        {
          int weightHor =  (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne);
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else if(needClipHor)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer =  (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne);
        for (int x = 0; x < width; x++)
        {
          int weightHor =  Clip3(0, clipRangeHor, (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne));
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer =  (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne);
        for (int x = 0; x < width; x++)
        {
          int weightHor =  (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne);
          int weightNonLocDep =  maxWeight - weightVer - weightHor;
          int blend = (int)pVer[x]  * weightVer + (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
  }
  else if(mode == 1) //ver blending
  {
    int clipRangeVer = 64; 
    int rangeVer = fixedRange;

    if(height > sizeThreshold)
    {
      rangeVer *= 2;
    }
    bool needClipVer = (((wVer + rangeVer) > clipRangeVer) || ((wVer - rangeVer) < 0));

    if (needClipVer)
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = Clip3(0, clipRangeVer, (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne));
        for (int x = 0; x < width; x++)
        {
          int weightNonLocDep =  maxWeight - weightVer;
          int blend = (int)pVer[x]  * weightVer + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pNonLocDep += strideNonLocDep;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        int weightVer = (((wVer + rangeVer) * heightMinusOne - ((rangeVer*y) << 1)) / heightMinusOne);
        for (int x = 0; x < width; x++)
        {
          int weightNonLocDep =  maxWeight - weightVer;
          int blend = (int)pVer[x]  * weightVer + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pVer += strideVer;
        pNonLocDep += strideNonLocDep;
      }
    }
  }
  else// if(mode == 2) //ver blending
  {
    int clipRangeHor = 64; 
    int rangeHor = fixedRange;

    if(width > sizeThreshold)
    {
      rangeHor *= 2;
    }
    bool needClipHor = (((wHor + rangeHor) > clipRangeHor) || ((wHor - rangeHor) < 0));

    if (needClipHor)
    {
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int weightHor =  Clip3(0, clipRangeHor, (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne));
          int weightNonLocDep =  maxWeight - weightHor;
          int blend = (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
    else
    {
      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int weightHor =  (((wHor + rangeHor) * widthMinusOne - ((rangeHor*x) << 1)) / widthMinusOne);
          int weightNonLocDep =  maxWeight - weightHor;
          int blend = (int)pHor[x]  * weightHor + (int)pNonLocDep[x]  * weightNonLocDep + weightOffset;
          pDst[x] = (Pel)(blend >> weightShift);
        }
        pDst += strideDst;
        pHor += strideHor;
        pNonLocDep += strideNonLocDep;
      }
    }
  }
}
#else
void xDimdLocationdepBlending(Pel *pDst, int strideDst, Pel *pMainAng, int strideMainAng, Pel *pSecondAng, int strideSecondAng,Pel *pPlanar, int stridePlanar, int width, int height, int sideMain, int sideSecond, int wMain, int wSecond, int wPlanar)
{
  int smallerWeightsTh = 2;

  int maxWeight = (1 << 6);
  int weightShift = 6;
  int weightOffset = 32;

  if(sideMain != 0 && sideSecond != 0)
  {
    wPlanar += 8;
    wMain -= 4;
    wSecond = 64 - wMain - wPlanar;
  }

  int weightMain = wMain;
  int weightSecond = wSecond; 
  int weightPlanar = wPlanar; 

  int mainRange = 0, secondRange = 0;
  

  if(sideMain != 0)
  {
    int tempRange = (sideSecond == 0 ? 20 : 15);
    mainRange = (weightMain < tempRange) ? weightMain : tempRange;
    if(sideMain > smallerWeightsTh)
    {
      int tempRange = (sideSecond == 0 ? 10 : 5);
      mainRange = (weightMain < tempRange) ? weightMain : tempRange;
      sideMain -= smallerWeightsTh;
    }
    mainRange = Clip3(0, (64 - wMain), mainRange);
  }
  if(sideSecond != 0)
  {
    int tempRange = (sideMain == 0 ? 10 : 5);
    secondRange = (weightSecond < tempRange) ? weightSecond : tempRange;
    if(sideSecond > smallerWeightsTh)
    {
      sideSecond -= smallerWeightsTh;
    }
    secondRange = Clip3(0, (64 - wSecond), secondRange);
  }
  int blend;
    
  if(sideMain == 1 && sideSecond == 0)
  {
    for (int y = 0; y < height; y++)
    {
      weightMain = ((wMain + mainRange) * (height - 1) - ((mainRange*y) << 1)) / (height - 1);
      weightPlanar = wPlanar + (( wMain - weightMain ) >> 1);
      weightSecond = maxWeight - weightMain - weightPlanar;
      for (int x = 0; x < width; x++)
      {
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
  else if(sideMain == 2 && sideSecond == 0)
  {
    for (int y = 0; y < height; y++)
    {
      for (int x = 0; x < width; x++)
      {
        weightMain = ((wMain + mainRange) * (width - 1) - ((mainRange*x) << 1)) / (width - 1);
        weightPlanar = wPlanar + (( wMain - weightMain ) >> 1);
        weightSecond = maxWeight - weightMain - weightPlanar;
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
  else if(sideMain == 0 && sideSecond == 1)
  {
    for (int y = 0; y < height; y++)
    {
      weightSecond = ((wSecond + secondRange) * (height - 1) - ((secondRange*y) << 1)) / (height - 1);
      weightPlanar = wPlanar + (( wSecond - weightSecond ) >> 1);
      weightMain = maxWeight - weightSecond - weightPlanar;
      for (int x = 0; x < width; x++)
      {
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
  else if(sideMain == 0 && sideSecond == 2)
  {
    for (int y = 0; y < height; y++)
    {
      for (int x = 0; x < width; x++)
      {
        weightSecond = ((wSecond + secondRange) * (width - 1) - ((secondRange*x) << 1)) / (width - 1);
        weightPlanar = wPlanar + (( wSecond - weightSecond ) >> 1);
        weightMain = maxWeight - weightSecond - weightPlanar;
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
  else if(sideMain == 1 && sideSecond == 1)
  {
    for (int y = 0; y < height; y++)
    {
      weightMain = ((wMain + mainRange) * (height - 1) - ((mainRange*y) << 1)) / (height - 1);
      weightSecond = ((wSecond + secondRange) * (height - 1) - ((secondRange*y) << 1)) / (height - 1);
      weightPlanar =  maxWeight - weightSecond - weightMain;
      for (int x = 0; x < width; x++)
      {
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
  else if(sideMain == 1 && sideSecond == 2)
  {
    for (int y = 0; y < height; y++)
    {
      weightMain = ((wMain + mainRange) * (height - 1) - ((mainRange*y) << 1)) / (height - 1);
      for (int x = 0; x < width; x++)
      {
        weightSecond = ((wSecond + secondRange) * (width - 1) - ((secondRange*x) << 1)) / (width - 1);
        weightPlanar =  maxWeight - weightSecond - weightMain;
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
  else if(sideMain == 2 && sideSecond == 1)
  {
    for (int y = 0; y < height; y++)
    {
      weightSecond = ((wSecond + secondRange) * (height - 1) - ((secondRange*y) << 1)) / (height - 1);
      for (int x = 0; x < width; x++)
      {
        weightMain = ((wMain + mainRange) * (width - 1) - ((mainRange*x) << 1)) / (width - 1);
        weightPlanar =  maxWeight - weightSecond - weightMain;
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
  else if(sideMain == 2 && sideSecond == 2)
  {
    for (int y = 0; y < height; y++)
    {
      for (int x = 0; x < width; x++)
      {
        weightMain = ((wMain + mainRange) * (width - 1) - ((mainRange*x) << 1)) / (width - 1);
        weightSecond = ((wSecond + secondRange) * (width - 1) - ((secondRange*x) << 1)) / (width - 1);
        weightPlanar =  maxWeight - weightSecond - weightMain;
        blend = (int)pMainAng[x]  * weightMain + (int)pSecondAng[x]  * weightSecond + (int)pPlanar[x]  * weightPlanar + weightOffset;
        pDst[x] = (Pel)(blend >> weightShift);
      }
      pDst += strideDst;
      pMainAng += strideMainAng;
      pSecondAng += strideSecondAng;
      pPlanar += stridePlanar;
    }
  }
}
#endif
#endif
#endif

#if INTRA_TRANS_ENC_OPT
void IntraPrediction::dimdBlending(Pel *pDst, int strideDst, Pel *pSrc0, int strideSrc0, Pel *pSrc1, int strideSrc1, int w0, int w1, int w2, int width, int height)
{
  Pel *pelPred = pDst;
  Pel *pelPlanar = pSrc0;
  Pel *pelPredAng = pSrc1;

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int blend = pelPred[x] * w0;
      blend += pelPlanar[x] * w1;
      blend += pelPredAng[x] * w2;
      pelPred[x] = (Pel)(blend >> 6);
    }

    pelPred += strideDst;
    pelPlanar += strideSrc0;
    pelPredAng += strideSrc1;
  }
}
#endif
#endif

#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
bool isPosAvailable(const CodingUnit &cu, const ChannelType &chType, const Position &refPos)
{
  const CodingStructure& cs = *cu.cs;

  if (!cs.isDecomp(refPos, chType))
  {
    return false;
  }

  return (cs.getCURestricted(refPos, cu, chType) != NULL);
}
#endif
bool isAboveLeftAvailable(const CodingUnit &cu, const ChannelType &chType, const Position &posLT)
{
  const CodingStructure& cs = *cu.cs;
  const Position refPos = posLT.offset(-1, -1);

  if (!cs.isDecomp(refPos, chType))
  {
    return false;
  }

  return (cs.getCURestricted(refPos, cu, chType) != NULL);
}

int isAboveAvailable(const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *bValidFlags)
{
  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDx      = uiNumUnitsInPU * unitWidth;

  for (int dx = 0; dx < maxDx; dx += unitWidth)
  {
    const Position refPos = posLT.offset(dx, -1);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags++;
  }

  return numIntra;
}

int isLeftAvailable(const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *bValidFlags)
{
  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDy      = uiNumUnitsInPU * unitHeight;

  for (int dy = 0; dy < maxDy; dy += unitHeight)
  {
    const Position refPos = posLT.offset(-1, dy);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags--;
  }

  return numIntra;
}

int isAboveRightAvailable(const CodingUnit &cu, const ChannelType &chType, const Position &posRT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *bValidFlags )
{
  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDx      = uiNumUnitsInPU * unitWidth;

  for (int dx = 0; dx < maxDx; dx += unitWidth)
  {
    const Position refPos = posRT.offset(unitWidth + dx, -1);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags++;
  }

  return numIntra;
}

int isBelowLeftAvailable(const CodingUnit &cu, const ChannelType &chType, const Position &posLB, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *bValidFlags )
{
  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDy      = uiNumUnitsInPU * unitHeight;

  for (int dy = 0; dy < maxDy; dy += unitHeight)
  {
    const Position refPos = posLB.offset(-1, unitHeight + dy);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags--;
  }

  return numIntra;
}

#if JVET_AJ0161_OBMC_EXT_WITH_INTRA_PRED
int isAboveAvailableOBMC(const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *bValidFlags, const int obmcNeighState)
{
  if (obmcNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL)
  { 
    return 0;
  }

  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDx      = uiNumUnitsInPU * unitWidth;

  for (int dx = 0; dx < maxDx; dx += unitWidth)
  {
    const Position refPos = posLT.offset(dx, -1);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags++;
  }

  return numIntra;
}

int isLeftAvailableOBMC(const CodingUnit &cu, const ChannelType &chType, const Position &posLT, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *bValidFlags, const int obmcNeighState)
{
  if (obmcNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL)
  {
    return 0;
  }
  
  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDy      = uiNumUnitsInPU * unitHeight;

  for (int dy = 0; dy < maxDy; dy += unitHeight)
  {
    const Position refPos = posLT.offset(-1, dy);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags--;
  }

  return numIntra;
}

int isAboveRightAvailableOBMC(const CodingUnit &cu, const ChannelType &chType, const Position &posRT, const uint32_t uiNumUnitsInPU, const uint32_t unitWidth, bool *bValidFlags, const int obmcNeighState )
{
  if (obmcNeighState == INTRA_OBMC_ONLY_LEFT_AVAIL)
  {
    return 0;
  }
  
  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDx      = uiNumUnitsInPU * unitWidth;

  for (int dx = 0; dx < maxDx; dx += unitWidth)
  {
    const Position refPos = posRT.offset(unitWidth + dx, -1);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags++;
  }

  return numIntra;
}

int isBelowLeftAvailableOBMC(const CodingUnit &cu, const ChannelType &chType, const Position &posLB, const uint32_t uiNumUnitsInPU, const uint32_t unitHeight, bool *bValidFlags, const int obmcNeighState )
{
  if (obmcNeighState == INTRA_OBMC_ONLY_ABOVE_AVAIL)
  {
    return 0;
  }
  
  const CodingStructure& cs = *cu.cs;

  bool *    validFlags = bValidFlags;
  int       numIntra   = 0;
  const int maxDy      = uiNumUnitsInPU * unitHeight;

  for (int dy = 0; dy < maxDy; dy += unitHeight)
  {
    const Position refPos = posLB.offset(-1, unitHeight + dy);

    if (!cs.isDecomp(refPos, chType))
    {
      break;
    }

    const bool valid = (cs.getCURestricted(refPos, cu, chType) != NULL);
    numIntra += valid ? 1 : 0;
    *validFlags = valid;

    validFlags--;
  }

  return numIntra;
}
#endif

#if JVET_AA0126_GLM
Pel IntraPrediction::xGlmGetLumaVal(const int s[6], const int c[6], const int glmIdx, const Pel val) const
{
  Pel grad = c[0] * s[0] + c[1] * s[1] + c[2] * s[2] 
           + c[3] * s[3] + c[4] * s[4] + c[5] * s[5];
#if NUM_GLM_WEIGHT && !JVET_AB0092_GLM_WITH_LUMA
  return (glmIdx >= NUM_GLM_PATTERN ? val + grad : grad);
#else
  return grad;
#endif
}

void IntraPrediction::xGetLumaRecPixelsGlmAll(const PredictionUnit &pu, CompArea chromaArea)
{
#if JVET_AB0092_GLM_WITH_LUMA
  const CPelBuf recoLuma = pu.cs->picture->getRecoBuf(COMPONENT_Y);
  const int  maxPosPicX = pu.cs->picture->chromaSize().width - 1;
  const int  maxPosPicY = pu.cs->picture->chromaSize().height - 1;

  xGlmCalcRefArea(pu, chromaArea); // Find the reference area

  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  PelBuf refGrad[NUM_GLM_IDC];
  for (int i = 0; i < NUM_GLM_IDC; i++)
  {
    refGrad[i] = xGlmGetGradRefBuf(pu, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY, i);
  }

  int puBorderX = refSizeX + chromaArea.width;
  int puBorderY = refSizeY + chromaArea.height;

  // Generate down-sampled luma and luma gradients
  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      if ((x >= puBorderX && y >= refSizeY) || (y >= puBorderY && x >= refSizeX))
      {
        continue;
      }

      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;

      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

      for (int i = 0; i < NUM_GLM_IDC; i++)
      {
        refGrad[i].at(x, y) = xGlmGetGradVal(pu, i, recoLuma, chromaPosPicX, chromaPosPicY);
      }
    }
  }
#endif
  int c[6] = { 0 };

  int iDstStride = 2 * MAX_CU_SIZE + 1;
  Pel* pDst0Cb[NUM_GLM_IDC];
  Pel* pDst0Cr[NUM_GLM_IDC];

  for (int k = 0; k < NUM_GLM_IDC; k++)
  {
    pDst0Cb[k] = m_glmTempCb[k] + iDstStride + 1;
    pDst0Cr[k] = m_glmTempCr[k] + iDstStride + 1;
  }

  //assert 420 chroma subsampling
  CompArea lumaArea = CompArea( COMPONENT_Y, pu.chromaFormat, chromaArea.lumaPos(), recalcSize( pu.chromaFormat, CHANNEL_TYPE_CHROMA, CHANNEL_TYPE_LUMA, chromaArea.size() ) );//needed for correct pos/size (4x4 Tus)

  CHECK(lumaArea.width == chromaArea.width && CHROMA_444 != pu.chromaFormat, "");
  CHECK(lumaArea.height == chromaArea.height && CHROMA_444 != pu.chromaFormat && CHROMA_422 != pu.chromaFormat, "");

  const SizeType uiCWidth = chromaArea.width;
  const SizeType uiCHeight = chromaArea.height;

  const CPelBuf Src = pu.cs->picture->getRecoBuf( lumaArea );
  Pel const* pRecSrc0   = Src.bufAt( 0, 0 );
  int iRecStride        = Src.stride;
  int logSubWidthC  = getChannelTypeScaleX(CHANNEL_TYPE_CHROMA, pu.chromaFormat);
  int logSubHeightC = getChannelTypeScaleY(CHANNEL_TYPE_CHROMA, pu.chromaFormat);

  int iRecStride2       = iRecStride << logSubHeightC;

  const CodingUnit& lumaCU = isChroma( pu.chType ) ? *pu.cs->picture->cs->getCU( lumaArea.pos(), CH_L ) : *pu.cu;
  const CodingUnit&     cu = *pu.cu;

  const CompArea& area = isChroma( pu.chType ) ? chromaArea : lumaArea;

  const uint32_t uiTuWidth  = area.width;
  const uint32_t uiTuHeight = area.height;

  int iBaseUnitSize = ( 1 << MIN_CU_LOG2 );

  const int  iUnitWidth       = iBaseUnitSize >> getComponentScaleX( area.compID, area.chromaFormat );
  const int  iUnitHeight = iBaseUnitSize >> getComponentScaleY(area.compID, area.chromaFormat);

  const int  iTUWidthInUnits = uiTuWidth / iUnitWidth;
  const int  iTUHeightInUnits = uiTuHeight / iUnitHeight;
  const int  iAboveUnits      = iTUWidthInUnits;
  const int  iLeftUnits       = iTUHeightInUnits;
  const int  chromaUnitWidth = iBaseUnitSize >> getComponentScaleX(COMPONENT_Cb, area.chromaFormat);
  const int  chromaUnitHeight = iBaseUnitSize >> getComponentScaleY(COMPONENT_Cb, area.chromaFormat);
  const int  topTemplateSampNum = 2 * uiCWidth; // for MDLM, the number of template samples is 2W or 2H.
  const int  leftTemplateSampNum = 2 * uiCHeight;

  CHECK( m_topRefLength < topTemplateSampNum, "Wrong top template length");
  CHECK(m_leftRefLength < leftTemplateSampNum, "Wrong left template length" );

  const int  totalAboveUnits = (topTemplateSampNum + (chromaUnitWidth - 1)) / chromaUnitWidth;
  const int  totalLeftUnits = (leftTemplateSampNum + (chromaUnitHeight - 1)) / chromaUnitHeight;
  const int  totalUnits = totalLeftUnits + totalAboveUnits + 1;
  const int  aboveRightUnits = totalAboveUnits - iAboveUnits;
  const int  leftBelowUnits = totalLeftUnits - iLeftUnits;

  int avaiAboveRightUnits = 0;
  int avaiLeftBelowUnits = 0;
  bool  bNeighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(bNeighborFlags, 0, totalUnits);
  bool aboveIsAvailable, leftIsAvailable;

  int availlableUnit = isLeftAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.pos(),
                                       iLeftUnits, iUnitHeight, (bNeighborFlags + iLeftUnits + leftBelowUnits - 1));

  leftIsAvailable = availlableUnit == iTUHeightInUnits;

  availlableUnit = isAboveAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.pos(),
                                    iAboveUnits, iUnitWidth, (bNeighborFlags + iLeftUnits + leftBelowUnits + 1));

  aboveIsAvailable = availlableUnit == iTUWidthInUnits;

  if (leftIsAvailable)   // if left is not available, then the below left is not available
  {
    avaiLeftBelowUnits = isBelowLeftAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.bottomLeftComp(area.compID), leftBelowUnits, iUnitHeight, (bNeighborFlags + leftBelowUnits - 1));
  }

  if (aboveIsAvailable)   // if above is not available, then  the above right is not available.
  {
    avaiAboveRightUnits = isAboveRightAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.topRightComp(area.compID), aboveRightUnits, iUnitWidth, (bNeighborFlags + iLeftUnits + leftBelowUnits + iAboveUnits + 1));
  }

  Pel*       pDstCb[NUM_GLM_IDC];
  Pel*       pDstCr[NUM_GLM_IDC];
  Pel const* piSrc = nullptr;

  if (aboveIsAvailable)
  {
    for (int k = 0; k < NUM_GLM_IDC; k++)
    {
      pDstCb[k]  = pDst0Cb[k]    - iDstStride;
      pDstCr[k]  = pDst0Cr[k]    - iDstStride;
    }

    int addedAboveRight = avaiAboveRightUnits*chromaUnitWidth;

    for (int i = 0; i < uiCWidth + addedAboveRight; i++)
    {
      const int l = (i == 0 && !leftIsAvailable) ? 0 : 1;
      {
        piSrc = pRecSrc0 - iRecStride2;
        int s[6] = { piSrc[2 * i              - l], piSrc[2 * i                 ], piSrc[2 * i              + 1],
                     piSrc[2 * i + iRecStride - l], piSrc[2 * i + iRecStride    ], piSrc[2 * i + iRecStride + 1] };
        int val = (1 * s[0] + 2 * s[1] + 1 * s[2] 
                 + 1 * s[3] + 2 * s[4] + 1 * s[5] + 4) >> 3;
        pDstCb[0][i] = val;
        pDstCr[0][i] = val;

        for (int k = 1; k < NUM_GLM_IDC; k++)
        {
          int p = (k - 1 < NUM_GLM_PATTERN) ? (k - 1) : (k - 1 - NUM_GLM_PATTERN);
          c[0] = g_glmPattern[p][0], c[1] = g_glmPattern[p][1], c[2] = g_glmPattern[p][2];
          c[3] = g_glmPattern[p][3], c[4] = g_glmPattern[p][4], c[5] = g_glmPattern[p][5];
          int grad = c[0] * s[0] + c[1] * s[1] + c[2] * s[2] 
                   + c[3] * s[3] + c[4] * s[4] + c[5] * s[5];
          pDstCb[k][i] = (k - 1 < NUM_GLM_PATTERN) ? grad : val + grad;
          pDstCr[k][i] = (k - 1 < NUM_GLM_PATTERN) ? grad : val + grad;
        }
      }
    }
  }

  if (leftIsAvailable)
  {
    for (int k = 0; k < NUM_GLM_IDC; k++)
    {
      pDstCb[k]  = pDst0Cb[k]    - 1;
      pDstCr[k]  = pDst0Cr[k]    - 1;
    }
    piSrc = pRecSrc0 - 1 - logSubWidthC;

    int addedLeftBelow = avaiLeftBelowUnits*chromaUnitHeight;

    for (int j = 0; j < uiCHeight + addedLeftBelow; j++)
    {
      {
        int s[6] = { piSrc[           - 1], piSrc[             0], piSrc[             1],
                     piSrc[iRecStride - 1], piSrc[iRecStride    ], piSrc[iRecStride + 1] };
        int val = (1 * s[0] + 2 * s[1] + 1 * s[2] 
                 + 1 * s[3] + 2 * s[4] + 1 * s[5] + 4) >> 3;
        pDstCb[0][0] = val;
        pDstCr[0][0] = val;

        for (int k = 1; k < NUM_GLM_IDC; k++)
        {
          int p = (k - 1 < NUM_GLM_PATTERN) ? (k - 1) : (k - 1 - NUM_GLM_PATTERN);
          c[0] = g_glmPattern[p][0], c[1] = g_glmPattern[p][1], c[2] = g_glmPattern[p][2];
          c[3] = g_glmPattern[p][3], c[4] = g_glmPattern[p][4], c[5] = g_glmPattern[p][5];
          int grad = c[0] * s[0] + c[1] * s[1] + c[2] * s[2] 
                   + c[3] * s[3] + c[4] * s[4] + c[5] * s[5];
          pDstCb[k][0] = (k - 1 < NUM_GLM_PATTERN) ? grad : val + grad;
          pDstCr[k][0] = (k - 1 < NUM_GLM_PATTERN) ? grad : val + grad;
        }
      }

      piSrc += iRecStride2;
      for (int k = 0; k < NUM_GLM_IDC; k++)
      {
        pDstCb[k] += iDstStride;
        pDstCr[k] += iDstStride;
      }
    }
  }

  // inner part from reconstructed picture buffer
  for( int j = 0; j < uiCHeight; j++ )
  {
    for( int i = 0; i < uiCWidth; i++ )
    {
      const int l = (i == 0 && !leftIsAvailable) ? 0 : 1;
      {
        int s[6] = { pRecSrc0[2 * i              - l], pRecSrc0[2 * i                 ], pRecSrc0[2 * i              + 1],
                     pRecSrc0[2 * i + iRecStride - l], pRecSrc0[2 * i + iRecStride    ], pRecSrc0[2 * i + iRecStride + 1] };
        int val = (1 * s[0] + 2 * s[1] + 1 * s[2] 
                 + 1 * s[3] + 2 * s[4] + 1 * s[5] + 4) >> 3;
        pDst0Cb[0][i] = val;
        pDst0Cr[0][i] = val;

        for (int k = 1; k < NUM_GLM_IDC; k++)
        {
          int p = (k - 1 < NUM_GLM_PATTERN) ? (k - 1) : (k - 1 - NUM_GLM_PATTERN);
          c[0] = g_glmPattern[p][0], c[1] = g_glmPattern[p][1], c[2] = g_glmPattern[p][2];
          c[3] = g_glmPattern[p][3], c[4] = g_glmPattern[p][4], c[5] = g_glmPattern[p][5];
          int grad = c[0] * s[0] + c[1] * s[1] + c[2] * s[2] 
                   + c[3] * s[3] + c[4] * s[4] + c[5] * s[5];
          pDst0Cb[k][i] = (k - 1 < NUM_GLM_PATTERN) ? grad : val + grad;
          pDst0Cr[k][i] = (k - 1 < NUM_GLM_PATTERN) ? grad : val + grad;
        }
      }
    }

    for (int k = 0; k < NUM_GLM_IDC; k++)
    {
      pDst0Cb[k]    += iDstStride;
      pDst0Cr[k]    += iDstStride;
    }
    pRecSrc0 += iRecStride2;
  }
}
#endif

// LumaRecPixels
void IntraPrediction::xGetLumaRecPixels(const PredictionUnit &pu, CompArea chromaArea
#if JVET_AD0202_CCCM_MDF
  , int downsFilterIdx
#endif
#if JVET_AF0073_INTER_CCP_MERGE
  , bool isTemplate
#endif
)
{
#if JVET_AF0073_INTER_CCP_MERGE
  if(!isTemplate)
  {
#endif
#if JVET_AA0057_CCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  if ( pu.cccmFlag )
  {
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
    if( pu.cccmNoSubFlag )
    {
      xCccmCreateLumaNoSubRef( pu, chromaArea );
      return;
    }
#endif
    xCccmCreateLumaRef(pu, chromaArea
#if JVET_AD0202_CCCM_MDF
      , downsFilterIdx
#endif
    );
#if JVET_AE0100_BVGCCCM
    if (pu.bvgCccmFlag)
    {
      CHECK(downsFilterIdx > 0, "downsFilterIdx in bvgCccm must be zero!");
      xBvgCccmCreateLumaRef(pu, chromaArea
#if JVET_AD0202_CCCM_MDF
      , downsFilterIdx
#endif
                            );
    }
#endif
    return;
  }
#endif

#if JVET_AB0092_GLM_WITH_LUMA
  if (pu.glmIdc.getIdc(chromaArea.compID, 0) > NUM_GLM_PATTERN)
  {
    xGlmCreateGradRef(pu, chromaArea);
    return;
  }
#endif

#if JVET_AC0119_LM_CHROMA_FUSION
  if (pu.isChromaFusion > 1)
  {
    xCflmCreateLumaRef(pu, chromaArea);
    return;
  }
#endif
#if JVET_AF0073_INTER_CCP_MERGE
  }
#if JVET_AB0092_GLM_WITH_LUMA
  else
  {
    if (pu.glmIdc.getIdc(chromaArea.compID, 0) > NUM_GLM_PATTERN)
    {
      xGlmCreateGradRef(pu, chromaArea, true);
      return;
    }
  }
#endif
#endif

#if JVET_AA0126_GLM
  ComponentID compID = chromaArea.compID;
  int glmIdc = pu.glmIdc.getIdc(compID, 0);
  int c[6] = { 0 };
  CHECK(glmIdc < 0 || glmIdc >= NUM_GLM_IDC, "glmIdc out of range");

  if (glmIdc != 0)
  {
    int glmIdx = glmIdc - 1;
    int p = glmIdx >= NUM_GLM_PATTERN ? glmIdx - NUM_GLM_PATTERN : glmIdx;
    CHECK(p < 0 || p >= NUM_GLM_PATTERN, "glmPattern out of range");
    c[0] = g_glmPattern[p][0], c[1] = g_glmPattern[p][1], c[2] = g_glmPattern[p][2];
    c[3] = g_glmPattern[p][3], c[4] = g_glmPattern[p][4], c[5] = g_glmPattern[p][5];
  }
#endif

  int iDstStride = 0;
  Pel* pDst0 = 0;
  int curChromaMode = pu.intraDir[1];
#if JVET_AA0126_GLM
  if (pu.glmIdc.isActive())
  {
    iDstStride = 2 * MAX_CU_SIZE + 1;
    Pel* glmTemp = compID == COMPONENT_Cb ? m_glmTempCb[glmIdc] : m_glmTempCr[glmIdc];
    pDst0 = glmTemp + iDstStride + 1;
  }
  else
  {
#endif
#if MMLM
  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX) || (curChromaMode == MMLM_L_IDX) || (curChromaMode == MMLM_T_IDX))
#else
  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX))
#endif
  {
    iDstStride = 2 * MAX_CU_SIZE + 1;
    pDst0 = m_pMdlmTemp + iDstStride + 1;
  }
  else
  {
    iDstStride = MAX_CU_SIZE + 1;
    pDst0 = m_piTemp + iDstStride + 1; //MMLM_SAMPLE_NEIGHBOR_LINES;
  }
#if JVET_AA0126_GLM
  }
#endif
  //assert 420 chroma subsampling
  CompArea lumaArea = CompArea( COMPONENT_Y, pu.chromaFormat, chromaArea.lumaPos(), recalcSize( pu.chromaFormat, CHANNEL_TYPE_CHROMA, CHANNEL_TYPE_LUMA, chromaArea.size() ) );//needed for correct pos/size (4x4 Tus)

  CHECK(lumaArea.width == chromaArea.width && CHROMA_444 != pu.chromaFormat, "");
  CHECK(lumaArea.height == chromaArea.height && CHROMA_444 != pu.chromaFormat && CHROMA_422 != pu.chromaFormat, "");

  const SizeType uiCWidth = chromaArea.width;
  const SizeType uiCHeight = chromaArea.height;

  const CPelBuf Src = pu.cs->picture->getRecoBuf( lumaArea );
  Pel const* pRecSrc0   = Src.bufAt( 0, 0 );
  int iRecStride        = Src.stride;
  int logSubWidthC  = getChannelTypeScaleX(CHANNEL_TYPE_CHROMA, pu.chromaFormat);
  int logSubHeightC = getChannelTypeScaleY(CHANNEL_TYPE_CHROMA, pu.chromaFormat);

  int iRecStride2       = iRecStride << logSubHeightC;

#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  const CodingUnit& lumaCU = isChroma( pu.chType ) ? *pu.cs->getLumaCU( lumaArea.pos(), CH_L ) : *pu.cu;
#else
  const CodingUnit& lumaCU = isChroma( pu.chType ) ? *pu.cs->picture->cs->getCU( lumaArea.pos(), CH_L ) : *pu.cu;
#endif
  const CodingUnit&     cu = *pu.cu;

  const CompArea& area = isChroma( pu.chType ) ? chromaArea : lumaArea;

  const uint32_t uiTuWidth  = area.width;
  const uint32_t uiTuHeight = area.height;

  int iBaseUnitSize = ( 1 << MIN_CU_LOG2 );

  const int  iUnitWidth       = iBaseUnitSize >> getComponentScaleX( area.compID, area.chromaFormat );
  const int  iUnitHeight = iBaseUnitSize >> getComponentScaleY(area.compID, area.chromaFormat);

  const int  iTUWidthInUnits = uiTuWidth / iUnitWidth;
  const int  iTUHeightInUnits = uiTuHeight / iUnitHeight;
  const int  iAboveUnits      = iTUWidthInUnits;
  const int  iLeftUnits       = iTUHeightInUnits;
  const int  chromaUnitWidth = iBaseUnitSize >> getComponentScaleX(COMPONENT_Cb, area.chromaFormat);
  const int  chromaUnitHeight = iBaseUnitSize >> getComponentScaleY(COMPONENT_Cb, area.chromaFormat);
  const int  topTemplateSampNum = 2 * uiCWidth; // for MDLM, the number of template samples is 2W or 2H.
  const int  leftTemplateSampNum = 2 * uiCHeight;
#if JVET_AF0073_INTER_CCP_MERGE
#if JVET_AH0066_JVET_AH0202_CCP_MERGE_LUMACBF0
  CHECK( pu.cu->rootCbf && !pu.cu->firstTU->interCcpMerge && m_topRefLength < topTemplateSampNum, "Wrong CcpMerge condition" );
  CHECK( pu.cu->rootCbf && !pu.cu->firstTU->interCcpMerge && m_leftRefLength < leftTemplateSampNum, "Wrong CcpMerBge condition" );
#else
  CHECK( !pu.cu->firstTU->interCcpMerge && m_topRefLength < topTemplateSampNum, "Wrong CcpMerge condition" );
  CHECK( !pu.cu->firstTU->interCcpMerge && m_leftRefLength < leftTemplateSampNum, "Wrong CcpMerge condition" );
#endif
#else
  CHECK( m_topRefLength < topTemplateSampNum, "Wrong top template length" );
  CHECK( m_leftRefLength < leftTemplateSampNum, "Wrong left template length" );
#endif
  const int  totalAboveUnits = (topTemplateSampNum + (chromaUnitWidth - 1)) / chromaUnitWidth;
  const int  totalLeftUnits = (leftTemplateSampNum + (chromaUnitHeight - 1)) / chromaUnitHeight;
  const int  totalUnits = totalLeftUnits + totalAboveUnits + 1;
  const int  aboveRightUnits = totalAboveUnits - iAboveUnits;
  const int  leftBelowUnits = totalLeftUnits - iLeftUnits;

  int avaiAboveRightUnits = 0;
  int avaiLeftBelowUnits = 0;
  bool  bNeighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(bNeighborFlags, 0, totalUnits);
  bool aboveIsAvailable, leftIsAvailable;

  int availlableUnit = isLeftAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.pos(),
                                       iLeftUnits, iUnitHeight, (bNeighborFlags + iLeftUnits + leftBelowUnits - 1));

  leftIsAvailable = availlableUnit == iTUHeightInUnits;

  availlableUnit = isAboveAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.pos(),
                                    iAboveUnits, iUnitWidth, (bNeighborFlags + iLeftUnits + leftBelowUnits + 1));

  aboveIsAvailable = availlableUnit == iTUWidthInUnits;

  if (leftIsAvailable)   // if left is not available, then the below left is not available
  {
    avaiLeftBelowUnits = isBelowLeftAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.bottomLeftComp(area.compID), leftBelowUnits, iUnitHeight, (bNeighborFlags + leftBelowUnits - 1));
  }

  if (aboveIsAvailable)   // if above is not available, then  the above right is not available.
  {
    avaiAboveRightUnits = isAboveRightAvailable(isChroma(pu.chType) ? cu : lumaCU, toChannelType(area.compID), area.topRightComp(area.compID), aboveRightUnits, iUnitWidth, (bNeighborFlags + iLeftUnits + leftBelowUnits + iAboveUnits + 1));
  }

  Pel*       pDst  = nullptr;
  Pel const* piSrc = nullptr;

  bool isFirstRowOfCtu = (lumaArea.y & ((pu.cs->sps)->getCTUSize() - 1)) == 0;

  if (aboveIsAvailable)
  {
    pDst  = pDst0    - iDstStride;
    int addedAboveRight = 0;
#if MMLM
    if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX) || (curChromaMode == MMLM_L_IDX) || (curChromaMode == MMLM_T_IDX))
#else
    if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX))
#endif
    {
      addedAboveRight = avaiAboveRightUnits*chromaUnitWidth;
    }
    for (int i = 0; i < uiCWidth + addedAboveRight; i++)
    {
      const bool leftPadding = i == 0 && !leftIsAvailable;
      if (pu.chromaFormat == CHROMA_444)
      {
        piSrc = pRecSrc0 - iRecStride;
        pDst[i] = piSrc[i];
      }
      else if (isFirstRowOfCtu)
      {
        piSrc   = pRecSrc0 - iRecStride;
        pDst[i] = (piSrc[2 * i] * 2 + piSrc[2 * i - (leftPadding ? 0 : 1)] + piSrc[2 * i + 1] + 2) >> 2;
      }
      else if (pu.chromaFormat == CHROMA_422)
      {
        piSrc = pRecSrc0 - iRecStride2;

        int s = 2;
        s += piSrc[2 * i] * 2;
        s += piSrc[2 * i - (leftPadding ? 0 : 1)];
        s += piSrc[2 * i + 1];
        pDst[i] = s >> 2;
      }
      else if (pu.cs->sps->getCclmCollocatedChromaFlag())
      {
        piSrc = pRecSrc0 - iRecStride2;

        int s = 4;
        s += piSrc[2 * i - iRecStride];
        s += piSrc[2 * i] * 4;
        s += piSrc[2 * i - (leftPadding ? 0 : 1)];
        s += piSrc[2 * i + 1];
        s += piSrc[2 * i + iRecStride];
        pDst[i] = s >> 3;
      }
      else
      {
        piSrc = pRecSrc0 - iRecStride2;
        int s = 4;
        s += piSrc[2 * i] * 2;
        s += piSrc[2 * i + 1];
        s += piSrc[2 * i - (leftPadding ? 0 : 1)];
        s += piSrc[2 * i + iRecStride] * 2;
        s += piSrc[2 * i + 1 + iRecStride];
        s += piSrc[2 * i + iRecStride - (leftPadding ? 0 : 1)];
        pDst[i] = s >> 3;
      }
#if JVET_AA0126_GLM
      if (glmIdc != 0)
      {
        piSrc = pRecSrc0 - iRecStride2;
        int l = leftPadding ? 0 : 1;
        int s[6] = { piSrc[2 * i              - l], piSrc[2 * i                 ], piSrc[2 * i              + 1],
                     piSrc[2 * i + iRecStride - l], piSrc[2 * i + iRecStride    ], piSrc[2 * i + iRecStride + 1] };
        pDst[i] = xGlmGetLumaVal(s, c, glmIdc - 1, pDst[i]);
      }
#endif
    }
  }

  if (leftIsAvailable)
  {
    pDst  = pDst0    - 1;
    piSrc = pRecSrc0 - 1 - logSubWidthC;

    int addedLeftBelow = 0;
#if MMLM
    if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX) || (curChromaMode == MMLM_L_IDX) || (curChromaMode == MMLM_T_IDX))
#else
    if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX))
#endif
    {
      addedLeftBelow = avaiLeftBelowUnits*chromaUnitHeight;
    }

    for (int j = 0; j < uiCHeight + addedLeftBelow; j++)
    {
      if (pu.chromaFormat == CHROMA_444)
      {
        pDst[0] = piSrc[0];
      }
      else if (pu.chromaFormat == CHROMA_422)
      {
        int s = 2;
        s += piSrc[0] * 2;
        s += piSrc[-1];
        s += piSrc[1];
        pDst[0] = s >> 2;
      }
      else if (pu.cs->sps->getCclmCollocatedChromaFlag())
      {
        const bool abovePadding = j == 0 && !aboveIsAvailable;

        int s = 4;
        s += piSrc[-(abovePadding ? 0 : iRecStride)];
        s += piSrc[0] * 4;
        s += piSrc[-1];
        s += piSrc[1];
        s += piSrc[iRecStride];
        pDst[0] = s >> 3;
      }
      else
      {
        int s = 4;
        s += piSrc[0] * 2;
        s += piSrc[1];
        s += piSrc[-1];
        s += piSrc[iRecStride] * 2;
        s += piSrc[iRecStride + 1];
        s += piSrc[iRecStride - 1];
        pDst[0] = s >> 3;
      }
#if JVET_AA0126_GLM
      if (glmIdc != 0)
      {
        int s[6] = { piSrc[           - 1], piSrc[             0], piSrc[             1],
                     piSrc[iRecStride - 1], piSrc[iRecStride    ], piSrc[iRecStride + 1] };
        pDst[0] = xGlmGetLumaVal(s, c, glmIdc - 1, pDst[0]);
      }
#endif

      piSrc += iRecStride2;
      pDst  += iDstStride;
    }
  }

#if JVET_AF0073_INTER_CCP_MERGE
  if (!isTemplate)
  {
#endif
  // inner part from reconstructed picture buffer
  for( int j = 0; j < uiCHeight; j++ )
  {
    for( int i = 0; i < uiCWidth; i++ )
    {
      if (pu.chromaFormat == CHROMA_444)
      {
        pDst0[i] = pRecSrc0[i];
      }
      else if (pu.chromaFormat == CHROMA_422)
      {
        const bool leftPadding  = i == 0 && !leftIsAvailable;

        int s = 2;
        s += pRecSrc0[2 * i] * 2;
        s += pRecSrc0[2 * i - (leftPadding ? 0 : 1)];
        s += pRecSrc0[2 * i + 1];
        pDst0[i] = s >> 2;
      }
      else if (pu.cs->sps->getCclmCollocatedChromaFlag())
      {
        const bool leftPadding  = i == 0 && !leftIsAvailable;
        const bool abovePadding = j == 0 && !aboveIsAvailable;

        int s = 4;
        s += pRecSrc0[2 * i - (abovePadding ? 0 : iRecStride)];
        s += pRecSrc0[2 * i] * 4;
        s += pRecSrc0[2 * i - (leftPadding ? 0 : 1)];
        s += pRecSrc0[2 * i + 1];
        s += pRecSrc0[2 * i + iRecStride];
        pDst0[i] = s >> 3;
      }
      else
      {
        CHECK(pu.chromaFormat != CHROMA_420, "Chroma format must be 4:2:0 for vertical filtering");
        const bool leftPadding = i == 0 && !leftIsAvailable;

        int s = 4;
        s += pRecSrc0[2 * i] * 2;
        s += pRecSrc0[2 * i + 1];
        s += pRecSrc0[2 * i - (leftPadding ? 0 : 1)];
        s += pRecSrc0[2 * i + iRecStride] * 2;
        s += pRecSrc0[2 * i + 1 + iRecStride];
        s += pRecSrc0[2 * i + iRecStride - (leftPadding ? 0 : 1)];
        pDst0[i] = s >> 3;
      }
#if JVET_AA0126_GLM
      if (glmIdc != 0)
      {
        const bool leftPadding = i == 0 && !leftIsAvailable;
        int l = leftPadding ? 0 : 1;
        int s[6] = { pRecSrc0[2 * i              - l], pRecSrc0[2 * i                 ], pRecSrc0[2 * i              + 1],
                     pRecSrc0[2 * i + iRecStride - l], pRecSrc0[2 * i + iRecStride    ], pRecSrc0[2 * i + iRecStride + 1] };
        pDst0[i] = xGlmGetLumaVal(s, c, glmIdc - 1, pDst0[i]);
      }
#endif
    }

    pDst0    += iDstStride;
    pRecSrc0 += iRecStride2;
  }
#if JVET_AF0073_INTER_CCP_MERGE
  }
#endif
}

#if !LMS_LINEAR_MODEL
void IntraPrediction::xGetLMParameters(const PredictionUnit &pu, const ComponentID compID, const CompArea &chromaArea, CclmModel &cclmModel)
{
  CHECK(compID == COMPONENT_Y, "");

  const SizeType cWidth  = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  const Position posLT = chromaArea;

  CodingStructure & cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const SPS &        sps           = *cs.sps;
  const uint32_t     tuWidth     = chromaArea.width;
  const uint32_t     tuHeight    = chromaArea.height;
  const ChromaFormat nChromaFormat = sps.getChromaFormatIdc();

  const int baseUnitSize = 1 << MIN_CU_LOG2;
  const int unitWidth    = baseUnitSize >> getComponentScaleX(chromaArea.compID, nChromaFormat);
  const int unitHeight   = baseUnitSize >> getComponentScaleY(chromaArea.compID, nChromaFormat);

  const int tuWidthInUnits  = tuWidth / unitWidth;
  const int tuHeightInUnits = tuHeight / unitHeight;
  const int aboveUnits      = tuWidthInUnits;
  const int leftUnits       = tuHeightInUnits;
  int topTemplateSampNum = 2 * cWidth; // for MDLM, the template sample number is 2W or 2H;
  int leftTemplateSampNum = 2 * cHeight;

  CHECK( m_topRefLength < topTemplateSampNum, "Wrong top template length" );
  CHECK( m_leftRefLength < leftTemplateSampNum, "Wrong left template length" );

  int totalAboveUnits = (topTemplateSampNum + (unitWidth - 1)) / unitWidth;
  int totalLeftUnits = (leftTemplateSampNum + (unitHeight - 1)) / unitHeight;
  int totalUnits = totalLeftUnits + totalAboveUnits + 1;
  int aboveRightUnits = totalAboveUnits - aboveUnits;
  int leftBelowUnits = totalLeftUnits - leftUnits;
  int avaiAboveRightUnits = 0;
  int avaiLeftBelowUnits = 0;
  int avaiAboveUnits = 0;
  int avaiLeftUnits = 0;

  int curChromaMode = pu.intraDir[1];
  bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(neighborFlags, 0, totalUnits);

  bool aboveAvailable, leftAvailable;

  int availableUnit =
    isAboveAvailable(cu, CHANNEL_TYPE_CHROMA, posLT, aboveUnits, unitWidth,
    (neighborFlags + leftUnits + leftBelowUnits + 1));
  aboveAvailable = availableUnit == tuWidthInUnits;

  availableUnit =
    isLeftAvailable(cu, CHANNEL_TYPE_CHROMA, posLT, leftUnits, unitHeight,
    (neighborFlags + leftUnits + leftBelowUnits - 1));
  leftAvailable = availableUnit == tuHeightInUnits;
  if (leftAvailable) // if left is not available, then the below left is not available
  {
    avaiLeftUnits = tuHeightInUnits;
    avaiLeftBelowUnits = isBelowLeftAvailable(cu, CHANNEL_TYPE_CHROMA, chromaArea.bottomLeftComp(chromaArea.compID), leftBelowUnits, unitHeight, (neighborFlags + leftBelowUnits - 1));
  }
  if (aboveAvailable) // if above is not available, then  the above right is not available.
  {
    avaiAboveUnits = tuWidthInUnits;
    avaiAboveRightUnits = isAboveRightAvailable(cu, CHANNEL_TYPE_CHROMA, chromaArea.topRightComp(chromaArea.compID), aboveRightUnits, unitWidth, (neighborFlags + leftUnits + leftBelowUnits + aboveUnits + 1));
  }
  Pel *srcColor0, *curChroma0;
  int srcStride;

  PelBuf temp;
#if MMLM
  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX) || (curChromaMode == MMLM_L_IDX) || (curChromaMode == MMLM_T_IDX)
    || (m_encPreRDRun && curChromaMode == MMLM_CHROMA_IDX))
#else
  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX))
#endif
  {
    srcStride = 2 * MAX_CU_SIZE + 1;
    temp = PelBuf(m_pMdlmTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
  else
  {
    srcStride = MAX_CU_SIZE + 1;
    temp        = PelBuf(m_piTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
  srcColor0 = temp.bufAt(0, 0);
  curChroma0 = getPredictorPtr(compID);

  unsigned internalBitDepth = sps.getBitDepth(CHANNEL_TYPE_CHROMA);

  int minLuma[2] = {  MAX_INT, 0 };
  int maxLuma[2] = { -MAX_INT, 0 };
#if MMLM
  int minLuma2[2][2] = { { MAX_INT, 0 },{ MAX_INT, 0 } };
  int maxLuma2[2][2] = { { -MAX_INT, 0 },{ -MAX_INT, 0 } };
  int minDim = 1;
#endif
  Pel *src = srcColor0 - srcStride;
  int actualTopTemplateSampNum = 0;
  int actualLeftTemplateSampNum = 0;
#if MMLM
  if (curChromaMode == MDLM_T_IDX || curChromaMode == MMLM_T_IDX)
#else
  if (curChromaMode == MDLM_T_IDX)
#endif
  {
    leftAvailable = 0;
    avaiAboveRightUnits = avaiAboveRightUnits > (cHeight/unitWidth) ?  cHeight/unitWidth : avaiAboveRightUnits;
    actualTopTemplateSampNum = unitWidth*(avaiAboveUnits + avaiAboveRightUnits);
#if MMLM
    minDim = actualTopTemplateSampNum;
#endif
  }
#if MMLM
  else if (curChromaMode == MDLM_L_IDX || curChromaMode == MMLM_L_IDX)
#else
  else if (curChromaMode == MDLM_L_IDX)
#endif
  {
    aboveAvailable = 0;
    avaiLeftBelowUnits = avaiLeftBelowUnits > (cWidth/unitHeight) ? cWidth/unitHeight : avaiLeftBelowUnits;
    actualLeftTemplateSampNum = unitHeight*(avaiLeftUnits + avaiLeftBelowUnits);
#if MMLM
    minDim = actualLeftTemplateSampNum;
#endif
  }
#if MMLM
  else if (curChromaMode == LM_CHROMA_IDX || curChromaMode == MMLM_CHROMA_IDX)
#else
  else if (curChromaMode == LM_CHROMA_IDX)
#endif
  {
    actualTopTemplateSampNum = cWidth;
    actualLeftTemplateSampNum = cHeight;
#if MMLM
    minDim = leftAvailable && aboveAvailable ? 1 << g_aucPrevLog2[std::min(actualLeftTemplateSampNum, actualTopTemplateSampNum)]
      : 1 << g_aucPrevLog2[leftAvailable ? actualLeftTemplateSampNum : actualTopTemplateSampNum];
#endif
  }
#if MMLM
  int numSteps = minDim;
  int yAvg = 0;
  int avgCnt = 0;
#endif
  int startPos[2]; //0:Above, 1: Left
  int pickStep[2];

  int aboveIs4 = leftAvailable  ? 0 : 1;
  int leftIs4 =  aboveAvailable ? 0 : 1;

  startPos[0] = actualTopTemplateSampNum >> (2 + aboveIs4);
  pickStep[0] = std::max(1, actualTopTemplateSampNum >> (1 + aboveIs4));

  startPos[1] = actualLeftTemplateSampNum >> (2 + leftIs4);
  pickStep[1] = std::max(1, actualLeftTemplateSampNum >> (1 + leftIs4));

  Pel selectLumaPix[4] = { 0, 0, 0, 0 };
  Pel selectChromaPix[4] = { 0, 0, 0, 0 };

  int cntT, cntL;
  cntT = cntL = 0;
  int cnt = 0;
  if (aboveAvailable)
  {
    cntT = std::min(actualTopTemplateSampNum, (1 + aboveIs4) << 1);
    src = srcColor0 - srcStride;
    const Pel *cur = curChroma0 + 1;
    for (int pos = startPos[0]; cnt < cntT; pos += pickStep[0], cnt++)
    {
      selectLumaPix[cnt] = src[pos];
      selectChromaPix[cnt] = cur[pos];
    }
#if MMLM
    for (int j = 0; j < numSteps; j++)
    {
      int idx = (j * actualTopTemplateSampNum) / minDim;

      if (minLuma2[0][0] > src[idx])
      {
        minLuma2[0][0] = src[idx];
        minLuma2[0][1] = cur[idx];
      }
      if (maxLuma2[1][0] < src[idx])
      {
        maxLuma2[1][0] = src[idx];
        maxLuma2[1][1] = cur[idx];
      }

      yAvg += src[idx];
      avgCnt++;
    }
#endif
  }

  if (leftAvailable)
  {
    cntL = std::min(actualLeftTemplateSampNum, ( 1 + leftIs4 ) << 1 );
    src = srcColor0 - 1;
    const Pel *cur = curChroma0 + m_refBufferStride[compID] + 1;
    for (int pos = startPos[1], cnt = 0; cnt < cntL; pos += pickStep[1], cnt++)
    {
      selectLumaPix[cnt + cntT] = src[pos * srcStride];
      selectChromaPix[cnt + cntT] = cur[pos];
    }
#if MMLM
    for (int i = 0; i < numSteps; i++)
    {
      int idx = (i * actualLeftTemplateSampNum) / minDim;


      if (minLuma2[0][0] > src[srcStride * idx])
      {
        minLuma2[0][0] = src[srcStride * idx];
        minLuma2[0][1] = cur[idx];
      }
      if (maxLuma2[1][0] < src[srcStride * idx])
      {
        maxLuma2[1][0] = src[srcStride * idx];
        maxLuma2[1][1] = cur[idx];
      }

      yAvg += src[srcStride * idx];
      avgCnt++;
    }
#endif
  }
  cnt = cntL + cntT;

  if (cnt == 2)
  {
    selectLumaPix[3] = selectLumaPix[0]; selectChromaPix[3] = selectChromaPix[0];
    selectLumaPix[2] = selectLumaPix[1]; selectChromaPix[2] = selectChromaPix[1];
    selectLumaPix[0] = selectLumaPix[1]; selectChromaPix[0] = selectChromaPix[1];
    selectLumaPix[1] = selectLumaPix[3]; selectChromaPix[1] = selectChromaPix[3];
  }

  int minGrpIdx[2] = { 0, 2 };
  int maxGrpIdx[2] = { 1, 3 };
  int *tmpMinGrp = minGrpIdx;
  int *tmpMaxGrp = maxGrpIdx;
  if (selectLumaPix[tmpMinGrp[0]] > selectLumaPix[tmpMinGrp[1]])
  {
    std::swap(tmpMinGrp[0], tmpMinGrp[1]);
  }
  if (selectLumaPix[tmpMaxGrp[0]] > selectLumaPix[tmpMaxGrp[1]])
  {
    std::swap(tmpMaxGrp[0], tmpMaxGrp[1]);
  }
  if (selectLumaPix[tmpMinGrp[0]] > selectLumaPix[tmpMaxGrp[1]])
  {
    std::swap(tmpMinGrp, tmpMaxGrp);
  }
  if (selectLumaPix[tmpMinGrp[1]] > selectLumaPix[tmpMaxGrp[0]])
  {
    std::swap(tmpMinGrp[1], tmpMaxGrp[0]);
  }

  minLuma[0] = (selectLumaPix[tmpMinGrp[0]] + selectLumaPix[tmpMinGrp[1]] + 1 )>>1;
  minLuma[1] = (selectChromaPix[tmpMinGrp[0]] + selectChromaPix[tmpMinGrp[1]] + 1) >> 1;
  maxLuma[0] = (selectLumaPix[tmpMaxGrp[0]] + selectLumaPix[tmpMaxGrp[1]] + 1 )>>1;
  maxLuma[1] = (selectChromaPix[tmpMaxGrp[0]] + selectChromaPix[tmpMaxGrp[1]] + 1) >> 1;
#if MMLM
  if (avgCnt)
  {
    int x = floorLog2(avgCnt);
    // 4bit significands - 8 ( MSB is omitted )
    const uint8_t divSigTable[1 << 4] = { 0,  7,  6,  5,  5,  4,  4,  3,  3,  2,  2,  1,  1,  1,  1,  0 };
    int normDiff = (avgCnt << 4 >> x) & 15;
    int v = divSigTable[normDiff] | 8;
    x += normDiff != 0;
    yAvg = (yAvg * v) >> (x + 3);
  }
  int cntMMLM[2] = { 0,0 };

  //minLuma2[0][0] = minLuma[0]; minLuma2[0][1] = minLuma[1];
  //maxLuma2[1][0] = maxLuma[0]; maxLuma2[1][1] = maxLuma[1];
  src = srcColor0 - srcStride;

  const Pel *curMMLM = curChroma0 + 1;
  if (aboveAvailable)
  {
    for (int j = 0; j < numSteps; j++)
    {
      int idx = (j * actualTopTemplateSampNum) / minDim;
      if (src[idx] >= yAvg)
      {
        if (minLuma2[1][0] > src[idx])
        {
          minLuma2[1][0] = src[idx];
          minLuma2[1][1] = curMMLM[idx];
        }
        cntMMLM[1]++;
      }
      else
      {
        if (maxLuma2[0][0] < src[idx])
        {
          maxLuma2[0][0] = src[idx];
          maxLuma2[0][1] = curMMLM[idx];
        }
        cntMMLM[0]++;
      }
    }
  }

  if (leftAvailable)
  {
    src = srcColor0 - 1;
    //curMMLM = curChroma0 - 1; // should check here -1 or not
    const Pel *curMMLM = curChroma0 + m_refBufferStride[compID] + 1;
    for (int i = 0; i < numSteps; i++)
    {
      int idx = (i * actualLeftTemplateSampNum) / minDim;

      if (src[srcStride * idx] >= yAvg)
      {
        if (minLuma2[1][0] > src[srcStride * idx])
        {
          minLuma2[1][0] = src[srcStride * idx];
          minLuma2[1][1] = curMMLM[idx];
        }
        cntMMLM[1]++;
      }
      else
      {
        if (maxLuma2[0][0] < src[srcStride * idx])
        {
          maxLuma2[0][0] = src[srcStride * idx];
          maxLuma2[0][1] = curMMLM[idx];
        }
        cntMMLM[0]++;
      }
    }
  }

  if (PU::isMultiModeLM(curChromaMode))
  {
    CHECK(cntMMLM[0] && minLuma2[0][0] > maxLuma2[0][0], "Invalid class");
    CHECK(cntMMLM[1] && minLuma2[1][0] > maxLuma2[1][0], "Invalid class");
    CHECK(cntMMLM[0] && cntMMLM[1] && maxLuma2[0][0] > minLuma2[1][0], "Invalid boundary");

    for (int i = 0; i < 2; i++)
    {
      int ax = 0, bx = 0, iShiftx = 0;
      if (cntMMLM[i])
      {
        int diff = maxLuma2[i][0] - minLuma2[i][0];
        if (diff > 0)
        {
          int diffC = maxLuma2[i][1] - minLuma2[i][1];
          int x = floorLog2(diff);
          // 4bit significands - 8 ( MSB is omitted )
          const uint8_t divSigTable[1 << 4] = { 0,  7,  6,  5,  5,  4,  4,  3,  3,  2,  2,  1,  1,  1,  1,  0 };
          int normDiff = (diff << 4 >> x) & 15;
          int v = divSigTable[normDiff] | 8;
          x += normDiff != 0;

          int y = floorLog2(abs(diffC)) + 1;
          int add = 1 << y >> 1;
          ax = (diffC * v + add) >> y;
          iShiftx = 3 + x - y;
          if (iShiftx < 1)
          {
            iShiftx = 1;
            ax = ((ax == 0) ? 0 : (ax < 0) ? -15 : 15);   // a=Sign(a)*15
          }
          bx = minLuma2[i][1] - ((ax * minLuma2[i][0]) >> iShiftx);
        }
        else
        {
          ax = 0;
          bx = minLuma2[i][1];
          iShiftx = 0;
        }
      }
      else
      {
        ax = 0; bx = 1 << (internalBitDepth - 1); iShiftx = 0;
      }
      if (i == 0)
      {
        cclmModel.setFirstModel ( ax, bx, iShiftx );
      }
      else
      {
        cclmModel.setSecondModel( ax, bx, iShiftx, yAvg );
      }
    }

#if JVET_Z0050_CCLM_SLOPE
    cclmModel.midLuma  = cntMMLM[0] ? ( maxLuma2[0][0] + minLuma2[0][0] ) >> 1 : 0;
    cclmModel.midLuma2 = cntMMLM[1] ? ( maxLuma2[1][0] + minLuma2[1][0] ) >> 1 : 0;
#endif
  }
  else
  {
#endif // Non MMLM mode
  if (leftAvailable || aboveAvailable)
  {
    int diff = maxLuma[0] - minLuma[0];
#if JVET_Z0050_CCLM_SLOPE
    cclmModel.midLuma = ( maxLuma[0] + minLuma[0] ) >> 1;
#endif

    if (diff > 0)
    {
      int diffC = maxLuma[1] - minLuma[1];
      int x = floorLog2( diff );
      // 4bit significands - 8 ( MSB is omitted )
      const uint8_t divSigTable[1 << 4] = { 0,  7,  6,  5,  5,  4,  4,  3,  3,  2,  2,  1,  1,  1,  1,  0 };
      int normDiff = (diff << 4 >> x) & 15;
      int v = divSigTable[normDiff] | 8;
      x += normDiff != 0;

      int y = floorLog2( abs( diffC ) ) + 1;
      int add = 1 << y >> 1;
      int a = (diffC * v + add) >> y;
      int b = 0;
      int iShift = 3 + x - y;

      if ( iShift < 1 )
      {
        iShift = 1;
        a = ( (a == 0)? 0: (a < 0)? -15 : 15 );   // a=Sign(a)*15
      }
      b = minLuma[1] - ((a * minLuma[0]) >> iShift);

      cclmModel.setFirstModel ( a, b, iShift );
    }
    else
    {
      cclmModel.setFirstModel ( 0, minLuma[1], 0 );
    }
  }
  else
  {
    cclmModel.setFirstModel ( 0, 1 << (internalBitDepth - 1), 0 );
  }
#if MMLM
  }
#endif
}
#endif

void IntraPrediction::initIntraMip( const PredictionUnit &pu, const CompArea &area )
{
  CHECK( area.width > MIP_MAX_WIDTH || area.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );

  // prepare input (boundary) data for prediction
  CHECK( m_ipaParam.refFilterFlag, "ERROR: unfiltered refs expected for MIP" );
  Pel       *ptrSrc     = getPredictorPtr(area.compID);
  const int  srcStride  = m_refBufferStride[area.compID];
  const int  srcHStride = 2;

  m_matrixIntraPred.prepareInputForPred(CPelBuf(ptrSrc, srcStride, srcHStride), area,
                                        pu.cu->slice->getSPS()->getBitDepth(toChannelType(area.compID)), area.compID);
}

#if JVET_AB0067_MIP_DIMD_LFNST
void IntraPrediction::predIntraMip(const ComponentID compId, PelBuf& piPred, const PredictionUnit& pu, bool useDimd)
#else
void IntraPrediction::predIntraMip( const ComponentID compId, PelBuf &piPred, const PredictionUnit &pu )
#endif
{
  CHECK( piPred.width > MIP_MAX_WIDTH || piPred.height > MIP_MAX_HEIGHT, "Error: block size not supported for MIP" );
  CHECK( piPred.width != (1 << floorLog2(piPred.width)) || piPred.height != (1 << floorLog2(piPred.height)), "Error: expecting blocks of size 2^M x 2^N" );
#if JVET_AK0118_BF_FOR_INTRA_PRED
  CodingStructure &cs = *pu.cu->cs;
  int blkQp = pu.cu->qp;
  int blkWidth = piPred.width;
  int blkHeight = piPred.height;
  bool applyBf = checkBfApplication(blkQp, blkWidth, blkHeight) ? true : false;
  applyBf &= cs.sps->getUseIntraPredBf() && cs.slice->isIntra();
#endif
  // generate mode-specific prediction
  uint32_t modeIdx       = MAX_NUM_MIP_MODE;
  bool     transposeFlag = false;
  if (compId == COMPONENT_Y)
  {
    modeIdx       = pu.intraDir[CHANNEL_TYPE_LUMA];
    transposeFlag = pu.mipTransposedFlag;
#if JVET_AI0208_PDP_MIP
    const uint32_t width = pu.lwidth();
    const uint32_t height = pu.lheight();
    const int sizeKey = (width << 8) + height;
    const int sizeIdx =  g_size.find( sizeKey ) != g_size.end() ? g_size[sizeKey] : -1;
    const ClpRng& clpRng(pu.cu->cs->slice->clpRng(compId));

    if (m_refAvailable && !pu.cu->ispMode
      && pu.cu->cs->sps->getUsePDP()
      && (pu.cu->plIdx == 0) && (pu.cu->sgpm == 0) && (pu.cu->dimd == 0) && (pu.cu->timd == 0) && (pu.cu->tmrlFlag == 0) && (pu.multiRefIdx == 0)
      )
    {

      if (( pu.mipTransposedFlag ? g_pdpFiltersMip[modeIdx+16][sizeIdx] : g_pdpFiltersMip[modeIdx][sizeIdx])
          && m_xPredIntraOpt(piPred, pu, modeIdx, clpRng, m_ref, m_refShort))
      {
#if JVET_AB0067_MIP_DIMD_LFNST
        if (useDimd)
        {
#if JVET_AI0050_INTER_MTSS
          int secondDimdIntraDir = 0;
#endif
          int iMode = deriveIpmForTransform(piPred, *pu.cu
#if JVET_AI0050_INTER_MTSS
              , secondDimdIntraDir
#endif
              );
#if JVET_AI0050_INTER_MTSS
          pu.cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
          pu.cu->mipDimdMode = iMode;
        }
#endif
        return;
      }
    }
#endif
  }
  else
  {
    const PredictionUnit &coLocatedLumaPU = PU::getCoLocatedLumaPU(pu);

    CHECK(pu.intraDir[CHANNEL_TYPE_CHROMA] != DM_CHROMA_IDX, "Error: MIP is only supported for chroma with DM_CHROMA.");
    CHECK(!coLocatedLumaPU.cu->mipFlag, "Error: Co-located luma CU should use MIP.");

    modeIdx       = coLocatedLumaPU.intraDir[CHANNEL_TYPE_LUMA];
    transposeFlag = coLocatedLumaPU.mipTransposedFlag;
  }
  const int bitDepth = pu.cu->slice->getSPS()->getBitDepth(toChannelType(compId));

  CHECK(modeIdx >= getNumModesMip(piPred), "Error: Wrong MIP mode index");

  static_vector<int, MIP_MAX_WIDTH* MIP_MAX_HEIGHT> predMip( piPred.width * piPred.height );
#if JVET_AB0067_MIP_DIMD_LFNST && !JVET_AK0217_INTRA_MTSS
  if (useDimd)
  {
    int sizeId = getMipSizeId(Size(piPred.width, piPred.height));
    int reducedPredSize = (sizeId < 2) ? 4 : 8;
    static_vector<int, MIP_MAX_WIDTH* MIP_MAX_HEIGHT> reducedPred(reducedPredSize * reducedPredSize);
    m_matrixIntraPred.predBlock(predMip.data(), modeIdx, transposeFlag, bitDepth, compId, reducedPred.data());
    int    iLumaStride = MAX_CU_SIZE + 1;
    PelBuf reducedPredTemp = PelBuf(m_pMipTemp + iLumaStride + 1, iLumaStride, Size(reducedPredSize, reducedPredSize));
    Pel* pReducePred = reducedPredTemp.buf;
    int idx = 0;
    for (int y = 0; y < reducedPredSize; y++)
    {
      for (int x = 0; x < reducedPredSize; x++)
      {
        pReducePred[x] = Pel(reducedPred[idx++]);
      }
      pReducePred += reducedPredTemp.stride;
    }
#if JVET_AI0050_INTER_MTSS || JVET_AK0217_INTRA_MTSS
    int secondDimdIntraDir = 0;
#endif
    int iMode = deriveIpmForTransform(reducedPredTemp, *pu.cu
#if JVET_AI0050_INTER_MTSS || JVET_AK0217_INTRA_MTSS
      , secondDimdIntraDir
#endif
    );
#if JVET_AI0050_INTER_MTSS || JVET_AK0217_INTRA_MTSS
    pu.cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
    pu.cu->mipDimdMode = iMode;
  }
  else
  {
    m_matrixIntraPred.predBlock(predMip.data(), modeIdx, transposeFlag, bitDepth, compId);
  }
#else
  m_matrixIntraPred.predBlock(predMip.data(), modeIdx, transposeFlag, bitDepth, compId);
#endif
  Pel *pred = piPred.buf;
  int idx = 0;

  for( int y = 0; y < piPred.height; y++ )
  {
    for( int x = 0; x < piPred.width; x++ )
    {
      pred[x] = Pel(predMip[idx++]);
    }

    pred += piPred.stride;
  }
#if JVET_AK0217_INTRA_MTSS
  if (useDimd)
  {
#if JVET_AI0050_INTER_MTSS || JVET_AK0217_INTRA_MTSS
    int secondDimdIntraDir = 0;
#endif
    int iMode = deriveIpmForTransform(piPred, *pu.cu
#if JVET_AI0050_INTER_MTSS || JVET_AK0217_INTRA_MTSS
      , secondDimdIntraDir
#endif
    );
#if JVET_AI0050_INTER_MTSS || JVET_AK0217_INTRA_MTSS
    pu.cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
    pu.cu->mipDimdMode = iMode;
  }
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
  if( applyBf )
  {
    bilateralFilterPredDiamond5x5Clip(cs, toChannelType(compId), piPred, blkWidth, blkHeight, blkQp, cs.slice->clpRng(compId), true, *pu.cu );
  }
#endif
}

void IntraPrediction::reorderPLT(CodingStructure& cs, Partitioner& partitioner, ComponentID compBegin, uint32_t numComp)
{
  CodingUnit &cu = *cs.getCU(partitioner.chType);

  uint8_t        reusePLTSizetmp = 0;
  uint8_t        pltSizetmp = 0;
  Pel            curPLTtmp[MAX_NUM_COMPONENT][MAXPLTSIZE];
  bool           curPLTpred[MAXPLTPREDSIZE];

  for (int idx = 0; idx < MAXPLTPREDSIZE; idx++)
  {
    curPLTpred[idx] = false;
    cu.reuseflag[compBegin][idx] = false;
  }
  for (int idx = 0; idx < MAXPLTSIZE; idx++)
  {
    curPLTpred[idx] = false;
  }

  for (int predidx = 0; predidx < cs.prevPLT.curPLTSize[compBegin]; predidx++)
  {
    bool match = false;
    int curidx = 0;

    for (curidx = 0; curidx < cu.curPLTSize[compBegin]; curidx++)
    {
      if( curPLTpred[curidx] )
      {
        continue;
      }
      bool matchTmp = true;
      for (int comp = compBegin; comp < (compBegin + numComp); comp++)
      {
        matchTmp = matchTmp && (cu.curPLT[comp][curidx] == cs.prevPLT.curPLT[comp][predidx]);
      }
      if (matchTmp)
      {
        match = true;
        break;
      }
    }

    if (match)
    {
      cu.reuseflag[compBegin][predidx] = true;
      curPLTpred[curidx] = true;
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
      if( cu.isLocalSepTree() )
#else
      if (CS::isDualITree(*cu.cs))
#endif
      {
        cu.reuseflag[COMPONENT_Y][predidx] = true;
        for( int comp = COMPONENT_Y; comp < MAX_NUM_COMPONENT; comp++ )
        {
          curPLTtmp[comp][reusePLTSizetmp] = cs.prevPLT.curPLT[comp][predidx];
        }
      }
      else
      {
        for (int comp = compBegin; comp < (compBegin + numComp); comp++)
        {
          curPLTtmp[comp][reusePLTSizetmp] = cs.prevPLT.curPLT[comp][predidx];
        }
      }
      reusePLTSizetmp++;
      pltSizetmp++;
    }
  }
  cu.reusePLTSize[compBegin] = reusePLTSizetmp;
  for (int curidx = 0; curidx < cu.curPLTSize[compBegin]; curidx++)
  {
    if (!curPLTpred[curidx])
    {
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
      if( cu.isLocalSepTree() )
      {
        for( int comp = compBegin; comp < (compBegin + numComp); comp++ )
        {
          curPLTtmp[comp][pltSizetmp] = cu.curPLT[comp][curidx];
        }
        if( isLuma(partitioner.chType) )
        {
          curPLTtmp[COMPONENT_Cb][pltSizetmp] = 1 << (cs.sps->getBitDepth(CHANNEL_TYPE_CHROMA) - 1);
          curPLTtmp[COMPONENT_Cr][pltSizetmp] = 1 << (cs.sps->getBitDepth(CHANNEL_TYPE_CHROMA) - 1);
        }
        else
        {
          curPLTtmp[COMPONENT_Y][pltSizetmp] = 1 << (cs.sps->getBitDepth(CHANNEL_TYPE_LUMA) - 1);
        }
      }
      else
      {
#endif
        for (int comp = compBegin; comp < (compBegin + numComp); comp++)
        {
          curPLTtmp[comp][pltSizetmp] = cu.curPLT[comp][curidx];
        }
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
      }
#endif
      pltSizetmp++;
    }
  }

  CHECK(pltSizetmp != cu.curPLTSize[compBegin], "Wrong palette size");

  for (int curidx = 0; curidx < cu.curPLTSize[compBegin]; curidx++)
  {
#if !INTRA_RM_SMALL_BLOCK_SIZE_CONSTRAINTS
    if( cu.isLocalSepTree() )
#else
    if (CS::isDualITree(*cu.cs))
#endif
    {
      for( int comp = COMPONENT_Y; comp < MAX_NUM_COMPONENT; comp++ )
      {
        cu.curPLT[comp][curidx] = curPLTtmp[comp][curidx];
      }
    }
    else
    {
    for (int comp = compBegin; comp < (compBegin + numComp); comp++)
    {
      cu.curPLT[comp][curidx] = curPLTtmp[comp][curidx];
    }
    }
  }
}

#if MMLM && LMS_LINEAR_MODEL
#if JVET_AJ0237_INTERNAL_12BIT
int IntraPrediction::xCalcLMParametersGeneralized(int64_t x, int64_t y, int64_t xx, int64_t xy, int count, int bitDepth, int& a, int& b, int& iShift)
#else
int IntraPrediction::xCalcLMParametersGeneralized(int x, int y, int xx, int xy, int count, int bitDepth, int &a, int &b, int &iShift)
#endif
{

  uint32_t uiInternalBitDepth = bitDepth;
  if (count == 0)
  {
    a = 0;
    b = 1 << (uiInternalBitDepth - 1);
    iShift = 0;
    return -1;
  }
  CHECK(count > 512, "");


  int iCountShift = g_aucLog2[count];

#if JVET_AJ0237_INTERNAL_12BIT
  int iTempShift = uiInternalBitDepth + iCountShift - ((uiInternalBitDepth > 10) ? 31 : 15);
#else
  int iTempShift = uiInternalBitDepth + iCountShift - 15;
#endif

  if (iTempShift > 0)
  {
#if JVET_AJ0237_INTERNAL_12BIT
    x = (x + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
    y = (y + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
    xx = (xx + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
    xy = (xy + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
#else
    x = (x + (1 << (iTempShift - 1))) >> iTempShift;
    y = (y + (1 << (iTempShift - 1))) >> iTempShift;
    xx = (xx + (1 << (iTempShift - 1))) >> iTempShift;
    xy = (xy + (1 << (iTempShift - 1))) >> iTempShift;
#endif
    iCountShift -= iTempShift;
  }
  /////// xCalcLMParameters

#if JVET_AJ0237_INTERNAL_12BIT
  int64_t avgX = x >> iCountShift;
  int64_t avgY = y >> iCountShift;

  int64_t RErrX = x & ((1 << iCountShift) - 1);
  int64_t RErrY = y & ((1 << iCountShift) - 1);
#else
  int avgX = x >> iCountShift;
  int avgY = y >> iCountShift;

  int RErrX = x & ((1 << iCountShift) - 1);
  int RErrY = y & ((1 << iCountShift) - 1);
#endif

  int iB = 7;
  iShift = 13 - iB;

  if (iCountShift == 0)
  {
    a = 0;
    b = 1 << (uiInternalBitDepth - 1);
    iShift = 0;
  }
  else
  {
#if JVET_AJ0237_INTERNAL_12BIT
    int64_t a1 = xy - (avgX * avgY << iCountShift) - avgX * RErrY - avgY * RErrX;
    int64_t a2 = xx - (avgX * avgX << iCountShift) - 2 * avgX * RErrX;
#else
    int a1 = xy - (avgX * avgY << iCountShift) - avgX * RErrY - avgY * RErrX;
    int a2 = xx - (avgX * avgX << iCountShift) - 2 * avgX * RErrX;
#endif
    const int iShiftA1 = uiInternalBitDepth - 2;
    const int iShiftA2 = 5;
    const int iAccuracyShift = uiInternalBitDepth + 4;

    int iScaleShiftA2 = 0;
    int iScaleShiftA1 = 0;

#if JVET_AJ0237_INTERNAL_12BIT
    int64_t a1s = a1;
    int64_t a2s = a2;

    iScaleShiftA1 = a1 == 0 ? 0 : floorLog2Uint64(abs(a1)) - iShiftA1;
    iScaleShiftA2 = a2 == 0 ? 0 : floorLog2Uint64(abs(a2)) - iShiftA2;
#else
    int a1s = a1;
    int a2s = a2;

    iScaleShiftA1 = a1 == 0 ? 0 : floorLog2(abs(a1)) - iShiftA1;
    iScaleShiftA2 = a2 == 0 ? 0 : floorLog2(abs(a2)) - iShiftA2;
#endif

    if (iScaleShiftA1 < 0)
    {
      iScaleShiftA1 = 0;
    }

    if (iScaleShiftA2 < 0)
    {
      iScaleShiftA2 = 0;
    }

    int iScaleShiftA = iScaleShiftA2 + iAccuracyShift - iShift - iScaleShiftA1;

    a2s = a2 >> iScaleShiftA2;

    a1s = a1 >> iScaleShiftA1;

    if (a2s >= 32)
    {
      uint32_t a2t = m_auShiftLM[a2s - 32];
#if JVET_AJ0237_INTERNAL_12BIT
      a = int(a1s * a2t);
#else
      a = a1s * a2t;
#endif
    }
    else
    {
      a = 0;
    }

    if (iScaleShiftA < 0)
    {
      a = a << -iScaleShiftA;
    }
    else
    {
      a = a >> iScaleShiftA;
    }
    a = Clip3(-(1 << (15 - iB)), (1 << (15 - iB)) - 1, a);
    a = a << iB;

    int16_t n = 0;
    if (a != 0)
    {
      n = floorLog2(abs(a) + ((a < 0 ? -1 : 1) - 1) / 2) - 5;
    }

    iShift = (iShift + iB) - n;
    a = a >> n;
#if JVET_AJ0237_INTERNAL_12BIT
    b = int(avgY - ((a * avgX) >> iShift));
#else
    b = avgY - ((a * avgX) >> iShift);
#endif
  }
  return 0;
}

int IntraPrediction::xLMSampleClassifiedTraining(int count, int mean, int meanC, int lumaSamples[], int chrmSamples[], int bitDepth, MMLMParameters parameters[])
{

  //Initialize

  for (int i = 0; i < 2; i++)
  {
    parameters[i].a = 0;
    parameters[i].b = 1 << (bitDepth - 1);
    parameters[i].shift = 0;
  }

  if (count < 4)//
  {
    return -1;
  }
  int groupCount[2] = { 0, 0 };

  CHECK(count > 512, "");

  int meanDiff = meanC - mean;
  mean = std::max(1, mean);

  int lumaPower2[2][128];
  int chromaPower2[2][128];
  //int GroupCount[2] = { 0, 0 };
  for (int i = 0; i < count; i++)
  {
    if (lumaSamples[i] <= mean)
    {
      lumaPower2[0][groupCount[0]] = lumaSamples[i];
      chromaPower2[0][groupCount[0]] = chrmSamples[i];
      groupCount[0]++;
    }
    else
    {
      lumaPower2[1][groupCount[1]] = lumaSamples[i];
      chromaPower2[1][groupCount[1]] = chrmSamples[i];
      groupCount[1]++;
    }
  }

  // Take power of two
  for (int group = 0; group < 2; group++)
  {
    int existSampNum = groupCount[group];
    if (existSampNum < 2)
    {
      continue;
    }

    int upperPower2 = 1 << (g_aucLog2[existSampNum - 1] + 1);
    int lowerPower2 = 1 << (g_aucLog2[existSampNum]);

    if (upperPower2 != lowerPower2)
    {
      int numPaddedSamples = std::min(existSampNum, upperPower2 - existSampNum);
      groupCount[group] = upperPower2;
      int step = (int)(existSampNum / numPaddedSamples);
      for (int i = 0; i < numPaddedSamples; i++)
      {
        lumaPower2[group][existSampNum + i] = lumaPower2[group][i * step];
        chromaPower2[group][existSampNum + i] = chromaPower2[group][i * step];

      }
    }
  }

#if JVET_AJ0237_INTERNAL_12BIT
  int64_t x[2], y[2], xy[2], xx[2];
#else
  int x[2], y[2], xy[2], xx[2];
#endif
  for (int group = 0; group < 2; group++)
  {
    x[group] = y[group] = xy[group] = xx[group] = 0;
  }

  for (int group = 0; group < 2; group++)
  {

    for (int i = 0; i < groupCount[group]; i++)
    {
      x[group] += lumaPower2[group][i];
      y[group] += chromaPower2[group][i];
      xx[group] += lumaPower2[group][i] * lumaPower2[group][i];
      xy[group] += lumaPower2[group][i] * chromaPower2[group][i];
    }
  }
  for (int group = 0; group < 2; group++)
  {
    int a, b, iShift;
    if (groupCount[group] > 1)
    {
      xCalcLMParametersGeneralized(x[group], y[group], xx[group], xy[group], groupCount[group], bitDepth, a, b, iShift);

      parameters[group].a = a;
      parameters[group].b = b;
      parameters[group].shift = iShift;
    }
    else
    {
      parameters[group].a = 0;
      parameters[group].b = meanDiff;
      parameters[group].shift = 0;
    }
  }
  return 0;
}
#endif
#if LMS_LINEAR_MODEL
void IntraPrediction::xPadMdlmTemplateSample(Pel*pSrc, Pel*pCur, int cWidth, int cHeight, int existSampNum, int targetSampNum)
{
  int sampNumToBeAdd = targetSampNum - existSampNum;
  Pel*pTempSrc = pSrc + existSampNum;
  Pel*pTempCur = pCur + existSampNum;

  int step = (int)(existSampNum / sampNumToBeAdd);

  for (int i = 0; i < sampNumToBeAdd; i++)
  {
    pTempSrc[i] = pSrc[i * step];
    pTempCur[i] = pCur[i * step];
  }
}
void IntraPrediction::xGetLMParametersLMS(const PredictionUnit &pu, const ComponentID compID, const CompArea& chromaArea, CclmModel &cclmModel)
{
  CHECK(compID == COMPONENT_Y, "");
  const SizeType cWidth = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  const Position posLT = chromaArea;

  CodingStructure & cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const SPS &        sps = *cs.sps;
  const uint32_t     tuWidth = chromaArea.width;
  const uint32_t     tuHeight = chromaArea.height;
  const ChromaFormat nChromaFormat = sps.getChromaFormatIdc();

  const int baseUnitSize = 1 << MIN_CU_LOG2;
  const int unitWidth = baseUnitSize >> getComponentScaleX(chromaArea.compID, nChromaFormat);
  const int unitHeight = baseUnitSize >> getComponentScaleY(chromaArea.compID, nChromaFormat);

  const int tuWidthInUnits = tuWidth / unitWidth;
  const int tuHeightInUnits = tuHeight / unitHeight;
  const int aboveUnits = tuWidthInUnits;
  const int leftUnits = tuHeightInUnits;
  int topTemplateSampNum = 2 * cWidth; // for MDLM, the template sample number is 2W or 2H;
  int leftTemplateSampNum = 2 * cHeight;

  CHECK( m_topRefLength < topTemplateSampNum, "Wrong top template length" );
  CHECK( m_leftRefLength < leftTemplateSampNum, "Wrong left template length" );

  int totalAboveUnits = (topTemplateSampNum + (unitWidth - 1)) / unitWidth;
  int totalLeftUnits = (leftTemplateSampNum + (unitHeight - 1)) / unitHeight;
  int totalUnits = totalLeftUnits + totalAboveUnits + 1;
  int aboveRightUnits = totalAboveUnits - aboveUnits;
  int leftBelowUnits = totalLeftUnits - leftUnits;
  int avaiAboveRightUnits = 0;
  int avaiLeftBelowUnits = 0;
  int avaiAboveUnits = 0;
  int avaiLeftUnits = 0;

  int curChromaMode = pu.intraDir[1];
  bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1];
  memset(neighborFlags, 0, totalUnits);

  bool aboveAvailable, leftAvailable;

  int availableUnit =
    isAboveAvailable(cu, CHANNEL_TYPE_CHROMA, posLT, aboveUnits, unitWidth,
    (neighborFlags + leftUnits + leftBelowUnits + 1));
  aboveAvailable = availableUnit == tuWidthInUnits;

  availableUnit =
    isLeftAvailable(cu, CHANNEL_TYPE_CHROMA, posLT, leftUnits, unitHeight,
    (neighborFlags + leftUnits + leftBelowUnits - 1));
  leftAvailable = availableUnit == tuHeightInUnits;
  if (leftAvailable) // if left is not available, then the below left is not available
  {
    avaiLeftUnits = tuHeightInUnits;
    avaiLeftBelowUnits = isBelowLeftAvailable(cu, CHANNEL_TYPE_CHROMA, chromaArea.bottomLeftComp(chromaArea.compID), leftBelowUnits, unitHeight, (neighborFlags + leftBelowUnits - 1));
  }
  if (aboveAvailable) // if above is not available, then  the above right is not available.
  {
    avaiAboveUnits = tuWidthInUnits;
    avaiAboveRightUnits = isAboveRightAvailable(cu, CHANNEL_TYPE_CHROMA, chromaArea.topRightComp(chromaArea.compID), aboveRightUnits, unitWidth, (neighborFlags + leftUnits + leftBelowUnits + aboveUnits + 1));
  }
  Pel *srcColor0, *curChroma0;
  int srcStride;

  PelBuf temp;
#if JVET_AA0126_GLM
  if (pu.glmIdc.isActive())
  {
    int glmIdc = pu.glmIdc.getIdc(compID, 0);
    Pel* glmTemp = compID == COMPONENT_Cb ? m_glmTempCb[glmIdc] : m_glmTempCr[glmIdc];
    srcStride = 2 * MAX_CU_SIZE + 1;
    temp = PelBuf(glmTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
  else
  {
#endif
#if MMLM
  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX) || (curChromaMode == MMLM_L_IDX) || (curChromaMode == MMLM_T_IDX)
    || (m_encPreRDRun && curChromaMode == MMLM_CHROMA_IDX))
#else
  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX))
#endif
  {
    srcStride = 2 * MAX_CU_SIZE + 1;
    temp = PelBuf(m_pMdlmTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
  else
  {
    srcStride = MAX_CU_SIZE + 1;
    temp = PelBuf(m_piTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
#if JVET_AA0126_GLM
  }
#endif
  srcColor0 = temp.bufAt(0, 0);
  curChroma0 = getPredictorPtr(compID);

#if JVET_AJ0237_INTERNAL_12BIT
  int64_t x = 0, y = 0, xx = 0, xy = 0;
#else
  int x = 0, y = 0, xx = 0, xy = 0;
#endif
  int iCountShift = 0;
  unsigned uiInternalBitDepth = sps.getBitDepth(CHANNEL_TYPE_CHROMA);

  Pel *src = srcColor0 - srcStride;
  int actualTopTemplateSampNum = 0;
  int actualLeftTemplateSampNum = 0;

  //get the temp buffer to store the downsampled luma and chroma
  Pel pTempBufferSrc[2 * MAX_CU_SIZE]; // for MDLM, use tempalte size 2W or 2H,
  Pel pTempBufferCur[2 * MAX_CU_SIZE];
  int minDim = 1;
  int cntT = 0; int cntL = 0;

#if MMLM
  if (curChromaMode == MDLM_T_IDX || curChromaMode == MMLM_T_IDX)
#else
  if (curChromaMode == MDLM_T_IDX)
#endif
  {
    leftAvailable = 0;
#if !LMS_LINEAR_MODEL
    avaiAboveRightUnits = avaiAboveRightUnits > (cHeight / unitWidth) ? cHeight / unitWidth : avaiAboveRightUnits;
#endif
    actualTopTemplateSampNum = unitWidth * (avaiAboveUnits + avaiAboveRightUnits);
    minDim = actualTopTemplateSampNum;
  }
#if MMLM
  else if (curChromaMode == MDLM_L_IDX || curChromaMode == MMLM_L_IDX)
#else
  else if (curChromaMode == MDLM_L_IDX)
#endif
  {
    aboveAvailable = 0;
#if !LMS_LINEAR_MODEL
    avaiLeftBelowUnits = avaiLeftBelowUnits > (cWidth / unitHeight) ? cWidth / unitHeight : avaiLeftBelowUnits;
#endif
    actualLeftTemplateSampNum = unitHeight * (avaiLeftUnits + avaiLeftBelowUnits);
    minDim = actualLeftTemplateSampNum;
  }
#if MMLM
  else if (curChromaMode == LM_CHROMA_IDX || curChromaMode == MMLM_CHROMA_IDX)
#else
  else if (curChromaMode == LM_CHROMA_IDX)
#endif
  {
    actualTopTemplateSampNum = cWidth;
    actualLeftTemplateSampNum = cHeight;
    minDim = leftAvailable && aboveAvailable ? 1 << g_aucPrevLog2[std::min(actualLeftTemplateSampNum, actualTopTemplateSampNum)]
      : 1 << g_aucPrevLog2[leftAvailable ? actualLeftTemplateSampNum : actualTopTemplateSampNum];
  }
  int numSteps = minDim;

#if JVET_Z0050_CCLM_SLOPE
  int sumLuma = 0;
  int numPels = aboveAvailable && leftAvailable ? 2*numSteps : aboveAvailable || leftAvailable ? numSteps : 0;
#endif

  if (aboveAvailable)
  {
    cntT = numSteps;
    src = srcColor0 - srcStride;
    const Pel *cur = curChroma0 + 1;

    for (int j = 0; j < numSteps; j++)
    {
      int idx = (j * actualTopTemplateSampNum) / minDim;

      pTempBufferSrc[j] = src[idx];
      pTempBufferCur[j] = cur[idx];
#if JVET_Z0050_CCLM_SLOPE
      sumLuma          += src[idx];
#endif
    }

  }

  if (leftAvailable)
  {
    cntL = numSteps;
    src = srcColor0 - 1;
    const Pel *cur = curChroma0 + m_refBufferStride[compID] + 1;

    for (int i = 0; i < numSteps; i++)
    {
      int idx = (i * actualLeftTemplateSampNum) / minDim;

      pTempBufferSrc[i + cntT] = src[srcStride * idx];
      pTempBufferCur[i + cntT] = cur[idx];
#if JVET_Z0050_CCLM_SLOPE
      sumLuma                 += src[srcStride * idx];
#endif
    }
  }
  
#if JVET_Z0050_CCLM_SLOPE
#if JVET_AD0184_REMOVAL_OF_DIVISION_OPERATIONS
  cclmModel.midLuma = numPels ? PU::getMeanValue( sumLuma + (numPels >> 1), numPels ) : 1 << (uiInternalBitDepth - 1);
#else
  cclmModel.midLuma = numPels ? ( sumLuma + numPels/2 ) / numPels : 1 << (uiInternalBitDepth - 1);
#endif
#endif

  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX))
  {
    //pad the temple sample to targetSampNum.
    int orgNumSample = (curChromaMode == MDLM_T_IDX) ? (avaiAboveUnits*unitWidth) : (avaiLeftUnits*unitHeight);
    int existSampNum = (curChromaMode == MDLM_T_IDX) ? actualTopTemplateSampNum : actualLeftTemplateSampNum;

    if( !orgNumSample || !existSampNum )
    {
      cclmModel.setFirstModel( 0, 1 << (uiInternalBitDepth - 1), 0 );
      return;
    }

    int targetSampNum = 1 << ( floorLog2( existSampNum - 1 ) + 1 );

    if (targetSampNum != existSampNum)//if existSampNum not a value of power of 2
    {
      xPadMdlmTemplateSample(pTempBufferSrc, pTempBufferCur, cWidth, cHeight, existSampNum, targetSampNum);
    }
    for (int j = 0; j < targetSampNum; j++)
    {
      x += pTempBufferSrc[j];
      y += pTempBufferCur[j];
      xx += pTempBufferSrc[j] * pTempBufferSrc[j];
      xy += pTempBufferSrc[j] * pTempBufferCur[j];
    }
    iCountShift = g_aucLog2[targetSampNum];

  }
  else if (curChromaMode == LM_CHROMA_IDX)
  {
    int       minStep = 1;
    //int       numSteps = minDim;

    if( aboveAvailable )
    {
      iCountShift = g_aucLog2[minDim / minStep];
    }

    if( leftAvailable )
    {
      iCountShift += aboveAvailable ? 1 : g_aucLog2[minDim / minStep];
    }

    for (int i = 0; i < (cntT + cntL); i++)
    {
      x += pTempBufferSrc[i];
      y += pTempBufferCur[i];
      xx += pTempBufferSrc[i] * pTempBufferSrc[i];
      xy += pTempBufferSrc[i] * pTempBufferCur[i];
    }
  }
#if MMLM
  if (PU::isMultiModeLM(pu.intraDir[1]))
  {
    // Classify and training
    MMLMParameters parameters[2];
    int lumaSamples[512];
    int chromaSamples[512];
    int meanC = 0; int mean = 0;
    int avgCnt = cntT + cntL;

    for (int i = 0; i < avgCnt; i++)
    {
      mean += pTempBufferSrc[i];
      meanC += pTempBufferCur[i];
      lumaSamples[i] = pTempBufferSrc[i];
      chromaSamples[i] = pTempBufferCur[i];
    }

    if (avgCnt)
    {
       int x = floorLog2(avgCnt);
       // 4bit significands - 8 ( MSB is omitted )
       const uint8_t divSigTable[1 << 4] = { 0,  7,  6,  5,  5,  4,  4,  3,  3,  2,  2,  1,  1,  1,  1,  0 };
       int normDiff = (avgCnt << 4 >> x) & 15;
       int v = divSigTable[normDiff] | 8;
       x += normDiff != 0;

       mean = (mean * v) >> (x + 3);
       meanC = (meanC * v) >> (x + 3);
    }

    xLMSampleClassifiedTraining(avgCnt, mean, meanC, lumaSamples, chromaSamples, uiInternalBitDepth, parameters);

    cclmModel.setFirstModel ( parameters[0].a, parameters[0].b, parameters[0].shift );
    cclmModel.setSecondModel( parameters[1].a, parameters[1].b, parameters[1].shift, mean );

#if JVET_Z0050_CCLM_SLOPE
    // Middle luma values for the two models
    int sumLuma0 = 0;
    int sumLuma1 = 0;
    int numPels0 = 0;
    int numPels1 = 0;

    for (int i = 0; i < avgCnt; i++)
    {
      if ( lumaSamples[i] <= mean )
      {
        sumLuma0 += lumaSamples[i];
        numPels0 += 1;
      }
      else
      {
        sumLuma1 += lumaSamples[i];
        numPels1 += 1;
      }
    }

#if JVET_AD0184_REMOVAL_OF_DIVISION_OPERATIONS
    cclmModel.midLuma  = numPels0 ? PU::getMeanValue( sumLuma0 + (numPels0 >> 1), numPels0 ) : mean;
    cclmModel.midLuma2 = numPels1 ? PU::getMeanValue( sumLuma1 + (numPels1 >> 1), numPels1 ) : mean;
#else
    cclmModel.midLuma  = numPels0 ? ( sumLuma0 + numPels0/2 ) / numPels0 : mean;
    cclmModel.midLuma2 = numPels1 ? ( sumLuma1 + numPels1/2 ) / numPels1 : mean;
#endif
#endif

    return;
  }
#endif

  if ((curChromaMode == MDLM_L_IDX) || (curChromaMode == MDLM_T_IDX))
  {
    if ((curChromaMode == MDLM_L_IDX) ? (!leftAvailable) : (!aboveAvailable))
    {
      cclmModel.setFirstModel( 0, 1 << (uiInternalBitDepth - 1), 0 );
      return;
    }
  }
  else
  {
    if (!leftAvailable && !aboveAvailable)
    {
      cclmModel.setFirstModel( 0, 1 << (uiInternalBitDepth - 1), 0 );
      return;
    }
  }
#if JVET_AJ0237_INTERNAL_12BIT
  int iTempShift = uiInternalBitDepth + iCountShift - ((uiInternalBitDepth > 10) ? 31 : 15);
#else
  int iTempShift = uiInternalBitDepth + iCountShift - 15;
#endif

  if (iTempShift > 0)
  {
#if JVET_AJ0237_INTERNAL_12BIT
    x = (x + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
    y = (y + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
    xx = (xx + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
    xy = (xy + ((int64_t)1 << (iTempShift - 1))) >> iTempShift;
#else
    x = (x + (1 << (iTempShift - 1))) >> iTempShift;
    y = (y + (1 << (iTempShift - 1))) >> iTempShift;
    xx = (xx + (1 << (iTempShift - 1))) >> iTempShift;
    xy = (xy + (1 << (iTempShift - 1))) >> iTempShift;
#endif
    iCountShift -= iTempShift;
  }

  /////// xCalcLMParameters
#if JVET_AJ0237_INTERNAL_12BIT
  int64_t avgX = x >> iCountShift;
  int64_t avgY = y >> iCountShift;

  int64_t RErrX = x & ((1 << iCountShift) - 1);
  int64_t RErrY = y & ((1 << iCountShift) - 1);
#else
  int avgX = x >> iCountShift;
  int avgY = y >> iCountShift;

  int RErrX = x & ((1 << iCountShift) - 1);
  int RErrY = y & ((1 << iCountShift) - 1);
#endif

  int iB = 7;
  int a      = 0;
  int b      = 0;
  int iShift = 13 - iB;

  if (iCountShift == 0)
  {
    cclmModel.setFirstModel( 0, 1 << (uiInternalBitDepth - 1), 0 );
  }
  else
  {
#if JVET_AJ0237_INTERNAL_12BIT
    int64_t a1 = xy - (avgX * avgY << iCountShift) - avgX * RErrY - avgY * RErrX;
    int64_t a2 = xx - (avgX * avgX << iCountShift) - 2 * avgX * RErrX;
#else
    int a1 = xy - (avgX * avgY << iCountShift) - avgX * RErrY - avgY * RErrX;
    int a2 = xx - (avgX * avgX << iCountShift) - 2 * avgX * RErrX;
#endif
    const int iShiftA1 = uiInternalBitDepth - 2;
    const int iShiftA2 = 5;
    const int iAccuracyShift = uiInternalBitDepth + 4;

    int iScaleShiftA2 = 0;
    int iScaleShiftA1 = 0;
#if JVET_AJ0237_INTERNAL_12BIT
    int64_t a1s = a1;
    int64_t a2s = a2;

    iScaleShiftA1 = a1 == 0 ? 0 : floorLog2Uint64(abs(a1)) - iShiftA1;
    iScaleShiftA2 = a2 == 0 ? 0 : floorLog2Uint64(abs(a2)) - iShiftA2;
#else
    int a1s = a1;
    int a2s = a2;

    iScaleShiftA1 = a1 == 0 ? 0 : floorLog2(abs(a1)) - iShiftA1;
    iScaleShiftA2 = a2 == 0 ? 0 : floorLog2(abs(a2)) - iShiftA2;
#endif
    if (iScaleShiftA1 < 0)
    {
      iScaleShiftA1 = 0;
    }

    if (iScaleShiftA2 < 0)
    {
      iScaleShiftA2 = 0;
    }

    int iScaleShiftA = iScaleShiftA2 + iAccuracyShift - iShift - iScaleShiftA1;

    a2s = a2 >> iScaleShiftA2;

    a1s = a1 >> iScaleShiftA1;

    if (a2s >= 32)
    {
      uint32_t a2t = m_auShiftLM[a2s - 32];
#if JVET_AJ0237_INTERNAL_12BIT
      a = int(a1s * a2t);
#else
      a = a1s * a2t;
#endif
    }
    else
    {
      a = 0;
    }

    if (iScaleShiftA < 0)
    {
      a = a << -iScaleShiftA;
    }
    else
    {
      a = a >> iScaleShiftA;
    }
    a = Clip3(-(1 << (15 - iB)), (1 << (15 - iB)) - 1, a);
    a = a << iB;

    int16_t n = 0;
    if (a != 0)
    {
      n = floorLog2(abs(a) + ((a < 0 ? -1 : 1) - 1) / 2) - 5;
    }

    iShift = (iShift + iB) - n;
    a = a >> n;
#if JVET_AJ0237_INTERNAL_12BIT
    b = int(avgY - ((a * avgX) >> iShift));
#else
    b = avgY - ((a * avgX) >> iShift);
#endif

    cclmModel.setFirstModel( a, b, iShift );
  }
}
#endif

#if JVET_V0130_INTRA_TMP
void insertNode( int diff, int& iXOffset, int& iYOffset, int& pDiff, int& pX, int& pY )
{
  pDiff = diff;
  pX = iXOffset;
  pY = iYOffset;
}

void clipMvIntraConstraint( CodingUnit* pcCU, int regionId, int& iHorMin, int& iHorMax, int& iVerMin, int& iVerMax, unsigned int uiTemplateSize, unsigned int uiBlkWidth, unsigned int uiBlkHeight, int iCurrY, int iCurrX, int offsetLCUY, int offsetLCUX, RefTemplateType tempType )
{
#if JVET_AD0086_ENHANCED_INTRA_TMP
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  const int searchRangeWidth = std::max((uiBlkWidth  == 64 ? TMP_SEARCH_RANGE_MULT_FACTOR - 1 : TMP_SEARCH_RANGE_MULT_FACTOR) * static_cast<int>(uiBlkWidth), TMP_MINSR);
  const int searchRangeHeight = std::max((uiBlkHeight == 64 ? TMP_SEARCH_RANGE_MULT_FACTOR - 1 : TMP_SEARCH_RANGE_MULT_FACTOR) * static_cast<int>(uiBlkHeight), TMP_MINSR);
#else
  int searchRangeWidth  = std::max(TMP_SEARCH_RANGE_MULT_FACTOR * (int) uiBlkWidth, TMP_MINSR);
  int searchRangeHeight = std::max(TMP_SEARCH_RANGE_MULT_FACTOR * (int) uiBlkHeight, TMP_MINSR);
#endif
#else  
  int searchRangeWidth = TMP_SEARCH_RANGE_MULT_FACTOR * uiBlkWidth;
  int searchRangeHeight = TMP_SEARCH_RANGE_MULT_FACTOR * uiBlkHeight;
#endif   
  int iMvShift = 0;
  int iTemplateSize = uiTemplateSize;
  int iBlkWidth = uiBlkWidth;
  int iBlkHeight = uiBlkHeight;
  int iCTUsize = pcCU->cs->sps->getCTUSize();

  iHorMin = iVerMin = 0;
  iHorMax = iVerMax = INT_MAX;

  if (regionId == 0) // Above outside CTU
  {
    iVerMax = (iCurrY - offsetLCUY - iBlkHeight) << iMvShift;
  }
  else if (regionId == 1) // Left outside and top-left within CTU
  {
#if JVET_AD0086_ENHANCED_INTRA_TMP
    iHorMax = (iCurrX - iBlkWidth) << iMvShift;
#if JVET_AE0077_EXT_INTRATMP
    iVerMin = (iCurrY - offsetLCUY - iBlkHeight + 1) << iMvShift;
#else
    iVerMin = (iCurrY - offsetLCUY - iBlkHeight) << iMvShift;
#endif
    iVerMax = (iCurrY) << iMvShift;
#else
    iHorMax = (iCurrX - offsetLCUX - iBlkWidth) << iMvShift;
    iVerMin = (iCurrY - offsetLCUY - iBlkHeight) << iMvShift;
    iVerMax = (iCurrY) << iMvShift;
#endif
  }
  else if (regionId == 2) // Left-bottom outside CTU
  {
    iHorMax = (iCurrX - offsetLCUX - iBlkWidth) << iMvShift;
    iVerMin = (iCurrY + 1) << iMvShift;
    iVerMax = (iCurrY - offsetLCUY + iCTUsize - iBlkHeight) << iMvShift;
  }
  else if (regionId == 3)   // Top within CTU
  {
    iVerMin = (iCurrY - offsetLCUY - iBlkHeight + 1) << iMvShift;
    iVerMax = (iCurrY - iBlkHeight) << iMvShift;
#if JVET_AD0086_ENHANCED_INTRA_TMP
    iHorMin = (iCurrX - iBlkWidth + 1) << iMvShift;
    iHorMax = (iCurrX) << iMvShift;
#else
    iHorMin = (iCurrX - offsetLCUX - iBlkWidth + 1) << iMvShift;
    iHorMax = (iCurrX - iBlkWidth) << iMvShift;
#endif
  }
#if JVET_AE0077_EXT_INTRATMP
  else if (regionId == 4)   // Bottom-Left within CTU
  {
    iHorMin = (iCurrX - offsetLCUX - iBlkWidth + 1) << iMvShift;
    iHorMax = (iCurrX - iBlkWidth) << iMvShift;
    iVerMin = (iCurrY + 1) << iMvShift;
    iVerMax = (iCurrY - offsetLCUY + iCTUsize - iBlkHeight) << iMvShift;
  }
  else if (regionId == 5)   // Top-right within CTU
  {
    iHorMin = (iCurrX + 1) << iMvShift;
    iHorMax = (iCurrX - offsetLCUX + iCTUsize - iBlkWidth) << iMvShift;
    iVerMin = (iCurrY - offsetLCUY - iBlkHeight + 1) << iMvShift;
    iVerMax = (iCurrY - iBlkHeight) << iMvShift;
  }
#endif

  // Clipping by frame boundaries
  iVerMin = std::max(iVerMin, (tempType != LEFT_TEMPLATE) ? iTemplateSize << iMvShift : 0);
  iVerMax = std::min(iVerMax, ((int)pcCU->cs->pps->getPicHeightInLumaSamples() - iBlkHeight) << iMvShift);
  iHorMin = std::max(iHorMin, (tempType != ABOVE_TEMPLATE) ? iTemplateSize << iMvShift : 0);
  iHorMax = std::min(iHorMax, ((int)pcCU->cs->pps->getPicWidthInLumaSamples() - iBlkWidth) << iMvShift);

  // Clipping by search range
#if !JVET_AE0077_EXT_INTRATMP
  if (regionId == 0)
  {
#endif
  iVerMin = std::max(iVerMin, (iCurrY - searchRangeHeight) << iMvShift);
  iVerMax = std::min(iVerMax, (iCurrY + searchRangeHeight) << iMvShift);
#if !JVET_AE0077_EXT_INTRATMP
  }
  if (regionId != 3)
  {
#endif
  iHorMin = std::max(iHorMin, (iCurrX - searchRangeWidth) << iMvShift);
  iHorMax = std::min(iHorMax, (iCurrX + searchRangeWidth) << iMvShift);
#if !JVET_AE0077_EXT_INTRATMP
  }
#endif

  iHorMin = iHorMin - iCurrX;
  iHorMax = iHorMax - iCurrX;
  iVerMax = iVerMax - iCurrY;
  iVerMin = iVerMin - iCurrY;
}

#if JVET_AB0130_ITMP_SAMPLING
void clipMvIntraConstraintRefine(int& iHorMin, int& iHorMax, int& iVerMin, int& iVerMax,int pX, int pY, int refinementRange
#if JVET_AG0136_INTRA_TMP_LIC
                                 , const int tmpSampling
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
                                 , const bool isTransferredLeft, const bool isTransferredTop, const int bestRegionId, const bool isExtLeft, const bool isExtTop, const bool isExceptionAllowed
#endif
                                 )
{
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  if (isTransferredLeft)
  {
    iHorMin = isExceptionAllowed && (bestRegionId == 3 || bestRegionId == 5) && isExtLeft ? pX : std::max(iHorMin, pX);
    iHorMax = isExceptionAllowed && bestRegionId == 3 ? pX + tmpSampling - 1 : std::min(iHorMax, pX + tmpSampling - 1);
  }
  else
  {
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  iHorMin = isExceptionAllowed && (bestRegionId == 3 || bestRegionId == 5) && isExtLeft ? pX - refinementRange : std::max(iHorMin, pX - refinementRange);
#else
  iHorMin = std::max(iHorMin, pX - refinementRange + (
#if JVET_AG0136_INTRA_TMP_LIC
                                                      tmpSampling
#else
                                                      TMP_SAMPLING
#endif
                                                      % 2 ? 0 : 1));
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  iHorMax = isExceptionAllowed && bestRegionId == 3 ? pX + refinementRange - (
#if JVET_AG0136_INTRA_TMP_LIC
                                                                              tmpSampling
#else
                                                                              TMP_SAMPLING
#endif
                                                                              % 2 ? 0 : 1)
                                  : std::min(iHorMax, pX + refinementRange - (
#if JVET_AG0136_INTRA_TMP_LIC
                                                                              tmpSampling
#else
                                                                              TMP_SAMPLING
#endif
                                                                              % 2 ? 0 : 1));
#else
  iHorMax = std::min(iHorMax, pX + refinementRange);
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  }
  if (isTransferredTop)
  {
    iVerMin = isExceptionAllowed && bestRegionId == 4 && isExtTop ? pY : std::max(iVerMin, pY);
    iVerMax = isExceptionAllowed && bestRegionId == 1 ? pY + tmpSampling - 1 : std::min(iVerMax, pY + tmpSampling - 1);
  }
  else
  {
  iVerMin = isExceptionAllowed && bestRegionId == 4 && isExtTop ? pY - refinementRange : std::max(iVerMin, pY - refinementRange);
#else
  iVerMin = std::max(iVerMin, pY - refinementRange + (
#if JVET_AG0136_INTRA_TMP_LIC
                                                      tmpSampling
#else
                                                      TMP_SAMPLING
#endif
                                                      % 2 ? 0 : 1));
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  iVerMax = isExceptionAllowed && bestRegionId == 1 ? pY + refinementRange - (
#if JVET_AG0136_INTRA_TMP_LIC
                                                                              tmpSampling
#else
                                                                              TMP_SAMPLING
#endif
                                                                              % 2 ? 0 : 1)
                                 : std::min(iVerMax, pY + refinementRange - (
#if JVET_AG0136_INTRA_TMP_LIC
                                                                             tmpSampling
#else
                                                                             TMP_SAMPLING
#endif
                                                                             % 2 ? 0 : 1));
#else
  iVerMax = std::min(iVerMax, pY + refinementRange);
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  }
#endif
#else
  iHorMin = std::max(iHorMin, pX - refinementRange);
  iHorMax = std::min(iHorMax, pX + refinementRange);
  iVerMin = std::max(iVerMin, pY - refinementRange);
  iVerMax = std::min(iVerMax, pY + refinementRange);
#endif
}
#endif

TempLibFast::TempLibFast()
{
}

TempLibFast::~TempLibFast()
{
}

#if !JVET_AD0086_ENHANCED_INTRA_TMP
void TempLibFast::initTemplateDiff( unsigned int uiPatchWidth, unsigned int uiPatchHeight, unsigned int uiBlkWidth, unsigned int uiBlkHeight, int bitDepth )
{
  int maxValue = ((1 << bitDepth) >> (INIT_THRESHOULD_SHIFTBITS)) * (uiPatchHeight * uiPatchWidth - uiBlkHeight * uiBlkWidth);
  m_diffMax = maxValue;
  {
    m_pDiff = maxValue;
  }
}
#endif

#if JVET_W0069_TMP_BOUNDARY
void IntraPrediction::getTargetTemplate( CodingUnit* pcCU, unsigned int uiBlkWidth, unsigned int uiBlkHeight, RefTemplateType tempType )
#else
void IntraPrediction::getTargetTemplate( CodingUnit* pcCU, unsigned int uiBlkWidth, unsigned int uiBlkHeight )
#endif
{
  const ComponentID compID = COMPONENT_Y;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  unsigned int uiPatchWidth = uiBlkWidth + TMP_TEMPLATE_SIZE;
  unsigned int uiPatchHeight = uiBlkHeight + TMP_TEMPLATE_SIZE;
  unsigned int uiTarDepth = floorLog2( std::max( uiBlkHeight, uiBlkWidth ) ) - 2;
  Pel** tarPatch = m_pppTarPatch[uiTarDepth];
#endif
  CompArea area = pcCU->blocks[compID];
  Pel* pCurrStart = pcCU->cs->picture->getRecoBuf( area ).buf;
  unsigned int  uiPicStride = pcCU->cs->picture->getRecoBuf( compID ).stride;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  unsigned int uiY, uiX;
#endif

  //fill template
  //up-left & up 
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  Pel* tarTemp;
#endif
#if JVET_W0069_TMP_BOUNDARY
  if( tempType == L_SHAPE_TEMPLATE )
  {
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    m_pppTarPatch = pCurrStart - TMP_TEMPLATE_SIZE * uiPicStride - TMP_TEMPLATE_SIZE;
#else
    Pel* pCurrTemp = pCurrStart - TMP_TEMPLATE_SIZE * uiPicStride - TMP_TEMPLATE_SIZE;
    for( uiY = 0; uiY < TMP_TEMPLATE_SIZE; uiY++ )
    {
      tarTemp = tarPatch[uiY];
      for( uiX = 0; uiX < uiPatchWidth; uiX++ )
      {
        tarTemp[uiX] = pCurrTemp[uiX];
      }
      pCurrTemp += uiPicStride;
    }
    //left
    for( uiY = TMP_TEMPLATE_SIZE; uiY < uiPatchHeight; uiY++ )
    {
      tarTemp = tarPatch[uiY];
      for( uiX = 0; uiX < TMP_TEMPLATE_SIZE; uiX++ )
      {
        tarTemp[uiX] = pCurrTemp[uiX];
      }
      pCurrTemp += uiPicStride;
    }
#endif
#if JVET_W0069_TMP_BOUNDARY
  }
  else if( tempType == ABOVE_TEMPLATE )
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    m_pppTarPatch = pCurrStart - TMP_TEMPLATE_SIZE * uiPicStride;
#else
    Pel* pCurrTemp = pCurrStart - TMP_TEMPLATE_SIZE * uiPicStride;
    for( uiY = 0; uiY < TMP_TEMPLATE_SIZE; uiY++ )
    {
      tarTemp = tarPatch[uiY];
      for( uiX = 0; uiX < uiBlkWidth; uiX++ )
      {
        tarTemp[uiX] = pCurrTemp[uiX];
      }
      pCurrTemp += uiPicStride;
    }
#endif
  }
  else if( tempType == LEFT_TEMPLATE )
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    m_pppTarPatch = pCurrStart - TMP_TEMPLATE_SIZE;
#else
    Pel* pCurrTemp = pCurrStart - TMP_TEMPLATE_SIZE;
    for( uiY = TMP_TEMPLATE_SIZE; uiY < uiPatchHeight; uiY++ )
    {
      tarTemp = tarPatch[uiY];
      for( uiX = 0; uiX < TMP_TEMPLATE_SIZE; uiX++ )
      {
        tarTemp[uiX] = pCurrTemp[uiX];
      }
      pCurrTemp += uiPicStride;
    }
#endif
  }
#endif
}

#if JVET_W0069_TMP_BOUNDARY
void IntraPrediction::candidateSearchIntra( CodingUnit* pcCU, unsigned int uiBlkWidth, unsigned int uiBlkHeight, RefTemplateType tempType
#if JVET_AG0136_INTRA_TMP_LIC || (JVET_AG0146_DIMD_ITMP_IBC || JVET_AG0152_SGPM_ITMP_IBC || JVET_AG0151_INTRA_TMP_MERGE_MODE)
                                           , const bool bJointCalc
#endif
                                           )
#else
void IntraPrediction::candidateSearchIntra( CodingUnit* pcCU, unsigned int uiBlkWidth, unsigned int uiBlkHeight )
#endif
{
  unsigned int uiPatchWidth = uiBlkWidth + TMP_TEMPLATE_SIZE;
  unsigned int uiPatchHeight = uiBlkHeight + TMP_TEMPLATE_SIZE;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  unsigned int uiTarDepth = floorLog2( std::max( uiBlkWidth, uiBlkHeight ) ) - 2;
#endif

#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  Pel* tarPatch = getTargetPatch();
#else
  Pel** tarPatch = getTargetPatch( uiTarDepth );
#endif
  //Initialize the library for saving the best candidates
#if !JVET_AD0086_ENHANCED_INTRA_TMP
  const ComponentID compID = COMPONENT_Y;
  const int channelBitDepth = pcCU->cs->sps->getBitDepth(toChannelType(compID));
  m_tempLibFast.initTemplateDiff( uiPatchWidth, uiPatchHeight, uiBlkWidth, uiBlkHeight, channelBitDepth );
#endif
#if JVET_W0069_TMP_BOUNDARY
  searchCandidateFromOnePicIntra( pcCU, tarPatch, uiPatchWidth, uiPatchHeight, tempType
#if JVET_AG0136_INTRA_TMP_LIC
                                 , bJointCalc ? false : pcCU->tmpLicFlag
#endif
#if JVET_AG0136_INTRA_TMP_LIC || (JVET_AG0146_DIMD_ITMP_IBC || JVET_AG0152_SGPM_ITMP_IBC || JVET_AG0151_INTRA_TMP_MERGE_MODE)
                                 , bJointCalc
#endif
                                 );
#else
  searchCandidateFromOnePicIntra( pcCU, tarPatch, uiPatchWidth, uiPatchHeight, );
#endif
#if !JVET_AD0086_ENHANCED_INTRA_TMP
  //count collected candidate number
  int pDiff = m_tempLibFast.getDiff();
  int maxDiff = m_tempLibFast.getDiffMax();


  if( pDiff < maxDiff )
  {
    m_uiVaildCandiNum = 1;
  }
  else
  {
    m_uiVaildCandiNum = 0;
  }
#if TMP_FAST_ENC
  pcCU->tmpNumCand = m_uiVaildCandiNum;
#endif
#endif   
}

#if JVET_W0069_TMP_BOUNDARY
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
void IntraPrediction::searchCandidateFromOnePicIntra(CodingUnit* pcCU, Pel* tarPatch, unsigned int uiPatchWidth, unsigned int uiPatchHeight, RefTemplateType tempType
#else
void IntraPrediction::searchCandidateFromOnePicIntra( CodingUnit* pcCU, Pel** tarPatch, unsigned int uiPatchWidth, unsigned int uiPatchHeight, RefTemplateType tempType
#endif
#if JVET_AG0136_INTRA_TMP_LIC
                                                     , const bool useMR
#endif
#if JVET_AG0136_INTRA_TMP_LIC || (JVET_AG0146_DIMD_ITMP_IBC || JVET_AG0152_SGPM_ITMP_IBC || JVET_AG0151_INTRA_TMP_MERGE_MODE)
                                                     , const bool bJointCalc
#endif
                                                     )
#else
void IntraPrediction::searchCandidateFromOnePicIntra( CodingUnit* pcCU, Pel** tarPatch, unsigned int uiPatchWidth, unsigned int uiPatchHeight, )
#endif
{
#if JVET_AD0086_ENHANCED_INTRA_TMP
#if JVET_AG0136_INTRA_TMP_LIC
  if (bJointCalc)
  {
    m_mtmpCandListUseMR.clear();
    m_mtmpCostListUseMR.clear();
    m_mtmpCandList.clear();
    m_mtmpCostList.clear();
  }
  else
  {
    if (useMR)
    {
      m_mtmpCandListUseMR.clear();
      m_mtmpCostListUseMR.clear();
    }
    else
    {
      m_mtmpCandList.clear();
      m_mtmpCostList.clear();
    }
  }
#else
  m_mtmpCandList.clear();
  m_mtmpCostList.clear();
#endif
  static_vector<TempLibFast, MTMP_NUM_SPARSE> sparseMtmpCandList[3];
  static_vector<uint64_t, MTMP_NUM_SPARSE>    sparseMtmpCostList[3];
#if JVET_AG0136_INTRA_TMP_LIC
  const int TMP_SAMPLING = pcCU->slice->getSPS()->getItmpLicMode() ? TMP_SAMPLING_LIC_MODE_1 : TMP_SAMPLING_LIC_MODE_0;
  static_vector<TempLibFast, MTMP_NUM_SPARSE> sparseMtmpCandListSupp[3];
  static_vector<uint64_t, MTMP_NUM_SPARSE> sparseMtmpCostListSupp[3];
  int mtmpNumSparse[3];
  int mtmpNumSparseForLic[3] = { pcCU->slice->getSPS()->getItmpLicMode() ? MTMP_NUM_SPARSE : MTMP_NUM_SPARSE_FOR_LIC, pcCU->slice->getSPS()->getItmpLicMode() ? TL_NUM_SPARSE : TL_NUM_SPARSE_FOR_LIC, pcCU->slice->getSPS()->getItmpLicMode() ? TL_NUM_SPARSE : TL_NUM_SPARSE_FOR_LIC };
  if ((!pcCU->cs->pcv->isEncoder || !bJointCalc) && pcCU->tmpFlag && (pcCU->tmpLicFlag || pcCU->ibcLicFlag))
  {
    mtmpNumSparse[0] = mtmpNumSparseForLic[0];
    mtmpNumSparse[1] = mtmpNumSparseForLic[1];
    mtmpNumSparse[2] = mtmpNumSparseForLic[2];
  }
  else
  {
    mtmpNumSparse[0] = MTMP_NUM_SPARSE;
    mtmpNumSparse[1] = TL_NUM_SPARSE;
    mtmpNumSparse[2] = TL_NUM_SPARSE;
  }
#else
  int                                         mtmpNumSparse[3] = { MTMP_NUM_SPARSE, TL_NUM_SPARSE, TL_NUM_SPARSE };
#endif
#endif

  const ComponentID compID      = COMPONENT_Y;
  unsigned int      uiBlkWidth  = uiPatchWidth - TMP_TEMPLATE_SIZE;
  unsigned int      uiBlkHeight = uiPatchHeight - TMP_TEMPLATE_SIZE;

#if !JVET_AD0086_ENHANCED_INTRA_TMP
  int      pX        = m_tempLibFast.getX();
  int      pY        = m_tempLibFast.getY();
  int      pDiff     = m_tempLibFast.getDiff();
#endif
  CompArea area      = pcCU->blocks[compID];
  int      refStride = pcCU->cs->picture->getRecoBuf(compID).stride;

  Pel* ref = pcCU->cs->picture->getRecoBuf( area ).buf;

  setRefPicUsed( ref ); //facilitate the access of each candidate point 
  setStride( refStride );

#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  Mv cTmpMvPred;
  cTmpMvPred.setZero();

  unsigned int uiCUPelY = area.pos().y;
  unsigned int uiCUPelX = area.pos().x;
  int          blkX     = 0;
  int          blkY     = 0;
  int          iCurrY   = uiCUPelY + blkY;
  int          iCurrX   = uiCUPelX + blkX;
#else
  const int iCurrY = area.pos().y;
  const int iCurrX = area.pos().x;
#endif

  Position ctuRsAddr  = CU::getCtuXYAddr(*pcCU);
  int      offsetLCUY = iCurrY - ctuRsAddr.y;
  int      offsetLCUX = iCurrX - ctuRsAddr.x;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  const int offset = TMP_SAMPLING >> 1;
#endif

  int iYOffset, iXOffset;
#if JVET_AD0086_ENHANCED_INTRA_TMP
  int numPixTopLeft = uiPatchWidth * TMP_TEMPLATE_SIZE + TMP_TEMPLATE_SIZE * uiBlkHeight;
  int numPixTop     = uiBlkWidth * TMP_TEMPLATE_SIZE;
  int numPixLeft    = TMP_TEMPLATE_SIZE * uiBlkHeight;
  const int channelBitDepth = pcCU->cs->sps->getBitDepth(toChannelType(compID));
  int       diff[3];
#if JVET_AG0136_INTRA_TMP_LIC
  const int factorInitSupp = (1 << channelBitDepth) >> INIT_THRESHOLD_SHIFTBITS_SUPP;
  const int factorInitBase = !bJointCalc && useMR ? factorInitSupp : (1 << channelBitDepth) >> INIT_THRESHOULD_SHIFTBITS;
  int pDiff[3] = { factorInitBase * numPixTopLeft, factorInitBase * numPixTop, factorInitBase * numPixLeft };
  int pDiffSupp[3] = { factorInitSupp * numPixTopLeft, factorInitSupp * numPixTop, factorInitSupp * numPixLeft };
  int diffSupp[3];
#else
  int       pDiff[3];
  pDiff[0] = ((1 << channelBitDepth) >> (INIT_THRESHOULD_SHIFTBITS)) * numPixTopLeft;
  pDiff[1] = ((1 << channelBitDepth) >> (INIT_THRESHOULD_SHIFTBITS)) * numPixTop;
  pDiff[2] = ((1 << channelBitDepth) >> (INIT_THRESHOULD_SHIFTBITS)) * numPixLeft;
#endif
#else
  int diff;
#endif
  Pel* refCurr;

#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  const int iRefine          = 1;
  const int iRefineRange     = TMP_SAMPLING >> 1;
  const int tmpMrgRefWind    = 5;
  const Mv  bvOffSparseTL    = Mv(iRefineRange, iRefineRange);
  const Mv  bvOffSparseBR    = Mv(iRefineRange, iRefineRange);
  const Mv  bvOffMerge       = Mv(tmpMrgRefWind, tmpMrgRefWind);
  const Mv  bvOffArbvp       = Mv(EBVP_RANGE, EBVP_RANGE);
  Mv        regTL, regBR, bvMrg;
  Mv        iMrgWindTL, iMrgWindBR;
  bool      bRegOverlap = false;
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
#if JVET_AE0077_EXT_INTRATMP
  const int regionNum = 6;
#else
  const int regionNum = 4;
#endif
#else
  const int regionNum = 3;
#endif
#if JVET_AB0130_ITMP_SAMPLING && !JVET_AD0086_ENHANCED_INTRA_TMP
  int mvYMins[regionNum + 1];
  int mvYMaxs[regionNum + 1];
  int mvXMins[regionNum + 1];
  int mvXMaxs[regionNum + 1];
#else
  int mvYMins[regionNum];
  int mvYMaxs[regionNum];
  int mvXMins[regionNum];
  int mvXMaxs[regionNum];
#endif
  int regionId = 0;
#if JVET_AB0130_ITMP_SAMPLING
#if JVET_AE0077_EXT_INTRATMP
  int bestRegionId = regionNum;
#else
  int bestRegionId = 4;
#endif
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
  bool needTopLeft =
    pcCU->cs->pcv->isEncoder
      ? true
      : (pcCU->tmpFusionFlag ? (((pcCU->tmpIdx % TMP_GROUP_IDX) + 1) * TMP_FUSION_NUM) : pcCU->tmpIdx + 1) > (MTMP_NUM - TL_NUM * 2) ? true : false;

#if JVET_AG0136_INTRA_TMP_LIC 
  int log2SizeTop = 0;
  int log2SizeLeft = 0;
  int sizeTopLeft = 0;
  int topTargetMean = 0;
  int leftTargetMean = 0;
  if (useMR || bJointCalc)
  {
    log2SizeTop = floorLog2(TMP_TEMPLATE_SIZE * uiBlkWidth);
    log2SizeLeft = floorLog2(uiBlkHeight * TMP_TEMPLATE_SIZE);
    sizeTopLeft = (uiBlkHeight + uiPatchWidth) * TMP_TEMPLATE_SIZE;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    m_calcTargetMean(tarPatch, m_uiPicStride, uiPatchWidth, uiPatchHeight, tempType, needTopLeft ? 3 : 0, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
#else
    m_calcTargetMean(tarPatch, uiPatchWidth, uiPatchHeight, tempType, needTopLeft ? 3 : 0, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
    m_log2SizeTop  = log2SizeTop ;
    m_log2SizeLeft = log2SizeLeft;
    m_sizeTopLeft  = sizeTopLeft ;
    m_topMeanTar   = topTargetMean  ;
    m_leftMeanTar  = leftTargetMean ;
#endif
  }
#endif
  for (regionId = 0; regionId < regionNum; regionId++)
  {
    clipMvIntraConstraint(pcCU, regionId, mvXMins[regionId], mvXMaxs[regionId], mvYMins[regionId], mvYMaxs[regionId],
                          TMP_TEMPLATE_SIZE, uiBlkWidth, uiBlkHeight, iCurrY, iCurrX, offsetLCUY, offsetLCUX, tempType);
  }

#if JVET_AG0151_INTRA_TMP_MERGE_MODE
  if (!bJointCalc && pcCU->cs->pcv->isEncoder)
  {
    m_bvBasedMergeCandidates.clear();
#if JVET_AH0200_INTRA_TMP_BV_REORDER
    m_sgpmMvBasedMergeCandidates.clear();
#endif
    PU::getItmpMergeCandidate(*pcCU->firstPU, m_bvBasedMergeCandidates
#if JVET_AH0200_INTRA_TMP_BV_REORDER
    , m_sgpmMvBasedMergeCandidates    
#endif
    );
  }
  std::vector<int> bvRegionIdList(m_bvBasedMergeCandidates.size(), regionNum);
#endif
  for (int checkIdx = 0; checkIdx < regionNum; checkIdx++)
  {
    regionId = (checkIdx + 3) % regionNum;   // 3->0->1->2

    int mvYMin = mvYMins[regionId];
    int mvYMax = mvYMaxs[regionId];
    int mvXMin = mvXMins[regionId];
    int mvXMax = mvXMaxs[regionId];
    if (mvYMax < mvYMin || mvXMax < mvXMin)
    {
      continue;
    }
#if JVET_AG0151_INTRA_TMP_MERGE_MODE
    for (int mergeCandIdx = 0; mergeCandIdx < m_bvBasedMergeCandidates.size(); mergeCandIdx++)
    {
      Mv mergeCand = m_bvBasedMergeCandidates[mergeCandIdx];
      if (mergeCand.getHor() >= mvXMin && mergeCand.getHor() <= mvXMax && mergeCand.getVer() >= mvYMin && mergeCand.getVer() <= mvYMax) // merge candidate is inside itmp region
      {
        bvRegionIdList[mergeCandIdx] = regionId;
      }
    }
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    const int numInitMrg = static_cast<int>(m_bvBasedMergeCandidates.size());
    if (uiBlkWidth <= 8 && uiBlkHeight <= 8)
    {
      regTL       = Mv(mvXMins[regionId], mvYMins[regionId]);
      regBR       = Mv(mvXMaxs[regionId], mvYMaxs[regionId]);
      bRegOverlap = false;
      for (int mrgIdx = 0; mrgIdx < numInitMrg; mrgIdx++)
      {
        bvMrg      = m_bvBasedMergeCandidates[mrgIdx];
        iMrgWindTL = bvMrg - bvOffMerge;
        iMrgWindBR = bvMrg + bvOffMerge;

        if ((regTL.hor >= iMrgWindTL.hor) && (regTL.ver >= iMrgWindTL.ver) && (regBR.hor <= iMrgWindBR.hor) && (regBR.ver <= iMrgWindBR.ver))
        {
          bRegOverlap = true;
          break;
        }
      }
      if (bRegOverlap)
      {
        continue;
      }
    }
#endif
#if JVET_AB0130_ITMP_SAMPLING
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    int shiftX = 0;
    for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset -= TMP_SAMPLING)
    {
      shiftX = (mvXMax != mvXMin) ? (shiftX % TMP_SAMPLING) : 0;
      bool isAvailablePairFound{false};
      for (iXOffset = mvXMax - shiftX++; iXOffset >= mvXMin; iXOffset -= TMP_SAMPLING)
      {
        int iXOffsetMetric = iXOffset + offset;
        int iYOffsetMetric = iYOffset + offset;
        bool isTransferredLeft = false;
        bool isTransferredTop = false;
        if (iXOffsetMetric > mvXMax)
        {
          iXOffsetMetric = iXOffset;
          isTransferredLeft = true;
        }
        if (iYOffsetMetric > mvYMax)
        {
          iYOffsetMetric = iYOffset;
          isTransferredTop = true;
        }
#else
    for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset -= TMP_SAMPLING)
    {
      for (iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset -= TMP_SAMPLING)
      {
#endif
#if JVET_AE0077_EXT_INTRATMP
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        if ((regionId == 4 || regionId == 5) && !isAvailablePairFound)
#else
        if (regionId == 4 || regionId == 5)
#endif
        {
          Position bottomRight(iCurrX + iXOffset + uiBlkWidth - 1, iCurrY + iYOffset + uiBlkHeight - 1);
          if (!pcCU->cs->isDecomp(bottomRight, CHANNEL_TYPE_LUMA))
          {
            continue;
          }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          else
          {
            if (bJointCalc || useMR)
            {
              if (!pcCU->cs->isDecomp(Position(iCurrX + iXOffsetMetric + uiBlkWidth - 1, iCurrY + iYOffsetMetric + uiBlkHeight - 1), CHANNEL_TYPE_LUMA))
              {
                iXOffsetMetric = iXOffset;
                iYOffsetMetric = iYOffset;
                isTransferredLeft = true;
                isTransferredTop = true;
              }
              else
              {
                isAvailablePairFound = true;
              }
            }
            else
            {
              isAvailablePairFound = true;
            }
          }
#endif
        }
#endif
#else
    for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset--)
    {
      for (iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset--)
      {
#endif
        refCurr = ref + iYOffset * refStride + iXOffset;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        int licShift = 0;
        if (!isTransferredLeft)
        {
          licShift += offset;
        }
        if (!isTransferredTop)
        {
          licShift += offset * m_uiPicStride;
        }
#endif

#if JVET_AG0136_INTRA_TMP_LIC
        if (bJointCalc)
        {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          m_calcTemplateDiffJointSadMrsad(refCurr, refStride, tarPatch, m_uiPicStride, uiPatchWidth, uiPatchHeight, diff, diffSupp, pDiff, pDiffSupp, tempType, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean, licShift);
#else
          m_calcTemplateDiffJointSadMrsad(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diff, diffSupp, pDiff, pDiffSupp, tempType, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          for (int temIdx = 0; temIdx < (needTopLeft ? 3 : 1); temIdx++)
#else
          for (int temIdx = 0; temIdx < 3; temIdx++)
#endif
          {
            if (diffSupp[temIdx] < pDiffSupp[temIdx])
            {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
              updateCandList(TempLibFast(iXOffsetMetric, iYOffsetMetric, Mv(iXOffsetMetric, iYOffsetMetric) - bvOffSparseTL, Mv(iXOffsetMetric, iYOffsetMetric) + bvOffSparseBR, isTransferredLeft, isTransferredTop, regionId), diffSupp[temIdx], sparseMtmpCandListSupp[temIdx], sparseMtmpCostListSupp[temIdx], mtmpNumSparseForLic[temIdx]);
#else
              updateCandList(TempLibFast(iXOffset, iYOffset, regionId), diffSupp[temIdx], sparseMtmpCandListSupp[temIdx], sparseMtmpCostListSupp[temIdx], mtmpNumSparseForLic[temIdx]);
#endif
              if (sparseMtmpCandListSupp[temIdx].size() == mtmpNumSparseForLic[temIdx])
              {
                pDiffSupp[temIdx] = std::min((int) sparseMtmpCostListSupp[temIdx][mtmpNumSparseForLic[temIdx] - 1], pDiffSupp[temIdx]);
              }
            }
          }
        }
        else
        {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          m_calcTemplateDiff(pcCU->tmpLicFlag ? refCurr + licShift : refCurr, refStride, tarPatch, m_uiPicStride, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType, needTopLeft ? 3 : 0, useMR, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
#else
          m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType, needTopLeft ? 3 : 0, useMR, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
#endif
        }
#else
        m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType, needTopLeft ? 3 : 0);
#endif

#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        for (int temIdx = 0; temIdx < (needTopLeft ? 3 : 1); temIdx++)
#else
        for (int temIdx = 0; temIdx < 3; temIdx++)
#endif
        {
          if (diff[temIdx] < pDiff[temIdx])
          {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
            int curXoffset = (!bJointCalc && (useMR)) ? iXOffsetMetric : iXOffset;
            int curYoffset = (!bJointCalc && (useMR)) ? iYOffsetMetric : iYOffset;
            updateCandList(TempLibFast(curXoffset, curYoffset, Mv(curXoffset, curYoffset) - bvOffSparseTL, Mv(curXoffset, curYoffset) + bvOffSparseBR, !bJointCalc && (useMR) ? isTransferredLeft : false, !bJointCalc && (useMR) ? isTransferredTop : false, regionId), diff[temIdx], sparseMtmpCandList[temIdx], sparseMtmpCostList[temIdx], mtmpNumSparse[temIdx]);
#else
            updateCandList(TempLibFast(iXOffset, iYOffset, regionId), diff[temIdx],
                           sparseMtmpCandList[temIdx], sparseMtmpCostList[temIdx], mtmpNumSparse[temIdx]);
#endif
            if (sparseMtmpCandList[temIdx].size() == mtmpNumSparse[temIdx])
            {
              pDiff[temIdx] = std::min((int) sparseMtmpCostList[temIdx][mtmpNumSparse[temIdx] - 1], pDiff[temIdx]);
            }
          }
        }
      }
    }
  }
#else
  //1. check the near pixels within LCU
  //above pixels in LCU
  int iTemplateSize = TMP_TEMPLATE_SIZE;
  int iBlkWidth = uiBlkWidth;
  int iBlkHeight = uiBlkHeight;

  //check within CTU pixels
  for( regionId = regionNum; regionId < regionNum+1; regionId++ )
  {
    clipMvIntraConstraint(pcCU, regionId, mvXMins[regionId], mvXMaxs[regionId], mvYMins[regionId], mvYMaxs[regionId],
      TMP_TEMPLATE_SIZE, uiBlkWidth, uiBlkHeight, iCurrY, iCurrX, offsetLCUY, offsetLCUX, tempType);

    int mvYMin = mvYMins[regionId];
    int mvYMax = mvYMaxs[regionId];
    int mvXMin = mvXMins[regionId];
    int mvXMax = mvXMaxs[regionId];
    if( mvYMax < mvYMin || mvXMax < mvXMin )
    {
      continue;
    }
#if JVET_AB0130_ITMP_SAMPLING
    for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset -= TMP_SAMPLING)
    {
      for (iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset -= TMP_SAMPLING)
      {
#else
    for( iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset-- )
    {
      for( iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset-- )
      {
#endif
        refCurr = ref + iYOffset * refStride + iXOffset;
#if JVET_W0069_TMP_BOUNDARY
        diff = m_calcTemplateDiff( refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, pDiff, tempType );
#else
        diff = m_calcTemplateDiff( refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, pDiff );
#endif
        if( diff < (pDiff) )
        {
          insertNode( diff, iXOffset, iYOffset, pDiff, pX, pY );
#if JVET_AB0130_ITMP_SAMPLING
          bestRegionId = regionId;
#endif
        }
        if( pDiff == 0 )
        {
          regionId++;
        }
      }
    }
  }

  //2. check the pixels outside CTU
  for( regionId = 0; regionId < regionNum; regionId++ )
  {
    // this function fills in the range the template matching for pixels outside the current CTU
    clipMvIntraConstraint(pcCU, regionId, mvXMins[regionId], mvXMaxs[regionId], mvYMins[regionId], mvYMaxs[regionId],
                          TMP_TEMPLATE_SIZE, uiBlkWidth, uiBlkHeight, iCurrY, iCurrX, offsetLCUY, offsetLCUX, tempType);
  }

  for( regionId = 0; regionId < regionNum; regionId++ )
  {
    int mvYMin = mvYMins[regionId];
    int mvYMax = mvYMaxs[regionId];
    int mvXMin = mvXMins[regionId];
    int mvXMax = mvXMaxs[regionId];
    if( mvYMax < mvYMin || mvXMax < mvXMin )
    {
      continue;
    }
#if JVET_AB0130_ITMP_SAMPLING
    for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset -= TMP_SAMPLING)
    {
      for (iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset -= TMP_SAMPLING)
      {
#else
    for( iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset-- )
    {
      for( iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset-- )
      {
#endif
        refCurr = ref + iYOffset * refStride + iXOffset;
#if JVET_W0069_TMP_BOUNDARY
        diff = m_calcTemplateDiff( refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, pDiff, tempType );
#else
        diff = m_calcTemplateDiff( refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, pDiff );
#endif

        if( diff < (pDiff) )
        {
          insertNode( diff, iXOffset, iYOffset, pDiff, pX, pY );
#if JVET_AB0130_ITMP_SAMPLING
          bestRegionId = regionId;
#endif
        }

        if( pDiff == 0 )
        {
          regionId = regionNum;
        }
      }
    }
  }
#endif 

#if JVET_AG0151_INTRA_TMP_MERGE_MODE
  std::vector<Mv> bvBasedMergeCandidatesITMP;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  bvBasedMergeCandidatesITMP = m_bvBasedMergeCandidates;
  std::vector<Mv> bvBasedMergeCandidatesOut;
  std::vector<Mv> bvBasedMergeCandidatesIn;
  for (int iBv = 0; iBv < bvRegionIdList.size(); iBv++)
  {
    if (bvRegionIdList[iBv] == TMP_MRG_REG_ID)
    {
      bvBasedMergeCandidatesOut.push_back(m_bvBasedMergeCandidates[iBv]);
    }
    else
    {
      bvBasedMergeCandidatesIn.push_back(m_bvBasedMergeCandidates[iBv]);
    }
  }
  bvBasedMergeCandidatesOut.insert(bvBasedMergeCandidatesOut.end(), bvBasedMergeCandidatesIn.begin(), bvBasedMergeCandidatesIn.end());
  bvBasedMergeCandidatesITMP = bvBasedMergeCandidatesOut;
#else
  if (m_bvBasedMergeCandidates.size() > TMP_NUM_MERGE_CANDS)
  {
    std::vector<Mv> bvBasedMergeCandidatesOut;
    std::vector<Mv> bvBasedMergeCandidatesIn;
    for (int iBv = 0; iBv < bvRegionIdList.size(); iBv++)
    {
      if (bvRegionIdList[iBv] == regionNum)
      {
        bvBasedMergeCandidatesOut.push_back(m_bvBasedMergeCandidates[iBv]);
      }
      else
      {
        bvBasedMergeCandidatesIn.push_back(m_bvBasedMergeCandidates[iBv]);
      }
    }

    if (bvBasedMergeCandidatesOut.size() < TMP_NUM_MERGE_CANDS)
    {
      bvBasedMergeCandidatesOut.insert(bvBasedMergeCandidatesOut.end(), bvBasedMergeCandidatesIn.begin(), bvBasedMergeCandidatesIn.end());
      if (bvBasedMergeCandidatesOut.size() > TMP_NUM_MERGE_CANDS)
      {
        bvBasedMergeCandidatesOut.resize(TMP_NUM_MERGE_CANDS);
      }
    }
    else
    {
      bvBasedMergeCandidatesOut.resize(TMP_NUM_MERGE_CANDS);
    }

    bvBasedMergeCandidatesITMP = bvBasedMergeCandidatesOut;
  }
  else
  {
    bvBasedMergeCandidatesITMP = m_bvBasedMergeCandidates;
  }
#endif
#if JVET_AH0055_INTRA_TMP_ARBVP
  const int numNeighborMerge = (int) bvBasedMergeCandidatesITMP.size();
  const int totalNum = numNeighborMerge + NUM_TMP_ARBVP;
  const CodingStructure& cs = *pcCU->cs;
  const PredictionUnit& pu = *cs.getPU(area.pos(), CHANNEL_TYPE_LUMA);
  Position posCand[5] = { pu.Y().center(), pu.Y().topLeft(), pu.Y().topRight(), pu.Y().bottomLeft(), pu.Y().bottomRight() };
  int        offsetX = 0, offsetY = 0, start = 0, end = 0;
  Mv         cMv;

  do
  {
    start = end;
    end   = (int)bvBasedMergeCandidatesITMP.size();
    for (int mergeIndex = start; mergeIndex < end && bvBasedMergeCandidatesITMP.size() < totalNum; mergeIndex++)
    {
      cMv = bvBasedMergeCandidatesITMP[mergeIndex];
      offsetX = cMv.getHor();
      offsetY = cMv.getVer();
      for (int n = 0; n < 5 && bvBasedMergeCandidatesITMP.size() < totalNum; n++)
      {
        const PredictionUnit* puCascaded = pu.cs->getPURestricted(posCand[n].offset(offsetX, offsetY), pu, pu.chType);

        if (!puCascaded || ((puCascaded->cu->predMode != MODE_IBC) && (!puCascaded->cu->tmpFlag)))
        {
          continue;
        }

        Mv arbv = cMv + puCascaded->bv;
        if (PU::validItmpBv(pu, arbv.hor, arbv.ver))
        {
          if (!PU::CheckBvAvailable(bvBasedMergeCandidatesITMP, arbv))
          {
            bvBasedMergeCandidatesITMP.push_back(arbv);

            if (bvBasedMergeCandidatesITMP.size() >= totalNum)
            {
              break;
            }
          }
        }
        if(PU::validItmpBv(pu, puCascaded->bv.hor, puCascaded->bv.ver))
        {
          if (!PU::CheckBvAvailable(bvBasedMergeCandidatesITMP, puCascaded->bv))
          {
            bvBasedMergeCandidatesITMP.push_back(puCascaded->bv);

            if (bvBasedMergeCandidatesITMP.size() >= totalNum)
            {
              break;
            }
          }
        }
        if ((puCascaded->cu->predMode == MODE_IBC && puCascaded->interDir == 3) || (puCascaded->cu->tmpFlag && puCascaded->cu->tmpIdx > 0
#if JVET_AG0136_INTRA_TMP_LIC
            && !puCascaded->cu->tmpLicFlag
#endif
          ))
        {
          Mv bv;
          if(puCascaded->cu->predMode == MODE_IBC)
          {
            bv = puCascaded->mv[REF_PIC_LIST_1];
            bv.changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_INT); 
          }
          else
          {
            bv = Mv(puCascaded->cu->tmpXdisp, puCascaded->cu->tmpYdisp);
          }
          Mv arbv2 = cMv + bv;
          if (PU::validItmpBv(pu, arbv2.hor, arbv2.ver))
          {
            if (!PU::CheckBvAvailable(bvBasedMergeCandidatesITMP, arbv2))
            {
              bvBasedMergeCandidatesITMP.push_back(arbv2);

              if (bvBasedMergeCandidatesITMP.size() >= totalNum)
              {
                break;
              }
            }
          }
          if(PU::validItmpBv(pu, bv.hor, bv.ver))
          {
            if (!PU::CheckBvAvailable(bvBasedMergeCandidatesITMP, bv))
            {
              bvBasedMergeCandidatesITMP.push_back(bv);

              if (bvBasedMergeCandidatesITMP.size() >= totalNum)
              {
                break;
              }
            }
          }
        }
      }
    }
  } while (bvBasedMergeCandidatesITMP.size() > end && bvBasedMergeCandidatesITMP.size() < totalNum);
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  // Add ARBVPs based on sparse candidates
  std::vector<Mv> bvBasedMergeCandidatesITMPSupp;
  bvBasedMergeCandidatesITMPSupp = bvBasedMergeCandidatesITMP;

  PU::getSparseArBvMergeCandidate(pu, bvBasedMergeCandidatesITMP, sparseMtmpCandList[0]);
  if (bJointCalc)
  {
    PU::getSparseArBvMergeCandidate(pu, bvBasedMergeCandidatesITMPSupp, sparseMtmpCandListSupp[0]);
  }

  // Clustering of the Merge and ARBVP candidates based on refinement window
  bool clustMrgReg[3]  = { false, false, false };
  bool clustMrgSupp[3] = { false, false, false };
  Mv   iMergeWindTL, iMergeWindBR;
  Mv   iSparseWindTL, iSparseWindBR;
  Mv   mergeCand, sparseCand;
  bool bOverlap = false;

  for (int iM = 0; iM < bvBasedMergeCandidatesITMP.size(); iM++)
  {
    mergeCand    = bvBasedMergeCandidatesITMP[iM];
    iMergeWindTL = (iM < numNeighborMerge) ? mergeCand - bvOffMerge : mergeCand - bvOffArbvp;
    iMergeWindBR = (iM < numNeighborMerge) ? mergeCand + bvOffMerge : mergeCand + bvOffArbvp;
    regionId     = (iM < numNeighborMerge) ? TMP_MRG_REG_ID : TMP_MRG_REG_ID + 1;
    refCurr      = ref + mergeCand.ver * refStride + mergeCand.hor;

    for (int temIdx = 0; temIdx < (needTopLeft ? 3 : 1); temIdx++)
    {
      m_calcTemplateDiff(refCurr, refStride, tarPatch, m_uiPicStride, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType, needTopLeft ? 3 : 0, useMR, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
      bOverlap = false;
      for (int i = 0; i < sparseMtmpCandList[temIdx].size(); i++)
      {
        sparseCand = Mv(sparseMtmpCandList[temIdx][i].m_pX, sparseMtmpCandList[temIdx][i].m_pY);
        if (mergeCand == sparseCand)
        {
          clustMrgReg[temIdx] = true;
          bOverlap = true;
          break;
        }

        iSparseWindTL = sparseMtmpCandList[temIdx][i].m_windTL;
        iSparseWindBR = sparseMtmpCandList[temIdx][i].m_windBR;
        if (!((iMergeWindBR.hor < iSparseWindTL.hor) || (iMergeWindTL.hor > iSparseWindBR.hor))
          && !((iMergeWindBR.ver < iSparseWindTL.ver) || (iMergeWindTL.ver > iSparseWindBR.ver)))
        {
          iSparseWindTL =
            Mv(std::min(iSparseWindTL.hor, iMergeWindTL.hor), std::min(iSparseWindTL.ver, iMergeWindTL.ver));
          iSparseWindBR =
            Mv(std::max(iSparseWindBR.hor, iMergeWindBR.hor), std::max(iSparseWindBR.ver, iMergeWindBR.ver));

          if (diff[temIdx] < sparseMtmpCostList[temIdx][i])
          {
            sparseMtmpCandList[temIdx].erase(sparseMtmpCandList[temIdx].begin() + i);
            sparseMtmpCostList[temIdx].erase(sparseMtmpCostList[temIdx].begin() + i);
            updateCandList(TempLibFast(mergeCand.hor, mergeCand.ver, iSparseWindTL, iSparseWindBR, false, false, regionId),
              diff[temIdx], sparseMtmpCandList[temIdx], sparseMtmpCostList[temIdx], mtmpNumSparse[temIdx]);
            if (sparseMtmpCandList[temIdx].size() == mtmpNumSparse[temIdx])
            {
              pDiff[temIdx] = std::min(static_cast<int>(sparseMtmpCostList[temIdx][mtmpNumSparse[temIdx] - 1]), pDiff[temIdx]);
            }
          }
          else
          {
            sparseMtmpCandList[temIdx][i].m_windTL = iSparseWindTL;
            sparseMtmpCandList[temIdx][i].m_windBR = iSparseWindBR;
            sparseMtmpCandList[temIdx][i].m_rId    = regionId;
          }
          clustMrgReg[temIdx] = true;
          bOverlap            = true;
          break;
        }
      }
      if (!bOverlap)
      {
        if (diff[temIdx] < pDiff[temIdx])
        {
          updateCandList(TempLibFast(mergeCand.hor, mergeCand.ver, iMergeWindTL, iMergeWindBR, false, false, regionId), diff[temIdx],
            sparseMtmpCandList[temIdx], sparseMtmpCostList[temIdx], mtmpNumSparse[temIdx]);
          if (sparseMtmpCandList[temIdx].size() == mtmpNumSparse[temIdx])
          {
            pDiff[temIdx] = std::min(static_cast<int>(sparseMtmpCostList[temIdx][mtmpNumSparse[temIdx] - 1]), pDiff[temIdx]);
          }
          clustMrgReg[temIdx] = true;
        }
      }
    }
  }

  if (bJointCalc)
  {
    for (int iM = 0; iM < bvBasedMergeCandidatesITMPSupp.size(); iM++)
    {
      mergeCand    = bvBasedMergeCandidatesITMPSupp[iM];
      iMergeWindTL = (iM < numNeighborMerge) ? mergeCand - bvOffMerge : mergeCand - bvOffArbvp;
      iMergeWindBR = (iM < numNeighborMerge) ? mergeCand + bvOffMerge : mergeCand + bvOffArbvp;
      regionId     = (iM < numNeighborMerge) ? TMP_MRG_REG_ID : TMP_MRG_REG_ID + 1;
      refCurr      = ref + mergeCand.ver * refStride + mergeCand.hor;

      for (int temIdx = 0; temIdx < (needTopLeft ? 3 : 1); temIdx++)
      {
        m_calcTemplateDiff(refCurr, refStride, tarPatch, m_uiPicStride, uiPatchWidth, uiPatchHeight, diffSupp, pDiffSupp, tempType, needTopLeft ? 3 : 0, true, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
        bOverlap = false;
        for (int i = 0; i < sparseMtmpCandListSupp[temIdx].size(); i++)
        {
          sparseCand = Mv(sparseMtmpCandListSupp[temIdx][i].m_pX, sparseMtmpCandListSupp[temIdx][i].m_pY);
          if (mergeCand == sparseCand)
          {
            clustMrgSupp[temIdx] = true;
            bOverlap = true;
            break;
          }

          iSparseWindTL = sparseMtmpCandListSupp[temIdx][i].m_windTL;
          iSparseWindBR = sparseMtmpCandListSupp[temIdx][i].m_windBR;
          if (!((iMergeWindBR.hor < iSparseWindTL.hor) || (iMergeWindTL.hor > iSparseWindBR.hor)) && !((iMergeWindBR.ver < iSparseWindTL.ver) || (iMergeWindTL.ver > iSparseWindBR.ver)))
          {
            iSparseWindTL = Mv(std::min(iSparseWindTL.hor, iMergeWindTL.hor), std::min(iSparseWindTL.ver, iMergeWindTL.ver));
            iSparseWindBR = Mv(std::max(iSparseWindBR.hor, iMergeWindBR.hor), std::max(iSparseWindBR.ver, iMergeWindBR.ver));

            if (diffSupp[temIdx] < sparseMtmpCostListSupp[temIdx][i])
            {
              sparseMtmpCandListSupp[temIdx].erase(sparseMtmpCandListSupp[temIdx].begin() + i);
              sparseMtmpCostListSupp[temIdx].erase(sparseMtmpCostListSupp[temIdx].begin() + i);
              updateCandList(TempLibFast(mergeCand.hor, mergeCand.ver, iSparseWindTL, iSparseWindBR, false, false, regionId), diffSupp[temIdx], sparseMtmpCandListSupp[temIdx], sparseMtmpCostListSupp[temIdx], mtmpNumSparseForLic[temIdx]);
              if (sparseMtmpCandListSupp[temIdx].size() == mtmpNumSparseForLic[temIdx])
              {
                pDiffSupp[temIdx] = std::min(static_cast<int>(sparseMtmpCostListSupp[temIdx][mtmpNumSparseForLic[temIdx] - 1]), pDiffSupp[temIdx]);
              }
            }
            else
            {
              sparseMtmpCandListSupp[temIdx][i].m_windTL = iSparseWindTL;
              sparseMtmpCandListSupp[temIdx][i].m_windBR = iSparseWindBR;
              sparseMtmpCandListSupp[temIdx][i].m_rId    = regionId;
            }
            bOverlap             = true;
            clustMrgSupp[temIdx] = true;
            break;
          }
        }
        if (!bOverlap)
        {
          if (diffSupp[temIdx] < pDiffSupp[temIdx])
          {
            updateCandList(TempLibFast(mergeCand.hor, mergeCand.ver, iMergeWindTL, iMergeWindBR, false, false, regionId),
              diffSupp[temIdx], sparseMtmpCandListSupp[temIdx], sparseMtmpCostListSupp[temIdx], mtmpNumSparseForLic[temIdx]);
            if (sparseMtmpCandListSupp[temIdx].size() == mtmpNumSparseForLic[temIdx])
            {
              pDiffSupp[temIdx] = std::min(static_cast<int>(sparseMtmpCostListSupp[temIdx][mtmpNumSparseForLic[temIdx] - 1]), pDiffSupp[temIdx]);
            }
            clustMrgSupp[temIdx] = true;
          }
        }
      }
    }
  }
#else
#if JVET_AG0136_INTRA_TMP_LIC
  bool isBvAddedReg = false;
  bool isBvAddedSupp = false;
#endif
  for (int iM = 0; iM < bvBasedMergeCandidatesITMP.size(); iM++)
  {
#if JVET_AH0055_INTRA_TMP_ARBVP
    regionId = iM < numNeighborMerge ? regionNum: regionNum + 1;
#else
    regionId = regionNum;
#endif 
    iYOffset = bvBasedMergeCandidatesITMP[iM].ver;
    iXOffset = bvBasedMergeCandidatesITMP[iM].hor;
    refCurr = ref + iYOffset * refStride + iXOffset;
#if JVET_AG0136_INTRA_TMP_LIC
    if (bJointCalc)
    {
      m_calcTemplateDiffJointSadMrsad(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diff, diffSupp, pDiff, pDiffSupp, tempType, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
      for (int temIdx = 0; temIdx < 3; temIdx++)
      {
        bool bRedundant = false;
        for (int i = 0; i < sparseMtmpCandListSupp[temIdx].size(); i++)
        {
          if (iYOffset == sparseMtmpCandListSupp[temIdx][i].m_pY && iXOffset == sparseMtmpCandListSupp[temIdx][i].m_pX)
          {
            bRedundant = true;
            break;
          }
        }
        if (bRedundant)
        {
          continue;
        }
        if (diffSupp[temIdx] < pDiffSupp[temIdx])
        {
          updateCandList(TempLibFast(iXOffset, iYOffset, regionId), diffSupp[temIdx], sparseMtmpCandListSupp[temIdx], sparseMtmpCostListSupp[temIdx], mtmpNumSparseForLic[temIdx]);
          if (sparseMtmpCandListSupp[temIdx].size() == mtmpNumSparseForLic[temIdx])
          {
            pDiffSupp[temIdx] = std::min((int)sparseMtmpCostListSupp[temIdx][mtmpNumSparseForLic[temIdx] - 1], pDiffSupp[temIdx]);
          }
          isBvAddedSupp = true;
        }
      }
    }
    else
    {
      m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType, needTopLeft ? 3 : 0, useMR, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
    }
#else
    m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType, needTopLeft ? 3 : 0);
#endif
    for (int temIdx = 0; temIdx < 3; temIdx++)
    {
      // check for redundancy
      bool bRedundant = false;
      for (int i = 0; i < sparseMtmpCandList[temIdx].size(); i++)
      {
        if (iYOffset == sparseMtmpCandList[temIdx][i].m_pY && iXOffset == sparseMtmpCandList[temIdx][i].m_pX)
        {
          bRedundant = true;
          break;
        }
      }
      if (bRedundant)
      {
        continue;
      }
      if (diff[temIdx] < pDiff[temIdx])
      {
        updateCandList(TempLibFast(iXOffset, iYOffset, regionId), diff[temIdx],
          sparseMtmpCandList[temIdx], sparseMtmpCostList[temIdx], mtmpNumSparse[temIdx]);
        if (sparseMtmpCandList[temIdx].size() == mtmpNumSparse[temIdx])
        {
          pDiff[temIdx] = std::min((int)sparseMtmpCostList[temIdx][mtmpNumSparse[temIdx] - 1], pDiff[temIdx]);
        }
#if JVET_AG0136_INTRA_TMP_LIC
        isBvAddedReg = true;
#endif
      }
    }
  }
#endif
#endif

#if JVET_AD0086_ENHANCED_INTRA_TMP
  static_vector<TempLibFast, MTMP_NUM> refineMtmpCandList[3];
  static_vector<uint64_t, MTMP_NUM>    refineMtmpCostList[3];
  int                                  mtmpNumRefine[3] = { MTMP_NUM, TL_NUM, TL_NUM };
  if (!needTopLeft)
  {
    mtmpNumRefine[0] = pcCU->tmpFusionFlag ? (((pcCU->tmpIdx % TMP_GROUP_IDX) + 1) * TMP_FUSION_NUM) : (pcCU->tmpIdx + 1); 
  }
  int pDiffSparse[3];
  for (int i = 0; i < 3; i++)
  {
    pDiffSparse[i] = pDiff[i]+(sparseMtmpCandList[i].size() < mtmpNumSparse[i] ? 0 : 1);
  }
  for (int temIdx = 0; temIdx < 3; temIdx++)
  {
    if ((tempType != L_SHAPE_TEMPLATE || !needTopLeft) && temIdx > 0)
    {
      continue;
    }
    for (int i = 0; i < 3; i++)
    {
      if (temIdx == i)
      {
        pDiff[i] = pDiffSparse[i];
      }
      else
      {
        pDiff[i] = 0;
      }
    }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    bool bRedundant = false;
    Mv refineWindTL, refineWindBR;
    int mvYMin = 0;
    int mvYMax = 0;
    int mvXMin = 0;
    int mvXMax = 0;
#endif
    for (int candIdx = 0; candIdx < sparseMtmpCandList[temIdx].size(); candIdx++)
    {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      refineWindTL = sparseMtmpCandList[temIdx][candIdx].m_windTL;
      refineWindBR = sparseMtmpCandList[temIdx][candIdx].m_windBR;
#else
      int iRefine      = 1;
      int iRefineRange = TMP_SAMPLING >> 1;
#endif
      bestRegionId     = sparseMtmpCandList[temIdx][candIdx].m_rId;

#if JVET_AG0151_INTRA_TMP_MERGE_MODE
#if JVET_AG0136_INTRA_TMP_LIC && !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      const int RefineSizeForLic = pcCU->slice->getSPS()->getItmpLicMode() ? 5 : 2;
#endif
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      int mvYMin = 0;
      int mvYMax = 0;
      int mvXMin = 0;
      int mvXMax = 0;
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      if (bestRegionId > 5)
#else
      if (bestRegionId == 6)
#endif
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        mvYMin = refineWindTL.ver;
        mvYMax = refineWindBR.ver;
        mvXMin = refineWindTL.hor;
        mvXMax = refineWindBR.hor; 
#else
#if JVET_AG0136_INTRA_TMP_LIC
        if ((!pcCU->cs->pcv->isEncoder || !bJointCalc) && pcCU->tmpFlag && (pcCU->tmpLicFlag || pcCU->ibcLicFlag))
        {
          mvYMin = sparseMtmpCandList[temIdx][candIdx].m_pY - RefineSizeForLic;
          mvYMax = sparseMtmpCandList[temIdx][candIdx].m_pY + RefineSizeForLic;
          mvXMin = sparseMtmpCandList[temIdx][candIdx].m_pX - RefineSizeForLic;
          mvXMax = sparseMtmpCandList[temIdx][candIdx].m_pX + RefineSizeForLic;
        }
        else
        {
          mvYMin = sparseMtmpCandList[temIdx][candIdx].m_pY - 5;
          mvYMax = sparseMtmpCandList[temIdx][candIdx].m_pY + 5;
          mvXMin = sparseMtmpCandList[temIdx][candIdx].m_pX - 5;
          mvXMax = sparseMtmpCandList[temIdx][candIdx].m_pX + 5;
        }
#else
        mvYMin = sparseMtmpCandList[temIdx][candIdx].m_pY - 5;
        mvYMax = sparseMtmpCandList[temIdx][candIdx].m_pY + 5;
        mvXMin = sparseMtmpCandList[temIdx][candIdx].m_pX - 5;
        mvXMax = sparseMtmpCandList[temIdx][candIdx].m_pX + 5;
#endif
#endif
      }
#if JVET_AH0055_INTRA_TMP_ARBVP && !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      else if (bestRegionId == 7)
      {
        mvYMin = sparseMtmpCandList[temIdx][candIdx].m_pY - EBVP_RANGE;
        mvYMax = sparseMtmpCandList[temIdx][candIdx].m_pY + EBVP_RANGE;
        mvXMin = sparseMtmpCandList[temIdx][candIdx].m_pX - EBVP_RANGE;
        mvXMax = sparseMtmpCandList[temIdx][candIdx].m_pX + EBVP_RANGE;
      }
#endif 
      else
      {
        mvYMin = mvYMins[bestRegionId];
        mvYMax = mvYMaxs[bestRegionId];
        mvXMin = mvXMins[bestRegionId];
        mvXMax = mvXMaxs[bestRegionId];
        clipMvIntraConstraintRefine(mvXMin, mvXMax, mvYMin, mvYMax, sparseMtmpCandList[temIdx][candIdx].m_pX, sparseMtmpCandList[temIdx][candIdx].m_pY, iRefineRange
#if JVET_AG0136_INTRA_TMP_LIC
                                    , TMP_SAMPLING
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
                                    , sparseMtmpCandList[temIdx][candIdx].m_isTransferredLeft, sparseMtmpCandList[temIdx][candIdx].m_isTransferredTop, bestRegionId, iCurrX + mvXMin >= TMP_TEMPLATE_SIZE + iRefineRange, iCurrY + mvYMin >= TMP_TEMPLATE_SIZE + iRefineRange, !pcCU->slice->getSPS()->getItmpLicMode()
#endif
                                    );
      }
#else
      int mvYMin       = mvYMins[bestRegionId];
      int mvYMax       = mvYMaxs[bestRegionId];
      int mvXMin       = mvXMins[bestRegionId];
      int mvXMax       = mvXMaxs[bestRegionId];
      clipMvIntraConstraintRefine(mvXMin, mvXMax, mvYMin, mvYMax, sparseMtmpCandList[temIdx][candIdx].m_pX, sparseMtmpCandList[temIdx][candIdx].m_pY, iRefineRange
#if JVET_AG0136_INTRA_TMP_LIC
                                  , TMP_SAMPLING
#endif
      );
#endif
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      if (!(mvYMax < mvYMin || mvXMax < mvXMin))
      {
#endif
        for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset -= iRefine)
        {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          bool isAvailablePairFound{false};
#endif
          for (iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset -= iRefine)
          {
#if JVET_AE0077_EXT_INTRATMP
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
            if ((bestRegionId == 4 || bestRegionId == 5 || (!pcCU->slice->getSPS()->getItmpLicMode() && ((bestRegionId == 3 && iXOffset > 0) || (bestRegionId == 1 && iYOffset > 0)))) && !isAvailablePairFound)
#else
            if (bestRegionId == 4 || bestRegionId == 5)
#endif
            {
              Position bottomRight(iCurrX + iXOffset + uiBlkWidth - 1, iCurrY + iYOffset + uiBlkHeight - 1);
              if (!pcCU->cs->isDecomp(bottomRight, CHANNEL_TYPE_LUMA))
              {
                continue;
              }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
              else
              {
                isAvailablePairFound = true;
              }
#endif
            }
#endif
#if JVET_AG0151_INTRA_TMP_MERGE_MODE
#if JVET_AG0136_INTRA_TMP_LIC
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
            if (clustMrgReg[temIdx])
#else
            if (isBvAddedReg)
#endif
            {
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
              bRedundant = false;
#else
              bool bRedundant = false;
#endif
              for (int i = 0; i < refineMtmpCandList[temIdx].size(); i++)
              {
                if (iYOffset == refineMtmpCandList[temIdx][i].m_pY && iXOffset == refineMtmpCandList[temIdx][i].m_pX)
                {
                  bRedundant = true;
                  break;
                }
              }
              if (bRedundant)
              {
                continue;
              }
#if JVET_AG0136_INTRA_TMP_LIC
            }
#endif
#if JVET_AH0055_INTRA_TMP_ARBVP
            if (bestRegionId == regionNum || bestRegionId == (regionNum + 1))
#else 
            if (bestRegionId == regionNum)
#endif
            {
              if (!PU::validItmpBv(*pcCU->firstPU, iXOffset, iYOffset))
              {
                continue;
              }
            }
#endif
            if (iXOffset == sparseMtmpCandList[temIdx][candIdx].m_pX
                && iYOffset == sparseMtmpCandList[temIdx][candIdx].m_pY)
            {
              diff[temIdx] = (int) sparseMtmpCostList[temIdx][candIdx];
            }
            else
            {
              refCurr = ref + iYOffset * refStride + iXOffset;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
              m_calcTemplateDiff(refCurr, refStride, tarPatch, m_uiPicStride, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType, temIdx
#else
              m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diff, pDiff, tempType,
                                 temIdx
#endif
#if JVET_AG0136_INTRA_TMP_LIC
                                 , useMR, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean
#endif
                                 );
            }
            if (diff[temIdx] < pDiff[temIdx])
            {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
              updateCandList(TempLibFast(iXOffset, iYOffset, refineWindTL, refineWindBR, false, false, bestRegionId), diff[temIdx], refineMtmpCandList[temIdx], refineMtmpCostList[temIdx], mtmpNumRefine[temIdx]);
#else
              updateCandList(TempLibFast(iXOffset, iYOffset, bestRegionId), diff[temIdx],
                             refineMtmpCandList[temIdx], refineMtmpCostList[temIdx], mtmpNumRefine[temIdx]);
#endif
              if (refineMtmpCandList[temIdx].size() == mtmpNumRefine[temIdx])
              {
                pDiff[temIdx] = std::min((int) refineMtmpCostList[temIdx][mtmpNumRefine[temIdx] - 1], pDiff[temIdx]);
              }
            }
          }
        }
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      }
#endif
    }
  }

#if JVET_AG0136_INTRA_TMP_LIC
  if (useMR)
  {
    m_mtmpCandListUseMR = refineMtmpCandList[0];
    m_mtmpCostListUseMR = refineMtmpCostList[0];
  }
  else
  {
    m_mtmpCandList = refineMtmpCandList[0];
    m_mtmpCostList = refineMtmpCostList[0];
  }
  static_vector<TempLibFast, MTMP_NUM>& refMtmpCandListTemp = useMR ? m_mtmpCandListUseMR : m_mtmpCandList;
#else
  m_mtmpCandList = refineMtmpCandList[0];
  m_mtmpCostList = refineMtmpCostList[0];
#endif

  if (tempType == L_SHAPE_TEMPLATE && needTopLeft)
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    // If the list size is less than INIT_TL_POS the Only-TL candidates are skip
    if (refMtmpCandListTemp.size() >= INIT_TL_POS)
    {
      int  cnt        = 0;
      bool bRedundant = false;
      int  mvXCur, mvYCur, pos;
#endif
    for (int temIdx = 2; temIdx >0; temIdx--)
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      int cnt = 0;
      for (int candIdx = 0; candIdx < refineMtmpCostList[temIdx].size() && cnt < TL_NUM; candIdx++)
      {
        // check redundancy
        bool bRedundant = false;

        int  mvXCur     = refineMtmpCandList[temIdx][candIdx].m_pX;
        int  mvYCur     = refineMtmpCandList[temIdx][candIdx].m_pY;
#else
      for (int candIdx = 0; candIdx < refineMtmpCandList[temIdx].size(); candIdx++)
      {
        bRedundant = false;
        mvXCur     = refineMtmpCandList[temIdx][candIdx].m_pX;
        mvYCur     = refineMtmpCandList[temIdx][candIdx].m_pY;
#endif
#if JVET_AG0136_INTRA_TMP_LIC
        for (int crIdx = 0; crIdx < refMtmpCandListTemp.size(); crIdx++)
        {
          if (mvXCur == refMtmpCandListTemp[crIdx].m_pX && mvYCur == refMtmpCandListTemp[crIdx].m_pY)
#else
        for (int crIdx = 0; crIdx < m_mtmpCandList.size(); crIdx++)
        {
          if (mvXCur == m_mtmpCandList[crIdx].m_pX && mvYCur == m_mtmpCandList[crIdx].m_pY)
#endif
          {
            bRedundant = true;
#if JVET_AG0136_INTRA_TMP_LIC
            break;
#endif
          }
        }

        if (!bRedundant)
        {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          pos = (MTMP_NUM - static_cast<int>(refineMtmpCandList[1].size()) - static_cast<int>(refineMtmpCandList[2].size())) + cnt++;
#else
          cnt++;
          int pos = MTMP_NUM - 1 - TL_NUM * temIdx + cnt;
#endif
#if JVET_AG0136_INTRA_TMP_LIC
          if (pos < refMtmpCandListTemp.size())
          {
            for (int updatePos = (int)refMtmpCandListTemp.size() - 1; updatePos > pos; updatePos--)
            {
              refMtmpCandListTemp[updatePos] = refMtmpCandListTemp[updatePos - 1];
            }
            refMtmpCandListTemp[pos] = refineMtmpCandList[temIdx][candIdx];
#else
          if (pos < m_mtmpCandList.size())
          {
            for (int updatePos = (int) m_mtmpCandList.size() - 1; updatePos > pos; updatePos--)
            {
              m_mtmpCandList[updatePos] = m_mtmpCandList[updatePos - 1];
            }
            m_mtmpCandList[pos] = refineMtmpCandList[temIdx][candIdx];
#endif
          }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          else
          {
            // TL candidates are appended sequentially if the list size is less than MTMP_NUM
            refMtmpCandListTemp.push_back(refineMtmpCandList[temIdx][candIdx]);
          }
#endif
        }
      }
    }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    }   
#endif
  }
#else
#if JVET_AB0130_ITMP_SAMPLING
  // now perform refinment with horizontal and vertical flips
  if (bestRegionId < 4)
  {
    for (int iRefineLog2 = LOG2_TMP_SAMPLING - 1; iRefineLog2 >= 0; iRefineLog2--)
    {
      int iRefine = 1 << iRefineLog2;
      int tmpRefineRange = std::min(uiBlkHeight, uiBlkHeight) / 2;
      int mvYMin = mvYMins[bestRegionId];
      int mvYMax = mvYMaxs[bestRegionId];
      int mvXMin = mvXMins[bestRegionId];
      int mvXMax = mvXMaxs[bestRegionId];
      clipMvIntraConstraintRefine(mvXMin, mvXMax, mvYMin, mvYMax, pX, pY, iRefine* tmpRefineRange);
      if (!(mvYMax < mvYMin || mvXMax < mvXMin))
      {
        for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset -= iRefine)
        {
          for (iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset -= iRefine)
          {
            refCurr = ref + iYOffset * refStride + iXOffset;
#if JVET_W0069_TMP_BOUNDARY
            diff = m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, pDiff, tempType);
#else
            diff = m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, pDiff);
#endif
            if (diff < (pDiff))
            {
              insertNode(diff, iXOffset, iYOffset, pDiff, pX, pY);
            }
          }
        }
      }
    }
  }
#endif
  m_tempLibFast.m_pX    = pX;
  m_tempLibFast.m_pY    = pY;
  m_tempLibFast.m_pDiff = pDiff;
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
#if JVET_AG0136_INTRA_TMP_LIC
  if (useMR)
  {
    m_tmpNumCandUseMR = static_cast<int>(m_mtmpCandListUseMR.size());
    m_tmpNumCandUseMR = static_cast<int>(refMtmpCandListTemp.size());
  }
  else
  {
    m_tmpNumCand = (int)m_mtmpCandList.size();
  }
  if (useMR)
  {
    for (int i = 0; i < refMtmpCandListTemp.size(); i++)
    {
      m_tmpXdispUseMR[i] = refMtmpCandListTemp[i].m_pX;
      m_tmpYdispUseMR[i] = refMtmpCandListTemp[i].m_pY;
    }
    if (refMtmpCandListTemp.size() != 0)
    {
      for (int i = static_cast<int>(refMtmpCandListTemp.size()); i < MTMP_NUM; i++)
      {
        m_tmpXdispUseMR[i] = m_tmpXdispUseMR[i - refMtmpCandListTemp.size()];
        m_tmpYdispUseMR[i] = m_tmpYdispUseMR[i - refMtmpCandListTemp.size()];
        m_mtmpCostListUseMR.push_back(m_mtmpCostListUseMR[i - refMtmpCandListTemp.size()]);
      }
    }
  }
  else
  {
    for (int i = 0; i < m_tmpNumCand; i++)
    {
      m_tmpXdisp[i] = m_mtmpCandList[i].m_pX;
      m_tmpYdisp[i] = m_mtmpCandList[i].m_pY;
    }
    if (m_tmpNumCand != 0)
    {
      for (int i = m_tmpNumCand; i < MTMP_NUM; i++)
      {
        m_tmpXdisp[i] = m_tmpXdisp[i - m_tmpNumCand];
        m_tmpYdisp[i] = m_tmpYdisp[i - m_tmpNumCand];
        m_mtmpCostList.push_back(m_mtmpCostList[i - m_tmpNumCand]);
      }
#if (JVET_AG0146_DIMD_ITMP_IBC || JVET_AG0152_SGPM_ITMP_IBC || JVET_AG0151_INTRA_TMP_MERGE_MODE)
      pcCU->tmpXdisp = m_tmpXdisp[0];
      pcCU->tmpYdisp = m_tmpYdisp[0];
#endif
    }
  }
#else
  m_tmpNumCand = (int) m_mtmpCandList.size();
  for (int i = 0; i < m_tmpNumCand; i++)
  {
    m_tmpXdisp[i] = m_mtmpCandList[i].m_pX;
    m_tmpYdisp[i] = m_mtmpCandList[i].m_pY;
  }

  if (m_tmpNumCand == 0)
  {
    return;
  }

  for (int i = m_tmpNumCand; i < MTMP_NUM; i++)
  {
    m_tmpXdisp[i] = m_tmpXdisp[i - m_tmpNumCand];
    m_tmpYdisp[i] = m_tmpYdisp[i - m_tmpNumCand];
    m_mtmpCostList.push_back(m_mtmpCostList[i - m_tmpNumCand]);
  }
#if (JVET_AG0146_DIMD_ITMP_IBC || JVET_AG0152_SGPM_ITMP_IBC || JVET_AG0151_INTRA_TMP_MERGE_MODE)
  pcCU->tmpXdisp = m_tmpXdisp[0];
  pcCU->tmpYdisp = m_tmpYdisp[0];
#endif
#endif
#else 
#if TMP_FAST_ENC
  m_tmpXdisp = pX;
  m_tmpYdisp = pY;
#endif
#endif   

#if JVET_AG0136_INTRA_TMP_LIC
  if (bJointCalc)
  {
    for (int i = 0; i < 3; i++)
    {
      refineMtmpCandList[i].clear();
      refineMtmpCostList[i].clear();
    }
    for (int i = 0; i < 3; i++)
    {
      pDiffSparse[i] = pDiffSupp[i] + (sparseMtmpCandListSupp[i].size() < mtmpNumSparseForLic[i] ? 0 : 1);
    }

#if JVET_AG0151_INTRA_TMP_MERGE_MODE && (!JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT)
    const int RefineSizeForLic = pcCU->slice->getSPS()->getItmpLicMode() ? 5 : 2;
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    bool bRedundant = false;
    Mv refineWindTL, refineWindBR;
    int mvYMin = 0;
    int mvYMax = 0;
    int mvXMin = 0;
    int mvXMax = 0;
#endif
    for (int temIdx = 0; temIdx < 3; temIdx++)
    {
      if ((tempType != L_SHAPE_TEMPLATE || !needTopLeft) && temIdx > 0)
      {
        continue;
      }
      for (int i = 0; i < 3; i++)
      {
        if (temIdx == i)
        {
          pDiffSupp[i] = pDiffSparse[i];
        }
        else
        {
          pDiffSupp[i] = 0;
        }
      }
      for (int candIdx = 0; candIdx < sparseMtmpCandListSupp[temIdx].size(); candIdx++)
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        refineWindTL = sparseMtmpCandListSupp[temIdx][candIdx].m_windTL;
        refineWindBR = sparseMtmpCandListSupp[temIdx][candIdx].m_windBR;
#endif
        bestRegionId = sparseMtmpCandListSupp[temIdx][candIdx].m_rId;
#if JVET_AG0151_INTRA_TMP_MERGE_MODE
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        int mvYMin = 0;
        int mvYMax = 0;
        int mvXMin = 0;
        int mvXMax = 0;
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        if (bestRegionId >= TMP_MRG_REG_ID)
        {
          mvYMin = refineWindTL.ver;
          mvYMax = refineWindBR.ver;
          mvXMin = refineWindTL.hor;
          mvXMax = refineWindBR.hor;
        }
#else
        if (bestRegionId == 6)
        {
          mvYMin = sparseMtmpCandListSupp[temIdx][candIdx].m_pY - RefineSizeForLic;
          mvYMax = sparseMtmpCandListSupp[temIdx][candIdx].m_pY + RefineSizeForLic;
          mvXMin = sparseMtmpCandListSupp[temIdx][candIdx].m_pX - RefineSizeForLic;
          mvXMax = sparseMtmpCandListSupp[temIdx][candIdx].m_pX + RefineSizeForLic;
        }
#if JVET_AH0055_INTRA_TMP_ARBVP
        else if (bestRegionId == 7)
        {
          mvYMin = sparseMtmpCandListSupp[temIdx][candIdx].m_pY - EBVP_RANGE;
          mvYMax = sparseMtmpCandListSupp[temIdx][candIdx].m_pY + EBVP_RANGE;
          mvXMin = sparseMtmpCandListSupp[temIdx][candIdx].m_pX - EBVP_RANGE;
          mvXMax = sparseMtmpCandListSupp[temIdx][candIdx].m_pX + EBVP_RANGE;
        }
#endif 
#endif 
        else
        {
          mvYMin = mvYMins[bestRegionId];
          mvYMax = mvYMaxs[bestRegionId];
          mvXMin = mvXMins[bestRegionId];
          mvXMax = mvXMaxs[bestRegionId];
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          clipMvIntraConstraintRefine(mvXMin, mvXMax, mvYMin, mvYMax, sparseMtmpCandListSupp[temIdx][candIdx].m_pX, sparseMtmpCandListSupp[temIdx][candIdx].m_pY, TMP_SAMPLING >> 1, TMP_SAMPLING, sparseMtmpCandListSupp[temIdx][candIdx].m_isTransferredLeft, sparseMtmpCandListSupp[temIdx][candIdx].m_isTransferredTop, bestRegionId, iCurrX + mvXMin >= TMP_TEMPLATE_SIZE + (TMP_SAMPLING >> 1), iCurrY + mvYMin >= TMP_TEMPLATE_SIZE + (TMP_SAMPLING >> 1), !pcCU->slice->getSPS()->getItmpLicMode());
#else
          clipMvIntraConstraintRefine(mvXMin, mvXMax, mvYMin, mvYMax, sparseMtmpCandListSupp[temIdx][candIdx].m_pX, sparseMtmpCandListSupp[temIdx][candIdx].m_pY, TMP_SAMPLING >> 1, TMP_SAMPLING);
#endif
        }
#else
        int mvYMin       = mvYMins[bestRegionId];
        int mvYMax       = mvYMaxs[bestRegionId];
        int mvXMin       = mvXMins[bestRegionId];
        int mvXMax       = mvXMaxs[bestRegionId];
        clipMvIntraConstraintRefine(mvXMin, mvXMax, mvYMin, mvYMax, sparseMtmpCandListSupp[temIdx][candIdx].m_pX, sparseMtmpCandListSupp[temIdx][candIdx].m_pY, TMP_SAMPLING >> 1
#if JVET_AG0136_INTRA_TMP_LIC
                                    , TMP_SAMPLING
#endif
        );
#endif
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT  
        if (!(mvYMax < mvYMin || mvXMax < mvXMin))
        {
#endif
          for (iYOffset = mvYMax; iYOffset >= mvYMin; iYOffset -= 1)
          {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
            bool isAvailablePairFound{false};
#endif
            for (iXOffset = mvXMax; iXOffset >= mvXMin; iXOffset -= 1)
            {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
              if ((bestRegionId == 4 || bestRegionId == 5 || (!pcCU->slice->getSPS()->getItmpLicMode() && ((bestRegionId == 3 && iXOffset > 0) || (bestRegionId == 1 && iYOffset > 0)))) && !isAvailablePairFound)
#else
              if (bestRegionId == 4 || bestRegionId == 5)
#endif
              {
                Position bottomRight(iCurrX + iXOffset + uiBlkWidth - 1, iCurrY + iYOffset + uiBlkHeight - 1);
                if (!pcCU->cs->isDecomp(bottomRight, CHANNEL_TYPE_LUMA))
                {
                  continue;
                }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
                else
                {
                  isAvailablePairFound = true;
                }
#endif
              }
#if JVET_AG0151_INTRA_TMP_MERGE_MODE
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
              if (clustMrgSupp[temIdx])
#else
              if (isBvAddedSupp)
#endif
              {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
                bRedundant = false;
#else
                bool bRedundant = false;
#endif
                for (int i = 0; i < refineMtmpCandList[temIdx].size(); i++)
                {
                  if (iYOffset == refineMtmpCandList[temIdx][i].m_pY && iXOffset == refineMtmpCandList[temIdx][i].m_pX)
                  {
                    bRedundant = true;
                    break;
                  }
                }
                if (bRedundant)
                {
                  continue;
                }
              }
#if JVET_AH0055_INTRA_TMP_ARBVP
              if (bestRegionId == regionNum || bestRegionId == (regionNum + 1))
#else
              if (bestRegionId == regionNum)
#endif 
              {
                if (!PU::validItmpBv(*pcCU->firstPU, iXOffset, iYOffset))
                {
                  continue;
                }
              }
#endif
              if (iXOffset == sparseMtmpCandListSupp[temIdx][candIdx].m_pX && iYOffset == sparseMtmpCandListSupp[temIdx][candIdx].m_pY)
              {
                diffSupp[temIdx] = (int) sparseMtmpCostListSupp[temIdx][candIdx];
              }
              else
              {
                refCurr = ref + iYOffset * refStride + iXOffset;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
                m_calcTemplateDiff(refCurr, refStride, tarPatch, m_uiPicStride, uiPatchWidth, uiPatchHeight, diffSupp, pDiffSupp, tempType, temIdx, true, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
#else
                m_calcTemplateDiff(refCurr, refStride, tarPatch, uiPatchWidth, uiPatchHeight, diffSupp, pDiffSupp, tempType, temIdx, true, log2SizeTop, log2SizeLeft, sizeTopLeft, topTargetMean, leftTargetMean);
#endif
              }
              if (diffSupp[temIdx] < pDiffSupp[temIdx])
              {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
                updateCandList(TempLibFast(iXOffset, iYOffset, refineWindTL, refineWindBR, false, false, bestRegionId), diffSupp[temIdx], refineMtmpCandList[temIdx], refineMtmpCostList[temIdx], mtmpNumRefine[temIdx]);
#else
                updateCandList(TempLibFast(iXOffset, iYOffset, bestRegionId), diffSupp[temIdx], refineMtmpCandList[temIdx], refineMtmpCostList[temIdx], mtmpNumRefine[temIdx]);
#endif
                if (refineMtmpCandList[temIdx].size() == mtmpNumRefine[temIdx])
                {
                  pDiffSupp[temIdx] = std::min((int) refineMtmpCostList[temIdx][mtmpNumRefine[temIdx] - 1], pDiffSupp[temIdx]);
                }
              }
            }
          }
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT  
        }
#endif
      }
    }

    m_mtmpCandListUseMR = refineMtmpCandList[0];
    m_mtmpCostListUseMR = refineMtmpCostList[0];
    static_vector<TempLibFast, MTMP_NUM>& refMtmpCandListTemp = m_mtmpCandListUseMR;
    if (tempType == L_SHAPE_TEMPLATE && needTopLeft)
    {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      // If the list size is less than INIT_TL_POS the Only-TL candidates are skip
      if (refMtmpCandListTemp.size() >= INIT_TL_POS)
      {
        int  cnt        = 0;
        bool bRedundant = false;
        int  mvXCur, mvYCur, pos;
#endif
      for (int temIdx = 2; temIdx > 0; temIdx--)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        int cnt = 0;
        for (int candIdx = 0; candIdx < refineMtmpCostList[temIdx].size() && cnt < TL_NUM; candIdx++)
        {
          bool bRedundant = false;
          const int mvXCur = refineMtmpCandList[temIdx][candIdx].m_pX;
          const int mvYCur = refineMtmpCandList[temIdx][candIdx].m_pY;
#else
        for (int candIdx = 0; candIdx < refineMtmpCostList[temIdx].size(); candIdx++)
        {
          bRedundant = false;
          mvXCur = refineMtmpCandList[temIdx][candIdx].m_pX;
          mvYCur = refineMtmpCandList[temIdx][candIdx].m_pY;
#endif
          for (int crIdx = 0; crIdx < refMtmpCandListTemp.size(); crIdx++)
          {
            if (mvXCur == refMtmpCandListTemp[crIdx].m_pX && mvYCur == refMtmpCandListTemp[crIdx].m_pY)
            {
              bRedundant = true;
              break;
            }
          }
          if (!bRedundant)
          {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
            pos = (MTMP_NUM - static_cast<int>(refineMtmpCandList[1].size()) - static_cast<int>(refineMtmpCandList[2].size())) + cnt++;
#else
            cnt++;
            int pos = MTMP_NUM - 1 - TL_NUM * temIdx + cnt;
#endif
            if (pos < refMtmpCandListTemp.size())
            {
              for (int updatePos = (int) refMtmpCandListTemp.size() - 1; updatePos > pos; updatePos--)
              {
                refMtmpCandListTemp[updatePos] = refMtmpCandListTemp[updatePos - 1];
              }
              refMtmpCandListTemp[pos] = refineMtmpCandList[temIdx][candIdx];
            }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
            else
            {
              // TL candidates are appended sequentially if the list size is less than MTMP_NUM
              refMtmpCandListTemp.push_back(refineMtmpCandList[temIdx][candIdx]);
            }
#endif
          }
        }
      }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      }
#endif
    }
    m_tmpNumCandUseMR = static_cast<int>(m_mtmpCandListUseMR.size());
    for (int i = 0; i < refMtmpCandListTemp.size(); i++)
    {
      m_tmpXdispUseMR[i] = refMtmpCandListTemp[i].m_pX;
      m_tmpYdispUseMR[i] = refMtmpCandListTemp[i].m_pY;
    }
    if (refMtmpCandListTemp.size() != 0)
    {
      for (int i = static_cast<int>(refMtmpCandListTemp.size()); i < MTMP_NUM; i++)
      {
        m_tmpXdispUseMR[i] = m_tmpXdispUseMR[i - refMtmpCandListTemp.size()];
        m_tmpYdispUseMR[i] = m_tmpYdispUseMR[i - refMtmpCandListTemp.size()];
        m_mtmpCostListUseMR.push_back(m_mtmpCostListUseMR[i - refMtmpCandListTemp.size()]);
      }
    }
  }
#endif
}

#if JVET_AD0086_ENHANCED_INTRA_TMP
int IntraPrediction::xCalTMPFusionNumber(const int maxNum, const int numIdx
#if JVET_AG0136_INTRA_TMP_LIC
                                         , const bool useMR
#endif
                                         )
{
  int tmpFusionNum = 1;
  int offset       = maxNum * numIdx;
#if JVET_AG0136_INTRA_TMP_LIC
  const static_vector<uint64_t, MTMP_NUM>& mtmpCostList = useMR ? m_mtmpCostListUseMR : m_mtmpCostList;
  CHECK(offset >= mtmpCostList.size(), "Wrong offset for mtmpCostList");
  const int threshold = numIdx ? int(mtmpCostList[offset] * 1.2) : int(mtmpCostList[offset] * 2);
#else
  int threshold    = numIdx ? int(m_mtmpCostList[offset] * 1.2) : int(m_mtmpCostList[offset] * 2);
#endif

  for (int i = 1; i < maxNum; i++)
  {
#if JVET_AG0136_INTRA_TMP_LIC
    if (mtmpCostList[offset + i] > threshold)
#else
    if (m_mtmpCostList[offset + i] > threshold)
#endif
    {
      break;
    }
    tmpFusionNum++;
  }
  return tmpFusionNum;
}

void IntraPrediction::convertDiff2Weight(int *pDiff, int *weights, const int start, const int foundCandiNum)
{
  if (foundCandiNum <= 1)
  {
    weights[0] = 64;
    return;
  }
  int end = foundCandiNum + start - 1;

  const int blendSumWeight = 6;
  int       sumWeight      = 1 << blendSumWeight;   // 64
  int       sumW           = 0;
  int       w[FUSION_IDX_NUM];

  for (int i = start; i <= end; i++)
  {
    if (!pDiff[i])
    {
      pDiff[i]++;
    }
    sumW += pDiff[i];
  }
  for (int i = start; i <= end; i++)
  {
    pDiff[i] = sumW - pDiff[i];
  }

  int sumDiff = (foundCandiNum - 1) * sumW;
  int x       = floorLog2(sumDiff);

  int norm = (sumDiff << 4 >> x) & 15;
  int v    = g_gradDivTable[norm] | 8;
  x += (norm != 0);
  int shift = x + 3;
  int add   = (1 << (shift - 1));

  sumW = 0;
  for (int j = start; j <= end; j++)
  {
    w[j] = (pDiff[j] * v * sumWeight + add) >> shift;
    sumW += w[j];
  }
  while (sumW > sumWeight)
  {
    for (int j = end; j >= start && sumW > sumWeight; j--)
    {
      if (w[j])
      {
        w[j]--;
        sumW--;
      }
    }
  }
  while (sumW < sumWeight)
  {
    for (int j = start; j <= end && sumW < sumWeight; j++)
    {
      w[j]++;
      sumW++;
    }
  }
  for (int i = start; i <= end; i++)
  {
    weights[i - start] = w[i];
  }
}

void IntraPrediction::xTMPBuildFusionCandidate(CodingUnit &cu, RefTemplateType tempType
#if JVET_AG0136_INTRA_TMP_LIC
                                               , const bool useMR
#endif
                                               )
{
#if JVET_AG0136_INTRA_TMP_LIC
  if (!(useMR ? m_tmpNumCandUseMR : m_tmpNumCand))
#else
  if (!m_tmpNumCand)
#endif
  {
    return;
  }

#if JVET_AG0136_INTRA_TMP_LIC
  IntraTMPFusionInfo* const ptrTmpFusionInfo = useMR ? m_tmpFusionInfoUseMR : m_tmpFusionInfo;
  ptrTmpFusionInfo[0] = IntraTMPFusionInfo{ true, false, 0, TMP_FUSION_NUM };
  ptrTmpFusionInfo[1] = IntraTMPFusionInfo{ true, false, TMP_FUSION_NUM, TMP_FUSION_NUM };
  ptrTmpFusionInfo[2] = IntraTMPFusionInfo{ true, false, TMP_FUSION_NUM << 1, TMP_FUSION_NUM };
  ptrTmpFusionInfo[3] = IntraTMPFusionInfo{ true, true, 0, TMP_FUSION_NUM };
  ptrTmpFusionInfo[4] = IntraTMPFusionInfo{ true, true, TMP_FUSION_NUM, TMP_FUSION_NUM };
  ptrTmpFusionInfo[5] = IntraTMPFusionInfo{ true, true, TMP_FUSION_NUM << 1, TMP_FUSION_NUM };
#else
  m_tmpFusionInfo[0] = IntraTMPFusionInfo{ true, false, 0, TMP_FUSION_NUM };
  m_tmpFusionInfo[1] = IntraTMPFusionInfo{ true, false, TMP_FUSION_NUM, TMP_FUSION_NUM };
  m_tmpFusionInfo[2] = IntraTMPFusionInfo{ true, false, TMP_FUSION_NUM << 1, TMP_FUSION_NUM };
  m_tmpFusionInfo[3] = IntraTMPFusionInfo{ true, true, 0, TMP_FUSION_NUM };
  m_tmpFusionInfo[4] = IntraTMPFusionInfo{ true, true, TMP_FUSION_NUM, TMP_FUSION_NUM };
  m_tmpFusionInfo[5] = IntraTMPFusionInfo{ true, true, TMP_FUSION_NUM << 1, TMP_FUSION_NUM };
#endif
  int tmpIdx = cu.tmpIdx;
  int idx0   = cu.cs->pcv->isEncoder ? 0 : cu.tmpIdx;
  int idx1   = cu.cs->pcv->isEncoder ? TMP_GROUP_IDX << 1 : cu.tmpIdx + 1;

  for (int i = idx0; i < idx1; i++)
  {
    cu.tmpIdx                           = i;
#if JVET_AG0136_INTRA_TMP_LIC
    ptrTmpFusionInfo[i].tmpFusionNumber = xCalTMPFusionNumber(ptrTmpFusionInfo[i].tmpMaxNum, 0, useMR);
    if (ptrTmpFusionInfo[i].bFilter)
#else
    m_tmpFusionInfo[i].tmpFusionNumber = xCalTMPFusionNumber(m_tmpFusionInfo[i].tmpMaxNum, 0);

    if (m_tmpFusionInfo[i].bFilter)
#endif
    {
      xTMPFusionCalcModels(&cu, cu.lwidth(), cu.lheight(), tempType
#if JVET_AG0136_INTRA_TMP_LIC
                           , useMR
#endif
                           );
    }
    else
    {
      static int iDiff[TMP_FUSION_NUM];
#if JVET_AG0136_INTRA_TMP_LIC
      const int  offset       = ptrTmpFusionInfo[i].tmpFusionIdx;
      const int  foundCandNum = ptrTmpFusionInfo[i].tmpFusionNumber;
      const static_vector<uint64_t, MTMP_NUM>& mtmpCostList = useMR ? m_mtmpCostListUseMR : m_mtmpCostList;
#else
      const int  offset       = m_tmpFusionInfo[i].tmpFusionIdx;
      const int  foundCandNum = m_tmpFusionInfo[i].tmpFusionNumber;
#endif
      for (int i = 0; i < foundCandNum; i++)
      {
#if JVET_AG0136_INTRA_TMP_LIC
        iDiff[i] = (int) mtmpCostList[offset + i];
#else
        iDiff[i] = (int) m_mtmpCostList[offset + i];
#endif
      }
      convertDiff2Weight(iDiff,
#if JVET_AG0136_INTRA_TMP_LIC
                         ptrTmpFusionInfo[i].tmpFusionWeight,
#else
                         m_tmpFusionInfo[i].tmpFusionWeight,
#endif
                         0, foundCandNum);
    }
  }
  cu.tmpIdx = tmpIdx;
  return;
}

void IntraPrediction::xTMPFusionCalcParams(CodingUnit *cu, CompArea area, CccmModel& tmpFusionModel,
                                           int foundCandiNum, RefTemplateType tempType, Pel *curPointTemplate,
                                           Pel *refPointTemplate[]
#if JVET_AG0136_INTRA_TMP_LIC
                                           , const bool useMR, const int* const ptrLicParamsFusion[TMP_BEST_CANDIDATES]
#endif
                                           )
{
  int sampleNum = 0;

  int uiHeight = area.height;
  int uiWidth  = area.width;

  int picStride = cu->cs->picture->getRecoBuf(area).stride;   // refTemplate and curTemplate

  int areaWidth  = uiWidth + TMP_TEMPLATE_SIZE;
  int areaHeight = uiHeight + TMP_TEMPLATE_SIZE;
  int refSizeX   = TMP_TEMPLATE_SIZE;
  int refSizeY   = TMP_TEMPLATE_SIZE;

  if (tempType == L_SHAPE_TEMPLATE)
  {
    refSizeX   = TMP_TEMPLATE_SIZE;
    refSizeY   = TMP_TEMPLATE_SIZE;
    areaWidth  = uiWidth + TMP_TEMPLATE_SIZE;
    areaHeight = uiHeight + TMP_TEMPLATE_SIZE;
  }
  else if (tempType == ABOVE_TEMPLATE)
  {
    refSizeX   = 0;
    refSizeY   = TMP_TEMPLATE_SIZE;
    areaWidth  = uiWidth;
    areaHeight = uiHeight + TMP_TEMPLATE_SIZE;
  }
  else if (tempType == LEFT_TEMPLATE)
  {
    refSizeX   = TMP_TEMPLATE_SIZE;
    refSizeY   = 0;
    areaWidth  = uiWidth + TMP_TEMPLATE_SIZE;
    areaHeight = uiHeight;
  }

#if JVET_AB0174_CCCM_DIV_FREE
  int curTemplatelumaOffset = 1 << (cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) - 1);
  int refPosX               = 0;
  int refPosY               = 0;
  if (refSizeX || refSizeY)
  {
    refPosX               = refSizeX > 0 ? refSizeX - 1 : 0;
    refPosY               = refSizeY > 0 ? refSizeY - 1 : 0;
    curTemplatelumaOffset = curPointTemplate[refPosY * picStride + refPosX];
  }
#endif
#if JVET_AG0136_INTRA_TMP_LIC
  if (useMR)
  {
    Pel* const ptrOffsetsFusionUseMR = m_memOffsetsFusionUseMR[cu->tmpIdx - 3];
    for (int i = 0; i < foundCandiNum; i++)
    {
      const int* const ptrLicInd = ptrLicParamsFusion[i];
      ptrOffsetsFusionUseMR[i] = ClipPel(rightShift(ptrLicInd[1] * refPointTemplate[i][refPosY * picStride + refPosX], ptrLicInd[0]) + ptrLicInd[2], cu->cs->slice->clpRng(COMPONENT_Y));
    }
  }
  if (useMR)
  {
    for (int i = 0; i < foundCandiNum; i++)
    {
      Pel* ptrTemp = &arrayTemp[i][0];
      const Pel* ptrRefPointCurr = refPointTemplate[i];
      if (refSizeY)
      {
        for (int j = 0; j < refSizeY; j++)
        {
          memcpy(ptrTemp, ptrRefPointCurr, areaWidth * sizeof(Pel));
          ptrTemp += areaWidth;
          ptrRefPointCurr += picStride;
        }
      }
      if (refSizeX)
      {
        for (int j = 0; j < uiHeight; j++)
        {
          memcpy(ptrTemp, ptrRefPointCurr, refSizeX * sizeof(Pel));
          ptrTemp += areaWidth;
          ptrRefPointCurr += picStride;
        }
      }
    }
    const Pel* const ptrOffsetsFusionUseMR = m_memOffsetsFusionUseMR[cu->tmpIdx - 3];
    for (int i = 0; i < foundCandiNum; i++)
    {
      const int* const ptrLicInd = ptrLicParamsFusion[i];
      if (refSizeY)
      {
        PelBuf bufferTemp(arrayTemp[i], areaWidth, areaWidth, refSizeY);
        bufferTemp.linearTransform(ptrLicInd[1], ptrLicInd[0], ptrLicInd[2], true, (cu->cs)->slice->clpRng(COMPONENT_Y));
        bufferTemp.subtract(ptrOffsetsFusionUseMR[i]);
      }
      if (refSizeX)
      {
        PelBuf bufferTemp(arrayTemp[i] + refSizeY * areaWidth, areaWidth, refSizeX, uiHeight);
        bufferTemp.linearTransform(ptrLicInd[1], ptrLicInd[0], ptrLicInd[2], true, (cu->cs)->slice->clpRng(COMPONENT_Y));
        bufferTemp.subtract(ptrOffsetsFusionUseMR[i]);
      }
    }
  }
#endif
  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      if (x >= refSizeX && y >= refSizeY)
      {
        continue;
      }

      int i;
#if JVET_AB0174_CCCM_DIV_FREE
#if JVET_AG0136_INTRA_TMP_LIC
      if (useMR)
      {
        for (i = 0; i < foundCandiNum; i++)
        {
          m_a[i][sampleNum] = arrayTemp[i][y * areaWidth + x];
        }
      }
      else
      {
#endif
      for (i = 0; i < foundCandiNum; i++)
      {
        m_a[i][sampleNum] = refPointTemplate[i][y * picStride + x] - refPointTemplate[i][refPosY * picStride + refPosX];
      }
#if JVET_AG0136_INTRA_TMP_LIC
      }
#endif
#else
      for (i = 0; i < foundCandiNum; i++)
      {
        m_a[i][sampleNum] = refPointTemplate[i][y * picStride + x];
      }
#endif
      for (; i < TMP_FUSION_PARAMS - 1; i++)
      {
        m_a[i][sampleNum] = 0;
      }

      m_a[i++][sampleNum] = tmpFusionModel.bias();

      m_cb[sampleNum++] = curPointTemplate[y * picStride + x];
    }
  }
  if (!sampleNum)   // Number of samples can go to zero in the multimode case
  {
    tmpFusionModel.clearModel();
  }
  else
  {
#if JVET_AB0174_CCCM_DIV_FREE
    m_cccmSolver.solve1(m_a, m_cb, sampleNum, curTemplatelumaOffset, tmpFusionModel);
#else
    m_cccmSolver.solve1(m_a, m_cb, sampleNum, tmpFusionModel);
#endif
  }
}

void IntraPrediction::xTMPFusionCalcModels(CodingUnit *cu, unsigned int uiBlkWidth, unsigned int uiBlkHeight,
                                           RefTemplateType tempType
#if JVET_AG0136_INTRA_TMP_LIC
                                           , const bool useMR
#endif
                                           )
{
#if JVET_AG0136_INTRA_TMP_LIC
  IntraTMPFusionInfo& tmpFusionInfo = (useMR ? m_tmpFusionInfoUseMR : m_tmpFusionInfo)[cu->tmpIdx];
  const int foundCandiNum = tmpFusionInfo.tmpFusionNumber;
#else
  int foundCandiNum = m_tmpFusionInfo[cu->tmpIdx].tmpFusionNumber;
#endif

  if (foundCandiNum < 1)
  {
    return;
  }
  int      iOffsetY, iOffsetX;
  CompArea area      = cu->Y();
  Pel *    ref       = cu->cs->picture->getRecoBuf(area).buf;
  int      picStride = cu->cs->picture->getRecoBuf(area).stride;

  Pel *refPointTemplate[TMP_BEST_CANDIDATES] = { NULL };
  Pel *curPointTemplate                      = nullptr;
#if JVET_AG0136_INTRA_TMP_LIC
  int* ptrLicParamsFusion[TMP_BEST_CANDIDATES] = { NULL };
#endif
  for (int i = 0; i < foundCandiNum; i++)
  {
#if JVET_AG0136_INTRA_TMP_LIC
    iOffsetX = (useMR ? m_tmpXdispUseMR : m_tmpXdisp)[i + tmpFusionInfo.tmpFusionIdx];
    iOffsetY = (useMR ? m_tmpYdispUseMR : m_tmpYdisp)[i + tmpFusionInfo.tmpFusionIdx];
    if (useMR)
    {
      ptrLicParamsFusion[i] = &getMemLicParams(0, i + tmpFusionInfo.tmpFusionIdx)[0];
    }
#else
    iOffsetX = m_tmpXdisp[i + m_tmpFusionInfo[cu->tmpIdx].tmpFusionIdx];
    iOffsetY = m_tmpYdisp[i + m_tmpFusionInfo[cu->tmpIdx].tmpFusionIdx];
#endif
    if (tempType == L_SHAPE_TEMPLATE)
    {
      refPointTemplate[i] = (ref + iOffsetY * picStride + iOffsetX) - picStride * TMP_TEMPLATE_SIZE - TMP_TEMPLATE_SIZE;
      curPointTemplate    = ref - TMP_TEMPLATE_SIZE * picStride - TMP_TEMPLATE_SIZE;
    }
    else if (tempType == ABOVE_TEMPLATE)
    {
      refPointTemplate[i] = (ref + iOffsetY * picStride + iOffsetX) - picStride * TMP_TEMPLATE_SIZE;
      curPointTemplate    = ref - TMP_TEMPLATE_SIZE * picStride;
    }
    else if (tempType == LEFT_TEMPLATE)
    {
      refPointTemplate[i] = (ref + iOffsetY * picStride + iOffsetX) - TMP_TEMPLATE_SIZE;
      curPointTemplate    = ref - TMP_TEMPLATE_SIZE;
    }
  }
  CccmModel tmpFusionModel( TMP_FUSION_PARAMS, cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );

  xTMPFusionCalcParams(cu, area, tmpFusionModel, foundCandiNum, tempType, curPointTemplate, refPointTemplate
#if JVET_AG0136_INTRA_TMP_LIC
                       , useMR, ptrLicParamsFusion
#endif
                       );

  for (int i = 0; i < TMP_FUSION_PARAMS; i++)
  {
#if JVET_AG0136_INTRA_TMP_LIC
    tmpFusionInfo.tmpFushionParams[i] = tmpFusionModel.params[i];
#else
    m_tmpFusionInfo[cu->tmpIdx].tmpFushionParams[i] = tmpFusionModel.params[i];
#endif
  }
}

void IntraPrediction::xCalTmpFlmParam(CodingUnit *cu, unsigned int uiBlkWidth, unsigned int uiBlkHeight,
                                      RefTemplateType tempType)
{
  int foundCandiNum = m_tmpNumCand;

  if (foundCandiNum < 1)
  {
    return;
  }

  CompArea area = cu->Y();

  xGetTmpFlmRefBuf(cu, uiBlkWidth, uiBlkHeight, tempType);

  int areaWidth, areaHeight, refSizeX, refSizeY;

  refSizeX         = m_tmpRefArea[cu->tmpIdx].x;
  refSizeY         = m_tmpRefArea[cu->tmpIdx].y;
  areaWidth        = m_tmpRefArea[cu->tmpIdx].width;
  areaHeight       = m_tmpRefArea[cu->tmpIdx].height;
  int    refStride = areaWidth + 2 * TMP_FILTER_PADDING;   // Including paddings required for the 2D filter
  int    refOrigin = refStride * TMP_FILTER_PADDING + TMP_FILTER_PADDING;
  PelBuf tmpRefBuf = PelBuf(m_tmpRefBuf[cu->tmpIdx] + refOrigin, refStride, areaWidth, areaHeight);

  int sampleNum = 0;

  Pel *ref       = cu->cs->picture->getRecoBuf(area).buf;   // cur Template
  int  picStride = cu->cs->picture->getRecoBuf(area).stride;

  ref = ref - refSizeY * picStride - refSizeX;
#if JVET_AB0174_CCCM_DIV_FREE
  int offset = 1 << (cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) - 1);
  if (refSizeX || refSizeY)
  {
    int  refPosX   = refSizeX > 0 ? refSizeX - 1 : 0;
    int  refPosY   = refSizeY > 0 ? refSizeY - 1 : 0;
    Pel *refOffset = ref + refPosY * picStride + refPosX;
    offset         = refOffset[0];
  }
#endif
  // Collect reference data to input matrix A and target vector Y
  Pel* Y = m_cb;

  CccmModel tmpModel( TMP_FLM_PARAMS, cu->cs->sps->getBitDepth( CHANNEL_TYPE_LUMA ) );

  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      if (x >= refSizeX && y >= refSizeY)
      {
        continue;
      }

      m_a[0][sampleNum] = tmpRefBuf.at(x, y);       // C
      m_a[1][sampleNum] = tmpRefBuf.at(x, y - 1);   // N
      m_a[2][sampleNum] = tmpRefBuf.at(x, y + 1);   // S
      m_a[3][sampleNum] = tmpRefBuf.at(x - 1, y);   // W
      m_a[4][sampleNum] = tmpRefBuf.at(x + 1, y);   // E
      m_a[5][sampleNum] = tmpModel.bias();

      Y[sampleNum++] = ref[x];
    }
    ref += picStride;
  }

  if (!sampleNum)   // Number of samples can go to zero in the multimode case
  {
    tmpModel.clearModel();
  }
  else
  {
    m_cccmSolver.solve1(m_a, Y, sampleNum, offset, tmpModel);
  }

  for (int i = 0; i < TMP_FLM_PARAMS; i++)
  {
    m_tmpFlmParams[i][cu->tmpIdx] = tmpModel.params[i];
  }
}

void IntraPrediction::xCalcTmpFlmRefArea(CodingUnit *cu, unsigned int uiBlkWidth, unsigned int uiBlkHeight,
                                         RefTemplateType tempType, bool &leftPadding, bool &rightPadding,
                                         bool &abovePadding, bool &belowPadding)
{
  int regionId      = m_mtmpCandList[cu->tmpIdx].m_rId;
#if JVET_AG0151_INTRA_TMP_MERGE_MODE
#if JVET_AH0055_INTRA_TMP_ARBVP
  if (regionId == 6 || regionId == 7)
#else
  if (regionId == 6)
#endif 
  {
    leftPadding = 1;
    rightPadding = 1;
    abovePadding = 1;
    belowPadding = 1;
    return;
  }
#endif

  int      iHorMax = 0, iHorMin = 0, iVerMax = 0, iVerMin = 0;
  CompArea area       = cu->blocks[COMPONENT_Y];
  int      iCurrY     = area.pos().y;
  int      iCurrX     = area.pos().x;
  Position ctuRsAddr  = CU::getCtuXYAddr(*cu);
  int      offsetLCUY = iCurrY - ctuRsAddr.y;
  int      offsetLCUX = iCurrX - ctuRsAddr.x;

  int pX = m_tmpXdisp[cu->tmpIdx];
  int pY = m_tmpYdisp[cu->tmpIdx];

  CHECK(regionId < 0 || regionId > 5, "region Id error\n");
  clipMvIntraConstraint(cu, regionId, iHorMin, iHorMax, iVerMin, iVerMax,
    TMP_TEMPLATE_SIZE, uiBlkWidth, uiBlkHeight, iCurrY, iCurrX, offsetLCUY, offsetLCUX, tempType);

  leftPadding  = !(pX > iHorMin);
  rightPadding = !(pX < iHorMax);
  abovePadding = !(pY > iVerMin);
  belowPadding = !(pY < iVerMax);
#if JVET_AE0077_EXT_INTRATMP
  int iBlkWidth = uiBlkWidth;
  int iBlkHeight = uiBlkHeight;
  int bestPosX = iCurrX + pX;
  int bestPosY = iCurrY + pY;
  if (regionId == 4 || regionId == 5
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      || regionId == 1 || regionId == 3
#endif
      )
  {
    if (!cu->cs->isDecomp(Position(bestPosX + iBlkWidth - 1, bestPosY + iBlkHeight), CHANNEL_TYPE_LUMA))
    {
      belowPadding = true;
    }
    if (!cu->cs->isDecomp(Position(bestPosX + iBlkWidth, bestPosY + iBlkHeight - 1), CHANNEL_TYPE_LUMA))
    {
      rightPadding = true;
    }
  }
#endif
}

void IntraPrediction::xGetTmpFlmRefBuf(CodingUnit *cu, unsigned int uiBlkWidth, unsigned int uiBlkHeight,
                                       RefTemplateType tempType)
{
  int pX = m_tmpXdisp[cu->tmpIdx];
  int pY = m_tmpYdisp[cu->tmpIdx];

  int      iOffsetY, iOffsetX;
  Pel *    refTarget;
  CompArea area     = cu->Y();
  int      uiHeight = area.height;
  int      uiWidth  = area.width;

  Pel *ref       = cu->cs->picture->getRecoBuf(area).buf;
  int  picStride = cu->cs->picture->getRecoBuf(area).stride;

  iOffsetY       = pY;
  iOffsetX       = pX;
  refTarget      = ref + iOffsetY * picStride + iOffsetX;   // refTarget
  int areaWidth  = uiWidth + TMP_TEMPLATE_SIZE;
  int areaHeight = uiHeight + TMP_TEMPLATE_SIZE;
  int refSizeX   = TMP_TEMPLATE_SIZE;
  int refSizeY   = TMP_TEMPLATE_SIZE;

  Pel *refTemp    = nullptr;
  bool paddingTop = false, paddingLeft = false, paddingRight = false, paddingBottom = false;
  xCalcTmpFlmRefArea(cu, uiBlkWidth, uiBlkHeight, tempType, paddingLeft, paddingRight, paddingTop, paddingBottom);

  if (tempType == L_SHAPE_TEMPLATE)
  {
    refSizeX   = TMP_TEMPLATE_SIZE;
    refSizeY   = TMP_TEMPLATE_SIZE;
    areaWidth  = uiWidth + TMP_TEMPLATE_SIZE;
    areaHeight = uiHeight + TMP_TEMPLATE_SIZE;
    refTemp    = refTarget - TMP_TEMPLATE_SIZE * picStride - TMP_TEMPLATE_SIZE;
  }
  else if (tempType == ABOVE_TEMPLATE)
  {
    refSizeX   = 0;
    refSizeY   = TMP_TEMPLATE_SIZE;
    areaWidth  = uiWidth;
    areaHeight = uiHeight + TMP_TEMPLATE_SIZE;
    refTemp    = refTarget - TMP_TEMPLATE_SIZE * picStride;
  }
  else if (tempType == LEFT_TEMPLATE)
  {
    refSizeX   = TMP_TEMPLATE_SIZE;
    refSizeY   = 0;
    areaWidth  = uiWidth + TMP_TEMPLATE_SIZE;
    areaHeight = uiHeight;
    refTemp    = refTarget - TMP_TEMPLATE_SIZE;
  }
  m_tmpRefArea[cu->tmpIdx] = Area(refSizeX, refSizeY, areaWidth, areaHeight);

  int refStride = areaWidth + 2 * TMP_FILTER_PADDING;   // Including paddings required for the 2D filter
  int refOrigin = refStride * TMP_FILTER_PADDING + TMP_FILTER_PADDING;

  PelBuf tmpRefBuf = PelBuf(m_tmpRefBuf[cu->tmpIdx] + refOrigin, refStride, areaWidth, areaHeight);
  PelBuf srcRefBuf = PelBuf(refTemp, picStride, areaWidth, areaHeight);
#if JVET_AB0174_CCCM_DIV_FREE
  int offset = 1 << (cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) - 1);
  if (refSizeX || refSizeY)
  {
    int refPosX = refSizeX > 0 ? refSizeX - 1 : 0;
    int refPosY = refSizeY > 0 ? refSizeY - 1 : 0;
    offset      = srcRefBuf.at(refPosX, refPosY);
  }
#endif
  for (int y = (paddingTop ? 0 : -1); y < (paddingBottom ? areaHeight : areaHeight + 1); y++)
  {
    for (int x = (paddingLeft ? 0 : -1); x < (paddingRight ? areaWidth : areaWidth + 1); x++)
    {
#if JVET_AB0174_CCCM_DIV_FREE
      tmpRefBuf.at(x, y) = srcRefBuf.at(x, y) - offset;
#else
      tmpRefBuf.at(x, y) = srcRefBuf.at(x, y);
#endif
    }
  }

  // Pad top area
  if (paddingTop)
  {
    for (int x = (paddingLeft ? 0 : -1); x < (paddingRight ? areaWidth : areaWidth + 1); x++)
    {
      tmpRefBuf.at(x, -1) = tmpRefBuf.at(x, 0);
    }
  }
  // Pad bottom area
  if (paddingBottom)
  {
    for (int x = (paddingLeft ? 0 : -1); x < (paddingRight ? areaWidth : areaWidth + 1); x++)
    {
      tmpRefBuf.at(x, areaHeight) = tmpRefBuf.at(x, areaHeight - 1);
    }
  }

  // Pad right area
  if (paddingRight)
  {
    for (int y = -1; y <= areaHeight; y++)
    {
      tmpRefBuf.at(areaWidth, y) = tmpRefBuf.at(areaWidth - 1, y);
    }
  }
  // Pad left area
  if (paddingLeft)
  {
    for (int y = -1; y <= areaHeight; y++)
    {
      tmpRefBuf.at(-1, y) = tmpRefBuf.at(0, y);
    }
  }
}

void IntraPrediction::xTMPFusionApplyModel(PelBuf &piPred, unsigned int uiBlkWidth, unsigned int uiBlkHeight,
                                           RefTemplateType tempType, CodingUnit *cu
#if JVET_AG0136_INTRA_TMP_LIC
                                           , const bool useMR
#endif
                                           , bool bDeriveDimdMode)
{
#if JVET_AG0136_INTRA_TMP_LIC
  if (!cu->tmpFusionFlag)
  {
    return;
  }

  const IntraTMPFusionInfo& tmpFusionInfo = (useMR ? m_tmpFusionInfoUseMR : m_tmpFusionInfo)[cu->tmpIdx];
  if (!tmpFusionInfo.bValid || !tmpFusionInfo.bFilter)
  {
    return;
  }
#else
  bool bTmpFusion = cu->tmpFusionFlag && m_tmpFusionInfo[cu->tmpIdx].bValid;
  if (!bTmpFusion || !m_tmpFusionInfo[cu->tmpIdx].bFilter)
  {
    return;
  }
#endif
#if JVET_AG0136_INTRA_TMP_LIC
  const int foundCandiNum = tmpFusionInfo.tmpFusionNumber;
#else
  int foundCandiNum = m_tmpFusionInfo[cu->tmpIdx].tmpFusionNumber;
#endif

  if (foundCandiNum < 1)
  {
    return;
  }

  CccmModel tmpFusionModel( TMP_FUSION_PARAMS, cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA));
  for (int i = 0; i < TMP_FUSION_PARAMS; i++)
  {
#if JVET_AG0136_INTRA_TMP_LIC
    tmpFusionModel.params[i] = tmpFusionInfo.tmpFushionParams[i];
#else
    tmpFusionModel.params[i] = m_tmpFusionInfo[cu->tmpIdx].tmpFushionParams[i];
#endif
  }
  CompArea      area      = cu->Y();
  Pel *         ref       = cu->cs->picture->getRecoBuf(area).buf;
  int           picStride = cu->cs->picture->getRecoBuf(area).stride;
  const ClpRng &clpRng(cu->cs->slice->clpRng(COMPONENT_Y));
#if !JVET_AG0136_INTRA_TMP_LIC
  int           iOffsetY, iOffsetX;
#endif
  Pel*          samples = m_samples;
  Pel *         refPointPatch[TMP_BEST_CANDIDATES] = { NULL };

  memset( samples, 0, sizeof( Pel ) * TMP_FUSION_PARAMS);

#if JVET_AG0136_INTRA_TMP_LIC
  if (useMR)
  {
    const Pel* const ptrOffsetsFusionUseMR = m_memOffsetsFusionUseMR[cu->tmpIdx - 3];
    for (int i = 0; i < foundCandiNum; i++)
    {
      Pel* ptrTemp = &arrayTemp[i][0];
      const Pel* ptrRefPointCurr = ref + m_tmpYdispUseMR[i + tmpFusionInfo.tmpFusionIdx] * picStride + m_tmpXdispUseMR[i + tmpFusionInfo.tmpFusionIdx];
      for (int j = 0; j < uiBlkHeight; j++)
      {
        memcpy(ptrTemp, ptrRefPointCurr, uiBlkWidth * sizeof(Pel));
        ptrTemp += uiBlkWidth;
        ptrRefPointCurr += picStride;
      }
      PelBuf bufferTemp(arrayTemp[i], uiBlkWidth, uiBlkWidth, uiBlkHeight);
      const int* const ptrLicInd = &getMemLicParams(0, i + tmpFusionInfo.tmpFusionIdx)[0];
      bufferTemp.linearTransform(ptrLicInd[1], ptrLicInd[0], ptrLicInd[2], true, (cu->cs)->slice->clpRng(COMPONENT_Y));
      bufferTemp.subtract(ptrOffsetsFusionUseMR[i]);
    }
  }
  else
  {
    for (int i = 0; i < foundCandiNum; i++)
    {
      refPointPatch[i] = ref + m_tmpYdisp[i + tmpFusionInfo.tmpFusionIdx] * picStride + m_tmpXdisp[i + tmpFusionInfo.tmpFusionIdx];
    }
  }
#else
  for (int i = 0; i < foundCandiNum; i++)
  {
    iOffsetY         = m_tmpYdisp[i + m_tmpFusionInfo[cu->tmpIdx].tmpFusionIdx];
    iOffsetX         = m_tmpXdisp[i + m_tmpFusionInfo[cu->tmpIdx].tmpFusionIdx];
    refPointPatch[i] = ref + iOffsetY * picStride + iOffsetX;
  }
#endif
  Pel *pPred    = piPred.buf;
  int  uiStride = piPred.stride;
  for (int y = 0; y < uiBlkHeight; y++)
  {
    for (int x = 0; x < uiBlkWidth; x++)
    {
      int i = 0;
#if JVET_AG0136_INTRA_TMP_LIC
      if (useMR)
      {
        for (i = 0; i < foundCandiNum; i++)
        {
          samples[i] = arrayTemp[i][y * uiBlkWidth + x];
        }
      }
      else
      {      
#endif
      if (tempType == L_SHAPE_TEMPLATE)
      {
        for (i = 0; i < foundCandiNum; i++)
        {
          samples[i] = refPointPatch[i][y * picStride + x] - refPointPatch[i][-picStride - 1];
        }
      }
      else if (tempType == ABOVE_TEMPLATE)
      {
        for (i = 0; i < foundCandiNum; i++)
        {
          samples[i] = refPointPatch[i][y * picStride + x] - refPointPatch[i][-picStride];
        }
      }
      else if (tempType == LEFT_TEMPLATE)
      {
        for (i = 0; i < foundCandiNum; i++)
        {
          samples[i] = refPointPatch[i][y * picStride + x] - refPointPatch[i][-1];
        }
      }
#if JVET_AG0136_INTRA_TMP_LIC
      }
#endif
      for (; i < TMP_FUSION_PARAMS - 1; i++)
      {
        samples[i] = 0;
      }
      samples[i++]            = tmpFusionModel.bias();
      pPred[y * uiStride + x] = ClipPel<Pel>(tmpFusionModel.convolve(samples), clpRng);
    }
  }
#if JVET_AG0136_INTRA_TMP_LIC
  const int pX = (useMR ? m_tmpXdispUseMR : m_tmpXdisp)[tmpFusionInfo.tmpFusionIdx];
  const int pY = (useMR ? m_tmpYdispUseMR : m_tmpYdisp)[tmpFusionInfo.tmpFusionIdx];
#else
  int pX = m_tmpXdisp[m_tmpFusionInfo[cu->tmpIdx].tmpFusionIdx];
  int pY = m_tmpYdisp[m_tmpFusionInfo[cu->tmpIdx].tmpFusionIdx];
#endif

  cu->firstPU->interDir               = 1;
  cu->firstPU->refIdx[REF_PIC_LIST_0] = MAX_NUM_REF;
  cu->firstPU->mv->set(pX << MV_FRACTIONAL_BITS_INTERNAL, pY << MV_FRACTIONAL_BITS_INTERNAL);
  cu->firstPU->bv.set(pX, pY);

#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
  if (bDeriveDimdMode)
  {
    CPelBuf predBuf      = piPred;
#if JVET_AI0050_INTER_MTSS
    int secondDimdIntraDir = 0;
#endif
    cu->intraTmpDimdMode = deriveIpmForTransform(predBuf, *cu
#if JVET_AI0050_INTER_MTSS
      , secondDimdIntraDir
#endif
    );
#if JVET_AI0050_INTER_MTSS
    cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
  }
#endif
  return;
}

void IntraPrediction::xGenerateTmpFlmPred(PelBuf &piPred, unsigned int uiBlkWidth, unsigned int uiBlkHeight,
                                          RefTemplateType tempType, CodingUnit *cu, bool bDeriveDimdMode)
{
  if (!cu->tmpFlmFlag)
  {
    return;
  }
  const ClpRng &            clpRng(cu->cs->slice->clpRng(COMPONENT_Y));
  Pel* samples = m_samples;
  CccmModel tmpModel( TMP_FLM_PARAMS, cu->cs->sps->getBitDepth(CHANNEL_TYPE_LUMA));

  for (int i = 0; i < TMP_FLM_PARAMS; i++)
  {
    tmpModel.params[i] = m_tmpFlmParams[i][cu->tmpIdx];
  }

  int refStride = m_tmpRefArea[cu->tmpIdx].width + 2 * TMP_FILTER_PADDING;   // Including paddings required for the 2D filter
  int refOrigin = refStride * (m_tmpRefArea[cu->tmpIdx].y + TMP_FILTER_PADDING) + m_tmpRefArea[cu->tmpIdx].x + TMP_FILTER_PADDING;
  PelBuf tmpRefBuf = PelBuf(m_tmpRefBuf[cu->tmpIdx] + refOrigin, refStride, uiBlkWidth, uiBlkHeight);

  for (int y = 0; y < tmpRefBuf.height; y++)
  {
    for (int x = 0; x < tmpRefBuf.width; x++)
    {
      samples[0] = tmpRefBuf.at(x, y);       // C
      samples[1] = tmpRefBuf.at(x, y - 1);   // N
      samples[2] = tmpRefBuf.at(x, y + 1);   // S
      samples[3] = tmpRefBuf.at(x - 1, y);   // W
      samples[4] = tmpRefBuf.at(x + 1, y);   // E
      samples[5] = tmpModel.bias();

      piPred.at(x, y) = ClipPel<Pel>(tmpModel.convolve(samples), clpRng);
    }
  }
  int pX = m_tmpXdisp[cu->tmpIdx];
  int pY = m_tmpYdisp[cu->tmpIdx];

  cu->firstPU->interDir               = 1;
  cu->firstPU->refIdx[REF_PIC_LIST_0] = MAX_NUM_REF;
  cu->firstPU->mv->set(pX << MV_FRACTIONAL_BITS_INTERNAL, pY << MV_FRACTIONAL_BITS_INTERNAL);
  cu->firstPU->bv.set(pX, pY);

#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
  if (bDeriveDimdMode)
  {
    CPelBuf predBuf      = piPred;
#if JVET_AI0050_INTER_MTSS
    int secondDimdIntraDir = 0;
#endif
    cu->intraTmpDimdMode = deriveIpmForTransform(predBuf, *cu
#if JVET_AI0050_INTER_MTSS
     , secondDimdIntraDir
#endif
    );
#if JVET_AI0050_INTER_MTSS
    cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
  }
#endif
  return;
}

void IntraPrediction::xPadForInterpolation(CodingUnit *cu)
{
  CodingStructure &cs       = *cu->cs;
  int              uiWidth  = cu->lwidth();
  int              uiHeight = cu->lheight();

  Position pos = cu->Y().offset(m_tmpXdisp[cu->tmpIdx], m_tmpYdisp[cu->tmpIdx]);

  const UnitArea localUnitArea(cu->firstPU->chromaFormat,
                               Area(0, 0, uiWidth + 2 * TMP_SUBPEL_PAD_NUM, uiHeight + 2 * TMP_SUBPEL_PAD_NUM));
  PelBuf         dstBuffer = m_tempBuffer[0].getBuf(localUnitArea.Y());
  int            dstStride = dstBuffer.stride;
  Pel *          dst0      = dstBuffer.buf + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM * dstStride;
  Pel *          dst       = dst0;

  int  srcStride = cu->cs->picture->getRecoBuf(cu->firstPU->Y()).stride;
  Pel *src0 =
    cu->cs->picture->getRecoBuf(cu->firstPU->Y()).buf + m_tmpXdisp[cu->tmpIdx] + m_tmpYdisp[cu->tmpIdx] * srcStride;
  Pel *src = src0;

  // block
  for (int j = 0; j < uiHeight; j++)
  {
    for (int i = 0; i < uiWidth; i++)
    {
      dst[i + j * dstStride] = src[i + j * srcStride];
    }
  }

  // above
  for (int j = -1; j >= -TMP_SUBPEL_PAD_NUM; j--)
  {
    for (int i = 0; i < uiWidth; i++)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i + (j + 1) * dstStride];
    }
  }

  // bottom
  for (int j = uiHeight; j < uiHeight + TMP_SUBPEL_PAD_NUM; j++)
  {
    for (int i = 0; i < uiWidth; i++)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i + (j - 1) * dstStride];
    }
  }

  // left
  for (int j = 0; j < uiHeight; j++)
  {
    for (int i = -1; i >= -TMP_SUBPEL_PAD_NUM; i--)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i + 1 + j * dstStride];
    }
  }

  // right
  for (int j = 0; j < uiHeight; j++)
  {
    for (int i = uiWidth; i < uiWidth + TMP_SUBPEL_PAD_NUM; i++)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i - 1 + j * dstStride];
    }
  }

  // aboveleft
  for (int j = -1; j >= -TMP_SUBPEL_PAD_NUM; j--)
  {
    for (int i = -1; i >= -TMP_SUBPEL_PAD_NUM; i--)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i + 1 + j * dstStride];
    }
  }

  // aboveright
  for (int j = -1; j >= -TMP_SUBPEL_PAD_NUM; j--)
  {
    for (int i = uiWidth; i < uiWidth + TMP_SUBPEL_PAD_NUM; i++)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i - 1 + j * dstStride];
    }
  }

  // bottomleft
  for (int j = uiHeight; j < uiHeight + TMP_SUBPEL_PAD_NUM; j++)
  {
    for (int i = -1; i >= -TMP_SUBPEL_PAD_NUM; i--)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i + 1 + j * dstStride];
    }
  }

  // bottomright
  for (int j = uiHeight; j < uiHeight + TMP_SUBPEL_PAD_NUM; j++)
  {
    for (int i = uiWidth; i < uiWidth + TMP_SUBPEL_PAD_NUM; i++)
    {
      dst[i + j * dstStride] =
        cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA) ? src[i + j * srcStride] : dst[i - 1 + j * dstStride];
    }
  }
}
#endif
#if JVET_AG0136_INTRA_TMP_LIC
template <int SIZE>
void tmpFusionBlending(int16_t* __restrict  refTarget[] , const int* const __restrict pDiff, int16_t* __restrict piPred, const int height, const int width, const int log2WeightSum, const int strideUsed, const int uiStride)
{
  const int shift = 1 << (log2WeightSum - 1);
  for (int uiY = 0; uiY < height; uiY++)
  {
    for (int uiX = 0; uiX < width; uiX++)
    {
      int blend = shift;
      for (int i = 0; i < SIZE; i++)
      {
        blend += (pDiff[i] * refTarget[i][uiX + uiY*strideUsed]);
      }
      piPred[uiX + uiY*uiStride] = static_cast<int16_t>(blend >> log2WeightSum);
    }
  }
}
#endif

#if !JVET_AD0086_ENHANCED_INTRA_TMP
#if TMP_FAST_ENC
bool IntraPrediction::generateTMPrediction(Pel* piPred, unsigned int uiStride, CompArea area, int& foundCandiNum, CodingUnit* cu)
#else
bool IntraPrediction::generateTMPrediction( Pel* piPred, unsigned int uiStride, unsigned int uiBlkWidth, unsigned int uiBlkHeight, int& foundCandiNum )
#endif
{
  bool bSucceedFlag = true;
#if !TMP_FAST_ENC
  unsigned int uiPatchWidth = uiBlkWidth + TMP_TEMPLATE_SIZE;
  unsigned int uiPatchHeight = uiBlkHeight + TMP_TEMPLATE_SIZE;
#endif

#if TMP_FAST_ENC
  foundCandiNum = cu->tmpNumCand;
#else
  foundCandiNum = m_uiVaildCandiNum;
#endif
  if( foundCandiNum < 1 )
  {
    return false;
  }

#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
  Pel* pPred = piPred;
#endif

#if TMP_FAST_ENC
  int pX = cu->tmpXdisp;
  int pY = cu->tmpYdisp;
#else
  int pX = m_tempLibFast.getX();
  int pY = m_tempLibFast.getY();
  Pel* ref;
  int picStride = getStride();
#endif
  int iOffsetY, iOffsetX;
  Pel* refTarget;
#if TMP_FAST_ENC
  int uiHeight = area.height;
  int uiWidth = area.width;
  Pel* ref = cu->cs->picture->getRecoBuf(area).buf;
  int picStride = cu->cs->picture->getRecoBuf(area).stride;
#else
  unsigned int uiHeight = uiPatchHeight - TMP_TEMPLATE_SIZE;
  unsigned int uiWidth = uiPatchWidth - TMP_TEMPLATE_SIZE;

  //the data center: we use the prediction block as the center now.
  //collect the candidates
  ref = getRefPicUsed();
#endif
  iOffsetY  = pY;
  iOffsetX  = pX;
  refTarget = ref + iOffsetY * picStride + iOffsetX;
  for (unsigned int uiY = 0; uiY < uiHeight; uiY++)
  {
    for (unsigned int uiX = 0; uiX < uiWidth; uiX++)
    {
      piPred[uiX] = refTarget[uiX];
    }
    refTarget += picStride;
    piPred += uiStride;
  }

#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
  CPelBuf predBuf(pPred, uiStride, uiWidth, uiHeight);
#if JVET_AI0050_INTER_MTSS
  int secondDimdIntraDir = 0;
#endif
  cu->intraTmpDimdMode = deriveIpmForTransform(predBuf, *cu
#if JVET_AI0050_INTER_MTSS
    , secondDimdIntraDir
#endif
  );
#if JVET_AI0050_INTER_MTSS
  cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
#endif
  return bSucceedFlag;
}
#endif

#if JVET_AB0061_ITMP_BV_FOR_IBC
#if JVET_AD0086_ENHANCED_INTRA_TMP
bool IntraPrediction::generateTMPrediction(Pel *piPred, unsigned int uiStride, int &foundCandiNum, PredictionUnit &pu
#if JVET_AG0136_INTRA_TMP_LIC
                                           , const bool useMR
#endif
                                           , bool bDeriveDimdMode)
#else
bool IntraPrediction::generateTMPrediction(Pel *piPred, unsigned int uiStride, int &foundCandiNum, PredictionUnit &pu)
#endif
{
  bool         bSucceedFlag  = true;
#if !TMP_FAST_ENC
  unsigned int uiPatchWidth  = pu.lwidth() + TMP_TEMPLATE_SIZE;
  unsigned int uiPatchHeight = pu.lheight() + TMP_TEMPLATE_SIZE;
#endif

#if TMP_FAST_ENC
#if JVET_AG0136_INTRA_TMP_LIC
  foundCandiNum = useMR ? m_tmpNumCandUseMR : m_tmpNumCand;
#else
  foundCandiNum = m_tmpNumCand;
#endif
#else
  foundCandiNum = m_uiVaildCandiNum;
#endif
  if (foundCandiNum < 1)
  {
    return false;
  }

#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
  Pel* pPred = piPred;
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
  CodingUnit *cu         = pu.cu;
  CompArea    area       = pu.Y();
  int         uiHeight   = area.height;
  int         uiWidth    = area.width;
  Pel *       ref        = cu->cs->picture->getRecoBuf(area).buf;
  int         picStride  = cu->cs->picture->getRecoBuf(area).stride;
#if JVET_AG0136_INTRA_TMP_LIC
  int pX = (useMR ? m_tmpXdispUseMR : m_tmpXdisp)[0];
  int pY = (useMR ? m_tmpYdispUseMR : m_tmpYdisp)[0];
#else
  int         pX         = m_tmpXdisp[0];
  int         pY         = m_tmpYdisp[0];
#endif

  bool bTmpFusion   = cu->tmpFusionFlag;
  int  tmpFusionNum = 0;
  int  tmpFusionIdx = 0;
  if (bTmpFusion)
  {
#if JVET_AG0136_INTRA_TMP_LIC
    const IntraTMPFusionInfo& tmpFusionInfo = (useMR ? m_tmpFusionInfoUseMR : m_tmpFusionInfo)[cu->tmpIdx];
    const bool bFilter = tmpFusionInfo.bFilter;
    tmpFusionNum = tmpFusionInfo.tmpFusionNumber;
#else
    bool bFilter      = m_tmpFusionInfo[cu->tmpIdx].bFilter;
    tmpFusionNum      = m_tmpFusionInfo[cu->tmpIdx].tmpFusionNumber;
#endif
    if (tmpFusionNum < 1 || bFilter)
    {
      return bSucceedFlag;
    }
#if JVET_AG0136_INTRA_TMP_LIC
    tmpFusionIdx  = tmpFusionInfo.tmpFusionIdx;
    pX         = (useMR ? m_tmpXdispUseMR : m_tmpXdisp)[tmpFusionIdx];
    pY         = (useMR ? m_tmpYdispUseMR : m_tmpYdisp)[tmpFusionIdx];
#else
    tmpFusionIdx      = m_tmpFusionInfo[cu->tmpIdx].tmpFusionIdx;
    pX         = m_tmpXdisp[tmpFusionIdx];
    pY         = m_tmpYdisp[tmpFusionIdx];
#endif
  }

  if (bTmpFusion)
  {
    const int log2WeightSum = 6;
#if JVET_AG0136_INTRA_TMP_LIC
    const int* const pDiff = (useMR ? m_tmpFusionInfoUseMR : m_tmpFusionInfo)[cu->tmpIdx].tmpFusionWeight;
#else
    int *pDiff = m_tmpFusionInfo[cu->tmpIdx].tmpFusionWeight;
#endif
    Pel *refTarget[TMP_FUSION_NUM];
#if JVET_AG0136_INTRA_TMP_LIC
    if (useMR)
    {
      for (int i = 0; i < tmpFusionNum; i++)
      {
        Pel* ptrTemp = &arrayTemp[i][0];
        const Pel* ptrTarCurr = ref + m_tmpYdispUseMR[i + tmpFusionIdx] * picStride + m_tmpXdispUseMR[i + tmpFusionIdx];
        for (int j = 0; j < uiHeight; j++)
        {
          memcpy(ptrTemp, ptrTarCurr, uiWidth * sizeof(Pel));
          ptrTemp += uiWidth;
          ptrTarCurr += picStride;
        }
        PelBuf bufferTemp(arrayTemp[i], uiWidth, uiWidth, uiHeight);
        const int* const ptrLicInd = &getMemLicParams(0, i + tmpFusionIdx)[0];
        bufferTemp.linearTransform(ptrLicInd[1], ptrLicInd[0], ptrLicInd[2], true, (cu->cs)->slice->clpRng(COMPONENT_Y));
        refTarget[i] = &arrayTemp[i][0];
      }
    }
    else
    {
      for (int i = 0; i < tmpFusionNum; i++)
      {
        refTarget[i] = ref + m_tmpYdisp[i + tmpFusionIdx] * picStride + m_tmpXdisp[i + tmpFusionIdx];
      }
    }
    const int strideUsed = useMR ? uiWidth : picStride;
    switch (tmpFusionNum)
    {
      case 1:
        tmpFusionBlending<1>(refTarget, pDiff, piPred, uiHeight, uiWidth, log2WeightSum, strideUsed, uiStride);
        break;
      case 2:
        tmpFusionBlending<2>(refTarget, pDiff, piPred, uiHeight, uiWidth, log2WeightSum, strideUsed, uiStride);
        break;
      case 3:
        tmpFusionBlending<3>(refTarget, pDiff, piPred, uiHeight, uiWidth, log2WeightSum, strideUsed, uiStride);
        break;
      case 4:
        tmpFusionBlending<4>(refTarget, pDiff, piPred, uiHeight, uiWidth, log2WeightSum, strideUsed, uiStride);
        break;
      case 5:
        tmpFusionBlending<5>(refTarget, pDiff, piPred, uiHeight, uiWidth, log2WeightSum, strideUsed, uiStride);
        break;
      default:
        CHECK(true, "`tmpFusionNum` does not belong to [|1, 5|].");
        break;
    }
#else
    for (int i = 0; i < tmpFusionNum; i++)
    {
      refTarget[i] = ref + m_tmpYdisp[i + tmpFusionIdx] * picStride + m_tmpXdisp[i + tmpFusionIdx];
    }
    const int shift = 1 << (log2WeightSum - 1);
    for (unsigned int uiY = 0; uiY < uiHeight; uiY++)
    {
      for (unsigned int uiX = 0; uiX < uiWidth; uiX++)
      {
        int blend = shift;

        for (int i = 0; i < tmpFusionNum; i++)
        {
          blend += (pDiff[i] * refTarget[i][uiX]);
        }
        piPred[uiX] = (Pel)(blend >> log2WeightSum);
      }
      for (int i = 0; i < tmpFusionNum; i++)
      {
        refTarget[i] += picStride;
      }
      piPred += uiStride;
    }
#endif
  }
  else
  {
#if JVET_AG0136_INTRA_TMP_LIC
    pX = (useMR ? m_tmpXdispUseMR : m_tmpXdisp)[cu->tmpIdx];
    pY = (useMR ? m_tmpYdispUseMR : m_tmpYdisp)[cu->tmpIdx];
#else
    pX                            = m_tmpXdisp[cu->tmpIdx];
    pY                            = m_tmpYdisp[cu->tmpIdx];
#endif
    Pel *            refTarget    = ref + pY * picStride + pX;
    int              tmpIsSubPel  = cu->tmpIsSubPel;
    int              tmpSubPelIdx = cu->tmpSubPelIdx;
#if !JVET_AH0200_INTRA_TMP_BV_REORDER
    TmpSubPelDirType tmpSubPelDir = tmpIsSubPel ? (TmpSubPelDirType) tmpSubPelIdx : LEFT_POS;

    const UnitArea localUnitArea(cu->firstPU->chromaFormat,
                                 Area(0, 0, uiWidth + 2 * TMP_SUBPEL_PAD_NUM, uiHeight + 2 * TMP_SUBPEL_PAD_NUM));
    PelBuf         predBuffer = m_tempBuffer[0].getBuf(localUnitArea.Y());
    int            dstStride  = predBuffer.stride;
    Pel *          dst0       = predBuffer.buf + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM * dstStride;
    Pel *          dst        = dst0;
    const ClpRng & clpRng(cu->cs->slice->clpRng(COMPONENT_Y));

    const TFilterCoeff *const f0 = InterpolationFilter::getChromaFilterTable(16);   // 1/2
    const TFilterCoeff *const f1 = InterpolationFilter::getChromaFilterTable(8);    // 1/4
    const TFilterCoeff *const f2 = InterpolationFilter::getChromaFilterTable(24);   // 3/4
#endif

    if (tmpIsSubPel == 0) // int-pel
    {
      for (unsigned int uiY = 0; uiY < uiHeight; uiY++)
      {
        memcpy(piPred, refTarget, uiWidth * sizeof(Pel));
        refTarget += picStride;
        piPred += uiStride;
      }
    }
#if !JVET_AH0200_INTRA_TMP_BV_REORDER
    else if (tmpSubPelDir < ABOVE_LEFT_POS)
    {
      const TFilterCoeff *p = f0;
      if (tmpSubPelDir == LEFT_POS || tmpSubPelDir == ABOVE_POS)
      {
        p = (tmpIsSubPel == 1) ? f0 : ((tmpIsSubPel == 2) ? f2 : f1);
      }
      else
      {
        p = (tmpIsSubPel == 1) ? f0 : ((tmpIsSubPel == 2) ? f1 : f2);
      }

      if (tmpSubPelDir == LEFT_POS) // left
      {
        m_if.m_filterHor[3][1][true](clpRng, dst - 1, dstStride, piPred, uiStride, uiWidth, uiHeight, p, false);
      }
      else if (tmpSubPelDir == RIGHT_POS) // right
      {
        m_if.m_filterHor[3][1][true](clpRng, dst, dstStride, piPred, uiStride, uiWidth, uiHeight, p, false);
      }
      else if (tmpSubPelDir == ABOVE_POS) // top
      {
        m_if.m_filterVer[3][true][true](clpRng, dst - dstStride, dstStride, piPred, uiStride, uiWidth, uiHeight, p, false);
      }
      else // bottom
      {
        m_if.m_filterVer[3][true][true](clpRng, dst, dstStride, piPred, uiStride, uiWidth, uiHeight, p, false);
      }
    }
    else
    {
      PelBuf tmpBuffer = m_tempBuffer[1].getBuf(localUnitArea.Y());
      int    tmpStride = tmpBuffer.stride;
      Pel *  tmp0      = tmpBuffer.buf + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM * tmpStride;
      Pel *  tmp       = tmp0 - TMP_SUBPEL_PAD_NUM * tmpStride;
      dst              = dst0 - TMP_SUBPEL_PAD_NUM * dstStride;

      const TFilterCoeff *p = f0;
      // hor
      if (tmpSubPelDir == ABOVE_LEFT_POS || tmpSubPelDir == LEFT_BOTTOM_POS) // left
      {
        p = (tmpIsSubPel == 1) ? f0 : ((tmpIsSubPel == 2) ? f2 : f1);
        m_if.m_filterHor[3][1][true](clpRng, dst - 1, dstStride, tmp, tmpStride, uiWidth, uiHeight + 2 * TMP_SUBPEL_PAD_NUM, p, false);
      }
      else // right
      {
        p = (tmpIsSubPel == 1) ? f0 : ((tmpIsSubPel == 2) ? f1 : f2);
        m_if.m_filterHor[3][1][true](clpRng, dst, dstStride, tmp, tmpStride, uiWidth, uiHeight + 2 * TMP_SUBPEL_PAD_NUM, p, false);
      }

      // ver
      tmp = tmp0;
      if (tmpSubPelDir == ABOVE_LEFT_POS || tmpSubPelDir == ABOVE_RIGHT_POS) // top
      {
        p = (tmpIsSubPel == 1) ? f0 : ((tmpIsSubPel == 2) ? f2 : f1);
        m_if.m_filterVer[3][true][true](clpRng, tmp - tmpStride, tmpStride, piPred, uiStride, uiWidth, uiHeight, p, false);
      }
      else // bottom
      {
        p = (tmpIsSubPel == 1) ? f0 : ((tmpIsSubPel == 2) ? f1 : f2);
        m_if.m_filterVer[3][true][true](clpRng, tmp, tmpStride, piPred, uiStride, uiWidth, uiHeight, p, false);
      }
    }
#endif
#if JVET_AF0079_STORING_INTRATMP
    if (tmpIsSubPel != 0)   
    {
      int absDistance = (tmpIsSubPel == 1) ? 8 : (tmpIsSubPel == 2) ? 4 : 12;
      int xDistance = 0, yDistance = 0;
      if ((tmpSubPelIdx == LEFT_POS) || (tmpSubPelIdx == ABOVE_LEFT_POS) || (tmpSubPelIdx == LEFT_BOTTOM_POS))
      {
        xDistance = -absDistance;
      }
      if ((tmpSubPelIdx == RIGHT_POS) || (tmpSubPelIdx == ABOVE_RIGHT_POS) || (tmpSubPelIdx == RIGHT_BOTTOM_POS))
      {
        xDistance = absDistance;
      }
      if ((tmpSubPelIdx == ABOVE_POS) || (tmpSubPelIdx == ABOVE_LEFT_POS) || (tmpSubPelIdx == ABOVE_RIGHT_POS))
      {
        yDistance = -absDistance;
      }
      if ((tmpSubPelIdx == BOTTOM_POS) || (tmpSubPelIdx == LEFT_BOTTOM_POS) || (tmpSubPelIdx == RIGHT_BOTTOM_POS))
      {
        yDistance = absDistance;
      }
      const int iHor = (pX << MV_FRACTIONAL_BITS_INTERNAL) + xDistance;
      const int iVer = (pY << MV_FRACTIONAL_BITS_INTERNAL) + yDistance;
      pu.mv[0].set(iHor, iVer);

      pu.bv.set(pX, pY);
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      PelUnitBuf tempPUBuf(pu.chromaFormat, PelBuf(piPred, uiStride, uiWidth, uiHeight));
      m_pcInterPred->getPredIBCBlk(pu, COMPONENT_Y, cu->cs->picture, pu.mv[0], tempPUBuf, false, true);
#endif
    }
#endif
  }
#else
#if TMP_FAST_ENC
  int pX = pu.cu->tmpXdisp;
  int pY = pu.cu->tmpYdisp;
#else
  int          pX = m_tempLibFast.getX();
  int          pY = m_tempLibFast.getY();
#endif
  Pel *        ref;
#if !TMP_FAST_ENC
  int          picStride = getStride();
#endif
  int          iOffsetY, iOffsetX;
  Pel *        refTarget;
#if TMP_FAST_ENC
  CompArea area = pu.Y();
  int uiHeight = area.height;
  int uiWidth = area.width;
  ref = pu.cu->cs->picture->getRecoBuf(area).buf;
  int picStride = pu.cu->cs->picture->getRecoBuf(area).stride;
#else
  unsigned int uiHeight = uiPatchHeight - TMP_TEMPLATE_SIZE;
  unsigned int uiWidth  = uiPatchWidth - TMP_TEMPLATE_SIZE;

  // the data center: we use the prediction block as the center now.
  // collect the candidates
  ref = getRefPicUsed();
#endif
  iOffsetY  = pY;
  iOffsetX  = pX;
  refTarget = ref + iOffsetY * picStride + iOffsetX;
  for (unsigned int uiY = 0; uiY < uiHeight; uiY++)
  {
    for (unsigned int uiX = 0; uiX < uiWidth; uiX++)
    {
      piPred[uiX] = refTarget[uiX];
    }
    refTarget += picStride;
    piPred += uiStride;
  }
#endif

  pu.interDir               = 1;
  pu.refIdx[REF_PIC_LIST_0] = MAX_NUM_REF;
#if JVET_AF0079_STORING_INTRATMP
  if ((cu->tmpIsSubPel == 0) || (cu->tmpIsSubPel == -1))
  {
    pu.mv[0].set(pX << MV_FRACTIONAL_BITS_INTERNAL, pY << MV_FRACTIONAL_BITS_INTERNAL);
    pu.bv.set(pX, pY);
  }
#else
  pu.mv->set(pX << MV_FRACTIONAL_BITS_INTERNAL, pY << MV_FRACTIONAL_BITS_INTERNAL);
  pu.bv.set(pX, pY);
#endif

#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
#if JVET_AD0086_ENHANCED_INTRA_TMP
  if (bDeriveDimdMode)
  {
#endif
    CPelBuf predBuf(pPred, uiStride, uiWidth, uiHeight);
#if JVET_AI0050_INTER_MTSS
    int secondDimdIntraDir = 0;
#endif
    pu.cu->intraTmpDimdMode = deriveIpmForTransform(predBuf, *pu.cu
#if JVET_AI0050_INTER_MTSS
      , secondDimdIntraDir
#endif
    );
#if JVET_AI0050_INTER_MTSS
    pu.cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
#if JVET_AD0086_ENHANCED_INTRA_TMP
  }
#endif
#endif

  return bSucceedFlag;
}

#if JVET_AH0200_INTRA_TMP_BV_REORDER
void IntraPrediction::xPadForFracSearchInterpolation(CodingUnit *cu, RefTemplateType tempType)
{
  CodingStructure &cs       = *cu->cs;
  int              extW     = (tempType != ABOVE_TEMPLATE)?TMP_TEMPLATE_SIZE:0;
  int              extH     = (tempType != LEFT_TEMPLATE)?TMP_TEMPLATE_SIZE:0;

  if (tempType == NO_TEMPLATE)
  {
    CHECK(1, "tempType == NO_TEMPLATE");
  }

  Position pos = cu->Y().offset(m_tmpXdisp[cu->tmpIdx] - extW, m_tmpYdisp[cu->tmpIdx] - extH);
  if(cu->tmpLicFlag)
  {
    pos = cu->Y().offset(m_tmpXdispUseMR[cu->tmpIdx] - extW, m_tmpYdispUseMR[cu->tmpIdx] - extH);
  }
  CHECK(pos.x < 0, "pos.x < 0");
  CHECK(pos.y < 0, "pos.y < 0");
  int            extUiWidth  = cu->lwidth() + extW;

  int            extUiHeight = cu->lheight() + extH;
  const UnitArea localUnitArea(cu->firstPU->chromaFormat,
                               Area(0, 0, extUiWidth + 2 * TMP_SUBPEL_PAD_NUM, extUiHeight + 2 * TMP_SUBPEL_PAD_NUM));
  PelBuf         dstBuffer = m_tempBuffer[0].getBuf(localUnitArea.Y());
  int            dstStride = dstBuffer.stride;
  Pel *          dst0      = dstBuffer.buf + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM * dstStride;
  Pel *          dst       = dst0;

  int  srcStride = cu->cs->picture->getRecoBuf(cu->firstPU->Y()).stride;
  Pel *src0 =
    cu->cs->picture->getRecoBuf(cu->firstPU->Y()).buf + m_tmpXdisp[cu->tmpIdx] - extW + (m_tmpYdisp[cu->tmpIdx] - extH) * srcStride;	
  if(cu->tmpLicFlag)
  {
    src0 = cu->cs->picture->getRecoBuf(cu->firstPU->Y()).buf + m_tmpXdispUseMR[cu->tmpIdx] - extW + (m_tmpYdispUseMR[cu->tmpIdx] - extH) * srcStride;
  }
  Pel *src = src0;

  Pel * curDst = dstBuffer.buf;
  Pel * curSrc = src - TMP_SUBPEL_PAD_NUM - TMP_SUBPEL_PAD_NUM * srcStride;
  int copyWidth = ((extUiWidth + 3) >> 2) << 2;
  CHECK(extUiWidth != copyWidth, "extUiWidth != copyWidth");
  copyWidth += TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM;
  int copyHeight = TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM;
  if(tempType != LEFT_TEMPLATE)
  {
      m_if.m_filterCopy[true][true]( cu->cs->slice->clpRng(COMPONENT_Y), curSrc, srcStride, curDst, dstStride, copyWidth, copyHeight, false );
      if(tempType == L_SHAPE_TEMPLATE)
      {
        curSrc = src - TMP_SUBPEL_PAD_NUM + (TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM) * srcStride;
        curDst = dstBuffer.buf + (TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM) * dstStride;
        copyWidth = TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM;
        copyHeight = cu->lheight();
        m_if.m_filterCopy[true][true]( cu->cs->slice->clpRng(COMPONENT_Y), curSrc, srcStride, curDst, dstStride, copyWidth, copyHeight, false );
      }
  }
  else
  {
    copyWidth = TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM;
    copyHeight = extUiHeight + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM;
    m_if.m_filterCopy[true][true]( cu->cs->slice->clpRng(COMPONENT_Y), curSrc, srcStride, curDst, dstStride, copyWidth, copyHeight, false );
  }

  int paddingWidth = extUiWidth;
  if(tempType == LEFT_TEMPLATE)
  {
    paddingWidth = TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM;
  }
  for (int j = -1; j >= -TMP_SUBPEL_PAD_NUM; j--)
  {
    if(!cs.isDecomp(pos.offset(0, j), CHANNEL_TYPE_LUMA))
    {
      curDst = dst + j * dstStride;
      curSrc = dst + (j+1) * dstStride;
      memcpy(curDst, curSrc, paddingWidth * sizeof(Pel));
    }
  }

  if(tempType != ABOVE_TEMPLATE)
  {
    paddingWidth = TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM;
    for (int j = extUiHeight; j < extUiHeight + TMP_SUBPEL_PAD_NUM; j++)
    {
      for (int i = 0; i < paddingWidth; i++)
      {
        if(!cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA))
        {
          curDst = dst + j * dstStride + i;
          curSrc = dst + (j-1) * dstStride + i;
          memcpy(curDst, curSrc, (paddingWidth - i) * sizeof(Pel));
          break;
        }
      }
    }
  }
  
  int paddingHeight = extUiHeight;
  if(tempType == ABOVE_TEMPLATE)
  {
    paddingHeight = TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM;
  }
  for (int i = -1; i >= -TMP_SUBPEL_PAD_NUM; i--)
  {
    curDst = dst -  dstStride;
    if(!cs.isDecomp(pos.offset(i, 0), CHANNEL_TYPE_LUMA))
    {
      for (int j = 0; j < paddingHeight; j++)
      {
        curDst += dstStride;
        for(int idx = i; idx >= -TMP_SUBPEL_PAD_NUM; idx--)
        {
          curDst[idx] = curDst[idx+1];
        }
      }  
      break;
    }
  }

  curDst = dst - (TMP_SUBPEL_PAD_NUM + 1) * dstStride;
  if(tempType == ABOVE_TEMPLATE)
  {
    paddingHeight = -TMP_SUBPEL_PAD_NUM;
  }
  for (int j = -TMP_SUBPEL_PAD_NUM; j < paddingHeight + TMP_SUBPEL_PAD_NUM; j++)
  {
    curDst += dstStride;
    for (int i = -1; i >= -TMP_SUBPEL_PAD_NUM; i--)
    {
      if(j > -1 && j < extUiHeight)
      {
        break;
      }

      if(!cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA))
      {
        for(int idx = i; idx >= -TMP_SUBPEL_PAD_NUM; idx--)
        {
          curDst[idx] = curDst[idx+1];
        }
        break;
      }
    }
  }
  if(tempType != LEFT_TEMPLATE)
  {
    curDst = dst - (TMP_SUBPEL_PAD_NUM + 1) * dstStride;
    for (int j = -TMP_SUBPEL_PAD_NUM; j < TMP_TEMPLATE_SIZE + TMP_SUBPEL_PAD_NUM; j++)
    {
      curDst += dstStride;
      for (int i = extUiWidth; i < extUiWidth + TMP_SUBPEL_PAD_NUM; i++)
      {
        if(!cs.isDecomp(pos.offset(i, j), CHANNEL_TYPE_LUMA))
        {
          for(int idx = i; idx < extUiWidth + TMP_SUBPEL_PAD_NUM; idx++)
          {
            curDst[idx] = curDst[idx-1];
          }
          break;
        }
      }
    }
  }
}

void IntraPrediction::xTmpFracSearchIF(PredictionUnit& pu, Pel* padbf0, unsigned int padStride, Pel* preTmpbf0, unsigned int predTempStride, 
                                     Pel* tmp0, unsigned int tmpStride, int extUiWidth, int extUiHeight, int fracPrec, int fracDir)
{
  CodingUnit *cu          = pu.cu;
  const ClpRng & clpRng(cu->cs->slice->clpRng(COMPONENT_Y));
  const TFilterCoeff *const f0 = InterpolationFilter::getExtIntraCubicFilter(32);
  const TFilterCoeff *const f1 = InterpolationFilter::getExtIntraCubicFilter(16);
  const TFilterCoeff *const f2 = InterpolationFilter::getExtIntraCubicFilter(48);
  const TFilterCoeff *p = f0;
  Pel *padBf    = padbf0;
  Pel *preTmpbf = preTmpbf0;
  Pel *tmp      = tmp0;

  if(fracPrec == 0)
  {
    for (unsigned int uiY = 0; uiY < extUiHeight; uiY++)
    {
      memcpy(preTmpbf, padBf, extUiWidth * sizeof(Pel));
      padBf += padStride;
      preTmpbf += predTempStride;
    }          
  }
  else if (fracDir < ABOVE_LEFT_POS)
  {
    if (fracDir == LEFT_POS || fracDir == ABOVE_POS)
    {
      p = (fracPrec == 1) ? f0 : ((fracPrec == 2) ? f2 : f1);
    }
    else
    {
      p = (fracPrec == 1) ? f0 : ((fracPrec == 2) ? f1 : f2);
    }

    if (fracDir == LEFT_POS) // left
    {
      m_if.m_filterHor[3][1][true](clpRng, padBf - 1, padStride, preTmpbf, predTempStride, extUiWidth, extUiHeight, p, false);
    }
    else if (fracDir == RIGHT_POS) // right
    {
      m_if.m_filterHor[3][1][true](clpRng, padBf, padStride, preTmpbf, predTempStride, extUiWidth, extUiHeight, p, false);
    }
    else if (fracDir == ABOVE_POS) // top
    {
      m_if.m_filterVer[3][true][true](clpRng, padBf - padStride, padStride, preTmpbf, predTempStride, extUiWidth, extUiHeight, p, false);
    }
    else // bottom
    {
      m_if.m_filterVer[3][true][true](clpRng, padBf, padStride, preTmpbf, predTempStride, extUiWidth, extUiHeight, p, false);
    }
  }
  else
  {
    tmp = tmp0 - TMP_SUBPEL_PAD_NUM * tmpStride;
    padBf = padbf0 - TMP_SUBPEL_PAD_NUM * padStride;
    // hor
    if (fracDir == ABOVE_LEFT_POS || fracDir == LEFT_BOTTOM_POS) // left
    {
      p = (fracPrec == 1) ? f0 : ((fracPrec == 2) ? f2 : f1);
      m_if.m_filterHor[3][1][true](clpRng, padBf - 1, padStride, tmp, tmpStride, extUiWidth, extUiHeight + 2 * TMP_SUBPEL_PAD_NUM, p, false);
    }
    else // right
    {
      p = (fracPrec == 1) ? f0 : ((fracPrec == 2) ? f1 : f2);
      m_if.m_filterHor[3][1][true](clpRng, padBf, padStride, tmp, tmpStride, extUiWidth, extUiHeight + 2 * TMP_SUBPEL_PAD_NUM, p, false);
    }

    // ver
    tmp = tmp0;
    if (fracDir == ABOVE_LEFT_POS || fracDir == ABOVE_RIGHT_POS) // top
    {
      p = (fracPrec == 1) ? f0 : ((fracPrec == 2) ? f2 : f1);
      m_if.m_filterVer[3][true][true](clpRng, tmp - tmpStride, tmpStride, preTmpbf, predTempStride, extUiWidth, extUiHeight, p, false);
    }
    else // bottom
    {
      p = (fracPrec == 1) ? f0 : ((fracPrec == 2) ? f1 : f2);
      m_if.m_filterVer[3][true][true](clpRng, tmp, tmpStride, preTmpbf, predTempStride, extUiWidth, extUiHeight, p, false);
    }
  }
}

TempLibFracFast::TempLibFracFast()
{
}

TempLibFracFast::~TempLibFracFast()
{
}

#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
void IntraPrediction::searchFracCandidate(CodingUnit* pcCU, Pel* tarPatch, RefTemplateType tempType)
#else
void IntraPrediction::searchFracCandidate( CodingUnit* pcCU, Pel** tarPatch, RefTemplateType tempType)
#endif
{
  const int tmpIdx = pcCU->tmpIdx;
  m_mtmpFracCandList[tmpIdx].clear();
  m_mtmpFracCostList[tmpIdx].clear();  
  int      fracmtmpNum[3] = { TMP_BV_REORDER_MAX, TMP_BV_REORDER_MAX, TMP_BV_REORDER_MAX };
  int         diff[3]     = {MAX_INT, MAX_INT, MAX_INT};
  int         pDiff[3]    = {MAX_INT, MAX_INT, MAX_INT};
  int         extW        = (tempType != ABOVE_TEMPLATE)?TMP_TEMPLATE_SIZE:0;
  int         extH        = (tempType != LEFT_TEMPLATE)?TMP_TEMPLATE_SIZE:0;
  int         extUiWidth  = pcCU->lwidth() + extW;
  int         extUiHeight = pcCU->lheight() + extH;

  const UnitArea localUnitArea(pcCU->firstPU->chromaFormat,
                                Area(0, 0, extUiWidth + 2 * TMP_SUBPEL_PAD_NUM, extUiHeight + 2 * TMP_SUBPEL_PAD_NUM));

  PelBuf         padBuffer  = m_tempBuffer[0].getBuf(localUnitArea.Y());
  int            padStride  = padBuffer.stride;
  Pel *          padbf0     = padBuffer.buf + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM * padStride;

  PelBuf         predTempBuffer  = m_tempBuffer[2].getBuf(localUnitArea.Y());
  int            predTempStride  = predTempBuffer.stride;
  Pel *          preTmpbf0       = predTempBuffer.buf + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM * predTempStride;
  Pel *          refCurr         = preTmpbf0 + extW + extH * predTempStride;

  PelBuf tmpBuffer = m_tempBuffer[1].getBuf(localUnitArea.Y());
  int    tmpStride = tmpBuffer.stride;
  Pel *  tmp0      = tmpBuffer.buf + TMP_SUBPEL_PAD_NUM + TMP_SUBPEL_PAD_NUM * tmpStride;

  Pel* padbfPart1       = padbf0;
  Pel* padbfPart2       = padbf0 + TMP_TEMPLATE_SIZE * padStride;
  Pel* preTmpbfPart1    = preTmpbf0;
  Pel* preTmpbfPart2    = preTmpbf0 + TMP_TEMPLATE_SIZE * predTempStride;
  Pel* tmpbfPart1       = tmp0;
  Pel* tmpbfPart2       = tmp0 + TMP_TEMPLATE_SIZE * tmpStride;;
  int  tmpPart1IFWidth  = extUiWidth;
  int  tmpPart1IFHeight = TMP_TEMPLATE_SIZE;
  int  tmpPart2IFWidth  = TMP_TEMPLATE_SIZE;
  int  tmpPart2IFHeight = pcCU->lheight();
  if(tempType == LEFT_TEMPLATE)
  {
    tmpPart1IFWidth  = TMP_TEMPLATE_SIZE;
    tmpPart1IFHeight = pcCU->lheight();
  }

  xPadForFracSearchInterpolation(pcCU, tempType);
  pDiff[0] = MAX_INT;

  xTmpFracSearchIF(*pcCU->firstPU, padbfPart1, padStride, preTmpbfPart1, predTempStride, tmpbfPart1, tmpStride, tmpPart1IFWidth, tmpPart1IFHeight, 0, -1);
  if(tempType == L_SHAPE_TEMPLATE)
  {
    xTmpFracSearchIF(*pcCU->firstPU, padbfPart2, padStride, preTmpbfPart2, predTempStride, tmpbfPart2, tmpStride, tmpPart2IFWidth, tmpPart2IFHeight, 0, -1);
  }

  if(pcCU->tmpLicFlag)
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    m_calcTemplateDiff(refCurr, predTempStride, tarPatch, m_uiPicStride, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, true
#else
    m_calcTemplateDiff(refCurr, predTempStride, tarPatch, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, true
#endif
            , m_log2SizeTop
            , m_log2SizeLeft
            , m_sizeTopLeft
            , m_topMeanTar
            , m_leftMeanTar);    
  }
  else
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    m_calcTemplateDiff(refCurr, predTempStride, tarPatch, m_uiPicStride, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, false, 0, 0, 0, 0, 0);
#else
    m_calcTemplateDiff(refCurr, predTempStride, tarPatch, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, false, 0, 0, 0, 0, 0);
#endif
  }

  diff[0] = (int) (diff[0] * TMP_INT_BV_COST_SCALE);
  updateCandList(TempLibFracFast(0, 0), diff[0], m_mtmpFracCandList[tmpIdx], m_mtmpFracCostList[tmpIdx], fracmtmpNum[0]);


  if(m_mtmpFracCandList[tmpIdx].size() >= fracmtmpNum[0])
  {
    pDiff[0] = std::min((int) m_mtmpFracCostList[tmpIdx][fracmtmpNum[0]-1], pDiff[0]);
  }

  for(int fracPrec = 1; fracPrec < 3; fracPrec++)
  {
    for (int fracDir = 0; fracDir < 8; fracDir++)
    {
      if(!fracPrec && fracDir > 0)
      {
        break;
      }

      xTmpFracSearchIF(*pcCU->firstPU, padbfPart1, padStride, preTmpbfPart1, predTempStride, tmpbfPart1, tmpStride, tmpPart1IFWidth, tmpPart1IFHeight, fracPrec, fracDir);
      if(tempType == L_SHAPE_TEMPLATE)
      {
        xTmpFracSearchIF(*pcCU->firstPU, padbfPart2, padStride, preTmpbfPart2, predTempStride, tmpbfPart2, tmpStride, tmpPart2IFWidth, tmpPart2IFHeight, fracPrec, fracDir);
      }

      if(pcCU->tmpLicFlag)
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        m_calcTemplateDiff(refCurr, predTempStride, tarPatch, m_uiPicStride, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, true
#else
        m_calcTemplateDiff(refCurr, predTempStride, tarPatch, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, true
#endif
                , m_log2SizeTop
                , m_log2SizeLeft
                , m_sizeTopLeft
                , m_topMeanTar
                , m_leftMeanTar);    
      }
      else
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        m_calcTemplateDiff(refCurr, predTempStride, tarPatch, m_uiPicStride, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, false, 0, 0, 0, 0, 0);
#else
        m_calcTemplateDiff(refCurr, predTempStride, tarPatch, pcCU->lwidth() + TMP_TEMPLATE_SIZE, pcCU->lheight() + TMP_TEMPLATE_SIZE, diff, pDiff, tempType, 0, false, 0, 0, 0, 0, 0);
#endif
      }
      if (diff[0] < pDiff[0])
      {
        updateCandList(TempLibFracFast(fracPrec, fracDir), diff[0],
                        m_mtmpFracCandList[tmpIdx], m_mtmpFracCostList[tmpIdx], fracmtmpNum[0]);
        if(m_mtmpFracCandList[tmpIdx].size() >= fracmtmpNum[0])
        {
          pDiff[0] = std::min((int) m_mtmpFracCostList[tmpIdx][fracmtmpNum[0]-1], pDiff[0]);
        }
      }
    }
  }
  if(!pcCU->cs->pcv->isEncoder && pcCU->tmpFracIdx >= 0 )
  {
    pcCU->tmpIsSubPel  = m_mtmpFracCandList[pcCU->tmpIdx][pcCU->tmpFracIdx].m_subpel;
    pcCU->tmpSubPelIdx = m_mtmpFracCandList[pcCU->tmpIdx][pcCU->tmpFracIdx].m_fracDir;        
  }
}

void IntraPrediction::setInterPrediction(InterPrediction* inter)
{
  m_pcInterPred     = inter;
}
#endif
#endif

#if JVET_W0069_TMP_BOUNDARY
#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST 
bool IntraPrediction::generateTmDcPrediction(Pel* piPred, unsigned int uiStride, unsigned int uiBlkWidth, unsigned int uiBlkHeight, int DC_Val, CodingUnit* cu)
#else
bool IntraPrediction::generateTmDcPrediction( Pel* piPred, unsigned int uiStride, unsigned int uiBlkWidth, unsigned int uiBlkHeight, int DC_Val )
#endif
{
#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
  Pel* pPred = piPred;
#endif
  bool bSucceedFlag = true;
  {
    for( unsigned int uiY = 0; uiY < uiBlkHeight; uiY++ )
    {
      for( unsigned int uiX = 0; uiX < uiBlkWidth; uiX++ )
      {
        piPred[uiX] = DC_Val;
      }
      piPred += uiStride;
    }
  }
#if JVET_AC0115_INTRA_TMP_DIMD_MTS_LFNST
  CPelBuf predBuf(pPred, uiStride, uiBlkWidth, uiBlkHeight);
#if JVET_AI0050_INTER_MTSS
  int secondDimdIntraDir = 0;
#endif
  cu->intraTmpDimdMode = deriveIpmForTransform(predBuf, *cu
#if JVET_AI0050_INTER_MTSS
    , secondDimdIntraDir
#endif
  );
#if JVET_AI0050_INTER_MTSS
  cu->dimdDerivedIntraDir2nd = secondDimdIntraDir;
#endif
#endif
  return bSucceedFlag;
}
#endif

#if JVET_AG0136_INTRA_TMP_LIC 
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
void IntraPrediction::calcTargetMean(Pel* tarPatch, int tarStride, const unsigned int uiPatchWidth, const unsigned int uiPatchHeight, const RefTemplateType tempType, const int requiredTemplate, const int log2SizeTop, const int log2SizeLeft, const int sizeTopLeft, int& topTargetMean, int& leftTargetMean)
#else
void IntraPrediction::calcTargetMean(Pel** tarPatch, const unsigned int uiPatchWidth, const unsigned int uiPatchHeight, const RefTemplateType tempType, const int requiredTemplate, const int log2SizeTop, const int log2SizeLeft, const int sizeTopLeft, int& topTargetMean, int& leftTargetMean)
#endif
{
  topTargetMean = 0;
  leftTargetMean = 0;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  const Pel* tarPatchRow = tarPatch;
#else
  const Pel* tarPatchRow = nullptr;
#endif
  if (tempType == L_SHAPE_TEMPLATE)
  {
    if (requiredTemplate == 3 || requiredTemplate == 0 || requiredTemplate == 1)
    {
      for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
        for (int iX = TMP_TEMPLATE_SIZE; iX < uiPatchWidth; iX++)
        {
          topTargetMean += tarPatchRow[iX];
        }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }
      topTargetMean >>= log2SizeTop;
    }
    if (requiredTemplate == 3 || requiredTemplate == 0 || requiredTemplate == 2)
    {
      for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
        for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
        {
          leftTargetMean += tarPatchRow[iX];
        }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }
      leftTargetMean >>= log2SizeLeft;
    }
  }
  else if (tempType == ABOVE_TEMPLATE)
  {
    for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++)
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
      for (int iX = 0; iX < uiPatchWidth - TMP_TEMPLATE_SIZE; iX++)
      {
        topTargetMean += tarPatchRow[iX];
      }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
    topTargetMean >>= log2SizeTop;
  }
  else if (tempType == LEFT_TEMPLATE)
  {
    for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++)
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
      for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
      {
        leftTargetMean += tarPatchRow[iX];
      }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
    leftTargetMean >>= log2SizeLeft;
  }
}

#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
void IntraPrediction::calcTemplateDiffJointSadMrsad(const Pel* const ref, const unsigned int uiStride, Pel* tarPatch, int tarStride, const unsigned int uiPatchWidth, const unsigned int uiPatchHeight, int* diffSad, int* diffMrsad, int* iMaxSad, int* iMaxMrsad, const RefTemplateType tempType, const int log2SizeTop, const int log2SizeLeft, const int sizeTopLeft, const int topTargetMean, const int leftTargetMean, const int licShift)
#else
void IntraPrediction::calcTemplateDiffJointSadMrsad(const Pel* const ref, const unsigned int uiStride, Pel** tarPatch, const unsigned int uiPatchWidth, const unsigned int uiPatchHeight, int* diffSad, int* diffMrsad, int* iMaxSad, int* iMaxMrsad, const RefTemplateType tempType, const int log2SizeTop, const int log2SizeLeft, const int sizeTopLeft, const int topTargetMean, const int leftTargetMean)
#endif
{
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  Pel intermediate = 0;
#endif
  int diffSumSad = 0;
  int diffSumMrsad = 0;
  int topDiffSad = MAX_INT;
  int topDiffMrsad = MAX_INT;
  int leftDiffSad = MAX_INT;
  int leftDiffMrsad = MAX_INT;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  const Pel* const refLic = ref + licShift;
  const Pel* tarPatchRow = tarPatch;
#else
  const Pel* tarPatchRow = nullptr;
#endif
  const Pel* refPatchRow = tempType == L_SHAPE_TEMPLATE ? ref - TMP_TEMPLATE_SIZE * uiStride - TMP_TEMPLATE_SIZE : (tempType == ABOVE_TEMPLATE ? ref - TMP_TEMPLATE_SIZE * uiStride : ref - TMP_TEMPLATE_SIZE);
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  const Pel* refPatchRowLic = tempType == L_SHAPE_TEMPLATE ? refLic - TMP_TEMPLATE_SIZE * uiStride - TMP_TEMPLATE_SIZE : (tempType == ABOVE_TEMPLATE ? refLic - TMP_TEMPLATE_SIZE * uiStride : refLic - TMP_TEMPLATE_SIZE);
#endif
  int topMeanRef = 0;
  int leftMeanRef = 0;
  if (tempType == L_SHAPE_TEMPLATE)
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    const Pel* refPatchRowTemp = refPatchRowLic;
#else
    const Pel* refPatchRowTemp = refPatchRow;
#endif
    for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++, refPatchRowTemp += uiStride)
    {
      for (int iX = TMP_TEMPLATE_SIZE; iX < uiPatchWidth; iX++)
      {
        topMeanRef += refPatchRowTemp[iX];
      }
    }
    topMeanRef >>= log2SizeTop;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    refPatchRowTemp = refLic - TMP_TEMPLATE_SIZE;
#else
    refPatchRowTemp = ref - TMP_TEMPLATE_SIZE;
#endif
    for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++, refPatchRowTemp += uiStride)
    {
      for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
      {
        leftMeanRef += refPatchRowTemp[iX];
      }
    }
    leftMeanRef >>= log2SizeLeft;
  }
  else if (tempType == ABOVE_TEMPLATE)
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    const Pel* refPatchRowTemp = refPatchRowLic;
#else
    const Pel* refPatchRowTemp = refPatchRow;
#endif
    for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++, refPatchRowTemp += uiStride)
    {
      for (int iX = 0; iX < uiPatchWidth - TMP_TEMPLATE_SIZE; iX++)
      {
        topMeanRef += refPatchRowTemp[iX];
      }
    }
    topMeanRef >>= log2SizeTop;
  }
  else if (tempType == LEFT_TEMPLATE)
  {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    const Pel* refPatchRowTemp = refPatchRowLic;
#else
    const Pel* refPatchRowTemp = refPatchRow;
#endif
    for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++, refPatchRowTemp += uiStride)
    {
      for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
      {
        leftMeanRef += refPatchRowTemp[iX];
      }
    }
    leftMeanRef >>= log2SizeLeft;
  }
  const int topMeanDiff = tempType == L_SHAPE_TEMPLATE || tempType == ABOVE_TEMPLATE ? topMeanRef - topTargetMean : 0;
  const int leftMeanDiff = tempType == L_SHAPE_TEMPLATE || tempType == LEFT_TEMPLATE ? leftMeanRef - leftTargetMean : 0;
#if JVET_AH0200_INTRA_TMP_BV_REORDER
  int tempDiff1 = 0;
  int tempDiff2 = 0;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  int tempDiff3 = 0;
  int tempDiff4 = 0;
#endif
#endif
  if (tempType == L_SHAPE_TEMPLATE)
  {
    int iSumSad = 0;
    int iSumMrsad = 0;
    topDiffSad = 0;
    topDiffMrsad = 0;
    leftDiffSad = 0;
    leftDiffMrsad = 0;
    for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++, refPatchRow += uiStride
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
         , refPatchRowLic += uiStride
#endif
         )
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      tempDiff1 = 0;
      tempDiff2 = 0;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tempDiff3 = 0;
      tempDiff4 = 0;
#endif
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
      {
        diffSumSad += abs(refPatchRow[iX] - tarPatchRow[iX]);
        diffSumMrsad += abs(refPatchRowLic[iX] - tarPatchRow[iX] - topMeanDiff);
      }
      for (int iX = TMP_TEMPLATE_SIZE; iX < uiPatchWidth; iX++)
#else
      for (int iX = 0; iX < uiPatchWidth; iX++)
#endif
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        iSumSad = abs(refPatchRow[iX] - tarPatchRow[iX]);
        iSumMrsad = abs(refPatchRowLic[iX] - tarPatchRow[iX] - topMeanDiff);
#else
        intermediate = refPatchRow[iX] - tarPatchRow[iX];
        iSumSad = abs(intermediate);
        iSumMrsad = abs(intermediate - topMeanDiff);
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 += iSumSad;
        tempDiff2 += iSumMrsad;
#else
        diffSumSad += iSumSad;
        diffSumMrsad += iSumMrsad;
#endif
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        if (iX >= TMP_TEMPLATE_SIZE)
        {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
          tempDiff3 += iSumSad;
          tempDiff4 += iSumMrsad;
#else
          topDiffSad += iSumSad;
          topDiffMrsad += iSumMrsad;
#endif
        }
#endif
      }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        if (iY == (TMP_TEMPLATE_SIZE - 1))
        {
          tempDiff1 <<= TMP_TEMPLATE_COST_SHIFT;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          tempDiff3 <<= TMP_TEMPLATE_COST_SHIFT;
#endif
          tempDiff2 <<= TMP_TEMPLATE_COST_SHIFT;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          tempDiff4 <<= TMP_TEMPLATE_COST_SHIFT;
#endif
        }

        diffSumSad += tempDiff1;
        diffSumMrsad += tempDiff2;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        topDiffSad += tempDiff1;
        topDiffMrsad += tempDiff2;
#else
        topDiffSad += tempDiff3;
        topDiffMrsad += tempDiff4;
#endif
#endif
      if (diffSumSad > iMaxSad[0] && topDiffSad > iMaxSad[1] && diffSumMrsad > iMaxMrsad[0] && topDiffMrsad > iMaxMrsad[1])
      {
        break;
      }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
    refPatchRow = ref - TMP_TEMPLATE_SIZE;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
    refPatchRowLic = refLic - TMP_TEMPLATE_SIZE;
    tarPatchRow = tarPatch + TMP_TEMPLATE_SIZE * tarStride;
    for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++, refPatchRow += uiStride, refPatchRowLic += uiStride)
#else
    for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++, refPatchRow += uiStride)
#endif
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
      for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        iSumSad = abs(refPatchRow[iX] - tarPatchRow[iX]);
        iSumMrsad = abs(refPatchRowLic[iX] - tarPatchRow[iX] - leftMeanDiff);
#else
        intermediate = refPatchRow[iX] - tarPatchRow[iX];
        iSumSad = abs(intermediate);
        iSumMrsad = abs(intermediate - leftMeanDiff);
#endif
        diffSumSad += iSumSad;
        diffSumMrsad += iSumMrsad;
        leftDiffSad += iSumSad;
        leftDiffMrsad += iSumMrsad;
      }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1]))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
      diffSumSad += tempDiff1;
      leftDiffSad += tempDiff1;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tempDiff1 = (abs(refPatchRowLic[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] - leftMeanDiff))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
#else
      tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] - leftMeanDiff))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
#endif
      diffSumMrsad += tempDiff1;  
      leftDiffMrsad += tempDiff1;
#endif
      if (diffSumSad > iMaxSad[0] && leftDiffSad > iMaxSad[2] && diffSumMrsad > iMaxMrsad[0] && leftDiffMrsad > iMaxMrsad[2])
      {
        break;
      }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
  }
  else if (tempType == ABOVE_TEMPLATE)
  {
    for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++, refPatchRow += uiStride
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
         , refPatchRowLic += uiStride
#endif
         )
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      tempDiff1 = 0;
      tempDiff2 = 0;
#endif
      for (int iX = 0; iX < uiPatchWidth - TMP_TEMPLATE_SIZE; iX++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        intermediate = refPatchRow[iX] - tarPatchRow[iX];
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tempDiff1 += abs(refPatchRow[iX] - tarPatchRow[iX]);
        tempDiff2 += abs(refPatchRowLic[iX] - tarPatchRow[iX] - topMeanDiff);
#else
        tempDiff1 += abs(intermediate);
        tempDiff2 += abs(intermediate - topMeanDiff);
#endif
#else
        diffSumSad += abs(intermediate);
        diffSumMrsad += abs(intermediate - topMeanDiff);
#endif
      }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      if (iY == (TMP_TEMPLATE_SIZE - 1))
      {
        tempDiff1 <<= TMP_TEMPLATE_COST_SHIFT;
        tempDiff2 <<= TMP_TEMPLATE_COST_SHIFT;
      }
      diffSumSad += tempDiff1;
      diffSumMrsad += tempDiff2;
#endif
      if (diffSumSad > iMaxSad[0] && diffSumMrsad > iMaxMrsad[0])
      {
        break;
      }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
  }
  else if (tempType == LEFT_TEMPLATE)
  {
    for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++, refPatchRow += uiStride
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
         , refPatchRowLic += uiStride
#endif
         )
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
      for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
      {
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        diffSumSad += abs(refPatchRow[iX] - tarPatchRow[iX]);
        diffSumMrsad += abs(refPatchRowLic[iX] - tarPatchRow[iX] - leftMeanDiff);
#else
        intermediate = refPatchRow[iX] - tarPatchRow[iX];
        diffSumSad += abs(intermediate);
        diffSumMrsad += abs(intermediate - leftMeanDiff);
#endif
      }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1]))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
      diffSumSad += tempDiff1;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tempDiff1 = (abs(refPatchRowLic[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] - leftMeanDiff))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
#else
      tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] - leftMeanDiff))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
#endif
      diffSumMrsad += tempDiff1;  
#endif
      if (diffSumSad > iMaxSad[0] && diffSumMrsad > iMaxMrsad[0])
      {
        break;
      }
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
  }
  diffSad[0] = diffSumSad;
  diffSad[1] = topDiffSad;
  diffSad[2] = leftDiffSad;
  diffMrsad[0] = diffSumMrsad;
  diffMrsad[1] = topDiffMrsad;
  diffMrsad[2] = leftDiffMrsad;
}
#endif

#if JVET_AD0086_ENHANCED_INTRA_TMP
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
void IntraPrediction::calcTemplateDiff(Pel* ref, unsigned int uiStride, Pel* tarPatch, int tarStride, unsigned int uiPatchWidth,
  unsigned int uiPatchHeight, int* diff, int* iMax, RefTemplateType tempType, int requiredTemplate
#if JVET_AG0136_INTRA_TMP_LIC
  , const bool isMrSad, const int log2SizeTop, const int log2SizeLeft, const int sizeTopLeft, const int topTargetMean, const int leftTargetMean
#endif
)
#else
void IntraPrediction::calcTemplateDiff(Pel *ref, unsigned int uiStride, Pel **tarPatch, unsigned int uiPatchWidth,
                                       unsigned int uiPatchHeight, int *diff, int *iMax, RefTemplateType tempType, int requiredTemplate
#if JVET_AG0136_INTRA_TMP_LIC
                                       , const bool isMrSad, const int log2SizeTop, const int log2SizeLeft, const int sizeTopLeft, const int topTargetMean, const int leftTargetMean
#endif
                                       )
#endif
{
  int diffSum = 0;
  int topDiff  = MAX_INT;
  int leftDiff = MAX_INT;
#if JVET_W0069_TMP_BOUNDARY
  Pel *refPatchRow;
  if (tempType == L_SHAPE_TEMPLATE)
  {
    refPatchRow = ref - TMP_TEMPLATE_SIZE * uiStride - TMP_TEMPLATE_SIZE;
  }
  else if (tempType == LEFT_TEMPLATE)
  {
    refPatchRow = ref - TMP_TEMPLATE_SIZE;
  }
  else if (tempType == ABOVE_TEMPLATE)
  {
    refPatchRow = ref - TMP_TEMPLATE_SIZE * uiStride;
  }
#else
  Pel *refPatchRow = ref - TMP_TEMPLATE_SIZE * uiStride - TMP_TEMPLATE_SIZE;
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  const Pel* tarPatchRow = tarPatch;
#else
  Pel *tarPatchRow;
#endif

#if JVET_AG0136_INTRA_TMP_LIC
  int topMeanDiff = 0;
  int leftMeanDiff = 0;
  if (isMrSad)
  {
    int topMeanRef = 0;
    int leftMeanRef = 0;
    if (tempType == L_SHAPE_TEMPLATE)
    {
      if (requiredTemplate == 3 || requiredTemplate == 0 || requiredTemplate == 1)
      {
        const Pel* refPatchRowTemp = refPatchRow;
        for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++, refPatchRowTemp += uiStride)
        {
          for (int iX = TMP_TEMPLATE_SIZE; iX < uiPatchWidth; iX++)
          {
            topMeanRef += refPatchRowTemp[iX];
          }
        }
        topMeanRef >>= log2SizeTop;
      }
      if (requiredTemplate == 3 || requiredTemplate == 0 || requiredTemplate == 2)
      {
        const Pel* refPatchRowTemp = ref - TMP_TEMPLATE_SIZE;
        for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++, refPatchRowTemp += uiStride)
        {
          for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
          {
            leftMeanRef += refPatchRowTemp[iX];
          }
        }
        leftMeanRef >>= log2SizeLeft;
      }
    }
    else if (tempType == ABOVE_TEMPLATE)
    {
      const Pel* refPatchRowTemp = refPatchRow;
      for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++, refPatchRowTemp += uiStride)
      {
        for (int iX = 0; iX < uiPatchWidth - TMP_TEMPLATE_SIZE; iX++)
        {
          topMeanRef += refPatchRowTemp[iX];
        }
      }
      topMeanRef >>= log2SizeTop;
    }
    else if (tempType == LEFT_TEMPLATE)
    {
      const Pel* refPatchRowTemp = refPatchRow;
      for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++, refPatchRowTemp += uiStride)
      {
        for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
        {
          leftMeanRef += refPatchRowTemp[iX];
        }
      }
      leftMeanRef >>= log2SizeLeft;
    }
    if ((tempType == L_SHAPE_TEMPLATE && requiredTemplate != 2) || tempType == ABOVE_TEMPLATE)
    {
      topMeanDiff = topMeanRef - topTargetMean;
    }
    if ((tempType == L_SHAPE_TEMPLATE && requiredTemplate != 1) || tempType == LEFT_TEMPLATE)
    {
      leftMeanDiff = leftMeanRef - leftTargetMean;
    }
  }
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
  int tempDiff1 = 0;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
  int tempDiff2 = 0;
#endif
#endif
#if JVET_W0069_TMP_BOUNDARY
  if (tempType == L_SHAPE_TEMPLATE)
  {
#endif

    topDiff  = 0;
    leftDiff = 0;

    // horizontal difference
    if(requiredTemplate == 3)//all
    {
      for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 = 0;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tempDiff2 = 0;
#endif
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
        {
          diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#if JVET_AG0136_INTRA_TMP_LIC
                         - topMeanDiff
#endif
                         );
        }
        for (int iX = TMP_TEMPLATE_SIZE; iX < uiPatchWidth; iX++)
#else
        for (int iX = 0; iX < uiPatchWidth; iX++)
#endif
        {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
          tempDiff1 += abs(refPatchRow[iX] - tarPatchRow[iX]
#else
          diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#endif
#if JVET_AG0136_INTRA_TMP_LIC
                         - topMeanDiff
#endif
                         );

#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          if (iX >= TMP_TEMPLATE_SIZE)
          {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
            tempDiff2 += abs(refPatchRow[iX] - tarPatchRow[iX]
#else
            topDiff += abs(refPatchRow[iX] - tarPatchRow[iX]
#endif
#if JVET_AG0136_INTRA_TMP_LIC
                           - topMeanDiff
#endif
                           );
          }
#endif
        }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        if (iY == (TMP_TEMPLATE_SIZE - 1))
        {
          tempDiff1 <<= TMP_TEMPLATE_COST_SHIFT;
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
          tempDiff2 <<= TMP_TEMPLATE_COST_SHIFT;
#endif
        }
        diffSum += tempDiff1;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        topDiff += tempDiff1;
#else
        topDiff += tempDiff2;
#endif
#endif

        if (diffSum > iMax[0] && topDiff > iMax[1])
        {
          break;
        }

        refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }

      refPatchRow = ref - TMP_TEMPLATE_SIZE;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch + TMP_TEMPLATE_SIZE * tarStride;
#endif

      // vertical difference
      for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
        for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
        {
          diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#if JVET_AG0136_INTRA_TMP_LIC
                         - leftMeanDiff
#endif
                         );
          leftDiff += abs(refPatchRow[iX] - tarPatchRow[iX]
#if JVET_AG0136_INTRA_TMP_LIC
                          - leftMeanDiff
#endif
                          );
        }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] 
#if JVET_AG0136_INTRA_TMP_LIC
                         - leftMeanDiff
#endif        
        ))*((1 << TMP_TEMPLATE_COST_SHIFT) - 1);
        diffSum += tempDiff1;
        leftDiff += tempDiff1;
#endif

        if (diffSum > iMax[0] && leftDiff > iMax[2])
        {
          break;
        }

        refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }
    }
    else if (requiredTemplate == 0)//TL
    {
      for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 = 0;
#endif
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
        {
          diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#if JVET_AG0136_INTRA_TMP_LIC
                         - topMeanDiff
#endif
                         );
        }
        for (int iX = TMP_TEMPLATE_SIZE; iX < uiPatchWidth; iX++)
#else
        for (int iX = 0; iX < uiPatchWidth; iX++)
#endif
        {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
          tempDiff1 += abs(refPatchRow[iX] - tarPatchRow[iX]
#else
          diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#endif
#if JVET_AG0136_INTRA_TMP_LIC
                         - topMeanDiff
#endif
                         );
        }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        if (iY == (TMP_TEMPLATE_SIZE - 1))
        {
          tempDiff1 <<= TMP_TEMPLATE_COST_SHIFT;
        }
        diffSum += tempDiff1;
#endif

        if (diffSum > iMax[0])
        {
          break;
        }

        refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }

      refPatchRow = ref - TMP_TEMPLATE_SIZE;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch + TMP_TEMPLATE_SIZE * tarStride;
#endif

      // vertical difference
      for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
        for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
        {
          diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#if JVET_AG0136_INTRA_TMP_LIC
                         - leftMeanDiff
#endif
                         );
        }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] 
#if JVET_AG0136_INTRA_TMP_LIC
                         - leftMeanDiff
#endif        
        ))*((1 << TMP_TEMPLATE_COST_SHIFT) - 1);
        diffSum += tempDiff1;
#endif

        if (diffSum > iMax[0])
        {
          break;
        }

        refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }
    }
    else if(requiredTemplate == 1) //T  
    {
      for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 = 0;
#endif
        for (int iX = TMP_TEMPLATE_SIZE; iX < uiPatchWidth; iX++)
        {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
          tempDiff1 += abs(refPatchRow[iX] - tarPatchRow[iX]
#else
          topDiff += abs(refPatchRow[iX] - tarPatchRow[iX]
#endif
#if JVET_AG0136_INTRA_TMP_LIC
                         - topMeanDiff
#endif
                         );
        }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        if (iY == (TMP_TEMPLATE_SIZE - 1))
        {
          tempDiff1 <<= TMP_TEMPLATE_COST_SHIFT;
        }
        topDiff += tempDiff1;
#endif

        if (topDiff > iMax[1])
        {
          break;
        }

        refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }
    }
    else // L
    {
      refPatchRow = ref - TMP_TEMPLATE_SIZE;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch + TMP_TEMPLATE_SIZE * tarStride;
#endif

      // vertical difference
      for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++)
      {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow = tarPatch[iY];
#endif
        for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
        {
          leftDiff += abs(refPatchRow[iX] - tarPatchRow[iX]
#if JVET_AG0136_INTRA_TMP_LIC
                          - leftMeanDiff
#endif
                          );
        }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] 
#if JVET_AG0136_INTRA_TMP_LIC
                         - leftMeanDiff
#endif        
        ))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
        leftDiff += tempDiff1;
#endif

        if (leftDiff > iMax[2])
        {
          break;
        }

        refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
        tarPatchRow += tarStride;
#endif
      }
    }
#if JVET_W0069_TMP_BOUNDARY
  }
  else if (tempType == ABOVE_TEMPLATE)
  {
    // top  template difference
    for (int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++)
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      tempDiff1 = 0;
#endif
      for (int iX = 0; iX < uiPatchWidth - TMP_TEMPLATE_SIZE; iX++)
      {
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        tempDiff1 += abs(refPatchRow[iX] - tarPatchRow[iX]
#else
        diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#endif
#if JVET_AG0136_INTRA_TMP_LIC
                       - topMeanDiff
#endif
                       );
      }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
        if (iY == (TMP_TEMPLATE_SIZE - 1))
        {
          tempDiff1 <<= TMP_TEMPLATE_COST_SHIFT;
        }
        diffSum += tempDiff1;
#endif
      if (diffSum > iMax[0])   // for speeding up
      {
        break;
      }
      refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
  }
  else if (tempType == LEFT_TEMPLATE)
  {
    // left template difference
    for (int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++)
    {
#if !JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow = tarPatch[iY];
#endif
      for (int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++)
      {
        diffSum += abs(refPatchRow[iX] - tarPatchRow[iX]
#if JVET_AG0136_INTRA_TMP_LIC
                       - leftMeanDiff
#endif
                       );
      }
#if JVET_AH0200_INTRA_TMP_BV_REORDER
      tempDiff1 = (abs(refPatchRow[TMP_TEMPLATE_SIZE - 1] - tarPatchRow[TMP_TEMPLATE_SIZE - 1] 
#if JVET_AG0136_INTRA_TMP_LIC
                        - leftMeanDiff
#endif        
      ))*((1<<TMP_TEMPLATE_COST_SHIFT) - 1);
      diffSum += tempDiff1;
#endif
      if (diffSum > iMax[0])   // for speeding up
      {
        break;
      }
      refPatchRow += uiStride;
#if JVET_AI0129_INTRA_TMP_OVERLAPPING_REFINEMENT
      tarPatchRow += tarStride;
#endif
    }
  }
#endif

  diff[0] = diffSum;
  diff[1] = topDiff;
  diff[2] = leftDiff;
}
#else
#if JVET_W0069_TMP_BOUNDARY
int IntraPrediction::calcTemplateDiff( Pel* ref, unsigned int uiStride, Pel** tarPatch, unsigned int uiPatchWidth, unsigned int uiPatchHeight, int iMax, RefTemplateType tempType )
#else
int IntraPrediction::calcTemplateDiff( Pel* ref, unsigned int uiStride, Pel** tarPatch, unsigned int uiPatchWidth, unsigned int uiPatchHeight, int iMax )
#endif
{
  int diffSum = 0;
#if JVET_W0069_TMP_BOUNDARY
  Pel* refPatchRow;
  if( tempType == L_SHAPE_TEMPLATE )
  {
    refPatchRow = ref - TMP_TEMPLATE_SIZE * uiStride - TMP_TEMPLATE_SIZE;
  }
  else if( tempType == LEFT_TEMPLATE )
  {
    refPatchRow = ref - TMP_TEMPLATE_SIZE;
  }
  else if( tempType == ABOVE_TEMPLATE )
  {
    refPatchRow = ref - TMP_TEMPLATE_SIZE * uiStride;
  }
#else
  Pel* refPatchRow = ref - TMP_TEMPLATE_SIZE * uiStride - TMP_TEMPLATE_SIZE;
#endif
  Pel* tarPatchRow;

#if JVET_W0069_TMP_BOUNDARY
  if( tempType == L_SHAPE_TEMPLATE )
  {
#endif
    // horizontal difference
    for( int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++ )
    {
      tarPatchRow = tarPatch[iY];
      for( int iX = 0; iX < uiPatchWidth; iX++ )
      {
        diffSum += abs( refPatchRow[iX] - tarPatchRow[iX] );
      }
      if( diffSum > iMax ) //for speeding up
      {
        return diffSum;
      }
      refPatchRow += uiStride;
    }

    // vertical difference
    for( int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++ )
    {
      tarPatchRow = tarPatch[iY];
      for( int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++ )
      {
        diffSum += abs( refPatchRow[iX] - tarPatchRow[iX] );
      }
      if( diffSum > iMax ) //for speeding up
      {
        return diffSum;
      }
      refPatchRow += uiStride;
    }
#if JVET_W0069_TMP_BOUNDARY
  }
  else if( tempType == ABOVE_TEMPLATE )
  {
    // top  template difference
    for( int iY = 0; iY < TMP_TEMPLATE_SIZE; iY++ )
    {
      tarPatchRow = tarPatch[iY];
      for( int iX = 0; iX < uiPatchWidth - TMP_TEMPLATE_SIZE; iX++ )
      {
        diffSum += abs( refPatchRow[iX] - tarPatchRow[iX] );
      }
      if( diffSum > iMax ) //for speeding up
      {
        return diffSum;
      }
      refPatchRow += uiStride;
    }
  }
  else if( tempType == LEFT_TEMPLATE )
  {
    // left template difference
    for( int iY = TMP_TEMPLATE_SIZE; iY < uiPatchHeight; iY++ )
    {
      tarPatchRow = tarPatch[iY];
      for( int iX = 0; iX < TMP_TEMPLATE_SIZE; iX++ )
      {
        diffSum += abs( refPatchRow[iX] - tarPatchRow[iX] );
      }
      if( diffSum > iMax ) //for speeding up
      {
        return diffSum;
      }
      refPatchRow += uiStride;
    }
  }
#endif

  return diffSum;
}
#endif
#endif


#if JVET_AD0188_CCP_MERGE || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
void IntraPrediction::xGlmApplyModelOffset(const PredictionUnit &pu, const ComponentID compId,
                                           const CompArea &chromaArea, CccmModel& glmModel, int glmIdc,
                                           PelBuf &piPred, int lumaOffset, int chromaOffset)
{
  const ClpRng &clpRng(pu.cu->cs->slice->clpRng(compId));
  Pel* samples = m_samples;

  CPelBuf refLumaBlk = xGlmGetGradPuBuf(pu, chromaArea, 0);
  CPelBuf refGradBlk = xGlmGetGradPuBuf(pu, chromaArea, glmIdc);

  for (int y = 0; y < refLumaBlk.height; y++)
  {
    for (int x = 0; x < refLumaBlk.width; x++)
    {
      samples[0] = refGradBlk.at(x, y);                // luma gradient
      samples[1] = refLumaBlk.at(x, y) + lumaOffset;   // luma value
      samples[2] = glmModel.bias();

      piPred.at(x, y) = ClipPel<Pel>(glmModel.convolve(samples) + chromaOffset, clpRng);
    }
  }
}

void IntraPrediction::xCccmApplyModelOffset(const PredictionUnit &pu, const ComponentID compId,
                                            CccmModel& cccmModel, int modelId, int modelThr,
                                            PelBuf &piPred, int lumaOffset, int chromaOffset[2], int type, int refSizeX, int refSizeY)
{
  const ClpRng &clpRng(pu.cu->cs->slice->clpRng(compId));
  Pel* samples = m_samples;

  int stepX = 1;
  int stepY = 1;
  int chromaScaleX = 0;
  int chromaScaleY = 0;

#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  if( pu.cccmNoSubFlag )
  {
    chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
    chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );

    stepX = 1 << chromaScaleX;
    stepY = 1 << chromaScaleY;
  }
#endif

  CPelBuf refLumaBlk;
#if JVET_AD0202_CCCM_MDF
  CPelBuf refLumaBlk1, refLumaBlk2, refLumaBlk3;

  if( ( type & CCP_TYPE_MDFCCCM ) && pu.curCand.cccmMultiFilterIdx == 1 )
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu, 0, 3, &refLumaBlk1, &refLumaBlk3, &refLumaBlk2 );
  }
  else if( ( type & CCP_TYPE_MDFCCCM ) && pu.curCand.cccmMultiFilterIdx > 1 )
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu, 0, 2, &refLumaBlk1, &refLumaBlk3 );
  }
  else
#endif
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu );
  }

  int offset = modelId == 2 ? chromaOffset[1] : chromaOffset[0];

  if (type & CCP_TYPE_CCCM)
  {
    for (int y = 0; y < refLumaBlk.height; y += stepY )
    {
      for (int x = 0; x < refLumaBlk.width; x += stepX )
      {
        if (modelId == 1 && (refLumaBlk.at(x, y) + lumaOffset) > modelThr)   // Model 1: Include only samples below or equal to the threshold
        {
          continue;
        }
        if (modelId == 2 && (refLumaBlk.at(x, y) + lumaOffset) <= modelThr)   // Model 2: Include only samples above the threshold
        {
          continue;
        }

        // 7-tap cross
        samples[0] = refLumaBlk.at(x, y) + lumaOffset;       // C
        samples[1] = refLumaBlk.at(x, y - 1) + lumaOffset;   // N
        samples[2] = refLumaBlk.at(x, y + 1) + lumaOffset;   // S
        samples[3] = refLumaBlk.at(x - 1, y) + lumaOffset;   // W
        samples[4] = refLumaBlk.at(x + 1, y) + lumaOffset;   // E
        samples[5] = cccmModel.nonlinear(refLumaBlk.at(x, y) + lumaOffset);
        samples[6] = cccmModel.bias();

        piPred.at( x >> chromaScaleX, y >> chromaScaleY ) = ClipPel<Pel>(cccmModel.convolve(samples) + offset, clpRng);
      }
    }
  }
#if JVET_AC0054_GLCCCM
  else if (type & CCP_TYPE_GLCCCM)
  {
    for( int y = 0; y < refLumaBlk.height; y += stepY )
    {
      for( int x = 0; x < refLumaBlk.width; x += stepX )
      {
        if (modelId == 1 && (refLumaBlk.at(x, y) + lumaOffset) > modelThr)   // Model 1: Include only samples below or equal to the threshold
        {
          continue;
        }
        if (modelId == 2 && (refLumaBlk.at(x, y) + lumaOffset) <= modelThr)   // Model 2: Include only samples above the threshold
        {
          continue;
        }

        samples[0] = refLumaBlk.at(x, y) + lumaOffset;   // C
        samples[1] = (2 * refLumaBlk.at(x, y - 1) + refLumaBlk.at(x - 1, y - 1) + refLumaBlk.at(x + 1, y - 1))
                   - (2 * refLumaBlk.at(x, y + 1) + refLumaBlk.at(x - 1, y + 1) + refLumaBlk.at(x + 1, y + 1));   // Vertical gradient
        samples[2] = (2 * refLumaBlk.at(x - 1, y) + refLumaBlk.at(x - 1, y - 1) + refLumaBlk.at(x - 1, y + 1))
                   - (2 * refLumaBlk.at(x + 1, y) + refLumaBlk.at(x + 1, y - 1) + refLumaBlk.at(x + 1, y + 1));   // Horizontal gradient
        samples[3] = ( y + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT;   // Y coordinate
        samples[4] = ( x + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT;   // X coordinate
        samples[5] = cccmModel.nonlinear( refLumaBlk.at( x, y ) + lumaOffset );
        samples[6] = cccmModel.bias();

        piPred.at( x >> chromaScaleX, y >> chromaScaleY ) = ClipPel<Pel>( cccmModel.convolve(samples) + offset, clpRng);
      }
    }
  }
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  else if( ( type & CCP_TYPE_NSCCCM ) && pu.cccmNoSubFlag )
  {
    for( int y = 0; y < refLumaBlk.height; y += stepY )
    {
      for( int x = 0; x < refLumaBlk.width; x += stepX )
      {
        const Pel *src0 = refLumaBlk.bufAt( x, y );
        const Pel *src1 = refLumaBlk.bufAt( x, y + 1 );

        if( modelId == 1 && ( src0[0] + lumaOffset ) > modelThr )   // Model 1: Include only samples below or equal to the threshold
        {
          continue;
        }
        if( modelId == 2 && ( src0[0] + lumaOffset ) <= modelThr )   // Model 2: Include only samples above the threshold
        {
          continue;
        }

        samples[0] = src0[0] + lumaOffset;
        samples[1] = src0[-1] + lumaOffset;
        samples[2] = src0[1] + lumaOffset;
        samples[3] = src1[0] + lumaOffset;
        samples[4] = src1[-1] + lumaOffset;
        samples[5] = src1[1] + lumaOffset;
        samples[6] = cccmModel.nonlinear( src0[0] + lumaOffset );
        samples[7] = cccmModel.nonlinear( src1[0] + lumaOffset );
        samples[8] = cccmModel.nonlinear( src0[1] + lumaOffset );
        samples[9] = cccmModel.nonlinear( src0[-1] + lumaOffset );
        samples[10] = cccmModel.bias();

        piPred.at( x >> chromaScaleX, y >> chromaScaleY ) = ClipPel<Pel>( cccmModel.convolve( samples ) + offset, clpRng );
      }
    }
  }
  else
#endif
#if JVET_AD0202_CCCM_MDF
  if( ( type & CCP_TYPE_MDFCCCM ) && pu.curCand.cccmMultiFilterIdx == 1 )
  {
    for( int y = 0; y < refLumaBlk.height; y += stepY )
    {
      for( int x = 0; x < refLumaBlk.width; x += stepX )
      {
        if( modelId == 1 && ( refLumaBlk.at( x, y ) + lumaOffset ) > modelThr )   // Model 1: Include only samples below or equal to the threshold
        {
          continue;
        }
        if( modelId == 2 && ( refLumaBlk.at( x, y ) + lumaOffset ) <= modelThr )   // Model 2: Include only samples above the threshold
        {
          continue;
        }

        // 7-tap cross
        samples[0] = refLumaBlk.at( x, y ) + lumaOffset; // C
        samples[1] = refLumaBlk1.at( x, y ) + lumaOffset; // W
        samples[2] = refLumaBlk2.at( x, y ) + lumaOffset; // E
        samples[3] = refLumaBlk3.at( x, y ) + lumaOffset;
        samples[4] = cccmModel.nonlinear( refLumaBlk.at( x, y ) + lumaOffset );
        samples[5] = cccmModel.nonlinear( refLumaBlk1.at( x, y ) + lumaOffset );
        samples[6] = cccmModel.nonlinear( refLumaBlk2.at( x, y ) + lumaOffset );
        samples[7] = ( y + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // Y coordinate
        samples[8] = ( x + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // X coordinate
        samples[9] = cccmModel.bias();

        piPred.at( x >> chromaScaleX, y >> chromaScaleY ) = ClipPel<Pel>( cccmModel.convolve( samples ) + offset, clpRng );
      }
    }
  }
  else if( ( type & CCP_TYPE_MDFCCCM ) && pu.curCand.cccmMultiFilterIdx == 2 )
  {
    for( int y = 0; y < refLumaBlk.height; y += stepY )
    {
      for( int x = 0; x < refLumaBlk.width; x += stepX )
      {
        if( modelId == 1 && ( refLumaBlk.at( x, y ) + lumaOffset ) > modelThr )   // Model 1: Include only samples below or equal to the threshold
        {
          continue;
        }
        if( modelId == 2 && ( refLumaBlk.at( x, y ) + lumaOffset ) <= modelThr )   // Model 2: Include only samples above the threshold
        {
          continue;
        }

        // 7-tap cross
        samples[0] = refLumaBlk.at( x, y ) + lumaOffset; // C
        samples[1] = refLumaBlk.at( x - 1, y ) + lumaOffset; // W
        samples[2] = refLumaBlk.at( x + 1, y ) + lumaOffset; // E
        samples[3] = refLumaBlk1.at( x, y ) + lumaOffset; // C
        samples[4] = refLumaBlk1.at( x - 1, y ) + lumaOffset; // W
        samples[5] = refLumaBlk1.at( x + 1, y ) + lumaOffset; // E
        samples[6] = cccmModel.nonlinear( refLumaBlk.at( x, y ) + lumaOffset );
        samples[7] = cccmModel.nonlinear( refLumaBlk.at( x - 1, y ) + lumaOffset );
        samples[8] = cccmModel.nonlinear( refLumaBlk.at( x + 1, y ) + lumaOffset );
        samples[9] = ( x + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // X coordinate
        samples[10] = cccmModel.bias();

        piPred.at( x >> chromaScaleX, y >> chromaScaleY ) = ClipPel<Pel>( cccmModel.convolve( samples ) + offset, clpRng );
      }
    }
  }
  else if( ( type & CCP_TYPE_MDFCCCM ) && pu.curCand.cccmMultiFilterIdx == 3 )
  {
    for( int y = 0; y < refLumaBlk.height; y += stepY )
    {
      for( int x = 0; x < refLumaBlk.width; x += stepX )
      {
        if( modelId == 1 && ( refLumaBlk.at( x, y ) + lumaOffset ) > modelThr )   // Model 1: Include only samples below or equal to the threshold
        {
          continue;
        }
        if( modelId == 2 && ( refLumaBlk.at( x, y ) + lumaOffset ) <= modelThr )   // Model 2: Include only samples above the threshold
        {
          continue;
        }

        // 7-tap cross
        samples[0] = refLumaBlk.at( x, y ) + lumaOffset; // C
        samples[1] = refLumaBlk.at( x + 1, y - 1 ) + lumaOffset; // EN
        samples[2] = refLumaBlk.at( x - 1, y + 1 ) + lumaOffset; // WS
        samples[3] = refLumaBlk3.at( x, y ) + lumaOffset; // C
        samples[4] = refLumaBlk3.at( x + 1, y - 1 ) + lumaOffset; // EN
        samples[5] = refLumaBlk3.at( x - 1, y + 1 ) + lumaOffset; // WS
        samples[6] = cccmModel.nonlinear( refLumaBlk.at( x, y ) + lumaOffset );
        samples[7] = cccmModel.nonlinear( refLumaBlk.at( x + 1, y - 1 ) + lumaOffset );
        samples[8] = cccmModel.nonlinear( refLumaBlk.at( x - 1, y + 1 ) + lumaOffset );
        samples[9] = ( y + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // Y coordinate
        samples[10] = cccmModel.bias();

        piPred.at( x >> chromaScaleX, y >> chromaScaleY ) = ClipPel<Pel>( cccmModel.convolve( samples ) + offset, clpRng );
      }
    }
  }
#endif
  else
  {
    THROW("Invalid type");
  }
}

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
int IntraPrediction::xGetCostCCPFusion(const PredictionUnit& pu, const ComponentID compID, const CompArea& chromaArea, int candIdx0, int candIdx1)
{
  const SizeType cWidth = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  Pel *curChroma0;

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf0(compID == COMPONENT_Cb ? m_CCPFusionTempCb[candIdx0] : m_CCPFusionTempCr[candIdx0], maxSize, Size(maxSize, 2));
  PelBuf predBuf1(compID == COMPONENT_Cb ? m_CCPFusionTempCb[candIdx1] : m_CCPFusionTempCr[candIdx1], maxSize, Size(maxSize, 2));

  Pel      *curChromaBuf = chromaReco.buf;
  const int curStride = chromaReco.stride;

  int sad = 0;
  if (aboveAvailable)
  {
    curChroma0 = curChromaBuf - curStride;
    for (int pos = 0; pos < cWidth; pos++)
    {
      Pel predChroma = (predBuf0.at(pos, 0) + predBuf1.at(pos, 0) + 1) >> 1;
      sad += abs(curChroma0[pos] - predChroma);
    }
  }

  if (leftAvailable)
  {
    curChroma0 = curChromaBuf - 1;
    for (int pos = 0; pos < cHeight; pos++)
    {
      Pel predChroma = (predBuf0.at(pos, 1) + predBuf1.at(pos, 1) + 1) >> 1;
      sad += abs(curChroma0[pos * curStride] - predChroma);
    }
  }

  return sad;
}
#endif

template <const bool updateOffsets>
int  IntraPrediction::xUpdateOffsetsAndGetCostCCLM(const PredictionUnit &pu, const ComponentID compID, const CompArea &chromaArea,CclmModel &cclmModel, int modelNum, int glmIdc
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
                                                 , int candIdx
#endif
                                                  )
{
  int    srcStride = 0;
  PelBuf temp;

  if (glmIdc > 0)
  {
    Pel *glmTemp = m_glmTempCb[glmIdc];
    srcStride    = 2 * MAX_CU_SIZE + 1;
    temp         = PelBuf(glmTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
  else
  {
    srcStride = MAX_CU_SIZE + 1;
    temp      = PelBuf(m_piTemp + srcStride + 1, srcStride, Size(chromaArea));
  }

  const SizeType cWidth  = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable  = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  Pel *srcColor0, *curChroma0;

  srcColor0 = temp.bufAt(0, 0);

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf(compID == COMPONENT_Cb ? m_CCPFusionTempCb[candIdx] : m_CCPFusionTempCr[candIdx], maxSize, Size(maxSize, 2));
#endif

  Pel      *curChromaBuf = chromaReco.buf;
  const int curStride    = chromaReco.stride;

  int sad = 0;
  int totalOffset[2] = { 0, 0 };
  int count[2] = { 0, 0 };

  if( aboveAvailable )
  {
    curChroma0 = curChromaBuf - curStride;
    Pel *src = srcColor0 - srcStride;
    Pel predChroma;
    for( int pos = 0; pos < cWidth; pos++ )
    {
      if( modelNum == 2 && src[pos] > cclmModel.yThres )
      {
        predChroma = rightShift( cclmModel.a2 * src[pos], cclmModel.shift2 ) + cclmModel.b2;
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 0) = predChroma;
#endif

        if( updateOffsets )
        {
          totalOffset[1] += curChroma0[pos] - predChroma;
          count[1]++;
        }
      }
      else
      {
        predChroma = rightShift( cclmModel.a * src[pos], cclmModel.shift ) + cclmModel.b;
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 0) = predChroma;
#endif

        if( updateOffsets )
        {
          totalOffset[0] += curChroma0[pos] - predChroma;
          count[0]++;
        }
      }
      sad += abs( curChroma0[pos] - predChroma );
    }
  }

  if( leftAvailable )
  {
    curChroma0 = curChromaBuf - 1;
    Pel *src = srcColor0 - 1;

    Pel predChroma;
    for( int pos = 0; pos < cHeight; pos++ )
    {
      if( modelNum == 2 && src[pos * srcStride] > cclmModel.yThres )
      {
        predChroma = rightShift( cclmModel.a2 * src[pos * srcStride], cclmModel.shift2 ) + cclmModel.b2;
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 1) = predChroma;
#endif

        if( updateOffsets )
        {
          totalOffset[1] += curChroma0[pos * curStride] - predChroma;
          count[1]++;
        }
      }
      else
      {
        predChroma = rightShift( cclmModel.a * src[pos * srcStride], cclmModel.shift ) + cclmModel.b;
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 1) = predChroma;
#endif

        if( updateOffsets )
        {
          totalOffset[0] += curChroma0[pos * curStride] - predChroma;
          count[0]++;
        }        
      }
      sad += abs( curChroma0[pos * curStride] - predChroma );
    }
  }

  if( updateOffsets )
  {
    if( count[0] )
    {
      cclmModel.b += PU::getMeanValue( totalOffset[0], count[0] );   // totalOffset[0] / count[0];
    }

    if( modelNum == 2 && count[1] )
    {
      cclmModel.b2 += PU::getMeanValue( totalOffset[1], count[1] );   //totalOffset[1] / count[1];
    }
  }

  return sad;
}

template <const bool updateOffsets>
int IntraPrediction::xUpdateOffsetsAndGetCostCCCM(const PredictionUnit &pu, const ComponentID compID,
                                  const CompArea &chromaArea, CccmModel cccmModel[2],
                                  int modelThr, int lumaOffset, int chromaOffset[2], int type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
                                , int candIdx
#endif
                                , int refSizeX, int refSizeY, const int cccmMultiFilterIdx)
{
  const ClpRng &clpRng(pu.cu->cs->slice->clpRng(compID));

  CHECK(compID != chromaArea.compID, "Invalid component ID");

  Pel* samples = m_samples;

  CPelBuf refLumaBlk;
#if JVET_AD0202_CCCM_MDF
  CPelBuf refLumaBlk1, refLumaBlk2, refLumaBlk3;

  if( cccmMultiFilterIdx == 1 )
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu, 0, 3, &refLumaBlk1, &refLumaBlk3, &refLumaBlk2 );
  }
  else if( cccmMultiFilterIdx > 1 )
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu, 0, 2, &refLumaBlk1, &refLumaBlk3 );
  }
  else
#endif
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu );
  }

  const SizeType cWidth  = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable  = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf(compID == COMPONENT_Cb ? m_CCPFusionTempCb[candIdx] : m_CCPFusionTempCr[candIdx], maxSize, Size(maxSize, 2));
#endif

  const Pel *curChromaBuf[2] = { nullptr, }, *srcBuf[2] = { nullptr, };
  int curStrideBuf[2] = { 0, }, srcStrideBuf[2] = { 0, };
  int sad = 0, start = 0, end = 0, posEnd[2] = { 0, }, step[2] = { 0, };
  const int srcStride = refLumaBlk.stride;

  int totalOffset[2] = { 0, 0 };
  int count[2] = { 0, 0 };

#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  const int chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
  const int chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
  const int stepX = 1 << chromaScaleX;
  const int stepY = 1 << chromaScaleY;
#endif

  Pel predChroma;

  if( aboveAvailable )
  {
    curChromaBuf[0] = chromaReco.bufAt( 0, -1 );
    srcBuf[0] = refLumaBlk.bufAt( 0, -1 );
    curStrideBuf[0] = 1;
    srcStrideBuf[0] = 1;
    posEnd[0] = cWidth;
    step[0] = stepX;
    start = 0;
    end = 1;
  }

  if( leftAvailable )
  {
    curChromaBuf[1] = chromaReco.bufAt( -1, 0 );
    srcBuf[1] = refLumaBlk.bufAt( -1, 0 );
    curStrideBuf[1] = chromaReco.stride;
    srcStrideBuf[1] = srcStride;
    posEnd[1] = cHeight;
    step[1] = stepY;
    start += !aboveAvailable;
    end = 2;
  }

  for( int i = start; i < end; i++ )
  {
    const Pel* curChroma0 = curChromaBuf[i];
    const Pel* src = srcBuf[i];    
    const int curStride = curStrideBuf[i];

    if( type & CCP_TYPE_CCCM )
    {
      for( int pos = 0; pos < posEnd[i]; pos++, src += srcStrideBuf[i] )
      {
        samples[0] = *src + lumaOffset;                 // C
        samples[1] = *( src - srcStride ) + lumaOffset;   // N
        samples[2] = *( src + srcStride ) + lumaOffset;   // S
        samples[3] = *( src - 1 ) + lumaOffset;           // W
        samples[4] = *( src + 1 ) + lumaOffset;           // E
        samples[5] = cccmModel[0].nonlinear( *src + lumaOffset );
        samples[6] = cccmModel[0].bias();

#if MMLM
        if( ( type & CCP_TYPE_MMLM ) && *src + lumaOffset > modelThr )
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[1].convolve( samples );
            totalOffset[1] += curChroma0[pos * curStride] - predChroma;
            count[1]++;
          }
          else
          {
            predChroma = cccmModel[1].convolve( samples ) + chromaOffset[1];
          }
        }
        else
#endif
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[0].convolve( samples );
            totalOffset[0] += curChroma0[pos * curStride] - predChroma;
            count[0]++;
          }
          else
          {
            predChroma = cccmModel[0].convolve( samples ) + chromaOffset[0];
          }
        }

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, i) = ClipPel<Pel>(predChroma, clpRng);
        sad += abs(curChroma0[pos * curStride] - predBuf.at(pos, i));
#else
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos * curStride] - predChroma );
#endif
      }
    }
#if JVET_AC0054_GLCCCM
    else if( type & CCP_TYPE_GLCCCM )
    {
      for( int pos = 0; pos < posEnd[i]; pos++, src += srcStrideBuf[i] )
      {
        samples[0] = *src + lumaOffset;   // C
        samples[1] = ( 2 * ( *( src - srcStride ) ) + ( *( src - 1 - srcStride ) ) + ( *( src - srcStride + 1 ) ) )
                   - ( 2 * ( *( src + srcStride ) ) + ( *( src - 1 + srcStride ) ) + ( *( src + srcStride + 1 ) ) );   // Vertical gradient
        samples[2] = ( 2 * ( *( src - 1 ) ) + ( *( src - 1 - srcStride ) ) + ( *( src - 1 + srcStride ) ) )
                   - ( 2 * ( *( src + 1 ) ) + ( *( src + 1 - srcStride ) ) + ( *( src + 1 + srcStride ) ) );   // Horizontal gradient
        samples[3] = ( ( ( i ? pos : -1 ) + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT );            // Y coordinate
        samples[4] = ( ( ( i ? -1 : pos ) + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT );            // X coordinate
        samples[5] = cccmModel[0].nonlinear( *src + lumaOffset );
        samples[6] = cccmModel[0].bias();

#if MMLM
        if( ( type & CCP_TYPE_MMLM ) && *src + lumaOffset > modelThr )
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[1].convolve( samples );
            totalOffset[1] += curChroma0[pos * curStride] - predChroma;
            count[1]++;
          }
          else
          {
            predChroma = cccmModel[1].convolve( samples ) + chromaOffset[1];
          }
        }
        else
#endif
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[0].convolve( samples );
            totalOffset[0] += curChroma0[pos * curStride] - predChroma;
            count[0]++;
          }
          else
          {
            predChroma = cccmModel[0].convolve( samples ) + chromaOffset[0];
          }
        }

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, i) = ClipPel<Pel>(predChroma, clpRng);
        sad += abs(curChroma0[pos * curStride] - predBuf.at(pos, i));
#else
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos * curStride] - predChroma );
#endif
      }
    }
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
    else if( type & CCP_TYPE_NSCCCM )
    {
      const int stride = step[i] * srcStrideBuf[i];
      const Pel *src0 = i ? refLumaBlk.bufAt( -stepX, 0 ) : refLumaBlk.bufAt( 0, -stepY );
      const Pel *src1 = i ? refLumaBlk.bufAt( -stepX, 1 ) : refLumaBlk.bufAt( 0, -stepY + 1 );

      for( int pos = 0; pos < posEnd[i]; pos++ )
      {
        samples[0] = src0[0] + lumaOffset;
        samples[1] = src0[-1] + lumaOffset;
        samples[2] = src0[1] + lumaOffset;
        samples[3] = src1[0] + lumaOffset;
        samples[4] = src1[-1] + lumaOffset;
        samples[5] = src1[1] + lumaOffset;
        samples[6] = cccmModel[0].nonlinear( src0[0] + lumaOffset );
        samples[7] = cccmModel[0].nonlinear( src1[0] + lumaOffset );
        samples[8] = cccmModel[0].nonlinear( src0[1] + lumaOffset );
        samples[9] = cccmModel[0].nonlinear( src0[-1] + lumaOffset );
        samples[10] = cccmModel[0].bias();

#if MMLM
        if( ( type & CCP_TYPE_MMLM ) && src0[0] + lumaOffset > modelThr )
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[1].convolve( samples );
            totalOffset[1] += curChroma0[pos * curStride] - predChroma;
            count[1]++;
          }
          else
          {
            predChroma = cccmModel[1].convolve( samples ) + chromaOffset[1];
          }
        }
        else
#endif
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[0].convolve( samples );
            totalOffset[0] += curChroma0[pos * curStride] - predChroma;
            count[0]++;
          }
          else
          {
            predChroma = cccmModel[0].convolve( samples ) + chromaOffset[0];
          }
        }

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, i) = ClipPel<Pel>(predChroma, clpRng);
        sad += abs(curChroma0[pos * curStride] - predBuf.at(pos, i));
#else
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos * curStride] - predChroma );
#endif

        src0 += stride;
        src1 += stride;
      }
    }
#endif
#if JVET_AD0202_CCCM_MDF
    else if( ( type & CCP_TYPE_MDFCCCM ) && cccmMultiFilterIdx == 1 )
    {
      for( int pos = 0; pos < posEnd[i]; pos++ )
      {
        Position p = Position( ( i ? -1 : pos ), ( i ? pos : -1 ) );

        samples[0] = refLumaBlk.at( p ) + lumaOffset; // C
        samples[1] = refLumaBlk1.at( p ) + lumaOffset; // W
        samples[2] = refLumaBlk2.at( p ) + lumaOffset; // E
        samples[3] = refLumaBlk3.at( p ) + lumaOffset;
        samples[4] = cccmModel[0].nonlinear( refLumaBlk.at( p ) + lumaOffset );
        samples[5] = cccmModel[0].nonlinear( refLumaBlk1.at( p ) + lumaOffset );
        samples[6] = cccmModel[0].nonlinear( refLumaBlk2.at( p ) + lumaOffset );
        samples[7] = ( p.y + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // Y coordinate
        samples[8] = ( p.x + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // X coordinate
        samples[9] = cccmModel[0].bias();

#if MMLM
        if( ( type & CCP_TYPE_MMLM ) && refLumaBlk.at( p ) + lumaOffset > modelThr )
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[1].convolve( samples );
            totalOffset[1] += curChroma0[pos * curStride] - predChroma;
            count[1]++;
          }
          else
          {
            predChroma = cccmModel[1].convolve( samples ) + chromaOffset[1];
          }
        }
        else
#endif
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[0].convolve( samples );
            totalOffset[0] += curChroma0[pos * curStride] - predChroma;
            count[0]++;
          }
          else
          {
            predChroma = cccmModel[0].convolve( samples ) + chromaOffset[0];
          }
        }

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, i) = ClipPel<Pel>(predChroma, clpRng);
        sad += abs(curChroma0[pos * curStride] - predBuf.at(pos, i));
#else
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos * curStride] - predChroma );
#endif
      }
    }
    else if( ( type & CCP_TYPE_MDFCCCM ) && cccmMultiFilterIdx == 2 )
    {
      const Pel* src0 = i ? refLumaBlk.bufAt( 0, 0 ) : refLumaBlk.bufAt( 1, -1 );
      const Pel* src1 = i ? refLumaBlk1.bufAt( 0, 0 ) : refLumaBlk1.bufAt( 1, -1 );

      const int stride0 = srcStrideBuf[i];
      const int stride1 = i ? refLumaBlk1.stride : 1;

      for( int pos = 0; pos < posEnd[i]; pos++ )
      {
        samples[0] = src0[-1] + lumaOffset; // C
        samples[1] = src0[-2] + lumaOffset; // W
        samples[2] = src0[0] + lumaOffset; // E
        samples[3] = src1[-1] + lumaOffset; // C
        samples[4] = src1[-2] + lumaOffset; // W
        samples[5] = src1[0] + lumaOffset; // E
        samples[6] = cccmModel[0].nonlinear( src0[-1] + lumaOffset );
        samples[7] = cccmModel[0].nonlinear( src0[-2] + lumaOffset );
        samples[8] = cccmModel[0].nonlinear( src0[0] + lumaOffset );
        samples[9] = ( ( i ? -1 : pos ) + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // X coordinate
        samples[10] = cccmModel[0].bias();

#if MMLM
        if( ( type & CCP_TYPE_MMLM ) && src0[-1] + lumaOffset > modelThr )
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[1].convolve( samples );
            totalOffset[1] += curChroma0[pos * curStride] - predChroma;
            count[1]++;
          }
          else
          {
            predChroma = cccmModel[1].convolve( samples ) + chromaOffset[1];
          }
        }
        else
#endif
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[0].convolve( samples );
            totalOffset[0] += curChroma0[pos * curStride] - predChroma;
            count[0]++;
          }
          else
          {
            predChroma = cccmModel[0].convolve( samples ) + chromaOffset[0];
          }
        }

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, i) = ClipPel<Pel>(predChroma, clpRng);
        sad += abs(curChroma0[pos * curStride] - predBuf.at(pos, i));
#else
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos * curStride] - predChroma );
#endif

        src0 += stride0;
        src1 += stride1;
      }
    }
    else if( ( type & CCP_TYPE_MDFCCCM ) && cccmMultiFilterIdx == 3 )
    {
      const Pel* src0[3] = { i ?  refLumaBlk.bufAt( -1, 0 ) :  refLumaBlk.bufAt( 0, -1 ), i ?  refLumaBlk.bufAt( 0, -1 ) :  refLumaBlk.bufAt( 1, -2 ), i ?  refLumaBlk.bufAt( -2, 1 ) :  refLumaBlk.bufAt( -1, 0 ) };
      const Pel* src1[3] = { i ? refLumaBlk3.bufAt( -1, 0 ) : refLumaBlk3.bufAt( 0, -1 ), i ? refLumaBlk3.bufAt( 0, -1 ) : refLumaBlk3.bufAt( 1, -2 ), i ? refLumaBlk3.bufAt( -2, 1 ) : refLumaBlk3.bufAt( -1, 0 ) };

      const int stride0 = srcStrideBuf[i];
      const int stride1 = i ? refLumaBlk3.stride : 1;

      for( int pos = 0; pos < posEnd[i]; pos++ )
      {
        samples[0] = *src0[0] + lumaOffset; // C
        samples[1] = *src0[1] + lumaOffset; // EN
        samples[2] = *src0[2] + lumaOffset; // WS
        samples[3] = *src1[0] + lumaOffset; // C
        samples[4] = *src1[1] + lumaOffset; // EN
        samples[5] = *src1[2] + lumaOffset; // WS
        samples[6] = cccmModel[0].nonlinear( *src0[0] + lumaOffset );
        samples[7] = cccmModel[0].nonlinear( *src0[1] + lumaOffset );
        samples[8] = cccmModel[0].nonlinear( *src0[2] + lumaOffset );
        samples[9] = ( ( i ? pos : -1 ) + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // Y coordinate
        samples[10] = cccmModel[0].bias();
        
#if MMLM
        if( ( type & CCP_TYPE_MMLM ) && *src0[0] + lumaOffset > modelThr )
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[1].convolve( samples );
            totalOffset[1] += curChroma0[pos * curStride] - predChroma;
            count[1]++;
          }
          else
          {
            predChroma = cccmModel[1].convolve( samples ) + chromaOffset[1];
          }
        }
        else
#endif
        {
          if( updateOffsets )
          {
            predChroma = cccmModel[0].convolve( samples );
            totalOffset[0] += curChroma0[pos * curStride] - predChroma;
            count[0]++;
          }
          else
          {
            predChroma = cccmModel[0].convolve( samples ) + chromaOffset[0];
          }
        }

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, i) = ClipPel<Pel>(predChroma, clpRng);
        sad += abs(curChroma0[pos * curStride] - predBuf.at(pos, i));
#else
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos * curStride] - predChroma );
#endif

        src0[0] += stride0;
        src0[1] += stride0;
        src0[2] += stride0;
        src1[0] += stride1;
        src1[1] += stride1;
        src1[2] += stride1;
      }
    }
#endif
    else
    {
      THROW( "Invalid type" );
    }
  }

  if( updateOffsets )
  {
    chromaOffset[0] = chromaOffset[1] = 0;

    if( count[0] )
    {
      chromaOffset[0] = PU::getMeanValue( totalOffset[0], count[0] );   // totalOffset[0] / count[0];
    }
    if( ( type & CCP_TYPE_MMLM ) && count[1] )
    {
      chromaOffset[1] = PU::getMeanValue( totalOffset[1], count[1] );   // totalOffset[1] / count[1];
    }
  }

  return sad;
}

template <const bool updateOffsets>
int IntraPrediction::xUpdateOffsetsAndGetCostGLM(const PredictionUnit &pu, const ComponentID compID, const CompArea &chromaArea,
                                                 CccmModel& glmModel, int glmIdc, int lumaOffset, int &chromaOffset
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
                                               , int candIdx
#endif
                                                )
{
  const ClpRng &clpRng(pu.cu->cs->slice->clpRng(compID));
  CHECK(compID != chromaArea.compID, "Invalid component ID");

  Pel* samples = m_samples;

  CPelBuf refLumaBlk = xGlmGetGradPuBuf(pu, chromaArea, 0);
  CPelBuf refGradBlk = xGlmGetGradPuBuf(pu, chromaArea, glmIdc);

  const SizeType cWidth  = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable  = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  const Pel *srcColor0, *srcColor1, *curChroma0;

  srcColor0      = refGradBlk.bufAt(0, 0);
  int srcStride0 = refGradBlk.stride;
  srcColor1      = refLumaBlk.bufAt(0, 0);
  int srcStride1 = refLumaBlk.stride;

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf(compID == COMPONENT_Cb ? m_CCPFusionTempCb[candIdx] : m_CCPFusionTempCr[candIdx], maxSize, Size(maxSize, 2));
#endif

  Pel      *curChromaBuf = chromaReco.buf;
  const int curStride    = chromaReco.stride;

  int sad = 0;
  int totalOffset = 0;
  int count = 0;

  if (aboveAvailable)
  {
    curChroma0      = curChromaBuf - curStride;
    const Pel *src0 = srcColor0 - srcStride0;
    const Pel *src1 = srcColor1 - srcStride1;

    for( int pos = 0; pos < cWidth; pos++, src0++, src1++ )
    {
      samples[0] = *src0;                // luma gradient
      samples[1] = *src1 + lumaOffset;   // luma value
      samples[2] = glmModel.bias();

      if( updateOffsets )
      {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 0) = glmModel.convolve(samples);
        totalOffset += curChroma0[pos] - predBuf.at(pos, 0);
#else
        Pel predChroma = glmModel.convolve( samples );
        totalOffset += curChroma0[pos] - predChroma;
#endif
        count++;
      }
      else
      {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 0) = glmModel.convolve(samples) + chromaOffset;
        predBuf.at(pos, 0) = ClipPel<Pel>(predBuf.at(pos, 0), clpRng);
        sad += abs(curChroma0[pos] - predBuf.at(pos, 0));
#else
        Pel predChroma = glmModel.convolve( samples ) + chromaOffset;
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos] - predChroma );
#endif
      }
    }
  }

  if (leftAvailable)
  {
    curChroma0 = curChromaBuf - 1;

    const Pel *src0 = srcColor0 - 1;
    const Pel *src1 = srcColor1 - 1;

    for (int pos = 0; pos < cHeight; pos++, src0 += srcStride0, src1 += srcStride1)
    {
      samples[0] = *src0;                // luma gradient
      samples[1] = *src1 + lumaOffset;   // luma value
      samples[2] = glmModel.bias();

      if( updateOffsets )
      {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 1) = glmModel.convolve(samples);
        totalOffset += curChroma0[pos * curStride] - predBuf.at(pos, 1);
#else
        Pel predChroma = glmModel.convolve( samples );
        totalOffset += curChroma0[pos * curStride] - predChroma;
#endif
        count++;
      }
      else
      {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        predBuf.at(pos, 1) = glmModel.convolve(samples) + chromaOffset;
        predBuf.at(pos, 1) = ClipPel<Pel>(predBuf.at(pos, 1), clpRng);
        sad += abs(curChroma0[pos * curStride] - predBuf.at(pos, 1));
#else
        Pel predChroma = glmModel.convolve( samples ) + chromaOffset;
        predChroma = ClipPel<Pel>( predChroma, clpRng );
        sad += abs( curChroma0[pos * curStride] - predChroma );
#endif
      }
    }
  }

  if( updateOffsets )
  {
    chromaOffset = 0;

    if( count )
    {
      chromaOffset = PU::getMeanValue( totalOffset, count );   // totalOffset / count;
    }
  }

  return sad;
}
void IntraPrediction::xCclmApplyModel(const PredictionUnit &pu, const ComponentID compId,
                                      CccmModel& cccmModel, int modelId, int modelThr,
                                      PelBuf &piPred)
{
  const ClpRng &clpRng(pu.cu->cs->slice->clpRng(compId));
  Pel* samples = m_samples;

  CPelBuf refLumaBlk = xCccmGetLumaPuBuf(pu);

  for (int y = 0; y < refLumaBlk.height; y++)
  {
    for (int x = 0; x < refLumaBlk.width; x++)
    {
      if (modelId == 1 && refLumaBlk.at(x, y) > modelThr)   // Model 1: Include only samples below or equal to the threshold
      {
        continue;
      }
      if (modelId == 2 && refLumaBlk.at(x, y) <= modelThr)   // Model 2: Include only samples above the threshold
      {
        continue;
      }
      samples[0] = refLumaBlk.at(x, y);   // C
      samples[1] = cccmModel.bias();

#if JVET_AJ0237_INTERNAL_12BIT
      piPred.at(x, y) = ClipPel<Pel>(Pel((cccmModel.params[0] * samples[0] + cccmModel.params[1] * samples[1] + cccmModel.decimRound) >> cccmModel.decimBits), clpRng);
#else
      piPred.at(x, y) = ClipPel<Pel>(Pel((cccmModel.params[0] * samples[0] + cccmModel.params[1] * samples[1] + CCCM_DECIM_ROUND) >> CCCM_DECIM_BITS), clpRng);
#endif
    }
  }
}

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
void IntraPrediction::reorderCCPCandidates(PredictionUnit &pu, CCPModelCandidate candList[], int reorderlistSize, int* fusionList)
#else
void IntraPrediction::reorderCCPCandidates(PredictionUnit &pu, CCPModelCandidate candList[], int reorderlistSize)
#endif
{
  int candCost[MAX_CCP_CAND_LIST_SIZE];
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  int ccpCandIndex[MAX_CCP_CAND_LIST_SIZE];
#endif
  for (int i = 0; i < reorderlistSize; i++)
  {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
    candCost[i] = xGetOneCCPCandCost(pu, candList[i], i);
    ccpCandIndex[i] = i;
#else
    candCost[i] = xGetOneCCPCandCost(pu, candList[i]);
#endif
  }

  //Inserting sorting
  for (int i = 1; i < reorderlistSize; i++)
  {
    for (int j = 0; j < i; j++)
    {
      if (candCost[i] < candCost[j])
      {
        CCPModelCandidate tmpCand = candList[i];
        int tmpCost = candCost[i];
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        int tempIndex = ccpCandIndex[i];
#endif
        for (int k = i; k > j; k--)
        {
          candList[k] = candList[k - 1];
          candCost[k] = candCost[k - 1];
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
          ccpCandIndex[k] = ccpCandIndex[k - 1];
#endif
        }
        candList[j] = tmpCand;
        candCost[j] = tmpCost;
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        ccpCandIndex[j] = tempIndex;
#endif
        break;
      }
    }
  }

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  if ((pu.cs->pcv->isEncoder || pu.ddNonLocalCCPFusion > 0) && (pu.cu->slice->getSPS()->getUseDdCcpFusion()))
  {
    int FusionCandCost[MAX_CCP_FUSION_NUM] = { MAX_INT };

    int maxCandIdxForCcpFusion = std::min(reorderlistSize, 9);
    for (int i = 0; i < maxCandIdxForCcpFusion - 1; i++)
    {
      for (int j = i + 1; j < maxCandIdxForCcpFusion; j++)
      {
        int sad = 0;
        sad += xGetCostCCPFusion(pu, COMPONENT_Cb, pu.Cb(), ccpCandIndex[i], ccpCandIndex[j]);
        sad += xGetCostCCPFusion(pu, COMPONENT_Cr, pu.Cr(), ccpCandIndex[i], ccpCandIndex[j]);
        for (int m = 0; m < MAX_CCP_FUSION_NUM; m++)
        {
          if (sad < FusionCandCost[m])
          {
            for (int n = MAX_CCP_FUSION_NUM - 2; n >= m; n--)
            {
              const int nextIdx = n + 1;
              FusionCandCost[nextIdx] = FusionCandCost[n];
              fusionList[2 * nextIdx] = fusionList[2 * n];
              fusionList[2 * nextIdx + 1] = fusionList[2 * n + 1];
            }
            FusionCandCost[m] = sad;
            fusionList[2 * m] = i;
            fusionList[2 * m + 1] = j;

            break;
          }
        }
      }
    }
  }
#endif
}

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
int IntraPrediction::xGetOneCCPCandCost( PredictionUnit &pu, CCPModelCandidate &ccpCand, const int candIdx )
#else
int IntraPrediction::xGetOneCCPCandCost( PredictionUnit &pu, CCPModelCandidate &ccpCand )
#endif
{
  CompArea chromaArea = pu.Cb();
  int cost = 0;
  const int bitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  int offsetCb[2] = { 0, 0 };
  int offsetCr[2] = { 0, 0 };

#if JVET_AF0073_INTER_CCP_MERGE
  CHECK((ccpCand.type & CCP_TYPE_INTER_CCCM) && (ccpCand.type & CCP_TYPE_MMLM), "wrong type");
#endif
  CHECK(ccpCand.type == CCP_TYPE_NONE, "CCP model with no type")
  {
    if (ccpCand.type & (CCP_TYPE_CCCM | CCP_TYPE_GLCCCM))
    {
#if JVET_AB0174_CCCM_DIV_FREE
      int lumaOffset = m_cccmLumaOffset - ccpCand.lumaOffset;
#else
      int lumaOffset = 0;
#endif
      int refSizeX = ccpCand.corOffX;
      int refSizeY = ccpCand.corOffY;

      CccmModel cccmModelCb[2] = { CccmModel( CCCM_NUM_PARAMS, bitDepth ), CccmModel( CCCM_NUM_PARAMS, bitDepth ) };
      CccmModel cccmModelCr[2] = { CccmModel( CCCM_NUM_PARAMS, bitDepth ), CccmModel( CCCM_NUM_PARAMS, bitDepth ) };

      PU::ccpParamsToCccmModel(ccpCand, cccmModelCb, cccmModelCr);

      cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cb, pu.Cb(), cccmModelCb, ccpCand.yThres, lumaOffset, offsetCb, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        , refSizeX, refSizeY);
      cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cr, pu.Cr(), cccmModelCr, ccpCand.yThres, lumaOffset, offsetCr, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        , refSizeX, refSizeY);
    }
#if JVET_AF0073_INTER_CCP_MERGE
    else if (ccpCand.type & (CCP_TYPE_INTER_CCCM))
    {
#if JVET_AB0174_CCCM_DIV_FREE
      int lumaOffset = m_cccmLumaOffset - ccpCand.lumaOffset;
#else
      int lumaOffset = 0;
#endif
      pu.cccmNoSubFlag = 1;

      CccmModel interCccmModels[] = { CccmModel( INTER_CCCM_NUM_PARAMS, bitDepth ), CccmModel( INTER_CCCM_NUM_PARAMS, bitDepth ) };

      PU::ccpParamsToCccmModel(ccpCand, interCccmModels[0], interCccmModels[1]);

      cost += xGetCostInterCccm(pu, COMPONENT_Cb, pu.Cb(), interCccmModels[0], lumaOffset, offsetCb[0]
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
      );
      cost += xGetCostInterCccm(pu, COMPONENT_Cr, pu.Cr(), interCccmModels[1], lumaOffset, offsetCr[0]
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
      );

      pu.cccmNoSubFlag = 0;
    }
#endif
#if JVET_AD0202_CCCM_MDF
    else if (ccpCand.type & (CCP_TYPE_MDFCCCM))
    {
      pu.cccmMultiFilterIdx = ccpCand.cccmMultiFilterIdx;
#if JVET_AB0174_CCCM_DIV_FREE
      int lumaOffset = m_cccmLumaOffset - ccpCand.lumaOffset;
#else
      int lumaOffset = 0;
#endif
      int refSizeX = ccpCand.corOffX;
      int refSizeY = ccpCand.corOffY;

      if (ccpCand.cccmMultiFilterIdx == 1)
      {
        CccmModel cccmModelCb[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth ), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth) };
        CccmModel cccmModelCr[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth ), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth) };

        PU::ccpParamsToCccmModel(ccpCand, cccmModelCb, cccmModelCr);

        cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cb, pu.Cb(), cccmModelCb, ccpCand.yThres, lumaOffset, offsetCb, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
          , candIdx
#endif
          , refSizeX, refSizeY, ccpCand.cccmMultiFilterIdx );
        cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cr, pu.Cr(), cccmModelCr, ccpCand.yThres, lumaOffset, offsetCr, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
          , candIdx
#endif
          , refSizeX, refSizeY, ccpCand.cccmMultiFilterIdx );
      }
      else
      {
        CHECK(ccpCand.cccmMultiFilterIdx != 2 && ccpCand.cccmMultiFilterIdx != 3, "Unexpected cccmMultiFilterIdx");

        CccmModel cccmModelCb[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth) };
        CccmModel cccmModelCr[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth) };

        PU::ccpParamsToCccmModel(ccpCand, cccmModelCb, cccmModelCr);

        cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cb, pu.Cb(), cccmModelCb, ccpCand.yThres, lumaOffset, offsetCb, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
          , candIdx
#endif
          , refSizeX, refSizeY, ccpCand.cccmMultiFilterIdx );
        cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cr, pu.Cr(), cccmModelCr, ccpCand.yThres, lumaOffset, offsetCr, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
          , candIdx
#endif
          , refSizeX, refSizeY, ccpCand.cccmMultiFilterIdx );
      }

      pu.cccmMultiFilterIdx = 0;
    }
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
    else if (ccpCand.type & CCP_TYPE_NSCCCM)
    {
#if JVET_AB0174_CCCM_DIV_FREE
      int lumaOffset = m_cccmLumaOffset - ccpCand.lumaOffset;
#else
      int lumaOffset = 0;
#endif
      pu.cccmNoSubFlag = 1;

      CccmModel cccmModelCb[2] = { CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ), CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ) };
      CccmModel cccmModelCr[2] = { CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ), CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ) };
        
      PU::ccpParamsToCccmModel(ccpCand, cccmModelCb, cccmModelCr);
        
      cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cb, pu.Cb(), cccmModelCb, ccpCand.yThres, lumaOffset, offsetCb, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        );
      cost += xUpdateOffsetsAndGetCostCCCM<false>(pu, COMPONENT_Cr, pu.Cr(), cccmModelCr, ccpCand.yThres, lumaOffset, offsetCr, ccpCand.type
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        );

      pu.cccmNoSubFlag = 0;
    }
#endif
    else if (ccpCand.type & (CCP_TYPE_CCLM | CCP_TYPE_GLM0123))
    {
      CPelBuf temp;
      int     lumaStride;

      if (ccpCand.type & CCP_TYPE_GLM0123)
      {
        Pel *glmTemp = m_glmTempCb[ccpCand.glmIdc];
        lumaStride   = 2 * MAX_CU_SIZE + 1;
        temp         = PelBuf(glmTemp + lumaStride + 1, lumaStride, Size(chromaArea));
      }
      else
      {
        lumaStride = MAX_CU_SIZE + 1;
        temp       = PelBuf(m_piTemp + lumaStride + 1, lumaStride, Size(chromaArea));
      }

      CclmModel cclmModels;
      PU::ccpParamsToCclmModel(COMPONENT_Cb, ccpCand, cclmModels);
      cost += xUpdateOffsetsAndGetCostCCLM<false>(pu, COMPONENT_Cb, pu.Cb(), cclmModels, 1, ccpCand.glmIdc
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        );
      PU::ccpParamsToCclmModel(COMPONENT_Cr, ccpCand, cclmModels);
      cost += xUpdateOffsetsAndGetCostCCLM<false>(pu, COMPONENT_Cr, pu.Cr(), cclmModels, 1, ccpCand.glmIdc
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        );
    }
    else if (ccpCand.type & CCP_TYPE_GLM4567)
    {
      int glmIdc       = ccpCand.glmIdc;
      int chromaOffset = 0;
#if JVET_AB0174_CCCM_DIV_FREE
      int lumaOffset = m_glmLumaOffset - ccpCand.lumaOffset;
#else
      int lumaOffset = 0;
#endif
      CccmModel glmModel( GLM_NUM_PARAMS, bitDepth );
      PU::ccpParamsToGlmModel(COMPONENT_Cb, ccpCand, glmModel);
      cost += xUpdateOffsetsAndGetCostGLM<false>(pu, COMPONENT_Cb, pu.Cb(), glmModel, glmIdc, lumaOffset, chromaOffset
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        );
      PU::ccpParamsToGlmModel(COMPONENT_Cr, ccpCand, glmModel);
      cost += xUpdateOffsetsAndGetCostGLM<false>(pu, COMPONENT_Cr, pu.Cr(), glmModel, glmIdc, lumaOffset, chromaOffset
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
        , candIdx
#endif
        );
    }
    else
    {
      THROW("Invalid type!");
    }
  }
  return cost;
}

void IntraPrediction::predCCPCandidate(PredictionUnit &pu, PelBuf &predCb, PelBuf &predCr)
{
  const int bitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  if (pu.idxNonLocalCCP)
  {
    CompArea                   chromaArea = pu.Cb();
    int                        cWidth     = chromaArea.width;
    int                        cHeight    = chromaArea.height;
    CccmModel cccmModelCb[2] = { CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth ) };
    CccmModel cccmModelCr[2] = { CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth ) };

    CHECK(pu.curCand.type == CCP_TYPE_NONE, "CCP model with no type")
    {
      if (pu.curCand.type & (CCP_TYPE_CCCM | CCP_TYPE_GLCCCM))
      {
#if JVET_AB0174_CCCM_DIV_FREE
        int lumaOffset = m_cccmLumaOffset - pu.curCand.lumaOffset;
#else
        int lumaOffset = 0;
#endif
        int refSizeX = pu.curCand.corOffX;
        int refSizeY = pu.curCand.corOffY;
        int offsetCb[2] = { 0, 0 };
        int offsetCr[2] = { 0, 0 };

        PU::ccpParamsToCccmModel(pu.curCand, cccmModelCb, cccmModelCr);

        if (!(pu.curCand.type & CCP_TYPE_MMLM))
        {
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), cccmModelCb, 0, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY);
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), cccmModelCr, 0, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY);
#endif
          xCccmApplyModelOffset(pu, COMPONENT_Cb, cccmModelCb[0], 0, 0, predCb, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY);
          xCccmApplyModelOffset(pu, COMPONENT_Cr, cccmModelCr[0], 0, 0, predCr, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY);
        }
        else
        {
          // Multimode case
          int modelThr = pu.curCand.yThres;
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), cccmModelCb, modelThr, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY);
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), cccmModelCr, modelThr, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY);
#endif
          xCccmApplyModelOffset(pu, COMPONENT_Cb, cccmModelCb[0], 1, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY);
          xCccmApplyModelOffset(pu, COMPONENT_Cr, cccmModelCr[0], 1, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY);

          xCccmApplyModelOffset(pu, COMPONENT_Cb, cccmModelCb[1], 2, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY);
          xCccmApplyModelOffset(pu, COMPONENT_Cr, cccmModelCr[1], 2, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY);
        }
      }
#if JVET_AF0073_INTER_CCP_MERGE
      else if (pu.curCand.type & CCP_TYPE_INTER_CCCM)
      {
        CccmModel interCccmModels[] = { CccmModel( INTER_CCCM_NUM_PARAMS, bitDepth ), CccmModel( INTER_CCCM_NUM_PARAMS, bitDepth ) };

#if JVET_AB0174_CCCM_DIV_FREE
        int lumaOffset = m_cccmLumaOffset - pu.curCand.lumaOffset;
#else
        int lumaOffset = 0;
#endif
        pu.cccmNoSubFlag = 1;
        int offsetCb = 0;
        int offsetCr = 0;

        PU::ccpParamsToCccmModel(pu.curCand, interCccmModels[0], interCccmModels[1]);

        xInterCccmApplyModelOffset(pu, COMPONENT_Cb, interCccmModels[0], predCb, lumaOffset, offsetCb);
        xInterCccmApplyModelOffset(pu, COMPONENT_Cr, interCccmModels[1], predCr, lumaOffset, offsetCr);
        pu.cccmNoSubFlag = 0;
      }
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
      else if (pu.curCand.type & CCP_TYPE_NSCCCM)
      {
        CccmModel nscccmModelCb[2] = { CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ), CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ) };
        CccmModel nscccmModelCr[2] = { CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ), CccmModel( CCCM_NO_SUB_NUM_PARAMS, bitDepth ) };
#if JVET_AB0174_CCCM_DIV_FREE
        int lumaOffset = m_cccmLumaOffset - pu.curCand.lumaOffset;
#else
        int lumaOffset = 0;
#endif
        pu.cccmNoSubFlag = 1;
        int offsetCb[2] = { 0, 0 };
        int offsetCr[2] = { 0, 0 };

        PU::ccpParamsToCccmModel(pu.curCand, nscccmModelCb, nscccmModelCr);

        if (!(pu.curCand.type & CCP_TYPE_MMLM))
        {
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), nscccmModelCb, 0, lumaOffset, offsetCb, pu.curCand.type );
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), nscccmModelCr, 0, lumaOffset, offsetCr, pu.curCand.type );
#endif
          xCccmApplyModelOffset(pu, COMPONENT_Cb, nscccmModelCb[0], 0, 0, predCb, lumaOffset, offsetCb, pu.curCand.type );
          xCccmApplyModelOffset(pu, COMPONENT_Cr, nscccmModelCr[0], 0, 0, predCr, lumaOffset, offsetCr, pu.curCand.type );
        }
        else
        {
          // Multimode case
          int modelThr = pu.curCand.yThres;
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), nscccmModelCb, modelThr, lumaOffset, offsetCb, pu.curCand.type );
          xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), nscccmModelCr, modelThr, lumaOffset, offsetCr, pu.curCand.type );
#endif
          xCccmApplyModelOffset(pu, COMPONENT_Cb, nscccmModelCb[0], 1, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type );
          xCccmApplyModelOffset(pu, COMPONENT_Cr, nscccmModelCr[0], 1, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type );

          xCccmApplyModelOffset(pu, COMPONENT_Cb, nscccmModelCb[1], 2, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type );
          xCccmApplyModelOffset(pu, COMPONENT_Cr, nscccmModelCr[1], 2, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type );
        }

        pu.cccmNoSubFlag = 0;
      }
#endif
#if JVET_AD0202_CCCM_MDF
      else if (pu.curCand.type & CCP_TYPE_MDFCCCM)
      {
        pu.cccmMultiFilterIdx = pu.curCand.cccmMultiFilterIdx;
#if JVET_AB0174_CCCM_DIV_FREE
        int lumaOffset = m_cccmLumaOffset - pu.curCand.lumaOffset;
#else
        int lumaOffset = 0;
#endif
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
        int refSizeX = pu.curCand.corOffX;
        int refSizeY = pu.curCand.corOffY;
#endif
        int offsetCb[2] = { 0, 0 };
        int offsetCr[2] = { 0, 0 };

        if (pu.curCand.cccmMultiFilterIdx == 1)
        {
          CccmModel mfcccmModelCb[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth) };
          CccmModel mfcccmModelCr[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, bitDepth) };

          PU::ccpParamsToCccmModel(pu.curCand, mfcccmModelCb, mfcccmModelCr);

          if (!(pu.curCand.type & CCP_TYPE_MMLM))
          {
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), mfcccmModelCb, 0, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), mfcccmModelCr, 0, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
#endif
            xCccmApplyModelOffset(pu, COMPONENT_Cb, mfcccmModelCb[0], 0, 0, predCb, lumaOffset, offsetCb, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
            xCccmApplyModelOffset(pu, COMPONENT_Cr, mfcccmModelCr[0], 0, 0, predCr, lumaOffset, offsetCr, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
          }
          else
          {
            // Multimode case
            int modelThr = pu.curCand.yThres;
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), mfcccmModelCb, modelThr, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), mfcccmModelCr, modelThr, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
#endif
            xCccmApplyModelOffset(pu, COMPONENT_Cb, mfcccmModelCb[0], 1, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
            xCccmApplyModelOffset(pu, COMPONENT_Cr, mfcccmModelCr[0], 1, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );

            xCccmApplyModelOffset(pu, COMPONENT_Cb, mfcccmModelCb[1], 2, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
            xCccmApplyModelOffset(pu, COMPONENT_Cr, mfcccmModelCr[1], 2, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
          }
        }
        else // if (pu.curCand.cccmMultiFilterIdx == 2 || pu.curCand.cccmMultiFilterIdx == 3)
        {
          CccmModel mfcccmModelCb[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth) };
          CccmModel mfcccmModelCr[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, bitDepth) };

          PU::ccpParamsToCccmModel(pu.curCand, mfcccmModelCb, mfcccmModelCr);

          if (!(pu.curCand.type & CCP_TYPE_MMLM))
          {
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), mfcccmModelCb, 0, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), mfcccmModelCr, 0, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
#endif
            xCccmApplyModelOffset(pu, COMPONENT_Cb, mfcccmModelCb[0], 0, 0, predCb, lumaOffset, offsetCb, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
            xCccmApplyModelOffset(pu, COMPONENT_Cr, mfcccmModelCr[0], 0, 0, predCr, lumaOffset, offsetCr, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
          }
          else
          {
            // Multimode case
            int modelThr = pu.curCand.yThres;
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cb, pu.Cb(), mfcccmModelCb, modelThr, lumaOffset, offsetCb, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
            xUpdateOffsetsAndGetCostCCCM<true>(pu, COMPONENT_Cr, pu.Cr(), mfcccmModelCr, modelThr, lumaOffset, offsetCr, pu.curCand.type, refSizeX, refSizeY, pu.curCand.cccmMultiFilterIdx );
#endif
            xCccmApplyModelOffset(pu, COMPONENT_Cb, mfcccmModelCb[0], 1, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
            xCccmApplyModelOffset(pu, COMPONENT_Cr, mfcccmModelCr[0], 1, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );

            xCccmApplyModelOffset(pu, COMPONENT_Cb, mfcccmModelCb[1], 2, modelThr, predCb, lumaOffset, offsetCb, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
            xCccmApplyModelOffset(pu, COMPONENT_Cr, mfcccmModelCr[1], 2, modelThr, predCr, lumaOffset, offsetCr, pu.curCand.type, m_cccmBlkArea.x - m_cccmRefArea.x, m_cccmBlkArea.y - m_cccmRefArea.y );
          }
        }

        pu.cccmMultiFilterIdx = 0;
      }
#endif
      else if (pu.curCand.type & (CCP_TYPE_CCLM | CCP_TYPE_GLM0123))
      {
        CPelBuf temp;
        int     lumaStride;

        if (pu.curCand.type & CCP_TYPE_GLM0123)
        {
          Pel *glmTemp = m_glmTempCb[pu.curCand.glmIdc];
          lumaStride   = 2 * MAX_CU_SIZE + 1;
          temp         = PelBuf(glmTemp + lumaStride + 1, lumaStride, Size(chromaArea));
        }
        else
        {
          lumaStride = MAX_CU_SIZE + 1;
          temp       = PelBuf(m_piTemp + lumaStride + 1, lumaStride, Size(chromaArea));
        }

        CclmModel modelsCb, modelsCr;
        PU::ccpParamsToCclmModel(COMPONENT_Cb, pu.curCand, modelsCb);
        PU::ccpParamsToCclmModel(COMPONENT_Cr, pu.curCand, modelsCr);

        if (!(pu.curCand.type & CCP_TYPE_MMLM))
        {
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
          xUpdateOffsetsAndGetCostCCLM<true>(pu, COMPONENT_Cb, pu.Cb(), modelsCb, 1, pu.curCand.glmIdc);
          xUpdateOffsetsAndGetCostCCLM<true>(pu, COMPONENT_Cr, pu.Cr(), modelsCr, 1, pu.curCand.glmIdc);
#endif
          predCb.copyFrom(temp);
          predCr.copyFrom(temp);

          predCb.linearTransform(modelsCb.a, modelsCb.shift, modelsCb.b, true, pu.cs->slice->clpRng(COMPONENT_Cb));
          predCr.linearTransform(modelsCr.a, modelsCr.shift, modelsCr.b, true, pu.cs->slice->clpRng(COMPONENT_Cb));
        }
        else
        {
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
          xUpdateOffsetsAndGetCostCCLM<true>(pu, COMPONENT_Cb, pu.Cb(), modelsCb, 2, pu.curCand.glmIdc);
          xUpdateOffsetsAndGetCostCCLM<true>(pu, COMPONENT_Cr, pu.Cr(), modelsCr, 2, pu.curCand.glmIdc);
#endif
          auto applyMMCM = [&](PelBuf &predBuf, const CclmModel &cclmModel)
          {
            Pel       *chromaPred   = predBuf.bufAt(0, 0);
            const Pel *lumaReco     = temp.bufAt(0, 0);
            int        chromaStride = predBuf.stride;

            for (int i = 0; i < cHeight; i++)
            {
              for (int j = 0; j < cWidth; j++)
              {
                if (lumaReco[j] <= cclmModel.yThres)
                {
                  chromaPred[j] = (Pel) ClipPel(((cclmModel.a * lumaReco[j]) >> cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(COMPONENT_Cb));
                }
                else
                {
                  chromaPred[j] = (Pel) ClipPel(((cclmModel.a2 * lumaReco[j]) >> cclmModel.shift2) + cclmModel.b2, pu.cs->slice->clpRng(COMPONENT_Cb));
                }
              }
              chromaPred += chromaStride;
              lumaReco += lumaStride;
            }
          };
          applyMMCM(predCb, modelsCb);
          applyMMCM(predCr, modelsCr);
        }
        PU::cclmModelToCcpParams(COMPONENT_Cb, pu.curCand, modelsCb);
        PU::cclmModelToCcpParams(COMPONENT_Cr, pu.curCand, modelsCr);
      }
      else if (pu.curCand.type & CCP_TYPE_GLM4567)
      {
#if JVET_AB0174_CCCM_DIV_FREE
        int lumaOffset = m_glmLumaOffset - pu.curCand.lumaOffset;
#else
        int lumaOffset = 0;
#endif
        int glmIdc       = pu.curCand.glmIdc;
        int chromaOffset = 0;
        CccmModel glmModel( GLM_NUM_PARAMS, bitDepth);

        PU::ccpParamsToGlmModel(COMPONENT_Cb, pu.curCand, glmModel);
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
        xUpdateOffsetsAndGetCostGLM<true>(pu, COMPONENT_Cb, pu.Cb(), glmModel, glmIdc, lumaOffset, chromaOffset);
#endif
        xGlmApplyModelOffset(pu, COMPONENT_Cb, pu.Cb(), glmModel, glmIdc, predCb, lumaOffset, chromaOffset);

        PU::ccpParamsToGlmModel(COMPONENT_Cr, pu.curCand, glmModel);
#if !JVET_AE0097_RM_OFFSET_UPDATE_IN_CCP_MERGE
        xUpdateOffsetsAndGetCostGLM<true>(pu, COMPONENT_Cr, pu.Cr(), glmModel, glmIdc, lumaOffset, chromaOffset);
#endif
        xGlmApplyModelOffset(pu, COMPONENT_Cr, pu.Cr(), glmModel, glmIdc, predCr, lumaOffset, chromaOffset);
      }
      else
      {
        THROW("Invalid Type");
      }
    }
#if JVET_AG0059_CCP_MERGE_ENHANCEMENT
    if (pu.curCand.ccInsideFilter)
    {
      filterPredInside(COMPONENT_Cb, predCb, pu);
      filterPredInside(COMPONENT_Cr, predCr, pu);
    }

    if (pu.ccpMergeFusionFlag == 1)
    {
      int width = predCb.width;
      int height = predCb.height;

      const int scaleX = getComponentScaleX(COMPONENT_Cb, pu.chromaFormat);
      const int scaleY = getComponentScaleY(COMPONENT_Cb, pu.chromaFormat);
      const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, width << scaleX, height << scaleY));

      PelBuf predBufferCb = m_tempBuffer[0].getBuf(localUnitArea.Cb());
      PelBuf predBufferCr = m_tempBuffer[0].getBuf(localUnitArea.Cr());
      PredictionUnit pu2 = pu;
      if (pu.ccpMergeFusionType == 0)
      {
        const int                         bitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
        static CccmModel cccmModelCb[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };
        static CccmModel cccmModelCr[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };

        pu2.cccmFlag = 1;
#if JVET_AC0054_GLCCCM
        pu2.glCccmFlag = 0;
#endif
#if JVET_AD0202_CCCM_MDF
        pu2.cccmMultiFilterIdx = 0;
#endif
#if MMLM
        pu2.intraDir[1] = MMLM_CHROMA_IDX;

        static int modelThr = 0;

        modelThr = xCccmCalcRefAver(pu2);
        xCccmCalcModels(pu2, cccmModelCb[0], cccmModelCr[0], 1, modelThr);
        xCccmCalcModels(pu2, cccmModelCb[1], cccmModelCr[1], 2, modelThr);

        xCccmApplyModel(pu2, COMPONENT_Cb, cccmModelCb[0], 1, modelThr, predBufferCb);
        xCccmApplyModel(pu2, COMPONENT_Cb, cccmModelCb[1], 2, modelThr, predBufferCb);

        xCccmApplyModel(pu2, COMPONENT_Cr, cccmModelCr[0], 1, modelThr, predBufferCr);
        xCccmApplyModel(pu2, COMPONENT_Cr, cccmModelCr[1], 2, modelThr, predBufferCr);
#else
        pu2.intraDir[1] = LM_CHROMA_IDX;

        xCccmCalcModels(pu2, cccmModelCb[0], cccmModelCr[0], 0, 0);

        xCccmApplyModel(pu2, COMPONENT_Cb, cccmModelCb[0], 0, 0, predBufferCb);
        xCccmApplyModel(pu2, COMPONENT_Cr, cccmModelCr[0], 0, 0, predBufferCr);
#endif
      }
      else
      {
        pu.intraDir[1] = DIMD_CHROMA_IDX;
        initIntraPatternChType(*pu.cu, pu.blocks[COMPONENT_Cb]);
        initIntraPatternChType(*pu.cu, pu.blocks[COMPONENT_Cr]);
        predIntraAng(COMPONENT_Cb, predBufferCb, pu);
        predIntraAng(COMPONENT_Cr, predBufferCr, pu);
        pu.intraDir[1] = LM_CHROMA_IDX;
      }

      int w0 = 2;
      int w1 = 2;
      int shift = 2;

      Pel* pelPredCb = predCb.buf;
      Pel* pelPredCr = predCr.buf;

      Pel* pelPredCb2 = predBufferCb.buf;
      Pel* pelPredCr2 = predBufferCr.buf;

      for (int y = 0; y < height; y++)
      {
        for (int x = 0; x < width; x++)
        {
          int blend = pelPredCb[x] * w0;
          blend += pelPredCb2[x] * w1;
          blend += 2;
          pelPredCb[x] = (Pel)(blend >> shift);

          blend = pelPredCr[x] * w0;
          blend += pelPredCr2[x] * w1;
          blend += 2;
          pelPredCr[x] = (Pel)(blend >> shift);
        }
        pelPredCb += predCb.stride;
        pelPredCb2 += predBufferCb.stride;

        pelPredCr += predCr.stride;
        pelPredCr2 += predBufferCr.stride;
      }
    }
#endif
  }
}
#endif

#if JVET_AF0073_INTER_CCP_MERGE
void IntraPrediction::xInterCccmApplyModelOffset(const PredictionUnit& pu, const ComponentID compId, CccmModel& cccmModel, PelBuf& piPred, int lumaOffset, int chromaOffset)
{
  CHECK(!pu.cccmNoSubFlag, "cccmNoSubFlag shall be enabled");

  const ClpRng& clpRng(pu.cu->cs->slice->clpRng(compId));
  static Pel    samples[INTER_CCCM_NUM_PARAMS];

  const PelBuf  refLumaBlk = xCccmGetLumaPuBuf(pu);
  const int chromaScaleX = getChannelTypeScaleX(CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc());
  const int chromaScaleY = getChannelTypeScaleY(CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc());
  const int stepX = 1 << chromaScaleX;
  const int stepY = 1 << chromaScaleY;
  int offset = chromaOffset;

  for (int y = 0; y < refLumaBlk.height; y += stepY)
  {
    for (int x = 0; x < refLumaBlk.width; x += stepX)
    {
      const Pel* src0 = refLumaBlk.bufAt(x, y);
      const Pel* src1 = refLumaBlk.bufAt(x, y + 1);

      samples[0] = src0[ 0] + lumaOffset;
      samples[1] = src1[ 0] + lumaOffset;
      samples[2] = src0[-1] + lumaOffset;
      samples[3] = src0[ 1] + lumaOffset;
      samples[4] = src1[-1] + lumaOffset;
      samples[5] = src1[ 1] + lumaOffset;
      samples[6] = cccmModel.nonlinear((samples[0] + samples[1] + 1) >> 1);
      samples[7] = cccmModel.bias();
      piPred.at(x >> chromaScaleX, y >> chromaScaleY) = ClipPel<Pel>(cccmModel.convolve(samples) + offset, clpRng);
    }
  }
}
int IntraPrediction::xGetCostInterCccm(const PredictionUnit& pu, const ComponentID compID, const CompArea& chromaArea, CccmModel& cccmModel, int lumaOffset, int chromaOffset
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
                                     , int candIdx
#endif
                                      )
{
  CHECK(!pu.cccmNoSubFlag, "cccmNoSubFlag shall be enabled");
  const ClpRng& clpRng(pu.cu->cs->slice->clpRng(compID));
  static Pel samples[INTER_CCCM_NUM_PARAMS];

  CPelBuf   refLumaBlk = xCccmGetLumaPuBuf(pu);
  const int chromaScaleX = getChannelTypeScaleX(CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc());
  const int chromaScaleY = getChannelTypeScaleY(CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc());
  const int stepX = 1 << chromaScaleX;
  const int stepY = 1 << chromaScaleY;

  const SizeType cWidth = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  CodingStructure& cs = *(pu.cs);
  const CodingUnit& cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  const Pel* curChroma0;

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf(compID == COMPONENT_Cb ? m_CCPFusionTempCb[candIdx] : m_CCPFusionTempCr[candIdx], maxSize, Size(maxSize, 2));
#endif

  Pel* curChromaBuf = chromaReco.buf;
  const int curStride = chromaReco.stride;

  int sad = 0;

  Pel predChroma;

  if (aboveAvailable)
  {
    curChroma0 = curChromaBuf - curStride;
    for (int pos = 0, x = 0; pos < cWidth; pos++, x += stepX)
    {
      const Pel* src0 = refLumaBlk.bufAt(x, -stepY);
      const Pel* src1 = refLumaBlk.bufAt(x, -stepY + 1);
      samples[0] = src0[0] + lumaOffset;
      samples[1] = src1[0] + lumaOffset;
      samples[2] = src0[-1] + lumaOffset;
      samples[3] = src0[1] + lumaOffset;
      samples[4] = src1[-1] + lumaOffset;
      samples[5] = src1[1] + lumaOffset;
      samples[6] = cccmModel.nonlinear((samples[0] + samples[1] + 1) >> 1);
      samples[7] = cccmModel.bias();

      predChroma = cccmModel.convolve(samples) + chromaOffset;
      predChroma = ClipPel<Pel>(predChroma, clpRng);
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      predBuf.at(pos, 0) = predChroma;
#endif
      sad += abs(curChroma0[pos] - predChroma);
    }
  }

  if (leftAvailable)
  {
    curChroma0 = curChromaBuf - 1;
    for (int pos = 0, y = 0; pos < cHeight; pos++, y += stepY)
    {
      const Pel* src0 = refLumaBlk.bufAt(-stepX, y);
      const Pel* src1 = refLumaBlk.bufAt(-stepX, y + 1);
      samples[0] = src0[0] + lumaOffset;
      samples[1] = src1[0] + lumaOffset;
      samples[2] = src0[-1] + lumaOffset;
      samples[3] = src0[1] + lumaOffset;
      samples[4] = src1[-1] + lumaOffset;
      samples[5] = src1[1] + lumaOffset;
      samples[6] = cccmModel.nonlinear((samples[0] + samples[1] + 1) >> 1);
      samples[7] = cccmModel.bias();

      predChroma = cccmModel.convolve(samples) + chromaOffset;
      predChroma = ClipPel<Pel>(predChroma, clpRng);
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      predBuf.at(pos, 1) = predChroma;
#endif
      sad += abs(curChroma0[pos * curStride] - predChroma);
    }
  }
  return sad;
}
void IntraPrediction::xAddOnTheFlyCalcCCPCands4InterBlk(const PredictionUnit &pu, CompArea chromaArea, CCPModelCandidate candList[], int &validNum)
{
  if (!pu.cs->slice->getCheckLDC())
  {
    return;
  }

  int  maxCandIdx = validNum;
  bool isValid    = false;

#if JVET_AC0094_REF_SAMPLES_OPT
  m_leftRefLength = chromaArea.height << 3;
  m_topRefLength  = chromaArea.width << 3;
#else
  m_leftRefLength     = (height << 1);
  m_topRefLength      = (width << 1);
#endif

  // single model CCCM w/ downsampling
  xCccmCreateLumaRef(pu, chromaArea);
  const int bitDepth       = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  CccmModel cccmModelCb[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };
  CccmModel cccmModelCr[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };
  xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 0, 0, -1, true);
  for (int i = 0; i < (CCCM_NUM_PARAMS - 1); i++)
  {
    if (cccmModelCb[0].params[i] != 0 || cccmModelCr[0].params[i] != 0)
    {
      isValid = true;
      break;
    }
  }
  if (isValid)
  {
#if JVET_AC0054_GLCCCM
    candList[maxCandIdx].type    = (pu.glCccmFlag ? CCP_TYPE_GLCCCM : CCP_TYPE_CCCM);
    candList[maxCandIdx].corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
    candList[maxCandIdx].corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;
#else
    ccpCand.type = CCP_TYPE_CCCM;
#endif
    PU::cccmModelToCcpParams(candList[maxCandIdx], cccmModelCb, cccmModelCr, 0
#if JVET_AB0174_CCCM_DIV_FREE
                             , m_cccmLumaOffset
#endif
    );
    maxCandIdx++;
  }

  CHECK(maxCandIdx > MAX_CCP_CAND_LIST_SIZE, "Invlid number of InterCCP merge candidates");
  validNum = maxCandIdx;
}
void IntraPrediction::selectCcpMergeCand(PredictionUnit& pu, CCPModelCandidate candList[], int reorderlistSize)
{
  int candCost[MAX_CCP_CAND_LIST_SIZE];
  for (int i = 0; i < reorderlistSize; i++)
  {
    candCost[i] = xGetOneCCPCandCost(pu, candList[i]);
  }

  //Find the candidate with smallest template cost
  int minCost = candCost[0];
  int minIdx = 0;
  for (int i = 1; i < reorderlistSize; i++)
  {
    if (candCost[i] < minCost)
    {
      minCost = candCost[i];
      minIdx = i;
    }
  }
  if (minIdx != 0)
  {
    CCPModelCandidate tmpCand = candList[0];
    int tmpCost = candCost[0];
    candList[0] = candList[minIdx];
    candCost[0] = minCost;
    candList[minIdx] = tmpCand;
    candCost[minIdx] = tmpCost;
  }
  return;
}
void IntraPrediction::combineCcpAndInter(PredictionUnit& pu, PelBuf& inPredCb, PelBuf& inPredCr, PelBuf& outPredCb, PelBuf& outPredCr
#if JVET_AH0066_JVET_AH0202_CCP_MERGE_LUMACBF0
  , bool useExistCcp
#endif
)
{
  CompArea chromaArea = pu.Cb();
  int predCbStride = MAX_CU_SIZE + 1;
  PelBuf predCbIntra = PelBuf(m_pCcpMerge[0] + predCbStride + 1, predCbStride, Size(chromaArea));
  int predCrStride = MAX_CU_SIZE + 1;
  PelBuf predCrIntra = PelBuf(m_pCcpMerge[1] + predCrStride + 1, predCrStride, Size(chromaArea));
#if JVET_AH0066_JVET_AH0202_CCP_MERGE_LUMACBF0
  if (!useExistCcp)
#endif
  predCCPCandidate(pu, predCbIntra, predCrIntra);

  Pel* predCbIntraBuf = predCbIntra.buf;
  const int predCbIntraStride = predCbIntra.stride;
  Pel* predCrIntraBuf = predCrIntra.buf;
  const int predCrIntraStride = predCrIntra.stride;

  Pel* predCbInterBuf = inPredCb.buf;
  const int predCbInterStride = inPredCb.stride;
  Pel* predCrInterBuf = inPredCr.buf;
  const int predCrInterStride = inPredCr.stride;

  Pel* predCbDstBuf = outPredCb.buf;
  const int predCbDstStride = outPredCb.stride;
  Pel* predCrDstBuf = outPredCr.buf;
  const int predCrDstStride = outPredCr.stride;

  const ClpRng& clpRngCb = pu.cu->cs->slice->clpRng(COMPONENT_Cb);
  const ClpRng& clpRngCr = pu.cu->cs->slice->clpRng(COMPONENT_Cr);
#if JVET_AH0066_JVET_AH0202_CCP_MERGE_LUMACBF0
  constexpr int shift = 2;
  constexpr int offset = shift << 1 >> 1;
  constexpr int one = 1 << shift;
  constexpr int ccpWeighting[one + 1] = { 0, 3, 4, 1, 2 };
  CHECK(pu.cu->interCcpMergeZeroRootCbfIdc > MAX_CCP_MERGE_WEIGHT_IDX, "Wrong interCcpMergeZeroRootCbfIdc");
  const auto tu = *pu.cu->firstTU;
  const bool lumaCbf = TU::getCbf(tu, COMPONENT_Y);
  int wCc = 3;
  if (tu.interCcpMerge)
  {
    wCc = lumaCbf || MAX_CCP_MERGE_WEIGHT_IDX == 1 ? 3 : 4;
  }
  else
  {
    wCc = ccpWeighting[pu.cu->interCcpMergeZeroRootCbfIdc];
  }
  const int wInter = one - wCc;
#endif
  for (int cntH = 0; cntH < outPredCb.height; cntH++)
  {
    for (int cntW = 0; cntW < outPredCb.width; cntW++)
    {
#if JVET_AH0066_JVET_AH0202_CCP_MERGE_LUMACBF0
      predCbDstBuf[cntH * predCbDstStride + cntW] = ClipPel(((wCc * predCbIntraBuf[cntH * predCbIntraStride + cntW] + wInter * predCbInterBuf[cntH * predCbInterStride + cntW] + offset) >> shift), clpRngCb);
      predCrDstBuf[cntH * predCrDstStride + cntW] = ClipPel(((wCc * predCrIntraBuf[cntH * predCrIntraStride + cntW] + wInter * predCrInterBuf[cntH * predCrInterStride + cntW] + offset) >> shift), clpRngCr);
#else
      predCbDstBuf[cntH * predCbDstStride + cntW] = ClipPel(((3 * predCbIntraBuf[cntH * predCbIntraStride + cntW] + predCbInterBuf[cntH * predCbInterStride + cntW] + 2) >> 2), clpRngCb);
      predCrDstBuf[cntH * predCrDstStride + cntW] = ClipPel(((3 * predCrIntraBuf[cntH * predCrIntraStride + cntW] + predCrInterBuf[cntH * predCrInterStride + cntW] + 2) >> 2), clpRngCr);
#endif
    }
  }
}
#endif

#if JVET_AB0174_CCCM_DIV_FREE
#define DIV_PREC_BITS       14
#define DIV_PREC_BITS_POW2  8
#define DIV_SLOT_BITS       3
#define DIV_INTR_BITS      (DIV_PREC_BITS - DIV_SLOT_BITS)
#define DIV_INTR_ROUND     (1 << DIV_INTR_BITS >> 1)

#if JVET_AJ0237_INTERNAL_12BIT
int64_t xDivide(int64_t num, int64_t denom, int decimBits) // Note: assumes positive denominator
#else
int64_t xDivide(int64_t num, int64_t denom) // Note: assumes positive denominator
#endif
{
  static const int pow2W[8] = {   214,   153,   113,    86,    67,    53,    43,    35  }; // DIV_PREC_BITS_POW2
  static const int pow2O[8] = {  4822,  5952,  6624,  6792,  6408,  5424,  3792,  1466  }; // DIV_PREC_BITS
  static const int pow2B[8] = { 12784, 12054, 11670, 11583, 11764, 12195, 12870, 13782  }; // DIV_PREC_BITS

  int shift     = floorLog2Uint64(denom);
  int round     = 1 << shift >> 1;
  int normDiff  = (((denom << DIV_PREC_BITS) + round) >> shift) & ((1 << DIV_PREC_BITS) - 1);
  int diffFull  = normDiff >> DIV_INTR_BITS;
  int normDiff2 = normDiff - pow2O[diffFull];

  int scale     = ((pow2W[diffFull] * ((normDiff2 * normDiff2) >> DIV_PREC_BITS)) >> DIV_PREC_BITS_POW2) - (normDiff2 >> 1) + pow2B[diffFull];

#if JVET_AJ0237_INTERNAL_12BIT
  return ((num << (decimBits - DIV_PREC_BITS)) * scale + round) >> shift;
#else
  return ( (num << (CCCM_DECIM_BITS - DIV_PREC_BITS)) * scale + round) >> shift;
#endif
}

#if JVET_AC0053_GAUSSIAN_SOLVER
#if JVET_AJ0237_INTERNAL_12BIT
void xGetDivScaleRoundShift(int64_t denom, int decimBits, int& scale, int& round, int& shift) // Note: assumes positive denominator
#else
void xGetDivScaleRoundShift(int64_t denom, int &scale, int &round, int &shift) // Note: assumes positive denominator
#endif
{
  static const int pow2W[8] = {   214,   153,   113,    86,    67,    53,    43,    35  }; // DIV_PREC_BITS_POW2
  static const int pow2O[8] = {  4822,  5952,  6624,  6792,  6408,  5424,  3792,  1466  }; // DIV_PREC_BITS
  static const int pow2B[8] = { 12784, 12054, 11670, 11583, 11764, 12195, 12870, 13782  }; // DIV_PREC_BITS

  shift         = floorLog2Uint64(denom);
  round         = 1 << shift >> 1;
  int normDiff  = (((denom << DIV_PREC_BITS) + round) >> shift) & ((1 << DIV_PREC_BITS) - 1);
  int diffFull  = normDiff >> DIV_INTR_BITS;
  int normDiff2 = normDiff - pow2O[diffFull];

  scale         = ((pow2W[diffFull] * ((normDiff2 * normDiff2) >> DIV_PREC_BITS)) >> DIV_PREC_BITS_POW2) - (normDiff2 >> 1) + pow2B[diffFull];
#if JVET_AJ0237_INTERNAL_12BIT
  scale       <<= decimBits - DIV_PREC_BITS;
#else
  scale       <<= CCCM_DECIM_BITS - DIV_PREC_BITS;
#endif
}
#endif

#undef DIV_PREC_BITS
#undef DIV_PREC_BITS_POW2
#undef DIV_SLOT_BITS
#undef DIV_INTR_BITS
#undef DIV_INTR_ROUND

#if JVET_AJ0237_INTERNAL_12BIT
int xCccmDivideLowPrec(int64_t num, int64_t denom, int decimBits)
#else
int xCccmDivideLowPrec(int64_t num, int64_t denom)
#endif
{
#if JVET_AJ0237_INTERNAL_12BIT
  if (num < 0)
  {
    return -int(xDivide(-num, denom, decimBits) >> decimBits);
  }
  else
  {
    return int(xDivide(num, denom, decimBits) >> decimBits);
  }
#else
  if ( num < 0 )
  {
    return -int(xDivide(-num, denom) >> CCCM_DECIM_BITS);
  }
  else
  {
    return int(xDivide(num, denom) >> CCCM_DECIM_BITS);
  }
#endif
}

#if JVET_AJ0237_INTERNAL_12BIT
int64_t xCccmDivide(int64_t num, int64_t denom, int decimBits) // Note: assumes positive denominator
{
  return xDivide(num, denom, decimBits);
}
#else
int64_t xCccmDivide(int64_t num, int64_t denom) // Note: assumes positive denominator
{
  return xDivide(num, denom);
}
#endif
#endif

#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
#if JVET_AA0057_CCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
uint32_t IntraPrediction::xCalculateCCLMcost(const PredictionUnit &pu, const ComponentID compID, int intraDir, const CompArea &chromaArea, const CclmModel &cclmModel)
{
  int    srcStride = 0;
  PelBuf temp;

#if MMLM
  if ((intraDir == MDLM_L_IDX) || (intraDir == MDLM_T_IDX) || (intraDir == MMLM_L_IDX) || (intraDir == MMLM_T_IDX) || (m_encPreRDRun && intraDir == MMLM_CHROMA_IDX))
#else
  if ((intraDir == MDLM_L_IDX) || (intraDir == MDLM_T_IDX))
#endif
  {
    srcStride = 2 * MAX_CU_SIZE + 1;
    temp      = PelBuf(m_pMdlmTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
  else
  {
    srcStride = MAX_CU_SIZE + 1;
    temp      = PelBuf(m_piTemp + srcStride + 1, srcStride, Size(chromaArea));
  }
  uint32_t totalSAD = 0;

  const SizeType cWidth  = chromaArea.width;
  const SizeType cHeight = chromaArea.height;
#if JVET_AJ0096_SATD_REORDER_INTRA
  const ChannelType chType = toChannelType(compID);
  DistParam cDistParam;
  cDistParam.applyWeight = false;
  static Pel predChromaA[MAX_CU_SIZE];
  static Pel predChromaL[MAX_CU_SIZE];
  PelBuf predTop(predChromaA, cWidth, 1);
  PelBuf predLeft(predChromaL, 1, cHeight);
  static Pel reconChromaA[MAX_CU_SIZE];
  static Pel reconChromaL[MAX_CU_SIZE];
  PelBuf reconTop(reconChromaA, cWidth, 1);
  PelBuf reconLeft(reconChromaL, 1, cHeight);
#endif

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable  = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  Pel *srcColor0, *curChroma0;

  srcColor0 = temp.bufAt(0, 0);

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);

  Pel      *curChromaBuf = chromaReco.buf;
  const int curStride    = chromaReco.stride;

  if (aboveAvailable)
  {
    curChroma0 = curChromaBuf - curStride;
    Pel *src   = srcColor0 - srcStride;
#if MMLM
    if (PU::isMultiModeLM(pu.intraDir[1]))
    {
      Pel predChroma;
      for (int pos = 0; pos < cWidth; pos++)
      {
        if (src[pos] <= cclmModel.yThres)
        {
          predChroma = ClipPel(rightShift(cclmModel.a * src[pos], cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
        }
        else
        {
          predChroma = ClipPel(rightShift(cclmModel.a2 * src[pos], cclmModel.shift2) + cclmModel.b2, pu.cs->slice->clpRng(compID));
        }
#if JVET_AJ0096_SATD_REORDER_INTRA
        predTop.at(pos, 0) = predChroma;
        reconTop.at(pos, 0) = curChroma0[pos];
#else
        totalSAD += abs(predChroma - curChroma0[pos]);
#endif
      }
#if JVET_AJ0096_SATD_REORDER_INTRA
      m_dbvSadCost->setDistParam(cDistParam, predTop, reconTop, pu.cs->sps->getBitDepth(chType), compID, cWidth >= 4 && cHeight >= 4 ? true : false);
      totalSAD += (int)cDistParam.distFunc(cDistParam);
#endif
    }
    else
#endif
    {
      for (int pos = 0; pos < cWidth; pos++)
      {
        Pel predChroma = ClipPel(rightShift(cclmModel.a * src[pos], cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
#if JVET_AJ0096_SATD_REORDER_INTRA
        predTop.at(pos, 0) = predChroma;
        reconTop.at(pos, 0) = curChroma0[pos];
#else
        totalSAD += abs(predChroma - curChroma0[pos]);
#endif
      }
#if JVET_AJ0096_SATD_REORDER_INTRA
      m_dbvSadCost->setDistParam(cDistParam, predTop, reconTop, pu.cs->sps->getBitDepth(chType), compID, cWidth >= 4 && cHeight >= 4 ? true : false);
      totalSAD += (int)cDistParam.distFunc(cDistParam);
#endif
    }
  }

  if (leftAvailable)
  {
    curChroma0 = curChromaBuf - 1;

    Pel *src = srcColor0 - 1;

#if MMLM
    if (PU::isMultiModeLM(pu.intraDir[1]))
    {
      Pel predChroma;
      for (int pos = 0; pos < cHeight; pos++)
      {
        if (src[pos * srcStride] <= cclmModel.yThres)
        {
          predChroma = ClipPel(rightShift(cclmModel.a * src[pos * srcStride], cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
        }
        else
        {
          predChroma = ClipPel(rightShift(cclmModel.a2 * src[pos * srcStride], cclmModel.shift2) + cclmModel.b2, pu.cs->slice->clpRng(compID));
        }
#if JVET_AJ0096_SATD_REORDER_INTRA
        predLeft.at(0, pos) = predChroma;
        reconLeft.at(0, pos) = curChroma0[pos * curStride];
#else
        totalSAD += abs(predChroma - curChroma0[pos * curStride]);
#endif
      }
#if JVET_AJ0096_SATD_REORDER_INTRA
      m_dbvSadCost->setDistParam(cDistParam, predLeft, reconLeft, pu.cs->sps->getBitDepth(chType), compID, cWidth >= 4 && cHeight >= 4 ? true : false);
      totalSAD += (int)cDistParam.distFunc(cDistParam);
#endif
    }
    else
#endif
    {
      for (int pos = 0; pos < cHeight; pos++)
      {
        Pel predChroma = ClipPel(rightShift(cclmModel.a * src[pos * srcStride], cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
#if JVET_AJ0096_SATD_REORDER_INTRA
        predLeft.at(0, pos) = predChroma;
        reconLeft.at(0, pos) = curChroma0[pos * curStride];
#else
        totalSAD += abs(predChroma - curChroma0[pos * curStride]);
#endif
      }
#if JVET_AJ0096_SATD_REORDER_INTRA
      m_dbvSadCost->setDistParam(cDistParam, predLeft, reconLeft, pu.cs->sps->getBitDepth(chType), compID, cWidth >= 4 && cHeight >= 4 ? true : false);
      totalSAD += (int)cDistParam.distFunc(cDistParam);
#endif
    }
  }

  return totalSAD;
}

void IntraPrediction::applyChromaLM(const ComponentID compID, PelBuf &piPred, const PredictionUnit &pu, const CompArea &chromaArea, int intraDir, const CclmModel &cclmModel)
{
  int    iLumaStride = 0;
  PelBuf temp;

#if MMLM
  if ((intraDir == MDLM_L_IDX) || (intraDir == MDLM_T_IDX) || (intraDir == MMLM_L_IDX) || (intraDir == MMLM_T_IDX) || (m_encPreRDRun && intraDir == MMLM_CHROMA_IDX))
#else
  if ((intraDir == MDLM_L_IDX) || (intraDir == MDLM_T_IDX))
#endif
  {
    iLumaStride = 2 * MAX_CU_SIZE + 1;
    temp        = PelBuf(m_pMdlmTemp + iLumaStride + 1, iLumaStride, Size(chromaArea));
  }
  else
  {
    iLumaStride = MAX_CU_SIZE + 1;
    temp        = PelBuf(m_piTemp + iLumaStride + 1, iLumaStride, Size(chromaArea));
  }

  piPred.copyFrom(temp);
#if MMLM
  if (PU::isMultiModeLM(pu.intraDir[1]))
  {
    Pel *pPred        = piPred.bufAt(0, 0);
    Pel *pLuma        = temp.bufAt(0, 0);
    int  uiPredStride = piPred.stride;
    int  uiCWidth     = chromaArea.width;
    int  uiCHeight    = chromaArea.height;

    for (int i = 0; i < uiCHeight; i++)
    {
      for (int j = 0; j < uiCWidth; j++)
      {
        if (pLuma[j] <= cclmModel.yThres)
        {
          pPred[j] = (Pel) ClipPel(((cclmModel.a * pLuma[j]) >> cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
        }
        else
        {
          pPred[j] = (Pel) ClipPel(((cclmModel.a2 * pLuma[j]) >> cclmModel.shift2) + cclmModel.b2, pu.cs->slice->clpRng(compID));
        }
      }
      pPred += uiPredStride;
      pLuma += iLumaStride;
    }
  }
  else
  {
#endif
    piPred.linearTransform(cclmModel.a, cclmModel.shift, cclmModel.b, true, pu.cs->slice->clpRng(compID));
#if MMLM
  }
#endif
}

uint32_t IntraPrediction::xCalculateCCCMcost(const PredictionUnit &pu, const ComponentID compID, int intraDir, const CompArea &chromaArea, CccmModel cccmModel[2], int modelThr)
{
  int    srcStride = 0;

  CHECK( compID != chromaArea.compID, "Invalid component ID");

  const ClpRng &clpRng(pu.cu->cs->slice->clpRng(compID));
  Pel* samples = m_samples;

  CPelBuf temp = xCccmGetLumaPuBuf(pu);

  uint32_t totalSAD = 0;

  const SizeType cWidth  = chromaArea.width;
  const SizeType cHeight = chromaArea.height;
#if JVET_AJ0096_SATD_REORDER_INTRA
  const ChannelType chType = toChannelType(compID);
  DistParam cDistParam;
  cDistParam.applyWeight = false;
  static Pel predChromaA[MAX_CU_SIZE];
  static Pel predChromaL[MAX_CU_SIZE];
  PelBuf predTop(predChromaA, cWidth, 1);
  PelBuf predLeft(predChromaL, 1, cHeight);
  static Pel reconChromaA[MAX_CU_SIZE];
  static Pel reconChromaL[MAX_CU_SIZE];
  PelBuf reconTop(reconChromaA, cWidth, 1);
  PelBuf reconLeft(reconChromaL, 1, cHeight);
#endif

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable  = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;
  const bool checkAbove = aboveAvailable && (pu.cccmFlag != 2);
  const bool checkLeft  = leftAvailable && (pu.cccmFlag != 3);

  const Pel *srcColor0, *curChroma0;

  srcColor0 = temp.bufAt(0, 0);
  srcStride = temp.stride;

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);

  Pel      *curChromaBuf = chromaReco.buf;
  const int curStride    = chromaReco.stride;

  if (checkAbove)
  {
    curChroma0     = curChromaBuf - curStride;
    const Pel *src = srcColor0 - srcStride;

    Pel predChroma;
    for (int pos = 0; pos < cWidth; pos++, src++)
    {
      samples[0] = *src;                 // C
      samples[1] = *(src - srcStride);   // N
      samples[2] = *(src + srcStride);   // S
      samples[3] = *(src - 1);           // W
      samples[4] = *(src + 1);           // E
      samples[5] = cccmModel[0].nonlinear(*src);
      samples[6] = cccmModel[0].bias();

#if MMLM
      if (PU::isMultiModeLM(pu.intraDir[1]))
      {
        if (*src <= modelThr)
        {
          predChroma = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);
        }
        else
        {
          predChroma = ClipPel<Pel>(cccmModel[1].convolve(samples), clpRng);
        }
      }
      else
#endif
        predChroma = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);

#if JVET_AJ0096_SATD_REORDER_INTRA
      predTop.at(pos, 0) = predChroma;
      reconTop.at(pos, 0) = curChroma0[pos];
#else
      totalSAD += abs(predChroma - curChroma0[pos]);
#endif
    }
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_dbvSadCost->setDistParam(cDistParam, predTop, reconTop, pu.cs->sps->getBitDepth(chType), compID, cWidth >= 4 && cHeight >= 4 ? true : false);
    totalSAD += (int)cDistParam.distFunc(cDistParam);
#endif
  }

  if (checkLeft)
  {
    curChroma0 = curChromaBuf - 1;

    const Pel *src = srcColor0 - 1;

    Pel predChroma;
    for (int pos = 0; pos < cHeight; pos++, src += srcStride)
    {
      samples[0] = *src;                 // C
      samples[1] = *(src - srcStride);   // N
      samples[2] = *(src + srcStride);   // S
      samples[3] = *(src - 1);           // W
      samples[4] = *(src + 1);           // E
      samples[5] = cccmModel[0].nonlinear(*src);
      samples[6] = cccmModel[0].bias();

#if MMLM
      if (PU::isMultiModeLM(pu.intraDir[1]))
      {
        if (*src <= modelThr)
        {
          predChroma = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);
        }
        else
        {
          predChroma = ClipPel<Pel>(cccmModel[1].convolve(samples), clpRng);
        }
      }
      else
#endif
        predChroma = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);
#if JVET_AJ0096_SATD_REORDER_INTRA
      predLeft.at(0, pos) = predChroma;
      reconLeft.at(0, pos) = curChroma0[pos * curStride];
#else
      totalSAD += abs(predChroma - curChroma0[pos * curStride]);
#endif
    }
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_dbvSadCost->setDistParam(cDistParam, predLeft, reconLeft, pu.cs->sps->getBitDepth(chType), compID, cWidth >= 4 && cHeight >= 4 ? true : false);
    totalSAD += (int)cDistParam.distFunc(cDistParam);
#endif
  }

  return totalSAD;
}
#endif

void IntraPrediction::filterPredInside(const ComponentID compID, PelBuf &piPred, const PredictionUnit &pu)
{
  CodingUnit   &cu          = *pu.cu;
  ChannelType   channelType = toChannelType(compID);
  int           W           = pu.blocks[compID].width;
  int           H           = pu.blocks[compID].height;
  const CPelBuf recoBuf     = pu.cs->picture->getRecoBuf(compID);

  const int  recStride = recoBuf.stride;
  const Pel *pRec      = &recoBuf.buf[pu.blocks[compID].y * recStride + pu.blocks[compID].x];
  const int  tmpStride = MAX_CU_SIZE + 2;
  Pel       *pTmp      = m_pCCFilterTemp;
  const int  preStride = piPred.stride;
  Pel       *pPre      = piPred.buf;

  const bool aboveAvailable      = isPosAvailable(cu, channelType, cu.blocks[compID].pos().offset(0, -1)) ? true : false;
  const bool leftAvailable       = isPosAvailable(cu, channelType, cu.blocks[compID].pos().offset(-1, 0)) ? true : false;
  const bool leftAboveAvailable  = isPosAvailable(cu, channelType, cu.blocks[compID].pos().offset(-1, -1)) ? true : false;
  const bool aboveRightAvailable = isPosAvailable(cu, channelType, cu.blocks[compID].pos().offset(W, -1)) ? true : false;
  const bool leftBelowAvailable  = isPosAvailable(cu, channelType, cu.blocks[compID].pos().offset(-1, H)) ? true : false;

  for (int y = 0; y < H; y++)
  {
    memcpy(&pTmp[1 + (y + 1) * tmpStride], &pPre[y * preStride], sizeof(Pel) * W);
    pTmp[(y + 1) * tmpStride + 1 + W] = pTmp[(y + 1) * tmpStride + W];
  }
  memcpy(&pTmp[1 + (H + 1) * tmpStride], &pTmp[1 + H * tmpStride], sizeof(Pel) * (W + 1));

  if (aboveAvailable)
  {
    memcpy(&pTmp[1], &pRec[-1 * recStride], sizeof(Pel) * W);
  }
  else
  {
    memcpy(&pTmp[1], &pTmp[1 + tmpStride], sizeof(Pel) * W);
  }

  if (leftAvailable)
  {
    for (int y = 0; y < H; y++)
    {
      pTmp[(y + 1) * tmpStride] = pRec[y * recStride - 1];
    }
  }
  else
  {
    for (int y = 0; y < H; y++)
    {
      pTmp[(y + 1) * tmpStride] = pTmp[(y + 1) * tmpStride + 1];
    }
  }

  if (leftAboveAvailable)
  {
    pTmp[0] = pRec[-recStride - 1];
  }
  else
  {
    pTmp[0] = (pTmp[1] + pTmp[tmpStride] + 1) >> 1;
  }

  if (aboveRightAvailable)
  {
    pTmp[W + 1] = pRec[-recStride + W];
  }
  else
  {
    pTmp[W + 1] = pTmp[W];
  }

  if (leftBelowAvailable)
  {
    pTmp[(H + 1) * tmpStride] = pRec[-1 + H * recStride];
  }
  else
  {
    pTmp[(H + 1) * tmpStride] = pTmp[H * tmpStride];
  }

  pTmp = &m_pCCFilterTemp[1 + tmpStride];


  for (int y = 0; y < H; y++)
  {
    for (int x = 0; x < W; x++)
    {
      int sum                 = pTmp[(y -1)* tmpStride + x-1  ] +  pTmp[(y -1)* tmpStride + x]  +  pTmp[(y -1)* tmpStride + x + 1] + pTmp[y * tmpStride + x - 1]  + 8 * pTmp[y * tmpStride + x] + pTmp[y * tmpStride + x + 1] + pTmp[(y + 1) * tmpStride + x - 1] + pTmp[(y + 1) * tmpStride + x] + pTmp[(y + 1) * tmpStride + x + 1];
      pPre[y * preStride + x] = (sum + 8) >> 4;
    }
  }
}
#endif

#if JVET_AA0057_CCCM || JVET_AC0119_LM_CHROMA_FUSION || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
#if JVET_AB0174_CCCM_DIV_FREE
void IntraPrediction::xCccmSetLumaRefValue(const PredictionUnit& pu)
{
  int lumaPosX = m_cccmBlkArea.x << getComponentScaleX(COMPONENT_Cb, pu.cu->chromaFormat);
  int lumaPosY = m_cccmBlkArea.y << getComponentScaleY(COMPONENT_Cb, pu.cu->chromaFormat);

  if (lumaPosX || lumaPosY)
  {
    lumaPosX = lumaPosX ? lumaPosX - 1 : 0;
    lumaPosY = lumaPosY ? lumaPosY - 1 : 0;

    m_cccmLumaOffset = pu.cs->picture->getRecoBuf(COMPONENT_Y).at(lumaPosX, lumaPosY);
  }
  else
  {
    m_cccmLumaOffset = 1 << (pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) - 1);
  }
}
#endif

// Calculate a single downsampled luma reference value (copied from IntraPrediction::xGetLumaRecPixels)
Pel IntraPrediction::xCccmGetLumaVal(const PredictionUnit& pu, const CPelBuf pi, const int x, const int y
#if JVET_AD0202_CCCM_MDF
  , int downsFilterIdx
#endif
) const
{
  const Pel* piSrc = pi.buf;
  const int iRecStride = pi.stride;
  Pel ypval = 0;
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  if (pu.cccmNoSubFlag || pu.chromaFormat == CHROMA_444)
#else
  if (pu.chromaFormat == CHROMA_444)
#endif
  {
    ypval = piSrc[x + iRecStride * y];
  }
  else if (pu.chromaFormat == CHROMA_422)
  {
    int s = 2;
    int offLeft = x > 0 ? -1 : 0;
    s += piSrc[2 * x + iRecStride * y] * 2;
    s += piSrc[2 * x + offLeft + iRecStride * y];
    s += piSrc[2 * x + 1 + iRecStride * y];
    ypval = s >> 2;
  }
  else if (pu.cs->sps->getCclmCollocatedChromaFlag())
  {
    int s = 4;
    int offLeft = x > 0 ? -1 : 0;
    int offAbove = y > 0 ? -1 : 0;
    s += piSrc[2 * x + iRecStride * 2 * y] * 4;
    s += piSrc[2 * x + offLeft + iRecStride * 2 * y];
    s += piSrc[2 * x + 1 + iRecStride * 2 * y];
    s += piSrc[2 * x + iRecStride * (2 * y + 1)];
    s += piSrc[2 * x + iRecStride * (2 * y + offAbove)];
    ypval = s >> 3;
  }
  else
  {
#if JVET_AD0202_CCCM_MDF
    const int lumaPosPicX1 = 2 * x;
    const int lumaPosPicY1 = 2 * y;
    int lumaPosPicX0 = lumaPosPicX1 - 1; lumaPosPicX0 = lumaPosPicX0 < 0 ? 0 : lumaPosPicX0;
    const int lumaPosPicX2 = lumaPosPicX1 + 1;
    const int lumaPosPicY2 = lumaPosPicY1 + 1;
    const int shift0 = iRecStride * lumaPosPicY1;
    const int shift1 = iRecStride * lumaPosPicY2;

    if (downsFilterIdx == 0)
    {
      int s = 4;

      s += piSrc[lumaPosPicX1 + shift0] * 2;
      s += piSrc[lumaPosPicX0 + shift0];
      s += piSrc[lumaPosPicX2 + shift0];
      s += piSrc[lumaPosPicX1 + shift1] * 2;
      s += piSrc[lumaPosPicX0 + shift1];
      s += piSrc[lumaPosPicX2 + shift1];
      ypval = s >> 3;
    }
    else if (downsFilterIdx == 1)
    {
      int s = 0;

      s += piSrc[lumaPosPicX0 + shift0];
      s -= piSrc[lumaPosPicX2 + shift0];
      s += piSrc[lumaPosPicX0 + shift1];
      s -= piSrc[lumaPosPicX2 + shift1];

      ypval = s < 0 ? 0 : s;
    }
    else if (downsFilterIdx == 2)
    {
      int s = 0;

      s += piSrc[lumaPosPicX0 + shift0];
      s += piSrc[lumaPosPicX1 + shift0] * 2;
      s += piSrc[lumaPosPicX2 + shift0];
      s -= piSrc[lumaPosPicX0 + shift1];
      s -= piSrc[lumaPosPicX1 + shift1] * 2;
      s -= piSrc[lumaPosPicX2 + shift1];

      ypval = s < 0 ? 0 : s;
    }
    else
    {
      int s = 0;

      s -= piSrc[lumaPosPicX0 + shift0];
      s += piSrc[lumaPosPicX1 + shift0];
      s += piSrc[lumaPosPicX2 + shift0] * 2;
      s -= piSrc[lumaPosPicX0 + shift1] * 2;
      s -= piSrc[lumaPosPicX1 + shift1];
      s += piSrc[lumaPosPicX2 + shift1];

      ypval = s < 0 ? 0 : s;
    }
#else
    int s = 4;
    int offLeft = x > 0 ? -1 : 0;
    s += piSrc[2 * x + iRecStride * y * 2] * 2;
    s += piSrc[2 * x + offLeft + iRecStride * y * 2];
    s += piSrc[2 * x + 1 + iRecStride * y * 2];
    s += piSrc[2 * x + iRecStride * (y * 2 + 1)] * 2;
    s += piSrc[2 * x + offLeft + iRecStride * (y * 2 + 1)];
    s += piSrc[2 * x + 1 + iRecStride * (y * 2 + 1)];
    ypval = s >> 3;
#endif
  }

#if JVET_AB0174_CCCM_DIV_FREE
  return ypval - m_cccmLumaOffset; // Note: this could have also been included in the rounding offset s to avoid the extra sample based operation
#else
  return ypval;
#endif
}
#endif

#if JVET_AA0057_CCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
#if JVET_AD0188_CCP_MERGE
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
void IntraPrediction::predIntraCCCM( PredictionUnit &pu, PelBuf &predCb, PelBuf &predCr, int intraDir, bool ccpModelStorage, CCPModelCandidate ccpModel2 )
#else
void IntraPrediction::predIntraCCCM( PredictionUnit &pu, PelBuf &predCb, PelBuf &predCr, int intraDir )
#endif
#else
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
void IntraPrediction::predIntraCCCM( const PredictionUnit &pu, PelBuf &predCb, PelBuf &predCr, int intraDir, bool ccpModelStorage, CCPModelCandidate ccpModel2 )
#else
void IntraPrediction::predIntraCCCM( const PredictionUnit &pu, PelBuf &predCb, PelBuf &predCr, int intraDir )
#endif
#endif
{
#if JVET_AE0100_BVGCCCM
  if (pu.bvgCccmFlag)
  {
    CccmModel cccmModelCb[2] = { CccmModel( BVG_CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( BVG_CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
    CccmModel cccmModelCr[2] = { CccmModel( BVG_CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( BVG_CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
    
    if (intraDir == LM_CHROMA_IDX || intraDir == MDLM_L_IDX || intraDir == MDLM_T_IDX)
    {
      int minVal = 0, maxVal = 0;
      xBvgCccmCalcBlkRange(pu, minVal, maxVal);
      
      xBvgCccmCalcModels(pu, cccmModelCb[0],  cccmModelCr[0], 0, 0, minVal, maxVal);
      xBvgCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 0, 0, predCb);
      xBvgCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 0, 0, predCr);
    }
    else
    {
      int modelThr = xBvgCccmCalcBlkAver(pu);
      int minVal = 0, maxVal = 0;
      xBvgCccmCalcBlkRange(pu, minVal, maxVal);
      
      xBvgCccmCalcModels(pu, cccmModelCb[0],  cccmModelCr[0], 1, modelThr, minVal, maxVal);
      xBvgCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 1, modelThr, predCb);
      xBvgCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 1, modelThr, predCr);
      
      xBvgCccmCalcModels(pu, cccmModelCb[1],  cccmModelCr[1], 2, modelThr, minVal, maxVal);
      xBvgCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[1], 2, modelThr, predCb);
      xBvgCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[1], 2, modelThr, predCr);
    }
    return;
  }
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  if( pu.cccmNoSubFlag )
  {
#if JVET_AD0188_CCP_MERGE
    CccmModel cccmModelCb[2] = { CccmModel( CCCM_NO_SUB_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_NO_SUB_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
    CccmModel cccmModelCr[2] = { CccmModel( CCCM_NO_SUB_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_NO_SUB_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
#else
    CccmModel cccmModelCb( CCCM_NO_SUB_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth( CHANNEL_TYPE_LUMA ) );
    CccmModel cccmModelCr( CCCM_NO_SUB_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth( CHANNEL_TYPE_LUMA ) );
#endif

#if JVET_AB0143_CCCM_TS
    if( intraDir == LM_CHROMA_IDX || intraDir == MDLM_L_IDX || intraDir == MDLM_T_IDX )
#else
    if( PU::cccmSingleModeAvail( pu, intraDir ) )
#endif
    {
#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 0, 0);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[0], 0, 0, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[0], 0, 0, predCr);

      pu.curCand.type = CCP_TYPE_NSCCCM;
      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, 0
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels( pu, cccmModelCb, cccmModelCr, 0, 0 );
      xCccmApplyModel( pu, COMPONENT_Cb, cccmModelCb, 0, 0, predCb );
      xCccmApplyModel( pu, COMPONENT_Cr, cccmModelCr, 0, 0, predCr );
#endif
    }
    else
    {
      // Multimode case
      int modelThr = xCccmCalcRefAver( pu );

#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels( pu, cccmModelCb[0], cccmModelCr[0], 1, modelThr );
      xCccmApplyModel( pu, COMPONENT_Cb,   cccmModelCb[0], 1, modelThr, predCb );
      xCccmApplyModel( pu, COMPONENT_Cr,   cccmModelCr[0], 1, modelThr, predCr );

      xCccmCalcModels( pu, cccmModelCb[1], cccmModelCr[1], 2, modelThr );
      xCccmApplyModel( pu, COMPONENT_Cb,   cccmModelCb[1], 2, modelThr, predCb );
      xCccmApplyModel( pu, COMPONENT_Cr,   cccmModelCr[1], 2, modelThr, predCr );

      pu.curCand.type = (CCP_TYPE_NSCCCM | CCP_TYPE_MMLM);
      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, modelThr
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels( pu, cccmModelCb, cccmModelCr, 1, modelThr );
      xCccmApplyModel( pu, COMPONENT_Cb, cccmModelCb, 1, modelThr, predCb );
      xCccmApplyModel( pu, COMPONENT_Cr, cccmModelCr, 1, modelThr, predCr );

      xCccmCalcModels( pu, cccmModelCb, cccmModelCr, 2, modelThr );
      xCccmApplyModel( pu, COMPONENT_Cb, cccmModelCb, 2, modelThr, predCb );
      xCccmApplyModel( pu, COMPONENT_Cr, cccmModelCr, 2, modelThr, predCr );
#endif
    }
  }
  else
#endif
#if JVET_AD0202_CCCM_MDF
  if (pu.cccmMultiFilterIdx == 1)
  {
#if JVET_AD0188_CCP_MERGE
    CccmModel cccmModelCb[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
    CccmModel cccmModelCr[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
#else
    CccmModel cccmModelCb( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA));
    CccmModel cccmModelCr( CCCM_MULTI_PRED_FILTER_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA));
#endif

#if JVET_AB0143_CCCM_TS
    if (intraDir == LM_CHROMA_IDX || intraDir == MDLM_L_IDX || intraDir == MDLM_T_IDX)
#else
    if (PU::cccmSingleModeAvail(pu, intraDir))
#endif
    {
#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 0, 0);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[0], 0, 0, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[0], 0, 0, predCr);

      pu.curCand.type = CCP_TYPE_MDFCCCM;
      pu.curCand.cccmMultiFilterIdx = pu.cccmMultiFilterIdx;
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;

      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, 0
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels(pu, cccmModelCb, cccmModelCr, 0, 0);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 0, 0, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 0, 0, predCr);
#endif
    }
    else
    {
      // Multimode case
      int modelThr = xCccmCalcRefAver(pu);

#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 1, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[0], 1, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[0], 1, modelThr, predCr);

      xCccmCalcModels(pu, cccmModelCb[1], cccmModelCr[1], 2, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[1], 2, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[1], 2, modelThr, predCr);

      pu.curCand.type = CCP_TYPE_MDFCCCM | CCP_TYPE_MMLM;
      pu.curCand.cccmMultiFilterIdx = pu.cccmMultiFilterIdx;
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;

      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, modelThr
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels(pu, cccmModelCb, cccmModelCr, 1, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 1, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 1, modelThr, predCr);

      xCccmCalcModels(pu, cccmModelCb, cccmModelCr, 2, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 2, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 2, modelThr, predCr);
#endif
    }
  }
  else if (pu.cccmMultiFilterIdx > 1)
  {
#if JVET_AD0188_CCP_MERGE
    CccmModel cccmModelCb[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
    CccmModel cccmModelCr[2] = { CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
#else
    CccmModel cccmModelCb(CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA));
    CccmModel cccmModelCr(CCCM_MULTI_PRED_FILTER_NUM_PARAMS2, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA));
#endif

#if JVET_AB0143_CCCM_TS
    if (intraDir == LM_CHROMA_IDX || intraDir == MDLM_L_IDX || intraDir == MDLM_T_IDX)
#else
    if (PU::cccmSingleModeAvail(pu, intraDir))
#endif
    {
#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 0, 0);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[0], 0, 0, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[0], 0, 0, predCr);

      pu.curCand.type = CCP_TYPE_MDFCCCM;
      pu.curCand.cccmMultiFilterIdx = pu.cccmMultiFilterIdx;
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;

      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, 0
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels(pu, cccmModelCb, cccmModelCr, 0, 0);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 0, 0, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 0, 0, predCr);
#endif
    }
    else
    {
      // Multimode case
      int modelThr = xCccmCalcRefAver(pu);

#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 1, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[0], 1, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[0], 1, modelThr, predCr);

      xCccmCalcModels(pu, cccmModelCb[1], cccmModelCr[1], 2, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[1], 2, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[1], 2, modelThr, predCr);

      pu.curCand.type = CCP_TYPE_MDFCCCM | CCP_TYPE_MMLM;
      pu.curCand.cccmMultiFilterIdx = pu.cccmMultiFilterIdx;
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;

      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, modelThr
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels(pu, cccmModelCb, cccmModelCr, 1, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 1, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 1, modelThr, predCr);

      xCccmCalcModels(pu, cccmModelCb, cccmModelCr, 2, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 2, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 2, modelThr, predCr);
#endif
    }
  }
  else
#endif
#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
    if (pu.cs->slice->isIntra() && pu.cccmFlag
#if JVET_AC0054_GLCCCM
        && !pu.glCccmFlag
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
        && !pu.cccmNoSubFlag
#endif
#if JVET_AE0174_NONINTER_TM_TOOLS_CONTROL
      && pu.cs->sps->getTMnoninterToolsEnableFlag()
#endif
    )
  {
    const int                  bitDepth       = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
    CccmModel cccmModelCb[4] = { CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth) };
    CccmModel cccmModelCr[4] = { CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth), CccmModel( CCCM_NUM_PARAMS, bitDepth) };

#if JVET_AB0143_CCCM_TS
    if (intraDir == LM_CHROMA_IDX || intraDir == MDLM_L_IDX || intraDir == MDLM_T_IDX)
#else
    if (PU::cccmSingleModeAvail(pu, intraDir))
#endif
    {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      if (pu.decoderDerivedCcpMode)
      {
        if (ccpModelStorage)
        {
          PU::ccpParamsToCccmModel(pu.curCand, cccmModelCb, cccmModelCr);
        }
        else
        {
          PU::ccpParamsToCccmModel(ccpModel2, cccmModelCb, cccmModelCr);
        }
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 0, 0, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 0, 0, predCr);
      }
      else
      {
#endif
      xCccmCalcModels(pu,cccmModelCb[0], cccmModelCr[0], 0, 0);

      int cccmSAD = xCalculateCCCMcost(pu, COMPONENT_Cb, intraDir, pu.blocks[COMPONENT_Cb], &cccmModelCb[0], 0);
      cccmSAD += xCalculateCCCMcost(pu, COMPONENT_Cr, intraDir, pu.blocks[COMPONENT_Cr], &cccmModelCr[0], 0);

      xCccmCalcModels(pu, cccmModelCb[2], cccmModelCr[2], 0, 0, 2);
      int cccmSADtmp = xCalculateCCCMcost(pu, COMPONENT_Cb, intraDir, pu.blocks[COMPONENT_Cb], &cccmModelCb[2], 0);
      cccmSADtmp += xCalculateCCCMcost(pu, COMPONENT_Cr, intraDir, pu.blocks[COMPONENT_Cr], &cccmModelCr[2], 0);
#if JVET_AD0188_CCP_MERGE
#if JVET_AC0054_GLCCCM
      pu.curCand.type = (pu.glCccmFlag ? CCP_TYPE_GLCCCM : CCP_TYPE_CCCM);
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;
#else
      pu.curCand.type = CCP_TYPE_CCCM;
#endif
#endif
      if (cccmSADtmp < cccmSAD)
      {
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[2], 0, 0, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[2], 0, 0, predCr);
#if JVET_AD0188_CCP_MERGE
        PU::cccmModelToCcpParams(pu.curCand, &cccmModelCb[2], &cccmModelCr[2], 0
#if JVET_AB0174_CCCM_DIV_FREE
                                 , m_cccmLumaOffset
#endif
        );
#endif
      }
      else
      {
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 0, 0, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 0, 0, predCr);
#if JVET_AD0188_CCP_MERGE
        PU::cccmModelToCcpParams(pu.curCand, &cccmModelCb[0], &cccmModelCr[0], 0
#if JVET_AB0174_CCCM_DIV_FREE
                                 , m_cccmLumaOffset
#endif
        );
#endif
      }
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION      
      }
#endif
    }
    else
    {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      if (pu.decoderDerivedCcpMode)
      {
        int modelThr;
        if (ccpModelStorage)
        {
          PU::ccpParamsToCccmModel(pu.curCand, cccmModelCb, cccmModelCr);
          modelThr = pu.curCand.yThres;
        }
        else
        {
          PU::ccpParamsToCccmModel(ccpModel2, cccmModelCb, cccmModelCr);
          modelThr = ccpModel2.yThres;
        }
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 1, modelThr, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 1, modelThr, predCr);
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[1], 2, modelThr, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[1], 2, modelThr, predCr);
      }
      else
      {
#endif
      // Multimode case
      int modelThr = 0, modelThrTmp = 0;
      int cccmSAD = MAX_INT, cccmSADtmp = MAX_INT;

      modelThr = xCccmCalcRefAver(pu);
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 1, modelThr);
      xCccmCalcModels(pu, cccmModelCb[1], cccmModelCr[1], 2, modelThr);
      cccmSAD = xCalculateCCCMcost(pu, COMPONENT_Cb, pu.intraDir[1], pu.blocks[COMPONENT_Cb], &cccmModelCb[0], modelThr);
      cccmSAD += xCalculateCCCMcost(pu, COMPONENT_Cr, pu.intraDir[1], pu.blocks[COMPONENT_Cr], &cccmModelCr[0], modelThr);

      modelThrTmp = xCccmCalcRefAver(pu, 2);
      xCccmCalcModels(pu, cccmModelCb[2], cccmModelCr[2], 1, modelThrTmp);
      xCccmCalcModels(pu, cccmModelCb[3], cccmModelCr[3], 2, modelThrTmp);
      cccmSADtmp = xCalculateCCCMcost(pu, COMPONENT_Cb, pu.intraDir[1], pu.blocks[COMPONENT_Cb], &cccmModelCb[2], modelThrTmp);
      cccmSADtmp += xCalculateCCCMcost(pu, COMPONENT_Cr, pu.intraDir[1], pu.blocks[COMPONENT_Cr], &cccmModelCr[2], modelThrTmp);
#if JVET_AD0188_CCP_MERGE
#if JVET_AC0054_GLCCCM
      pu.curCand.type = ((pu.glCccmFlag ? CCP_TYPE_GLCCCM : CCP_TYPE_CCCM) | CCP_TYPE_MMLM);
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;
#else
      pu.curCand.type = (CCP_TYPE_CCCM | CCP_TYPE_MMLM);
#endif
#endif
      if (cccmSADtmp < cccmSAD)
      {
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[2], 1, modelThrTmp, predCb);
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[3], 2, modelThrTmp, predCb);

        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[2], 1, modelThrTmp, predCr);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[3], 2, modelThrTmp, predCr);
#if JVET_AD0188_CCP_MERGE
        PU::cccmModelToCcpParams(pu.curCand, &cccmModelCb[2], &cccmModelCr[2], modelThrTmp
#if JVET_AB0174_CCCM_DIV_FREE
                                 , m_cccmLumaOffset
#endif
        );
#endif
      }
      else
      {
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 1, modelThr, predCb);
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[1], 2, modelThr, predCb);

        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 1, modelThr, predCr);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[1], 2, modelThr, predCr);
#if JVET_AD0188_CCP_MERGE
        PU::cccmModelToCcpParams(pu.curCand, &cccmModelCb[0], &cccmModelCr[0], modelThr
#if JVET_AB0174_CCCM_DIV_FREE
                                 , m_cccmLumaOffset
#endif
        );
#endif
      }
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      }
#endif
    }
  }
  else
#endif
  if ( pu.cccmFlag )
  {
#if JVET_AD0188_CCP_MERGE
    CccmModel cccmModelCb[2] = { CccmModel( CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
    CccmModel cccmModelCr[2] = { CccmModel( CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)), CccmModel( CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) };
#else
    CccmModel cccmModelCb( CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
    CccmModel cccmModelCr( CCCM_NUM_PARAMS, pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) );
#endif

#if JVET_AB0143_CCCM_TS
    if ( intraDir == LM_CHROMA_IDX || intraDir == MDLM_L_IDX || intraDir == MDLM_T_IDX )
#else
    if ( PU::cccmSingleModeAvail(pu, intraDir) )
#endif
    {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      if (pu.decoderDerivedCcpMode)
      {
        if (ccpModelStorage)
        {
          PU::ccpParamsToCccmModel(pu.curCand, cccmModelCb, cccmModelCr);
        }
        else
        {
          PU::ccpParamsToCccmModel(ccpModel2, cccmModelCb, cccmModelCr);
        }
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 0, 0, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 0, 0, predCr);
      }
      else
      {
#endif
#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 0, 0);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[0], 0, 0, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[0], 0, 0, predCr);

#if JVET_AC0054_GLCCCM
      pu.curCand.type = (pu.glCccmFlag ? CCP_TYPE_GLCCCM : CCP_TYPE_CCCM);
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;
#else
      pu.curCand.type = CCP_TYPE_CCCM;
#endif
      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, 0
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels(pu, cccmModelCb,  cccmModelCr, 0, 0);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 0, 0, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 0, 0, predCr);
#endif
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      }
#endif
    }
    else
    {
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      if (pu.decoderDerivedCcpMode)
      {
        int modelThr;
        if (ccpModelStorage)
        {
          PU::ccpParamsToCccmModel(pu.curCand, cccmModelCb, cccmModelCr);
          modelThr = pu.curCand.yThres;
        }
        else
        {
          PU::ccpParamsToCccmModel(ccpModel2, cccmModelCb, cccmModelCr);
          modelThr = ccpModel2.yThres;
        }
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[0], 1, modelThr, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[0], 1, modelThr, predCr);
        xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb[1], 2, modelThr, predCb);
        xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr[1], 2, modelThr, predCr);
      }
      else
      {
#endif
      // Multimode case
      int modelThr = xCccmCalcRefAver(pu);
#if JVET_AD0188_CCP_MERGE
      xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 1, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[0], 1, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[0], 1, modelThr, predCr);

      xCccmCalcModels(pu, cccmModelCb[1], cccmModelCr[1], 2, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb,   cccmModelCb[1], 2, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr,   cccmModelCr[1], 2, modelThr, predCr);

#if JVET_AC0054_GLCCCM
      pu.curCand.type = ((pu.glCccmFlag ? CCP_TYPE_GLCCCM : CCP_TYPE_CCCM) | CCP_TYPE_MMLM);
      pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
      pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;
#else
      pu.curCand.type = (CCP_TYPE_CCCM | CCP_TYPE_MMLM);
#endif
      PU::cccmModelToCcpParams(pu.curCand, cccmModelCb, cccmModelCr, modelThr
#if JVET_AB0174_CCCM_DIV_FREE
                               , m_cccmLumaOffset
#endif
                               );
#else
      xCccmCalcModels(pu, cccmModelCb,  cccmModelCr, 1, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 1, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 1, modelThr, predCr);

      xCccmCalcModels(pu, cccmModelCb,  cccmModelCr, 2, modelThr);
      xCccmApplyModel(pu, COMPONENT_Cb, cccmModelCb, 2, modelThr, predCb);
      xCccmApplyModel(pu, COMPONENT_Cr, cccmModelCr, 2, modelThr, predCr);
#endif
#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      }
#endif
    }
  }
#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  if (pu.ccInsideFilter)
  {
    filterPredInside(COMPONENT_Cb, predCb, pu);
    filterPredInside(COMPONENT_Cr, predCr, pu);
  }
#endif
}

void IntraPrediction::xCccmApplyModel(const PredictionUnit& pu, const ComponentID compId, CccmModel& cccmModel, int modelId, int modelThr, PelBuf &piPred)
{
  const  ClpRng& clpRng(pu.cu->cs->slice->clpRng(compId));
  Pel* samples = m_samples;

  int stepX = 1;
  int stepY = 1;
  int chromaScaleX = 0;
  int chromaScaleY = 0;

#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  if( pu.cccmNoSubFlag )
  {
    chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
    chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );

    stepX = 1 << chromaScaleX;
    stepY = 1 << chromaScaleY;
  }
#endif

#if JVET_AC0054_GLCCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  int refSizeX   = m_cccmBlkArea.x - m_cccmRefArea.x; // Reference lines available left and above
  int refSizeY   = m_cccmBlkArea.y - m_cccmRefArea.y;
#endif

  CPelBuf refLumaBlk;
#if JVET_AD0202_CCCM_MDF
  CPelBuf refLumaBlk1, refLumaBlk2, refLumaBlk3;

  if( pu.cccmMultiFilterIdx == 1 )
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu, 0, 3, &refLumaBlk1, &refLumaBlk3, &refLumaBlk2 );
  }
  else if( pu.cccmMultiFilterIdx > 1 )
  {
    refLumaBlk = xCccmGetLumaPuBuf( pu, 0, 2, &refLumaBlk1, &refLumaBlk3 );
  }
  else
#endif  
  refLumaBlk = xCccmGetLumaPuBuf( pu );

  for (int y = 0; y < refLumaBlk.height; y += stepY )
  {
    for (int x = 0; x < refLumaBlk.width; x += stepX )
    {
      const Pel* src0 = refLumaBlk.bufAt( x, y );

      if ( modelId == 1 && src0[0] > modelThr ) // Model 1: Include only samples below or equal to the threshold
      {
        continue;
      }
      if ( modelId == 2 && src0[0] <= modelThr) // Model 2: Include only samples above the threshold
      {
        continue;
      }

      const Pel* src1 = refLumaBlk.bufAt( x, y + 1 );
      const Pel* src2 = refLumaBlk.bufAt( x, y - 1 );
      
      // 7-tap cross
#if JVET_AC0054_GLCCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      if( pu.glCccmFlag )      
      {
        samples[0] = src0[0]; // C
        samples[1] = ( 2 * src2[0] + src2[-1] + src2[1] ) - ( 2 * src1[0] + src1[-1] + src1[1] ); // Vertical gradient
        samples[2] = ( 2 * src0[-1] + src2[-1] + src1[-1] ) - ( 2 * src0[1] + src2[1] + src1[1] ); // Horizontal gradient
        samples[3] = (y + refSizeY + CCCM_LOC_OFFSET) << CCCM_LOC_SHIFT; // Y coordinate
        samples[4] = (x + refSizeX + CCCM_LOC_OFFSET) << CCCM_LOC_SHIFT; // X coordinate
        samples[5] = cccmModel.nonlinear( src0[0] );
        samples[6] = cccmModel.bias();
      }
      else
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
      if( pu.cccmNoSubFlag )
      {
        samples[0] = src0[0];
        samples[1] = src0[-1];
        samples[2] = src0[1];
        samples[3] = src1[0];
        samples[4] = src1[-1];
        samples[5] = src1[1];
        samples[6] = cccmModel.nonlinear( src0[0] );
        samples[7] = cccmModel.nonlinear( src1[0] );
        samples[8] = cccmModel.nonlinear( src0[1] );
        samples[9] = cccmModel.nonlinear( src0[-1] );
        samples[10] = cccmModel.bias();
      }
      else
#endif
#if JVET_AD0202_CCCM_MDF
      if( pu.cccmMultiFilterIdx == 1 )
      {
        // 7-tap cross
        samples[0] = src0[0]; // C
        samples[1] = refLumaBlk1.at( x, y ); // W
        samples[2] = refLumaBlk2.at( x, y ); // E
        samples[3] = refLumaBlk3.at( x, y );
        samples[4] = cccmModel.nonlinear( src0[0] );
        samples[5] = cccmModel.nonlinear( refLumaBlk1.at( x, y ) );
        samples[6] = cccmModel.nonlinear( refLumaBlk2.at( x, y ) );
        samples[7] = ( ( y + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT ); // Y coordinate
        samples[8] = ( ( x + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT ); // X coordinate
        samples[9] = cccmModel.bias();
      }
      else if( pu.cccmMultiFilterIdx == 2 )
      {
        samples[0] = src0[0]; // C
        samples[1] = src0[-1]; // W
        samples[2] = src0[1]; // E
        samples[3] = refLumaBlk1.at( x, y ); // C
        samples[4] = refLumaBlk1.at( x - 1, y ); // W
        samples[5] = refLumaBlk1.at( x + 1, y ); // E
        samples[6] = cccmModel.nonlinear( src0[0] );
        samples[7] = cccmModel.nonlinear( src0[-1] );
        samples[8] = cccmModel.nonlinear( src0[1] );
        samples[9] = ( ( x + refSizeX + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT ); // X coordinate
        samples[10] = cccmModel.bias();
      }
      else if( pu.cccmMultiFilterIdx == 3 )
      {
        samples[0] = src0[0]; // C
        samples[1] = src2[1]; // EN
        samples[2] = src1[-1]; // WS
        samples[3] = refLumaBlk3.at( x, y ); // C
        samples[4] = refLumaBlk3.at( x + 1, y - 1 ); // EN
        samples[5] = refLumaBlk3.at( x - 1, y + 1 ); // WS
        samples[6] = cccmModel.nonlinear( src0[0] );
        samples[7] = cccmModel.nonlinear( src2[1] );
        samples[8] = cccmModel.nonlinear( src1[-1] );
        samples[9] = ( ( y + refSizeY + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT ); // Y coordinate
        samples[10] = cccmModel.bias();
      }
      else
#endif
      {
        samples[0] = src0[0]; // C
        samples[1] = src2[0]; // N
        samples[2] = src1[0]; // S
        samples[3] = src0[-1]; // W
        samples[4] = src0[1]; // E
        samples[5] = cccmModel.nonlinear( refLumaBlk.at( x, y ) );
        samples[6] = cccmModel.bias();
      }

      piPred.at( x >> chromaScaleX, y >> chromaScaleY ) = ClipPel<Pel>( cccmModel.convolve( samples ), clpRng );
    }
  }
}

void IntraPrediction::xCccmCalcModels(const PredictionUnit& pu, CccmModel& cccmModelCb, CccmModel& cccmModelCr, int modelId, int modelThr
#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
                                      , int trainingRange
#endif
#if JVET_AF0073_INTER_CCP_MERGE
                                      , bool useRefSampOnly
#endif
)
{
  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  const CPelBuf recoCb  = pu.cs->picture->getRecoBuf(COMPONENT_Cb);
  const CPelBuf recoCr  = pu.cs->picture->getRecoBuf(COMPONENT_Cr);
  PelBuf        refLuma;

#if JVET_AD0202_CCCM_MDF
  PelBuf        refLuma1, refLuma2, refLuma3;

  if( pu.cccmMultiFilterIdx == 1 )
  {
    refLuma = xCccmGetLumaRefBuf( pu, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY, 0, 3, &refLuma1, &refLuma3, &refLuma2 );
  }
  else if( pu.cccmMultiFilterIdx > 1 )
  {
    refLuma = xCccmGetLumaRefBuf( pu, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY, 0, 2, &refLuma1, &refLuma3 );
  }
  else
#endif
  refLuma = xCccmGetLumaRefBuf( pu, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY );
  
  int sampleNum = 0;
  int stepX = 1;
  int stepY = 1;
  int chromaScaleX = 0;
  int chromaScaleY = 0;

#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  if( pu.cccmNoSubFlag )
  {
    chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
    chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );

    stepX = 1 << chromaScaleX;
    stepY = 1 << chromaScaleY;
  }
#endif
  
#if JVET_AB0174_CCCM_DIV_FREE
  int chromaOffsetCb = 1 << ( pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_CHROMA) - 1 );
  int chromaOffsetCr = 1 << ( pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_CHROMA) - 1 );
  
  if ( refSizeX || refSizeY )
  {
    int refPosX = refSizeX > 0 ? refSizeX - 1 : 0;
    int refPosY = refSizeY > 0 ? refSizeY - 1 : 0;

    refPosX = ( refPosX + refPosPicX ) >> chromaScaleX;
    refPosY = ( refPosY + refPosPicY ) >> chromaScaleY;

    chromaOffsetCb = recoCb.at( refPosX, refPosY );
    chromaOffsetCr = recoCr.at( refPosX, refPosY );
  }
#endif

#if JVET_AB0143_CCCM_TS
  int yStart = pu.cccmFlag == 2 ? refSizeY : 0;
  int yEnd = pu.cccmFlag == 3 ? refSizeY : areaHeight;
  int xStart = pu.cccmFlag == 3 ? refSizeX : 0;
  int xEnd = pu.cccmFlag == 2 ? refSizeX : areaWidth;
#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  if( trainingRange != -1 )
  {
    if( pu.cccmFlag != 2 && ( refSizeY > trainingRange ) )
    {
      yStart = refSizeY - trainingRange;
    }
    if( pu.cccmFlag != 3 && ( refSizeX > trainingRange ) )
    {
      xStart = refSizeX - trainingRange;
    }
  }
#endif

  for (int y = yStart; y < yEnd; y += stepY )
  {
    for (int x = xStart; x < xEnd; x += stepX )
    {
#else
  for (int y = 0; y < areaHeight; y += stepY )
  {
    for (int x = 0; x < areaWidth; x += stepX )
    {
#endif
      if ( x >= refSizeX && y >= refSizeY )
      {
        continue;
      }
      
      const Pel* src0 = refLuma.bufAt( x, y );

      if( modelId == 1 && src0[0] > modelThr )   // Model 1: Include only samples below or equal to the threshold
      {
        continue;
      }
      if( modelId == 2 && src0[0] <= modelThr )   // Model 2: Include only samples above the threshold
      {
        continue;
      }

      const Pel* src1 = refLuma.bufAt( x, y + 1 );
      const Pel* src2 = refLuma.bufAt( x, y - 1 );
#if JVET_AF0073_INTER_CCP_MERGE
      bool isBorderLeft = false, isBorderTop = false;
      if (useRefSampOnly)
      {
        if (y >= refSizeY && (x ==  pu.chromaPos().x - refPosPicX - 1))
        {
          isBorderLeft = true;
        }
        if(x >= refSizeX && (y ==  pu.chromaPos().y - refPosPicY - 1))
        {
          isBorderTop = true;
        }
      }
#endif

      // 7-tap cross
#if JVET_AC0054_GLCCCM || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
      if (pu.glCccmFlag)
      {        
        m_a[0][sampleNum] = src0[0]; // C
        m_a[1][sampleNum] = ( 2 * src2[0] + src2[-1] + src2[1] ) - ( 2 * src1[0] + src1[-1] + src1[1] ); // Vertical gradient
        m_a[2][sampleNum] = ( 2 * src0[-1] + src2[-1] + src1[-1] ) - ( 2 * src0[1] + src2[1] + src1[1] ); // Horizontal gradient
        m_a[3][sampleNum] = ( y + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // Y coordinate
        m_a[4][sampleNum] = ( x + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // X coordinate
        m_a[5][sampleNum] = cccmModelCb.nonlinear( src0[0] );
        m_a[6][sampleNum] = cccmModelCb.bias();
      }
      else
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
      if( pu.cccmNoSubFlag )
      {
        m_a[0][sampleNum] = src0[0];
        m_a[1][sampleNum] = src0[-1];
        m_a[2][sampleNum] = src0[1];
        m_a[3][sampleNum] = src1[0];
        m_a[4][sampleNum] = src1[-1];
        m_a[5][sampleNum] = src1[1];
        m_a[6][sampleNum] = cccmModelCb.nonlinear( src0[0] );
        m_a[7][sampleNum] = cccmModelCb.nonlinear( src1[0] );
        m_a[8][sampleNum] = cccmModelCb.nonlinear( src0[1] );
        m_a[9][sampleNum] = cccmModelCb.nonlinear( src0[-1] );
        m_a[10][sampleNum] = cccmModelCb.bias();
      }
      else
#endif
#if JVET_AD0202_CCCM_MDF
      if( pu.cccmMultiFilterIdx == 1 )
      {
        // 7-tap cross
        m_a[0][sampleNum] = src0[0];
        m_a[1][sampleNum] = refLuma1.at( x, y );
        m_a[2][sampleNum] = refLuma2.at( x, y );
        m_a[3][sampleNum] = refLuma3.at( x, y );
        m_a[4][sampleNum] = cccmModelCb.nonlinear( src0[0] );
        m_a[5][sampleNum] = cccmModelCb.nonlinear( refLuma1.at( x, y ) );
        m_a[6][sampleNum] = cccmModelCb.nonlinear( refLuma2.at( x, y ) );
        m_a[7][sampleNum] = ( y + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // Y coordinate
        m_a[8][sampleNum] = ( x + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // X coordinate
        m_a[9][sampleNum] = cccmModelCb.bias();
      }
      else if( pu.cccmMultiFilterIdx == 2 )
      {
        m_a[0][sampleNum] = src0[0]; // C
        m_a[1][sampleNum] = src0[-1]; // W
        m_a[2][sampleNum] = src0[1]; // E
        m_a[3][sampleNum] = refLuma1.at( x, y ); // C
        m_a[4][sampleNum] = refLuma1.at( x - 1, y ); // W
        m_a[5][sampleNum] = refLuma1.at( x + 1, y ); // E
        m_a[6][sampleNum] = cccmModelCb.nonlinear( src0[0] );
        m_a[7][sampleNum] = cccmModelCb.nonlinear( src0[-1] );
        m_a[8][sampleNum] = cccmModelCb.nonlinear( src0[1] );
        m_a[9][sampleNum] = ( x + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // X coordinate
        m_a[10][sampleNum] = cccmModelCb.bias();
      }
      else if( pu.cccmMultiFilterIdx == 3 )
      {
        m_a[0][sampleNum] = src0[0]; // C
        m_a[1][sampleNum] = src2[1]; // EN
        m_a[2][sampleNum] = src1[-1]; // WS
        m_a[3][sampleNum] = refLuma3.at( x, y ); // C
        m_a[4][sampleNum] = refLuma3.at( x + 1, y - 1 ); // EN
        m_a[5][sampleNum] = refLuma3.at( x - 1, y + 1 ); // WS
        m_a[6][sampleNum] = cccmModelCb.nonlinear( src0[0] );
        m_a[7][sampleNum] = cccmModelCb.nonlinear( src2[1] );
        m_a[8][sampleNum] = cccmModelCb.nonlinear( src1[-1] );
        m_a[9][sampleNum] = ( y + CCCM_LOC_OFFSET ) << CCCM_LOC_SHIFT; // Y coordinate
        m_a[10][sampleNum] = cccmModelCb.bias();
      }
      else
#endif
      {
        m_a[0][sampleNum] = src0[0]; // C
        m_a[1][sampleNum] = src2[0]; // N
#if JVET_AF0073_INTER_CCP_MERGE
        m_a[2][sampleNum] = isBorderTop ? src0[0] : src1[0]; // S
#else
        m_a[2][sampleNum] = src1[0]; // S
#endif
        m_a[3][sampleNum] = src0[-1]; // W
#if JVET_AF0073_INTER_CCP_MERGE
        m_a[4][sampleNum] = isBorderLeft ? src0[0] : src0[1]; // E
#else
        m_a[4][sampleNum] = src0[1]; // E
#endif
        m_a[5][sampleNum] = cccmModelCb.nonlinear( src0[0] );
        m_a[6][sampleNum] = cccmModelCb.bias();
      }
      
      const int refPosX = ( refPosPicX + x ) >> chromaScaleX;
      const int refPosY = ( refPosPicY + y ) >> chromaScaleY;

      m_cb[sampleNum] = recoCb.at( refPosX, refPosY );
      m_cr[sampleNum++] = recoCr.at( refPosX, refPosY );
    }
  }

  if( !sampleNum ) // Number of samples can go to zero in the multimode case
  {
    cccmModelCb.clearModel();
    cccmModelCr.clearModel();
  }
  else
  {
#if JVET_AB0174_CCCM_DIV_FREE
    m_cccmSolver.solve2( m_a, m_cb, m_cr, sampleNum, chromaOffsetCb, chromaOffsetCr, cccmModelCb, cccmModelCr );
#else
    m_cccmSolver.solve2( m_a, m_cb, m_cr, sampleNum, cccmModelCb, cccmModelCr );
#endif
  }
}

#if JVET_AG0136_INTRA_TMP_LIC
void IntraPrediction::setBvMvFromMemory(const CodingUnit& cu, const int idx, const bool useMR)
{
  const int pX = (useMR ? m_tmpXdispUseMR : m_tmpXdisp)[idx];
  const int pY = (useMR ? m_tmpYdispUseMR : m_tmpYdisp)[idx];
  (cu.firstPU)->mv->set(pX << MV_FRACTIONAL_BITS_INTERNAL, pY << MV_FRACTIONAL_BITS_INTERNAL);
  (cu.firstPU)->bv.set(pX, pY);
}
#endif
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
void IntraPrediction::xCccmCreateLumaNoSubRef( const PredictionUnit& pu, CompArea chromaArea 
#if JVET_AF0073_INTER_CCP_MERGE
    , bool isTemplate
#endif
)
{
  const CPelBuf recoLuma = pu.cs->picture->getRecoBuf( COMPONENT_Y );
  const int  maxPosPicX = pu.cs->picture->lumaSize().width - 1;
  const int  maxPosPicY = pu.cs->picture->lumaSize().height - 1;

  xCccmCalcRefArea( pu, chromaArea ); // Find the reference area

  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  CHECK( !pu.cccmNoSubFlag, "cccmNoSubFlag shall be enabled" );

  PelBuf refLuma = xCccmGetLumaRefBuf( pu, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY );

  const int chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
  const int chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );

  int puBorderX = refSizeX + (m_cccmBlkArea.width << chromaScaleX);
  int puBorderY = refSizeY + (m_cccmBlkArea.height << chromaScaleY);

#if JVET_AB0174_CCCM_DIV_FREE
  xCccmSetLumaRefValue( pu );
#endif

#if JVET_AF0073_INTER_CCP_MERGE
  if (!isTemplate)
  {
#endif
  const int filterPaddingX = CCCM_FILTER_PADDING << chromaScaleX;
  const int filterPaddingY = CCCM_FILTER_PADDING << chromaScaleY;

  // luma for the area covering both the PU and the top/left reference areas (+ top and left paddings)
  for( int y = -filterPaddingY; y < areaHeight; y++ )
  {
    for( int x = -filterPaddingX; x < areaWidth; x++ )
    {
      if( (x >= puBorderX && y >= refSizeY) || (y >= puBorderY && x >= refSizeX) )
      {
        continue;
      }

      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;

      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

      refLuma.at( x, y ) = xCccmGetLumaVal( pu, recoLuma, chromaPosPicX, chromaPosPicY );
    }
  }

  // Pad right of top reference area
  for( int x = 0; x < filterPaddingX; x++ )
  {
    for( int y = -filterPaddingY; y < refSizeY; y++ )
    {
      refLuma.at( areaWidth + x, y ) = refLuma.at( areaWidth - 1, y );
    }

    // Pad right of PU
    for( int y = refSizeY; y < puBorderY; y++ )
    {
      refLuma.at( puBorderX + x, y ) = refLuma.at( puBorderX - 1, y );
    }

    // Pad right of left reference area
    for( int y = puBorderY; y < areaHeight; y++ )
    {
      refLuma.at( refSizeX + x, y ) = refLuma.at( refSizeX - 1, y );
    }
  }

  for( int y = 0; y < filterPaddingY; y++ )
  {
    // Pad below left reference area
    for( int x = -filterPaddingX; x < refSizeX + filterPaddingX; x++ )
    {
      refLuma.at( x, areaHeight + y ) = refLuma.at( x, areaHeight - 1 );
    }

    // Pad below PU
    for( int x = refSizeX; x < puBorderX + filterPaddingX; x++ )
    {
      refLuma.at( x, puBorderY + y ) = refLuma.at( x, puBorderY - 1 );
    }

    // Pad below right reference area
    for( int x = puBorderX + filterPaddingX; x < areaWidth + filterPaddingX; x++ )
    {
      refLuma.at( x, refSizeY + y ) = refLuma.at( x, refSizeY - 1 );
    }
  }

  // In dualtree we can also use luma from the right and below (if not on CTU/picture boundary)
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if( pu.cu->separateTree )
#else
  if( CS::isDualITree( *pu.cs ) )
#endif
  {
    int ctuWidth = pu.cs->sps->getMaxCUWidth() >> getComponentScaleX( COMPONENT_Cb, pu.chromaFormat );
    int ctuHeight = pu.cs->sps->getMaxCUHeight() >> getComponentScaleY( COMPONENT_Cb, pu.chromaFormat );

    // Samples right of top reference area
    int padPosPicX = refPosPicX + areaWidth;

    if( padPosPicX <= maxPosPicX && (padPosPicX % ctuWidth) )
    {
      for( int y = -filterPaddingY; y < refSizeY; y++ )
      {
        int chromaPosPicY = refPosPicY + y;
        chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        for( int x = 0; x < filterPaddingX; x++ )
        {
          refLuma.at( areaWidth + x, y ) = xCccmGetLumaVal( pu, recoLuma, padPosPicX, chromaPosPicY );
        }
      }
    }

    // Samples right of PU
    padPosPicX = refPosPicX + puBorderX;

    if( padPosPicX <= maxPosPicX && (padPosPicX % ctuWidth) )
    {
      for( int y = refSizeY; y < puBorderY; y++ )
      {
        int chromaPosPicY = refPosPicY + y;
        chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        for( int x = 0; x < filterPaddingX; x++ )
        {
          refLuma.at( puBorderX + x, y ) = xCccmGetLumaVal( pu, recoLuma, padPosPicX, chromaPosPicY );
        }
      }
    }

    // Samples right of left reference area
    padPosPicX = refPosPicX + refSizeX;

    if( padPosPicX <= maxPosPicX )
    {
      for( int y = puBorderY; y < areaHeight; y++ )
      {
        int chromaPosPicY = refPosPicY + y;
        chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        for( int x = 0; x < filterPaddingX; x++ )
        {
          refLuma.at( refSizeX + x, y ) = xCccmGetLumaVal( pu, recoLuma, padPosPicX, chromaPosPicY );
        }
      }
    }

    // Samples below left reference area
    int padPosPicY = refPosPicY + areaHeight;

    if( padPosPicY <= maxPosPicY && (padPosPicY % ctuHeight) )
    {
      for( int x = -filterPaddingX; x < refSizeX + filterPaddingX; x++ )
      {
        int chromaPosPicX = refPosPicX + x;
        chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;

        for( int y = 0; y < filterPaddingY; y++ )
        {
          refLuma.at( x, areaHeight + y ) = xCccmGetLumaVal( pu, recoLuma, chromaPosPicX, padPosPicY );
        }
      }
    }

    // Samples below PU
    padPosPicY = refPosPicY + puBorderY;

    if( padPosPicY <= maxPosPicY && (padPosPicY % ctuHeight) )
    {
      for( int x = refSizeX; x < puBorderX; x++ ) // Just go to PU border as the next sample may be out of CTU (and not needed anyways)
      {
        int chromaPosPicX = refPosPicX + x;
        chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;

        for( int y = 0; y < filterPaddingY; y++ )
        {
          refLuma.at( x, puBorderY + y ) = xCccmGetLumaVal( pu, recoLuma, chromaPosPicX, padPosPicY );
        }
      }
    }

    // Samples below right reference area
    padPosPicY = refPosPicY + refSizeY;

    if( padPosPicY <= maxPosPicY )
    {
      // Avoid going outside of right CTU border where these samples are not yet available
      int puPosPicX = pu.blocks[COMPONENT_Cb].x;
      int ctuRightEdgeDist = ctuWidth - (puPosPicX % ctuWidth) + refSizeX;
      int lastPosX = ctuRightEdgeDist < areaWidth ? ctuRightEdgeDist : areaWidth;

      for( int x = puBorderX + 1; x < lastPosX; x++ ) // Just go to ref area border as the next sample may be out of CTU (and not needed anyways)
      {
        int chromaPosPicX = refPosPicX + x;
        chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;

        for( int y = 0; y < filterPaddingY; y++ )
        {
          refLuma.at( x, refSizeY + y ) = xCccmGetLumaVal( pu, recoLuma, chromaPosPicX, padPosPicY );
        }
      }
    }
  }
#if JVET_AF0073_INTER_CCP_MERGE
  }
  else
  {
    const int stepX        = 1 << chromaScaleX;
    const int stepY        = 1 << chromaScaleY;
    
    // Generate top template
    if (refSizeY > 0)
    {
      for (int y = refSizeY - stepY; y < refSizeY; y++)
      {
        for ( int x = refSizeX - 1; x < puBorderX; x++ )
        {
          int chromaPosPicX = refPosPicX + x;
          int chromaPosPicY = refPosPicY + y;

          chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
          chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

          refLuma.at( x, y ) = xCccmGetLumaVal( pu, recoLuma, chromaPosPicX, chromaPosPicY );
        }
      }
    }

    // Generate left template
    if (refSizeX > 0)
    {
      for (int x = refSizeX - stepX - 1; x < refSizeX; x++)
      {
        for( int y = refSizeY; y <= puBorderY; y++ )
        {
          int chromaPosPicX = refPosPicX + x;
          int chromaPosPicY = refPosPicY + y;

          chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
          chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

          refLuma.at( x, y ) = xCccmGetLumaVal( pu, recoLuma, chromaPosPicX, chromaPosPicY );
        }
      }
    }
  }
#endif  
}
#endif
#if JVET_AE0100_BVGCCCM
void IntraPrediction::xBvgCccmCalcModels( const PredictionUnit& pu, CccmModel& cccmModelCb, CccmModel &cccmModelCr, int modelId, int modelThr, int minVal, int maxVal )
{
  const CPelBuf recoCb = pu.cs->picture->getRecoBuf( COMPONENT_Cb );
  const CPelBuf recoCr = pu.cs->picture->getRecoBuf( COMPONENT_Cr );
  int chromaOffsetCb = 1 << ( pu.cu->slice->getSPS()->getBitDepth( CHANNEL_TYPE_CHROMA ) - 1 );
  int chromaOffsetCr = 1 << ( pu.cu->slice->getSPS()->getBitDepth( CHANNEL_TYPE_CHROMA ) - 1 );
  
  int refSizeX   = m_cccmBlkArea.x - m_cccmRefArea.x; // Reference lines available left and above
  int refSizeY   = m_cccmBlkArea.y - m_cccmRefArea.y;
  int refPosPicX = m_cccmRefArea.x;                   // Position of the reference area in picture coordinates
  int refPosPicY = m_cccmRefArea.y;
#if JVET_AB0174_CCCM_DIV_FREE
  if ( refSizeX || refSizeY )
  {
    int refPosX = refSizeX > 0 ? refSizeX - 1 : 0;
    int refPosY = refSizeY > 0 ? refSizeY - 1 : 0;
    
    chromaOffsetCb = recoCb.at(refPosPicX + refPosX, refPosPicY + refPosY);
    chromaOffsetCr = recoCr.at(refPosPicX + refPosX, refPosPicY + refPosY);
  }
#endif
  int sampleNum = 0;
  int strX[NUM_BVG_CCCM_CANDS], endX[NUM_BVG_CCCM_CANDS], strY[NUM_BVG_CCCM_CANDS], endY[NUM_BVG_CCCM_CANDS];
  for (int candIdx = 0; candIdx < pu.numBvgCands; candIdx++)
  {
    Mv chromaBv = pu.bvList[candIdx];
    PelBuf refLuma = xBvgCccmGetLumaPuBuf(pu, candIdx);
    int refPosPicX = pu.blocks[COMPONENT_Cb].x + chromaBv.hor;
    int refPosPicY = pu.blocks[COMPONENT_Cb].y + chromaBv.ver;
    strX[candIdx] = refPosPicX;
    strY[candIdx] = refPosPicY;
    endX[candIdx] = refPosPicX + refLuma.width;
    endY[candIdx] = refPosPicY + refLuma.height;
  }
  
  for (int candIdx = 0; candIdx < pu.numBvgCands; candIdx++)
  {
    PelBuf refLuma = xBvgCccmGetLumaPuBuf(pu, candIdx);
    PelBuf refCb = xBvgCccmGetChromaPuBuf(pu, COMPONENT_Cb, candIdx);
    PelBuf refCr = xBvgCccmGetChromaPuBuf(pu, COMPONENT_Cr, candIdx);
      //-- collect data
    for( int y = 0; y < refLuma.height; y++ )
    {
      for( int x = 0; x < refLuma.width; x++ )
      {
        if ( modelId == 1 && refLuma.at(x, y) > modelThr ) // Model 1: Include only samples below or equal to the threshold
        {
          continue;
        }
        if ( modelId == 2 && refLuma.at(x, y) <= modelThr) // Model 2: Include only samples above the threshold
        {
          continue;
        }
        if (refLuma.at(x, y) < minVal || refLuma.at(x, y) > maxVal)
        {
          continue;
        }
        bool exist = false;
        if (candIdx > 0)
        {
          for (int i = 0; i < candIdx; i++)
          {
            int xx = strX[candIdx] + x;
            int yy = strY[candIdx] + y;
            if (xx >= strX[i] && xx < endX[i] && yy >= strY[i] && yy < endY[i])
            {
              exist = true;
              break;
            }
          }
        }
        if (exist)
        {
          continue;
        }
        // 11-tap filter
        m_a[0][sampleNum] = refLuma.at(x, y    ); // C
        m_a[1][sampleNum] = refLuma.at(x, y - 1); // N
        m_a[2][sampleNum] = refLuma.at(x, y + 1); // S
        m_a[3][sampleNum] = refLuma.at(x - 1, y); // W
        m_a[4][sampleNum] = refLuma.at(x + 1, y); // E
        m_a[5][sampleNum] = cccmModelCb.nonlinear( refLuma.at(x, y) );     // nonlinear(C)
        m_a[6][sampleNum] = cccmModelCb.nonlinear( refLuma.at(x, y - 1) ); // nonlinear(N)
        m_a[7][sampleNum] = cccmModelCb.nonlinear( refLuma.at(x, y + 1) ); // nonlinear(S)
        m_a[8][sampleNum] = cccmModelCb.nonlinear( refLuma.at(x - 1, y) ); // nonlinear(W)
        m_a[9][sampleNum] = cccmModelCb.nonlinear( refLuma.at(x + 1, y) ); // nonlinear(E)
        m_a[10][sampleNum] = cccmModelCb.bias();
        
        m_cb[sampleNum] = refCb.at( x, y );
        m_cr[sampleNum++] = refCr.at( x, y );
      }
    }
  }
  
  if( !sampleNum ) // Number of samples can go to zero in the multimode case
  {
    cccmModelCb.clearModel();
    cccmModelCr.clearModel();
  }
  else
  {
#if JVET_AB0174_CCCM_DIV_FREE
    m_cccmSolver.solve2( m_a, m_cb, m_cr, sampleNum, chromaOffsetCb, chromaOffsetCr, cccmModelCb, cccmModelCr );
#else
    m_cccmSolver.solve2( m_a, m_cb, m_cr, sampleNum, cccmModelCb, cccmModelCr );
#endif
  }
  return;
}
void IntraPrediction::xBvgCccmApplyModel( const PredictionUnit& pu, const ComponentID compId, CccmModel &cccmModel, int modelId, int modelThr, PelBuf &piPred )
{
  const  ClpRng& clpRng(pu.cu->cs->slice->clpRng(compId));
  Pel* samples = m_samples;
  
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  CHECK( pu.cccmNoSubFlag, "cccmNoSubFlag shall be disabled" );
#endif
  CPelBuf refLumaBlk = xCccmGetLumaPuBuf(pu);
  for (int y = 0; y < refLumaBlk.height; y++)
  {
    for (int x = 0; x < refLumaBlk.width; x++)
    {
      if ( modelId == 1 && refLumaBlk.at( x, y ) > modelThr ) // Model 1: Include only samples below or equal to the threshold
      {
        continue;
      }
      if ( modelId == 2 && refLumaBlk.at( x, y ) <= modelThr) // Model 2: Include only samples above the threshold
      {
        continue;
      }
      // 11-tap filter
      samples[0] = refLumaBlk.at(x, y    ); // C
      samples[1] = refLumaBlk.at(x, y - 1); // N
      samples[2] = refLumaBlk.at(x, y + 1); // S
      samples[3] = refLumaBlk.at(x - 1, y); // W
      samples[4] = refLumaBlk.at(x + 1, y); // E
      samples[5] = cccmModel.nonlinear( refLumaBlk.at(x, y) );     // nonlinear(C)
      samples[6] = cccmModel.nonlinear( refLumaBlk.at(x, y - 1) ); // nonlinear(N)
      samples[7] = cccmModel.nonlinear( refLumaBlk.at(x, y + 1) ); // nonlinear(S)
      samples[8] = cccmModel.nonlinear( refLumaBlk.at(x - 1, y) ); // nonlinear(W)
      samples[9] = cccmModel.nonlinear( refLumaBlk.at(x + 1, y) ); // nonlinear(E)
      samples[10] = cccmModel.bias();
      
      piPred.at(x, y) = ClipPel<Pel>( cccmModel.convolve(samples), clpRng );
    }
  }
}
int IntraPrediction::xBvgCccmCalcBlkAver(const PredictionUnit& pu) const
{
  int numSamples = 0;
  int sumSamples = 0;
  CPelBuf refLumaBlk = xCccmGetLumaPuBuf( pu );
  
  for (int y = 0; y < refLumaBlk.height; y++)
  {
    for (int x = 0; x < refLumaBlk.width; x++)
    {
      sumSamples += refLumaBlk.at(x, y);
      numSamples += 1;
    }
  }
#if JVET_AB0174_CCCM_DIV_FREE
#if JVET_AJ0237_INTERNAL_12BIT
#if JVET_AJ0237_INTERNAL_12BIT
  const int bd = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  return numSamples == 0 ? (1 << (bd - 1)) : xCccmDivideLowPrec(sumSamples, numSamples, DECIM_BITS(bd));
#else
  return numSamples == 0 ? ((1 << pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) - 1) : xCccmDivideLowPrec(sumSamples, numSamples);
#endif
#else
  return numSamples == 0 ? 512 : xCccmDivideLowPrec(sumSamples, numSamples);
#endif
#else
  return numSamples == 0 ? 512 : ( sumSamples + numSamples/2) / numSamples;
#endif
}
void IntraPrediction::xBvgCccmCalcBlkRange(const PredictionUnit& pu, int& minVal, int&maxVal) const
{
  minVal = MAX_INT, maxVal = -MAX_INT;
  CPelBuf refLumaBlk = xCccmGetLumaPuBuf(pu);
  for (int y = 0; y < refLumaBlk.height; y++)
  {
    for (int x = 0; x < refLumaBlk.width; x++)
    {
      if (refLumaBlk.at(x, y) < minVal)
      {
        minVal = refLumaBlk.at(x, y);
      }
      if (refLumaBlk.at(x, y) > maxVal)
      {
        maxVal = refLumaBlk.at(x, y);
      }
    }
  }
  int range = abs(maxVal - minVal) >> 4;
  minVal -= range;
  maxVal += range;
}
void IntraPrediction::xBvgCccmCalcRefArea(const PredictionUnit& pu, CompArea chromaArea)
{
  m_bvgCccmBlkArea = chromaArea;
  m_bvgCccmRefArea = chromaArea;
  int refWidth = chromaArea.width + 2 * CCCM_FILTER_PADDING;
  int refHeight = chromaArea.height + 2 * CCCM_FILTER_PADDING;
  m_bvgCccmRefArea = Area(chromaArea.x - CCCM_FILTER_PADDING, chromaArea.y - CCCM_FILTER_PADDING, refWidth, refHeight);
}
PelBuf IntraPrediction::xBvgCccmGetLumaPuBufFul(const PredictionUnit& pu, int candIdx) const
{
  int refStride = m_bvgCccmRefArea.width;
  int tuWidth = m_bvgCccmRefArea.width;
  int tuHeight = m_bvgCccmRefArea.height;
  return PelBuf( m_bvgCccmLumaBuf[candIdx], refStride, tuWidth, tuHeight );  // Points to the top-left corner
                                                                             //  return PelBuf( m_bvgCccmLumaBuf[0], refStride, tuWidth, tuHeight );  // Points to the top-left corner
}
PelBuf IntraPrediction::xBvgCccmGetLumaPuBuf(const PredictionUnit& pu, int candIdx) const
{
  int refSizeX  = 0;//m_bvgCccmBlkArea.x; // Reference lines available left and above
  int refSizeY  = 0;//m_bvgCccmBlkArea.y;
  int tuWidth   = m_bvgCccmBlkArea.width;
  int tuHeight  = m_bvgCccmBlkArea.height;
  int refStride = m_bvgCccmBlkArea.width + 2 * CCCM_FILTER_PADDING; // Including paddings required for the 2D filter
  int refOrigin = refStride * (refSizeY + CCCM_FILTER_PADDING) + refSizeX + CCCM_FILTER_PADDING;
  
  return PelBuf( m_bvgCccmLumaBuf[candIdx] + refOrigin, refStride, tuWidth, tuHeight );  // Points to the top-left corner of the block
                                                                                         //  return PelBuf( m_bvgCccmLumaBuf[0] + refOrigin, refStride, tuWidth, tuHeight );  // Points to the top-left corner of the block
}
PelBuf IntraPrediction::xBvgCccmGetChromaPuBuf(const PredictionUnit& pu, const ComponentID compID, int candIdx) const
{
  int refSizeX  = 0;//m_bvgCccmBlkArea.x; // Reference lines available left and above
  int refSizeY  = 0;//m_bvgCccmBlkArea.y;
  int tuWidth   = m_bvgCccmBlkArea.width;
  int tuHeight  = m_bvgCccmBlkArea.height;
  int refStride = m_bvgCccmBlkArea.width + 2 * CCCM_FILTER_PADDING; // Including paddings required for the 2D filter
  int refOrigin = refStride * (refSizeY + CCCM_FILTER_PADDING) + refSizeX + CCCM_FILTER_PADDING;
  if (compID == COMPONENT_Cb)
  {
    return PelBuf( m_bvgCccmChromaBuf[candIdx][0] + refOrigin, refStride, tuWidth, tuHeight );  // Points to the top-left corner of the block
  }
  else
  {
    return PelBuf( m_bvgCccmChromaBuf[candIdx][1] + refOrigin, refStride, tuWidth, tuHeight );  // Points to the top-left corner of the block
  }
}
void IntraPrediction::xBvgCccmCreateLumaRef(const PredictionUnit& pu, CompArea chromaArea
#if JVET_AD0202_CCCM_MDF
                                            , int downsFilterIdx
#endif
                                            )
{
  const CPelBuf recoLuma = pu.cs->picture->getRecoBuf(COMPONENT_Y);
  const CPelBuf recoCb = pu.cs->picture->getRecoBuf( COMPONENT_Cb );
  const CPelBuf recoCr = pu.cs->picture->getRecoBuf( COMPONENT_Cr );
  
  const int  maxPosPicX  = pu.cs->picture->chromaSize().width  - 1;
  const int  maxPosPicY  = pu.cs->picture->chromaSize().height - 1;
  int ctuWidth  = pu.cs->sps->getMaxCUWidth()  >> getComponentScaleX(COMPONENT_Cb, pu.chromaFormat);
  int ctuHeight = pu.cs->sps->getMaxCUHeight() >> getComponentScaleY(COMPONENT_Cb, pu.chromaFormat);
  
  for (int candIdx = 0; candIdx < pu.numBvgCands; candIdx++)
  {
    Mv chromaBv = pu.bvList[candIdx];
    xBvgCccmCalcRefArea(pu, chromaArea); // Find the reference area
    PelBuf refLuma = xBvgCccmGetLumaPuBuf(pu, candIdx);
    PelBuf refCb = xBvgCccmGetChromaPuBuf(pu, COMPONENT_Cb, candIdx);
    PelBuf refCr = xBvgCccmGetChromaPuBuf(pu, COMPONENT_Cr, candIdx);
    
#if JVET_AB0174_CCCM_DIV_FREE
    xCccmSetLumaRefValue( pu );
#endif
    
    int refPosPicX = pu.blocks[COMPONENT_Cb].x + chromaBv.hor;
    int refPosPicY = pu.blocks[COMPONENT_Cb].y + chromaBv.ver;
    int maxWidth = refLuma.width;
    int maxHeight =  refLuma.height;
    PU::checkIsChromaBvCandidateValid(pu, chromaBv, maxWidth, maxHeight);
    // Generate down-sampled luma for the area covering both the PU and the top/left reference areas (+ top and left paddings)
    for (int y = 0; y < refLuma.height; y++)
    {
      for (int x = 0; x < refLuma.width; x++)
      {
        int chromaPosPicX = refPosPicX + x;
        int chromaPosPicY = refPosPicY + y;
        
        chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;
        
        refLuma.at( x, y ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
                                             , downsFilterIdx
#endif
                                             );
        refCb.at( x, y ) = recoCb.at( chromaPosPicX, chromaPosPicY );
        refCr.at( x, y ) = recoCr.at( chromaPosPicX, chromaPosPicY );
        // pad if not available
        if ( x >= maxWidth )
        {
          refLuma.at( x, y ) = refLuma.at( x - 1, y );
          refCb.at( x, y ) = refCb.at( x - 1, y );
          refCr.at( x, y ) = refCr.at( x - 1, y );
        }
        else if (y >= maxHeight)
        {
          refLuma.at( x, y ) = refLuma.at( x, y - 1);
          refCb.at( x, y ) = refCb.at( x, y - 1);
          refCr.at( x, y ) = refCr.at( x, y - 1);
        }
      }
    }
    //-- Now fill the out of block samples (North)
    for (int x = 0; x < refLuma.width; x++)
    {
      int y = -1;
      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;
      
      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;
      
      refLuma.at( x, y ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
                                           , downsFilterIdx
#endif
                                           );
      if (chromaPosPicY < 0)
      {
        refLuma.at( x, y ) = refLuma.at( x, y + 1 );
      }
      if ( x >= maxWidth )
      {
        refLuma.at( x, y ) = refLuma.at( x - 1, y );
      }
    }
    //-- Now fill the out of block samples (South)
    for (int x = 0; x < refLuma.width; x++)
    {
      int y = refLuma.height;
      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;
      
      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;
      
      refLuma.at( x, y ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
                                           , downsFilterIdx
#endif
                                           );
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
      if (!pu.cu->slice->isIntra() && pu.cu->separateTree)
      {
        refLuma.at( x, y ) = refLuma.at( x, y - 1 );
      }
#endif
      if (chromaPosPicY >= maxPosPicY)
      {
        refLuma.at( x, y ) = refLuma.at( x, y - 1 );
      }
      if (!( chromaPosPicY <= maxPosPicY && (chromaPosPicY % ctuHeight) ))
      {
        refLuma.at( x, y ) = refLuma.at( x, y - 1 );
      }
      if (maxHeight < refLuma.height)
      {
        refLuma.at( x, y ) = refLuma.at( x, y - 1);
      }
      if ( x >= maxWidth )
      {
        refLuma.at( x, y ) = refLuma.at( x - 1, y );
      }
    }
    //-- Now fill the out of block samples (West)
    for (int y = 0; y < refLuma.height; y++)
    {
      int x = -1;
      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;
      
      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;
      
      refLuma.at( x, y ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
                                           , downsFilterIdx
#endif
                                           );
      if (chromaPosPicX < 0)
      {
        refLuma.at( x, y ) = refLuma.at( x + 1, y );
      }
      if ( y >= maxHeight )
      {
        refLuma.at( x, y ) = refLuma.at( x, y - 1 );
      }
    }
    //-- Now fill the out of block samples (East)
    for (int y = 0; y < refLuma.height; y++)
    {
      int x = refLuma.width;
      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;
      
      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;
      
      refLuma.at( x, y ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
                                           , downsFilterIdx
#endif
                                           );
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
      if (!pu.cu->slice->isIntra() && pu.cu->separateTree)
      {
        refLuma.at( x, y ) = refLuma.at( x - 1, y );
      }
#endif
      if (chromaPosPicX >= maxPosPicX)
      {
        refLuma.at( x, y ) = refLuma.at( x - 1, y );
      }
      if (!( chromaPosPicX <= maxPosPicX && (chromaPosPicX % ctuWidth) ))
      {
        refLuma.at( x, y ) = refLuma.at( x - 1, y );
      }
      if (maxWidth < refLuma.width)
      {
        refLuma.at( x, y ) = refLuma.at( x - 1, y );
      }
      if ( y >= maxHeight )
      {
        refLuma.at( x, y ) = refLuma.at( x, y - 1 );
      }
    }
    
    int rribcFlipType = pu.rrIbcList[candIdx];
    if (rribcFlipType > 0)
    {
      PelBuf refLumaExt = xBvgCccmGetLumaPuBufFul(pu, candIdx);
      refLumaExt.flipSignal(rribcFlipType == 1);
      refCb.flipSignal(rribcFlipType == 1);
      refCr.flipSignal(rribcFlipType == 1);
    }
  }
}
#endif

// Using the same availability checking as in IntraPrediction::xFillReferenceSamples
void IntraPrediction::xCccmCalcRefArea(const PredictionUnit& pu, CompArea chromaArea)
{
  const ChannelType     chType  = CHANNEL_TYPE_CHROMA;
  const CodingUnit&     cu      = *pu.cu;
  const CodingStructure &cs     = *cu.cs;
  const SPS             &sps    = *cs.sps;
  const PreCalcValues   &pcv    = *cs.pcv;

  const int tuWidth      = chromaArea.width;
  const int tuHeight     = chromaArea.height;

  const bool noShift     = pcv.noChroma2x2 && chromaArea.width == 4;   // don't shift on the lowest level (chroma not-split)
  const int  compScaleX  = getComponentScaleX(chromaArea.compID, sps.getChromaFormatIdc());
  const int  compScaleY  = getComponentScaleY(chromaArea.compID, sps.getChromaFormatIdc());
  const int  unitWidth   = pcv.minCUWidth  >> (noShift ? 0 : compScaleX);
  const int  unitHeight  = pcv.minCUHeight >> (noShift ? 0 : compScaleY);

  const int  totalAboveUnits    = (2 * tuWidth + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits     = (2 * tuHeight + (unitHeight - 1)) / unitHeight;
  const int  numAboveUnits      = std::max<int>( tuWidth / unitWidth, 1 );
  const int  numLeftUnits       = std::max<int>( tuHeight / unitHeight, 1 );
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits  = totalLeftUnits - numLeftUnits;

  static bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1] = { false }; // Just a dummy array here, content not used

  int avaiAboveRightUnits = isAboveRightAvailable( cu, chType, chromaArea.topRight(),   numAboveRightUnits, unitWidth,  (neighborFlags + totalLeftUnits + 1 + numAboveUnits) );
  int avaiLeftBelowUnits  = isBelowLeftAvailable ( cu, chType, chromaArea.bottomLeft(), numLeftBelowUnits,  unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits) );
  
  int refSizeX, refSizeY;
  
  PU::getCccmRefLineNum(pu, chromaArea, refSizeX, refSizeY); // Reference lines available left and above

  int refWidth  = chromaArea.width  + refSizeX;              // Reference buffer size excluding paddings
  int refHeight = chromaArea.height + refSizeY;

  int extWidth  = avaiAboveRightUnits * unitWidth;
  int extHeight = avaiLeftBelowUnits  * unitHeight;
  
  refWidth  += refSizeY ? extWidth  : 0; // Add above right if above is available
  refHeight += refSizeX ? extHeight : 0; // Add below left if left is available

  m_cccmBlkArea = chromaArea;
  m_cccmRefArea = Area(chromaArea.x - refSizeX, chromaArea.y - refSizeY, refWidth, refHeight);
}

// Return downsampled luma buffer that contains PU and the reference areas above and left of the PU
PelBuf IntraPrediction::xCccmGetLumaRefBuf(const PredictionUnit& pu, int &areaWidth, int &areaHeight, int &refSizeX, int &refSizeY, int &refPosPicX, int &refPosPicY
#if JVET_AD0202_CCCM_MDF
  , int cccmDownsamplesFilterIdx, int numBuffer, PelBuf* refLuma1, PelBuf* refLuma3, PelBuf* refLuma2
#endif
) const
{
#if JVET_AC0147_CCCM_NO_SUBSAMPLING
  if( pu.cccmNoSubFlag )
  {
    const int chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
    const int chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );

    refPosPicX = m_cccmRefArea.x << chromaScaleX;                          // Position of the reference area in picture coordinates
    refPosPicY = m_cccmRefArea.y << chromaScaleY;
    refSizeX   = ((m_cccmBlkArea.x - m_cccmRefArea.x) << chromaScaleX);    // Reference lines available left and above
    refSizeY   = ((m_cccmBlkArea.y - m_cccmRefArea.y) << chromaScaleY);
    areaWidth  = m_cccmRefArea.width << chromaScaleX;                      // Reference buffer size excluding paddings
    areaHeight = m_cccmRefArea.height << chromaScaleY;

    int refStride = areaWidth + 2 * (CCCM_FILTER_PADDING << chromaScaleX); // Including paddings required for the 2D filter
    int refOrigin = refStride * (CCCM_FILTER_PADDING << chromaScaleY) + (CCCM_FILTER_PADDING << chromaScaleX);
#if JVET_AD0202_CCCM_MDF
    return PelBuf(m_cccmLumaBuf[0] + refOrigin, refStride, areaWidth, areaHeight); // Points to the top-left corner of the reference area 
#else
    return PelBuf( m_cccmLumaBuf[1] + refOrigin, refStride, areaWidth, areaHeight ); // Points to the top-left corner of the reference area 
#endif
  }
#endif

  refSizeX   = m_cccmBlkArea.x - m_cccmRefArea.x; // Reference lines available left and above
  refSizeY   = m_cccmBlkArea.y - m_cccmRefArea.y;
  areaWidth  = m_cccmRefArea.width;               // Reference buffer size excluding paddings
  areaHeight = m_cccmRefArea.height;
  refPosPicX = m_cccmRefArea.x;                   // Position of the reference area in picture coordinates
  refPosPicY = m_cccmRefArea.y;

  int refStride = areaWidth + 2 * CCCM_FILTER_PADDING; // Including paddings required for the 2D filter
  int refOrigin = refStride * CCCM_FILTER_PADDING + CCCM_FILTER_PADDING;

#if JVET_AC0147_CCCM_NO_SUBSAMPLING
#if JVET_AD0202_CCCM_MDF
  if (numBuffer == 0)
  {
    return PelBuf(m_cccmLumaBuf[cccmDownsamplesFilterIdx + 1] + refOrigin, refStride, areaWidth, areaHeight); // Points to the top-left corner of the reference area
}
  else if (numBuffer == 2)
  {
    *refLuma1 = PelBuf(m_cccmLumaBuf[2] + refOrigin, refStride, areaWidth, areaHeight);
    *refLuma3 = PelBuf(m_cccmLumaBuf[4] + refOrigin, refStride, areaWidth, areaHeight);
    return PelBuf(m_cccmLumaBuf[1] + refOrigin, refStride, areaWidth, areaHeight); // Points to the top-left corner of the reference area
  }
  else
  {
    *refLuma1 = PelBuf(m_cccmLumaBuf[2] + refOrigin, refStride, areaWidth, areaHeight);
    *refLuma2 = PelBuf(m_cccmLumaBuf[3] + refOrigin, refStride, areaWidth, areaHeight);
    *refLuma3 = PelBuf(m_cccmLumaBuf[4] + refOrigin, refStride, areaWidth, areaHeight);
    return PelBuf(m_cccmLumaBuf[1] + refOrigin, refStride, areaWidth, areaHeight); // Points to the top-left corner of the reference area
  }
#else
  return PelBuf( m_cccmLumaBuf[0] + refOrigin, refStride, areaWidth, areaHeight ); // Points to the top-left corner of the reference area
#endif
#else
  return PelBuf(m_cccmLumaBuf + refOrigin, refStride, areaWidth, areaHeight); // Points to the top-left corner of the reference area
#endif
}

// Return downsampled luma buffer for a PU
PelBuf IntraPrediction::xCccmGetLumaPuBuf(const PredictionUnit& pu
#if JVET_AD0202_CCCM_MDF
  , int cccmDownsamplesFilterIdx, int numBuffer, CPelBuf* refLuma1, CPelBuf* refLuma3, CPelBuf* refLuma2
#endif
) const
{
#if JVET_AC0147_CCCM_NO_SUBSAMPLING || JVET_AF0073_INTER_CCP_MERGE
  if( pu.cccmNoSubFlag )
  {
    const int chromaScaleX = getChannelTypeScaleX( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );
    const int chromaScaleY = getChannelTypeScaleY( CHANNEL_TYPE_CHROMA, pu.cu->slice->getSPS()->getChromaFormatIdc() );

    int refSizeX = ((m_cccmBlkArea.x - m_cccmRefArea.x) << chromaScaleX); // Reference lines available left and above
    int refSizeY = ((m_cccmBlkArea.y - m_cccmRefArea.y) << chromaScaleY);
    int tuWidth  = m_cccmBlkArea.width << chromaScaleX;
    int tuHeight = m_cccmBlkArea.height << chromaScaleY;

    int refStride = (m_cccmRefArea.width + 2 * CCCM_FILTER_PADDING) << chromaScaleX; // Including paddings required for the 2D filter
    int refOrigin = refStride * (refSizeY + (CCCM_FILTER_PADDING << chromaScaleY)) + refSizeX + (CCCM_FILTER_PADDING << chromaScaleX);
#if JVET_AD0202_CCCM_MDF
    return PelBuf(m_cccmLumaBuf[0] + refOrigin, refStride, tuWidth, tuHeight);  // Points to the top-left corner of the block
#else
    return PelBuf( m_cccmLumaBuf[1] + refOrigin, refStride, tuWidth, tuHeight );  // Points to the top-left corner of the block
#endif
  }
#endif

  int refSizeX  = m_cccmBlkArea.x - m_cccmRefArea.x; // Reference lines available left and above
  int refSizeY  = m_cccmBlkArea.y - m_cccmRefArea.y;
  int tuWidth   = m_cccmBlkArea.width;
  int tuHeight  = m_cccmBlkArea.height;
  int refStride = m_cccmRefArea.width + 2 * CCCM_FILTER_PADDING; // Including paddings required for the 2D filter
  int refOrigin = refStride * (refSizeY + CCCM_FILTER_PADDING) + refSizeX + CCCM_FILTER_PADDING;

#if JVET_AC0147_CCCM_NO_SUBSAMPLING
#if JVET_AD0202_CCCM_MDF
  if (numBuffer == 0)
  {
    return PelBuf(m_cccmLumaBuf[1] + refOrigin, refStride, tuWidth, tuHeight);  // Points to the top-left corner of the block
  }
  else if (numBuffer == 2)
  {
    *refLuma1 = PelBuf(m_cccmLumaBuf[2] + refOrigin, refStride, tuWidth, tuHeight);
    *refLuma3 = PelBuf(m_cccmLumaBuf[4] + refOrigin, refStride, tuWidth, tuHeight);
    return PelBuf(m_cccmLumaBuf[1] + refOrigin, refStride, tuWidth, tuHeight);  // Points to the top-left corner of the block
  }
  else
  {
    *refLuma1 = PelBuf(m_cccmLumaBuf[2] + refOrigin, refStride, tuWidth, tuHeight);
    *refLuma2 = PelBuf(m_cccmLumaBuf[3] + refOrigin, refStride, tuWidth, tuHeight);
    *refLuma3 = PelBuf(m_cccmLumaBuf[4] + refOrigin, refStride, tuWidth, tuHeight);
    return PelBuf(m_cccmLumaBuf[1] + refOrigin, refStride, tuWidth, tuHeight);  // Points to the top-left corner of the block
  }
#else
  return PelBuf( m_cccmLumaBuf[0] + refOrigin, refStride, tuWidth, tuHeight );  // Points to the top-left corner of the block
#endif
#else
  return PelBuf(m_cccmLumaBuf + refOrigin, refStride, tuWidth, tuHeight);  // Points to the top-left corner of the block
#endif
}

int IntraPrediction::xCccmCalcRefAver(const PredictionUnit& pu
#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
                                      ,int trainingRange
#endif
) const
{
  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  PelBuf refLuma = xCccmGetLumaRefBuf(pu, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY);
  
  int numSamples = 0;
  int sumSamples = 0;
  
#if JVET_AB0143_CCCM_TS && MMLM
#if JVET_AD0120_LBCCP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
  if (trainingRange != -1)
  {
    CPelBuf refLumaBlk = xCccmGetLumaPuBuf(pu);
    const auto divShift = floorLog2(refLumaBlk.height) + floorLog2(refLumaBlk.width);
    const auto offset   = 1 << (divShift - 1);
    for (int y = 0; y < refLumaBlk.height; y++)
    {
      for (int x = 0; x < refLumaBlk.width; x++)
      {
        sumSamples += refLumaBlk.at(x, y);
      }
    }
    return (sumSamples + offset) >> divShift;
  }
#endif
  if( pu.cccmFlag == 1 || pu.cccmFlag == 3 )
  {
    // above samples
    for( int y = 0; y < refSizeY; y++ )
    {
      for( int x = (pu.cccmFlag == 3 ? refSizeX : 0); x < areaWidth; x++ )
      {
        sumSamples += refLuma.at( x, y );
        numSamples++;
      }
    }
  }

  if( pu.cccmFlag == 1 || pu.cccmFlag == 2 )
  {
    // left samples
    for (int y = refSizeY; y < areaHeight; y++)
    {
      for (int x = 0; x < refSizeX; x++)
      {
        sumSamples += refLuma.at(x, y);
        numSamples++;
      }
    }
  }  
#else
  // Top samples
  for (int y = 0; y < refSizeY; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      sumSamples += refLuma.at(x, y);
      numSamples++;
    }
  }

  // Left samples
  for (int y = refSizeY; y < areaHeight; y++)
  {
    for (int x = 0; x < refSizeX; x++)
    {
      sumSamples += refLuma.at(x, y);
      numSamples++;
    }
  }
#endif

#if JVET_AB0174_CCCM_DIV_FREE
#if JVET_AJ0237_INTERNAL_12BIT
#if JVET_AJ0237_INTERNAL_12BIT
  const int bd = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  return numSamples == 0 ? (1 << (bd - 1)) : xCccmDivideLowPrec(sumSamples, numSamples, DECIM_BITS(bd));
#else
  return numSamples == 0 ? ((1 << pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA)) - 1) : xCccmDivideLowPrec(sumSamples, numSamples);
#endif
#else
  return numSamples == 0 ? 512 : xCccmDivideLowPrec(sumSamples, numSamples);
#endif
#else
  return numSamples == 0 ? 512 : ( sumSamples + numSamples/2) / numSamples;
#endif
}

void IntraPrediction::xCccmCreateLumaRef(const PredictionUnit& pu, CompArea chromaArea
#if JVET_AD0202_CCCM_MDF
  , int downsFilterIdx
#endif
#if JVET_AF0073_INTER_CCP_MERGE
    , bool isTemplate
#endif
)
{
  const CPelBuf recoLuma = pu.cs->picture->getRecoBuf(COMPONENT_Y);
  const int  maxPosPicX  = pu.cs->picture->chromaSize().width  - 1;
  const int  maxPosPicY  = pu.cs->picture->chromaSize().height - 1;

  xCccmCalcRefArea(pu, chromaArea); // Find the reference area
  
  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  PelBuf refLuma = xCccmGetLumaRefBuf(pu, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY
#if JVET_AD0202_CCCM_MDF
    , downsFilterIdx
#endif
  );
  
  int puBorderX = refSizeX + m_cccmBlkArea.width;
  int puBorderY = refSizeY + m_cccmBlkArea.height;
  
#if JVET_AB0174_CCCM_DIV_FREE
  xCccmSetLumaRefValue( pu );
#endif

#if JVET_AF0073_INTER_CCP_MERGE
  if (!isTemplate)
  {
#endif
  // Generate down-sampled luma for the area covering both the PU and the top/left reference areas (+ top and left paddings)
  for (int y = -CCCM_FILTER_PADDING; y < areaHeight; y++)
  {
    for (int x = -CCCM_FILTER_PADDING; x < areaWidth; x++)
    {
      if (( x >= puBorderX && y >= refSizeY ) ||
          ( y >= puBorderY && x >= refSizeX ))
      {
        continue;
      }

      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;
      
      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;
      
      refLuma.at( x, y ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
        , downsFilterIdx
#endif
      );
    }
  }

  CHECK( CCCM_FILTER_PADDING != 1, "Only padding with one sample implemented" );

  // Pad right of top reference area
  for (int y = -1; y < refSizeY; y++)
  {
    refLuma.at( areaWidth, y ) = refLuma.at( areaWidth - 1, y );
  }

  // Pad right of PU
  for (int y = refSizeY; y < puBorderY; y++)
  {
    refLuma.at( puBorderX, y ) = refLuma.at( puBorderX - 1, y );
  }

  // Pad right of left reference area
  for (int y = puBorderY; y < areaHeight; y++)
  {
    refLuma.at( refSizeX, y ) = refLuma.at( refSizeX - 1, y );
  }

  // Pad below left reference area
  for (int x = -1; x < refSizeX + 1; x++)
  {
    refLuma.at( x, areaHeight ) = refLuma.at( x, areaHeight - 1 );
  }

  // Pad below PU
  for (int x = refSizeX; x < puBorderX + 1; x++)
  {
    refLuma.at( x, puBorderY ) = refLuma.at( x, puBorderY - 1 );
  }

  // Pad below right reference area
  for (int x = puBorderX + 1; x < areaWidth + 1; x++)
  {
    refLuma.at( x, refSizeY ) = refLuma.at( x, refSizeY - 1 );
  }
  
  // In dualtree we can also use luma from the right and below (if not on CTU/picture boundary)
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  if( CS::isDualITree( *pu.cs ) && ( pu.cs->slice->isIntra() || !pu.cs->slice->getSeparateTreeEnabled() ) )
#else
  if ( CS::isDualITree( *pu.cs ) )
#endif
  {
    int ctuWidth  = pu.cs->sps->getMaxCUWidth()  >> getComponentScaleX(COMPONENT_Cb, pu.chromaFormat);
    int ctuHeight = pu.cs->sps->getMaxCUHeight() >> getComponentScaleY(COMPONENT_Cb, pu.chromaFormat);

    // Samples right of top reference area
    int padPosPicX = refPosPicX + areaWidth;

    if ( padPosPicX <= maxPosPicX && (padPosPicX % ctuWidth) )
    {
      for (int y = -1; y < refSizeY; y++)
      {
        int chromaPosPicY = refPosPicY + y;
        chromaPosPicY     = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        refLuma.at( areaWidth, y ) = xCccmGetLumaVal(pu, recoLuma, padPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
#endif
        );
      }
    }

    // Samples right of PU
    padPosPicX = refPosPicX + puBorderX;

    if ( padPosPicX <= maxPosPicX && (padPosPicX % ctuWidth) )
    {
      for (int y = refSizeY; y < puBorderY; y++)
      {
        int chromaPosPicY = refPosPicY + y;
        chromaPosPicY     = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        refLuma.at( puBorderX, y ) = xCccmGetLumaVal(pu, recoLuma, padPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
#endif
        );
      }
    }

    // Samples right of left reference area
    padPosPicX = refPosPicX + refSizeX;

    if ( padPosPicX <= maxPosPicX )
    {
      for (int y = puBorderY; y < areaHeight; y++)
      {
        int chromaPosPicY = refPosPicY + y;
        chromaPosPicY     = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        refLuma.at( refSizeX, y ) = xCccmGetLumaVal(pu, recoLuma, padPosPicX, chromaPosPicY
#if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
#endif
        );
      }
    }
    
    // Samples below left reference area
    int padPosPicY = refPosPicY + areaHeight;
    
    if ( padPosPicY <= maxPosPicY && (padPosPicY % ctuHeight) )
    {
      for (int x = -1; x < refSizeX + 1; x++)
      {
        int chromaPosPicX = refPosPicX + x;
        chromaPosPicX     = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        
        refLuma.at( x, areaHeight ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, padPosPicY
#if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
#endif
        );
      }
    }
    
    // Samples below PU
    padPosPicY = refPosPicY + puBorderY;
    
    if ( padPosPicY <= maxPosPicY && (padPosPicY % ctuHeight) )
    {
      for (int x = refSizeX; x < puBorderX; x++) // Just go to PU border as the next sample may be out of CTU (and not needed anyways)
      {
        int chromaPosPicX = refPosPicX + x;
        chromaPosPicX     = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        
        refLuma.at( x, puBorderY ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, padPosPicY
#if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
#endif
        );
      }
    }

    // Samples below right reference area
    padPosPicY = refPosPicY + refSizeY;
    
    if ( padPosPicY <= maxPosPicY )
    {
      // Avoid going outside of right CTU border where these samples are not yet available
      int puPosPicX        = m_cccmBlkArea.x;
      int ctuRightEdgeDist = ctuWidth - (puPosPicX % ctuWidth) + refSizeX;
      int lastPosX         = ctuRightEdgeDist < areaWidth ? ctuRightEdgeDist : areaWidth;

      for (int x = puBorderX + 1; x < lastPosX; x++) // Just go to ref area border as the next sample may be out of CTU (and not needed anyways)
      {
        int chromaPosPicX = refPosPicX + x;
        chromaPosPicX     = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        
        refLuma.at( x, refSizeY ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, padPosPicY
#if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
#endif
        );
      }
    }
  }
#if JVET_AF0073_INTER_CCP_MERGE
  }
  else
  {
    // Generate down-sampled luma for area needed to compute template cost
    int startY = refSizeY > 0 ? refSizeY - 1 - CCCM_FILTER_PADDING : -CCCM_FILTER_PADDING;
    int startX = refSizeX > 0 ? refSizeX - 1 - CCCM_FILTER_PADDING : -CCCM_FILTER_PADDING;
    for (int y = startY; y < areaHeight; y++)
    {
      for (int x = startX; x < areaWidth; x++)
      {
        if ( x > refSizeX && y > refSizeY )
        {
          continue;
        }

        int chromaPosPicX = refPosPicX + x;
        int chromaPosPicY = refPosPicY + y;
        
        chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;
        
        refLuma.at( x, y ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY
  #if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
  #endif
        );
      }
    }

    CHECK( CCCM_FILTER_PADDING != 1, "Only padding with one sample implemented" );

    // Pad right of top reference area
    for (int y = startY; y < refSizeY; y++)
    {
      refLuma.at( areaWidth, y ) = refLuma.at( areaWidth - 1, y );
    }

    // Pad right of PU
    refLuma.at( puBorderX, refSizeY ) = refLuma.at( puBorderX - 1, refSizeY );

    // Pad below left reference area
    for (int x = startX; x < refSizeX + 1; x++)
    {
      refLuma.at( x, areaHeight ) = refLuma.at( x, areaHeight - 1 );
    }

    // Pad below PU
    refLuma.at( refSizeX, puBorderY ) = refLuma.at( refSizeX, puBorderY - 1 );
  
    // In dualtree we can also use luma from the right and below (if not on CTU/picture boundary)
    if ( CS::isDualITree( *pu.cs ) )
    {
      int ctuWidth  = pu.cs->sps->getMaxCUWidth()  >> getComponentScaleX(COMPONENT_Cb, pu.chromaFormat);
      int ctuHeight = pu.cs->sps->getMaxCUHeight() >> getComponentScaleY(COMPONENT_Cb, pu.chromaFormat);

      // Samples right of top reference area
      int padPosPicX = refPosPicX + areaWidth;

      if ( padPosPicX <= maxPosPicX && (padPosPicX % ctuWidth) )
      {
        for (int y = startY; y < refSizeY; y++)
        {
          int chromaPosPicY = refPosPicY + y;
          chromaPosPicY     = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

          refLuma.at( areaWidth, y ) = xCccmGetLumaVal(pu, recoLuma, padPosPicX, chromaPosPicY
  #if JVET_AD0202_CCCM_MDF
            , downsFilterIdx
  #endif
          );
        }
      }

      // Samples right of PU
      padPosPicX = refPosPicX + puBorderX;

      if ( padPosPicX <= maxPosPicX && (padPosPicX % ctuWidth) )
      {
        int y = refSizeY;
        int chromaPosPicY = refPosPicY + y;
        chromaPosPicY     = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        refLuma.at( puBorderX, y ) = xCccmGetLumaVal(pu, recoLuma, padPosPicX, chromaPosPicY
  #if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
  #endif
        );
      }
      
      // Samples below left reference area
      int padPosPicY = refPosPicY + areaHeight;
      
      if ( padPosPicY <= maxPosPicY && (padPosPicY % ctuHeight) )
      {
        for (int x = startX; x < refSizeX + 1; x++)
        {
          int chromaPosPicX = refPosPicX + x;
          chromaPosPicX     = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
          
          refLuma.at( x, areaHeight ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, padPosPicY
  #if JVET_AD0202_CCCM_MDF
            , downsFilterIdx
  #endif
          );
        }
      }
      
      // Samples below PU
      padPosPicY = refPosPicY + puBorderY;
      
      if ( padPosPicY <= maxPosPicY && (padPosPicY % ctuHeight) )
      {
        int x = refSizeX;
        int chromaPosPicX = refPosPicX + x;
        chromaPosPicX     = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        
        refLuma.at( x, puBorderY ) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, padPosPicY
  #if JVET_AD0202_CCCM_MDF
          , downsFilterIdx
  #endif
        );
      }
    }
  }
#endif
}
#endif

#if JVET_AC0119_LM_CHROMA_FUSION
void IntraPrediction::xCflmCalcRefArea(const PredictionUnit& pu, const CompArea& chromaArea)
{
  const ChannelType     chType = CHANNEL_TYPE_CHROMA;
  const CodingUnit& cu = *pu.cu;
  const CodingStructure& cs = *cu.cs;
  const SPS& sps = *cs.sps;
  const PreCalcValues& pcv = *cs.pcv;

  const int tuWidth = chromaArea.width;
  const int tuHeight = chromaArea.height;

  const bool noShift = pcv.noChroma2x2 && chromaArea.width == 4;   // don't shift on the lowest level (chroma not-split)
  const int  compScaleX = getComponentScaleX(chromaArea.compID, sps.getChromaFormatIdc());
  const int  compScaleY = getComponentScaleY(chromaArea.compID, sps.getChromaFormatIdc());
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : compScaleX);
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : compScaleY);

  const int  totalAboveUnits = (2 * tuWidth + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (2 * tuHeight + (unitHeight - 1)) / unitHeight;
  const int  numAboveUnits = std::max<int>(tuWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(tuHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  static bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1] = { false }; // Just a dummy array here, content not used

  int avaiAboveRightUnits = isAboveRightAvailable(cu, chType, chromaArea.topRight(), numAboveRightUnits, unitWidth, (neighborFlags + totalLeftUnits + 1 + numAboveUnits));
  int avaiLeftBelowUnits = isBelowLeftAvailable(cu, chType, chromaArea.bottomLeft(), numLeftBelowUnits, unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits));

  int refSizeX, refSizeY;

  PU::getCccmRefLineNum(pu, chromaArea, refSizeX, refSizeY); // Reference lines available left and above

  int refWidth = chromaArea.width + refSizeX;              // Reference buffer size excluding paddings
  int refHeight = chromaArea.height + refSizeY;

  int extWidth = avaiAboveRightUnits * unitWidth;
  int extHeight = avaiLeftBelowUnits * unitHeight;

  refWidth += refSizeY ? extWidth : 0; // Add above right if above is available
  refHeight += refSizeX ? extHeight : 0; // Add below left if left is available

  m_cccmBlkArea = chromaArea;
  m_cflmRefArea = Area(chromaArea.x - refSizeX, chromaArea.y - refSizeY, refWidth, refHeight); // Position with respect to the PU
}

PelBuf IntraPrediction::xCflmGetRefBuf(const PredictionUnit& pu, const ComponentID compId, const CompArea& chromaArea, int& areaWidth, int& areaHeight, int& refSizeX, int& refSizeY, int& refPosPicX, int& refPosPicY) const
{
  refSizeX = std::min(chromaArea.x - m_cflmRefArea.x, 2);  // Reference lines available left and above
  refSizeY = std::min(chromaArea.y - m_cflmRefArea.y, 2);
  areaWidth = chromaArea.width + refSizeX;
  areaHeight = chromaArea.height + refSizeY;
  refPosPicX = chromaArea.x - refSizeX; // Position of the reference area in picture coordinates
  refPosPicY = chromaArea.y - refSizeY;

  return PelBuf(m_cflmBuf[compId], areaWidth, areaWidth, areaHeight); // Points to the top-left corner of the reference area
}

PelBuf IntraPrediction::xCflmGetPuBuf(const PredictionUnit& pu, const ComponentID compId, const CompArea& chromaArea) const
{
  int refSizeX = std::min(chromaArea.x - m_cflmRefArea.x, 2);  // Reference lines available left and above
  int refSizeY = std::min(chromaArea.y - m_cflmRefArea.y, 2);
  int tuWidth = chromaArea.width;
  int tuHeight = chromaArea.height;
  int refStride = chromaArea.width + refSizeX;
  int refOrigin = refStride * refSizeY + refSizeX;

  return PelBuf(m_cflmBuf[compId] + refOrigin, refStride, tuWidth, tuHeight);  // Points to the top-left corner of the block
}

void IntraPrediction::xCflmCreateLumaRef(const PredictionUnit& pu, const CompArea& chromaArea)
{
  const CPelBuf recoLuma = pu.cs->picture->getRecoBuf(COMPONENT_Y);
  const int  maxPosPicX = pu.cs->picture->chromaSize().width - 1;
  const int  maxPosPicY = pu.cs->picture->chromaSize().height - 1;

  xCflmCalcRefArea(pu, chromaArea); // Find the reference area

  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  PelBuf refLuma = xCflmGetRefBuf(pu, COMPONENT_Y, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY);

#if JVET_AB0174_CCCM_DIV_FREE
  xCccmSetLumaRefValue(pu);
#endif

  // Generate down-sampled luma for the area covering both the PU and the top/left reference areas
  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      if (x >= 0 && x < refSizeX && y >= 0 && y < refSizeY)
      {
        continue;
      }

      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;

      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

      refLuma.at(x, y) = xCccmGetLumaVal(pu, recoLuma, chromaPosPicX, chromaPosPicY);
    }
  }
}

bool IntraPrediction::xCflmCreateChromaPred(const PredictionUnit& pu, const ComponentID compId, PelBuf& piPred
#if JVET_AH0136_CHROMA_REORDERING
  , InterPrediction *pcInterPred
#endif
)
{
  uint32_t iMode = PU::getFinalIntraMode(pu, CHANNEL_TYPE_CHROMA);

  const CompArea& area = pu.blocks[compId];
  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  PelBuf refChroma = xCflmGetRefBuf(pu, compId, area, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY);

  // top/left reference areas
  TemplateType eTplType = (TemplateType)((refSizeX > 0 ? LEFT_NEIGHBOR : 0) + (refSizeY > 0 ? ABOVE_NEIGHBOR : 0));
  if (eTplType == NO_NEIGHBOR)
  {
    return false;
  }

#if JVET_AH0136_CHROMA_REORDERING
  Pel* piRefPred = refChroma.bufAt(0, 0);
#endif

#if JVET_AH0136_CHROMA_REORDERING && JVET_AC0071_DBV
  if (PU::isDbvMode(iMode))
  {
    Mv mv = refineChromaBv(compId, pu, pcInterPred);

    int tmpSize = 2;
    const CodingStructure &cs = *pu.cs;
    Position posRT = pu.blocks[compId].topRight();
    const PredictionUnit *puAbove = cs.getPURestricted(posRT.offset(0, -2), pu, pu.chType);
    bool topCanUse = puAbove && pu.cu != puAbove->cu;
    Position posLB = pu.blocks[compId].bottomLeft();
    const PredictionUnit *puLeft = cs.getPURestricted(posLB.offset(-2, 0), pu, pu.chType);
    bool leftCanUse = puLeft && pu.cu != puLeft->cu;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
    const int bvShiftHor = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleX(compId, pu.chromaFormat);
    const int bvShiftVer = MV_FRACTIONAL_BITS_INTERNAL + ::getComponentScaleY(compId, pu.chromaFormat);
#else
    const int shiftSampleHor = ::getComponentScaleX(compId, pu.chromaFormat);
    const int shiftSampleVer = ::getComponentScaleY(compId, pu.chromaFormat);
#endif
    CHECK(topCanUse == false && leftCanUse == false, "wrong type");

    int filterIdx = 0;
    CompArea area = pu.blocks[compId];
    int uiHeight = area.height;
    int uiWidth = area.width;

    Pel temp[MAX_CU_SIZE * 4];
    memset(temp, 0, MAX_CU_SIZE * 4 * sizeof(Pel));
    int stride = MAX_CU_SIZE;
    Pel *refPix = temp;
    Pel *refPixTemp;
    const CPelBuf recBuf = pu.cs->picture->getRecoBuf(pu.cs->picture->blocks[compId]);

    Mv mvCurr = mv;
    if (topCanUse)
    {
      Mv mvTop(0, -tmpSize);
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 2)
      {
        mvTop.setVer(uiHeight);
      }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      mvTop <<= bvShiftVer;
#endif
      mvTop += mvCurr;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      if (!PU::checkIsChromaBvCandidateValidChromaTm(pu, mvTop, tmpSize, filterIdx, true, true))
      {
#if JVET_AA0070_RRIBC
        if (pu.cu->rribcFlipType == 2)
        {
          mvTop.setVer(mvCurr.getVer() + ((uiHeight - tmpSize) << bvShiftVer));
        }
        else
#endif
        {
          mvTop = mvCurr;
        }
      }
#else
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 2)
      {
        if (!PU::checkIsChromaBvCandidateValid(pu, mvTop, true, true))
        {
          mvTop.setVer(mvCurr.getVer() + uiHeight - tmpSize);
        }
      }
      else
#endif
        if (!PU::checkIsChromaBvCandidateValid(pu, mvTop, true, true))
        {
          mvTop = mvCurr;
        }
#endif

#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      bool isFracMv = pu.cs->sps->getIBCFracFlag() && mvTop.isFracMv<false>(pu.chromaFormat);
      if (isFracMv)
      {
        PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), PelBuf(refPix, uiWidth, tmpSize), PelBuf(refPix, uiWidth, tmpSize));
        pcInterPred->getPredIBCBlk(pu, compId, pu.cs->picture, mvTop, pcBuf, filterIdx == 1);
#if JVET_AA0070_RRIBC
        pcBuf.bufs[compId].flip(pu.cu->rribcFlipType);
#endif
      }
      else
      {
#endif
        refPixTemp = refPix;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
        const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvTop.hor >> bvShiftHor, mvTop.ver >> bvShiftVer));
#else
        const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvTop.hor, mvTop.ver));
#endif
        for (int k = 0; k < uiWidth; k++)
        {
          for (int l = 0; l < tmpSize; l++)
          {
#if JVET_AA0070_RRIBC
            int recVal;
            if (pu.cu->rribcFlipType == 0)
            {
              recVal = rec[k + l * recBuf.stride];
            }
            else if (pu.cu->rribcFlipType == 1)
            {
              recVal = rec[uiWidth - 1 - k + l * recBuf.stride];
            }
            else
            {
              recVal = rec[k + (tmpSize - 1 - l) * recBuf.stride];
            }
#else
            int recVal = rec[k + l * recBuf.stride];
#endif
            refPixTemp[k + l * uiWidth] = recVal;
          }
        }
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      }
#endif
    }

    if (leftCanUse)
    {
      Mv mvLeft(-tmpSize, 0);
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 1)
      {
        mvLeft.setHor(uiWidth);
      }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      mvLeft <<= bvShiftHor;
#endif
      mvLeft += mvCurr;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      if (!PU::checkIsChromaBvCandidateValidChromaTm(pu, mvLeft, tmpSize, filterIdx, true, false))
      {
#if JVET_AA0070_RRIBC
        if (pu.cu->rribcFlipType == 1)
        {
          mvLeft.setHor(mvCurr.getHor() + ((uiWidth - tmpSize) << bvShiftHor));
        }
        else
#endif
        {
          mvLeft = mvCurr;
        }
      }
#else
#if JVET_AA0070_RRIBC
      if (pu.cu->rribcFlipType == 1)
      {
        if (!PU::checkIsChromaBvCandidateValid(pu, mvLeft, true, false))
        {
          mvLeft.setHor(mvCurr.getHor() + uiWidth - DBV_TEMPLATE_SIZE);
        }
      }
      else
#endif
        if (!PU::checkIsChromaBvCandidateValid(pu, mvLeft, true, false))
        {
          mvLeft = mvCurr;
        }
#endif
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      bool isFracMv = pu.cs->sps->getIBCFracFlag() && mvLeft.isFracMv<false>(pu.chromaFormat);
      if (isFracMv)
      {
        PelUnitBuf pcBuf(pu.chromaFormat, PelBuf(), PelBuf(refPix + 2 * stride, tmpSize, uiHeight), PelBuf(refPix + 2 * stride, tmpSize, uiHeight));
        pcInterPred->getPredIBCBlk(pu, compId, pu.cs->picture, mvLeft, pcBuf, filterIdx == 1);
#if JVET_AA0070_RRIBC
        pcBuf.bufs[compId].flip(pu.cu->rribcFlipType);
#endif
      }
      else
      {
#endif
        refPixTemp = refPix + 2 * stride;
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
        const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvLeft.hor >> bvShiftHor, mvLeft.ver >> bvShiftVer));
#else
        const Pel *rec = recBuf.bufAt(pu.blocks[compId].pos().offset(mvLeft.hor, mvLeft.ver));
#endif
        for (int k = 0; k < uiHeight; k++)
        {
          for (int l = 0; l < tmpSize; l++)
          {
#if JVET_AA0070_RRIBC
            int recVal;
            if (pu.cu->rribcFlipType == 0)
            {
              recVal = rec[recBuf.stride * k + l];
            }
            else if (pu.cu->rribcFlipType == 1)
            {
              recVal = rec[recBuf.stride * k + tmpSize - 1 - l];
            }
            else
            {
              recVal = rec[recBuf.stride * (uiHeight - 1 - k) + l];
            }
#else
            int recVal = rec[recBuf.stride * k + l];
#endif
            refPixTemp[l + k * tmpSize] = recVal;
          }
        }
#if JVET_AD0208_IBC_ADAPT_FOR_CAM_CAPTURED_CONTENTS
      }
#endif
    }

    if (topCanUse)
    {
      //top
      for (int i = 0; i < uiWidth; i++)
      {
        refChroma.at(refSizeX + i, 0) = temp[i];
        refChroma.at(refSizeX + i, 1) = temp[uiWidth + i];
      }
    }
    if (leftCanUse)
    {
      //left
      for (int j = 0; j < uiHeight; j++)
      {
        refChroma.at(0, refSizeY + j) = temp[2 * stride + j * 2];
        refChroma.at(1, refSizeY + j) = temp[2 * stride + j * 2 + 1];
      }
    }
  }
  else
  {
#endif
  m_topRefLength = areaWidth << 1;
  m_leftRefLength = areaHeight << 1;
  xFillTimdReferenceSamples(pu.cs->picture->getRecoBuf(area), m_refBuffer[compId][PRED_BUF_UNFILTERED], area, *pu.cu, refSizeX, refSizeY);
#if !JVET_AH0136_CHROMA_REORDERING
  Pel* piRefPred = refChroma.bufAt(0, 0);
#endif
  initPredIntraParams(pu, area, *(pu.cs->sps));
  predTimdIntraAng(compId, pu, iMode, piRefPred, refChroma.stride, areaWidth, areaHeight, eTplType, refSizeX, refSizeY);
#if JVET_AH0136_CHROMA_REORDERING
  }
#endif

  // the PU reference areas
  PelBuf predChroma = xCflmGetPuBuf(pu, compId, area);
  Pel* piPredBuf = piPred.buf;
  for (int y = 0; y < piPred.height; y++)
  {
    for (int x = 0; x < piPred.width; x++)
    {
      predChroma.at(x, y) = piPredBuf[x];
    }

    piPredBuf += piPred.stride;
  }
#if JVET_AH0136_CHROMA_REORDERING && JVET_AC0071_DBV
  if (pu.cu->rribcFlipType != 0 && PU::isDbvMode(iMode))
  {
    predChroma.flipSignal(pu.cu->rribcFlipType == 1);
  }
#endif

#if JVET_AB0174_CCCM_DIV_FREE
  int chromaOffset = 1 << (pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_CHROMA) - 1);
  const CPelBuf reco = pu.cs->picture->getRecoBuf(compId);

  if (refSizeX || refSizeY)
  {
    int refPosX = refSizeX > 0 ? refSizeX - 1 : 0;
    int refPosY = refSizeY > 0 ? refSizeY - 1 : 0;

    chromaOffset = reco.at(refPosPicX + refPosX, refPosPicY + refPosY);
  }

  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      piRefPred[x] -= chromaOffset;
    }

    piRefPred += refChroma.stride;
  }
#endif

  return true;
}

void IntraPrediction::xCflmCalcModels(const PredictionUnit& pu, const ComponentID compId, const CompArea& chromaArea, CccmModel& cflmModel, int modelId, int modelThr)
{
  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  const CPelBuf reco = pu.cs->picture->getRecoBuf(compId);
  PelBuf        refLuma = xCflmGetRefBuf(pu, COMPONENT_Y, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY);
  PelBuf        refChroma = xCflmGetRefBuf(pu, compId, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY);

  int sampleNum = 0;

#if JVET_AB0174_CCCM_DIV_FREE
  int chromaOffset = 1 << (pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_CHROMA) - 1);

  if (refSizeX || refSizeY)
  {
    int refPosX = refSizeX > 0 ? refSizeX - 1 : 0;
    int refPosY = refSizeY > 0 ? refSizeY - 1 : 0;

    chromaOffset = reco.at(refPosPicX + refPosX, refPosPicY + refPosY);
  }
#endif

  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      if ((x >= refSizeX && y >= refSizeY)
        || (x >= 0 && x < refSizeX && y >= 0 && y < refSizeY))
      {
        continue;
      }

      if (modelId == 1 && refLuma.at(x, y) > modelThr) // Model 1: Include only samples below or equal to the threshold
      {
        continue;
      }
      if (modelId == 2 && refLuma.at(x, y) <= modelThr) // Model 2: Include only samples above the threshold
      {
        continue;
      }

      if (pu.intraDir[1] == MDLM_L_IDX || pu.intraDir[1] == MMLM_L_IDX)
      {
        if (y < refSizeY)
        {
          continue;
        }
      }

      if (pu.intraDir[1] == MDLM_T_IDX || pu.intraDir[1] == MMLM_T_IDX)
      {
        if (x < refSizeX)
        {
          continue;
        }
      }

      m_a[0][sampleNum] = refLuma.at(x, y); // Luma
      m_a[1][sampleNum] = refChroma.at(x, y); // Chroma
      m_a[2][sampleNum] = cflmModel.bias();

      m_cb[sampleNum] = reco.at(refPosPicX + x, refPosPicY + y);
      sampleNum++;
    }
  }

  if (!sampleNum) // Number of samples can go to zero in the multimode case
  {
    cflmModel.clearModel();
    return;
  }
  else
  {
#if JVET_AB0174_CCCM_DIV_FREE
    m_cccmSolver.solve1(m_a, m_cb, sampleNum, chromaOffset, cflmModel);
#else
    m_cccmSolver.solve1(m_a, m_cb, sampleNum, cflmModel);
#endif
  }
}

void IntraPrediction::xCflmApplyModel(const PredictionUnit& pu, const ComponentID compId, const CompArea& chromaArea, CccmModel& cflmModel, int modelId, int modelThr, PelBuf& piPred)
{
  const  ClpRng& clpRng(pu.cu->cs->slice->clpRng(compId));
  Pel* samples = m_samples;

  CPelBuf refLumaBlk = xCflmGetPuBuf(pu, COMPONENT_Y, chromaArea);
  CPelBuf refChromaBlk = xCflmGetPuBuf(pu, compId, chromaArea);

  for (int y = 0; y < refLumaBlk.height; y++)
  {
    for (int x = 0; x < refLumaBlk.width; x++)
    {
      if (modelId == 1 && refLumaBlk.at(x, y) > modelThr) // Model 1: Include only samples below or equal to the threshold
      {
        continue;
      }
      if (modelId == 2 && refLumaBlk.at(x, y) <= modelThr) // Model 2: Include only samples above the threshold
      {
        continue;
      }

      samples[0] = refLumaBlk.at(x, y); // Luma
      samples[1] = refChromaBlk.at(x, y); // Chroma
      samples[2] = cflmModel.bias();

      piPred.at(x, y) = ClipPel<Pel>(cflmModel.convolve(samples), clpRng);
    }
  }
}

int IntraPrediction::xCflmCalcRefAver(const PredictionUnit& pu, const CompArea& chromaArea)
{
  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  PelBuf refLuma = xCflmGetRefBuf(pu, COMPONENT_Y, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY);

  int numSamples = 0;
  int sumSamples = 0;

  // Top samples
  if (pu.intraDir[1] != MDLM_L_IDX && pu.intraDir[1] != MMLM_L_IDX)
  {
    for (int y = 0; y < refSizeY; y++)
    {
      for (int x = refSizeX; x < areaWidth; x++)
      {
        sumSamples += refLuma.at(x, y);
        numSamples++;
      }
    }
  }

  // Left samples
  if (pu.intraDir[1] != MDLM_T_IDX && pu.intraDir[1] != MMLM_T_IDX)
  {
    for (int y = refSizeY; y < areaHeight; y++)
    {
      for (int x = 0; x < refSizeX; x++)
      {
        sumSamples += refLuma.at(x, y);
        numSamples++;
      }
    }
  }

#if JVET_AD0184_REMOVAL_OF_DIVISION_OPERATIONS
#if JVET_AJ0237_INTERNAL_12BIT
  return numSamples == 0 ? (1 << (pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) - 1)) : PU::getMeanValue(sumSamples + (numSamples >> 1), numSamples);
#else
  return numSamples == 0 ? 512 : PU::getMeanValue( sumSamples + (numSamples >> 1), numSamples);
#endif
#else
  return numSamples == 0 ? 512 : (sumSamples + numSamples / 2) / numSamples;
#endif
}
#endif

#if JVET_AA0057_CCCM || JVET_AB0092_GLM_WITH_LUMA || JVET_AC0119_LM_CHROMA_FUSION || JVET_AG0058_EIP || JVET_AG0154_DECODER_DERIVED_CCP_FUSION
    
#if JVET_AC0053_GAUSSIAN_SOLVER
#if JVET_AJ0237_INTERNAL_12BIT
void CccmCovariance::gaussBacksubstitution( TCccmCoeff* x, int numEq, int col, int round, int bits)
#else
void CccmCovariance::gaussBacksubstitution( TCccmCoeff* x, int numEq, int col )
#endif
{
  x[numEq-1] = C[numEq-1][col];

  for( int i = numEq-2; i >= 0; i-- )
  {
    x[i] = C[i][col];

    for( int j = i+1; j < numEq; j++ )
    {
#if JVET_AJ0237_INTERNAL_12BIT
      x[i] -= FIXED_MULT(C[i][j], x[j], round, bits);
#else
      x[i] -= FIXED_MULT(C[i][j], x[j]);
#endif
    }
  }
}

void CccmCovariance::gaussElimination( TCccmCoeff A[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff* y0, TCccmCoeff* x0, TCccmCoeff* y1, TCccmCoeff* x1, int numEq, int numFilters, int bd
#if JVET_AE0059_INTER_CCCM
  ,const bool interCccmMode
#endif
)
{ 
  int colChr0 = numEq;
  int colChr1 = numEq + 1;
#if JVET_AE0059_INTER_CCCM
  int reg = interCccmMode ? 1 : 2 << (bd - 8);
#else
  int reg = 2 << (bd - 8);
#endif

#if JVET_AJ0237_INTERNAL_12BIT
  const int decimBits = DECIM_BITS(bd);
  const int decimRound = (1 << (decimBits - 1));
#endif
  
  // Create an [M][M+2] matrix system (could have been done already when calculating auto/cross-correlations)
  for( int i = 0; i < numEq; i++ )
  {
    for( int j = 0; j < numEq; j++ )
    {
      C[i][j] = j >= i ? A[i][j] : A[j][i];
    }
    
    C[i][i]      += reg; // Regularization
    C[i][colChr0] = y0[i];
    C[i][colChr1] = numFilters == 2 ? y1[i] : 0; // Only applicable if solving for 2 filters at the same time
  }

  for( int i = 0; i < numEq; i++ )
  {
    TCccmCoeff *src = C[i];
    TCccmCoeff diag = src[i] < 1 ? 1 : src[i];

#if JVET_AB0174_CCCM_DIV_FREE
    int scale, round, shift;
    
#if JVET_AJ0237_INTERNAL_12BIT
    xGetDivScaleRoundShift(diag, decimBits, scale, round, shift);
#else
    xGetDivScaleRoundShift(diag, scale, round, shift);
#endif
#endif

    for( int j = i+1; j < numEq+numFilters; j++ )
    {
#if JVET_AB0174_CCCM_DIV_FREE
      src[j] = ( int64_t(src[j]) * scale + round ) >> shift;
#else
      src[j] = FIXED_DIV(src[j], diag);
#endif
    }
    
    for( int j = i + 1; j < numEq; j++ )
    {
      TCccmCoeff *dst  = C[j];
      TCccmCoeff scale = dst[i];

      // On row j all elements with k < i+1 are now zero (not zeroing those here as backsubstitution does not need them)
      for( int k = i + 1; k < numEq+numFilters; k++ )
      {
#if JVET_AJ0237_INTERNAL_12BIT
        dst[k] -= FIXED_MULT(scale, src[k], decimRound, decimBits);
#else
         dst[k] -= FIXED_MULT(scale, src[k]);
#endif
      }
    }
  }

  // Solve with backsubstitution
  if ( numFilters == 2 )
  {
#if JVET_AJ0237_INTERNAL_12BIT
    gaussBacksubstitution(x0, numEq, colChr0, decimRound, decimBits);
    gaussBacksubstitution(x1, numEq, colChr1, decimRound, decimBits);
#else
    gaussBacksubstitution(x0, numEq, colChr0);
    gaussBacksubstitution(x1, numEq, colChr1);
#endif
  }
  else
  {
#if JVET_AJ0237_INTERNAL_12BIT
    gaussBacksubstitution(x0, numEq, colChr0, decimRound, decimBits);
#else
    gaussBacksubstitution(x0, numEq, colChr0);
#endif
  }
}

#else

// LDL decomposing A to U'*diag*U
bool CccmCovariance::ldlDecomp( TCccmCoeff A[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff U[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff* diag, int numEq) const
{
  for (int i = 0; i < numEq; i++)
  {
    diag[i] = A[i][i];
    
    for (int k = i - 1; k >= 0; k--)
    {
      TCccmCoeff tmp = FIXED_MULT(U[k][i], U[k][i]);
      diag[i]       -= FIXED_MULT(tmp, diag[k]);
    }

    if ( diag[i] <= 0) // A is singular
    {
      return false;
    }

    for (int j = i + 1; j < numEq; j++)
    {
      TCccmCoeff scale = A[i][j];
      
      for (int k = i - 1; k >= 0; k--)
      {
        TCccmCoeff tmp = FIXED_MULT(U[k][j], U[k][i]);
        scale         -= FIXED_MULT(tmp, diag[k]);
      }

#if JVET_AB0174_CCCM_DIV_FREE
      U[i][j] = xCccmDivide(scale, diag[i]);
#else
      U[i][j] = FIXED_DIV(scale, diag[i]);
#endif
    }
  }

  return true;
}

// Solve U'z = y for z
void CccmCovariance::ldlTransposeBacksubstitution( TCccmCoeff U[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff* y, TCccmCoeff* z, int numEq) const
{
  z[0] = y[0];
  
  for (int i = 1; i < numEq; i++)
  {
    TCccmCoeff sum = 0;

    for (int j = 0; j < i; j++)
    {
      sum += FIXED_MULT(z[j], U[j][i]);
    }

    z[i] = y[i] - sum;
  }
}

// Solve Ux = z for x
void CccmCovariance::ldlBacksubstitution( TCccmCoeff U[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff* z, TCccmCoeff* x, int numEq) const
{
  x[numEq - 1] = z[numEq - 1];

  for (int i = numEq - 2; i >= 0; i--)
  {
    TCccmCoeff sum = 0;

    for (int j = i + 1; j < numEq; j++)
    {
      sum += FIXED_MULT(U[i][j], x[j]);
    }

    x[i] = z[i] - sum;
  }
}

bool CccmCovariance::ldlDecompose( TCccmCoeff A[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff U[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff* diag, int numEq) const
{
  // Compute upper triangular U and diagonal D such that U'*D*U = A
  // (U being the tranpose of L in LDL decomposition: L*D*L' = A)

  // Regularize A to reduce singularities
  for (int i = 0; i < numEq; i++)
  {
    A[i][i] += 1;
  }
  
  return ldlDecomp(A, U, diag, numEq);
}

void CccmCovariance::ldlSolve( TCccmCoeff U[CCCM_NUM_PARAMS_MAX][CCCM_NUM_PARAMS_MAX], TCccmCoeff* diag, TCccmCoeff* y, TCccmCoeff* x, int numEq, bool decompOk) const
{
  if ( decompOk )
  {
    // Now, the equation is  U'*D*U*x = y, where U is upper triangular
    // Solve U'*aux = y for aux
    Ty aux;
    
    ldlTransposeBacksubstitution(U, y, aux, numEq);

    // The equation is now D*U*x = aux, remove diagonal by scaling
    for (int i = 0; i < numEq; i++)
    {
#if JVET_AB0174_CCCM_DIV_FREE
      aux[i] = xCccmDivide(aux[i], diag[i]);
#else
      aux[i] = FIXED_DIV(aux[i], diag[i]);
#endif
    }
    
    // The equation is now U*x = aux, solve it for x (filter coefficients)
    ldlBacksubstitution(U, aux, x, numEq);
  }
  else // A was singular
  {
    std::memset(x, 0, sizeof(TCccmCoeff) * numEq);
  }
}
#endif

#if JVET_AB0174_CCCM_DIV_FREE
void CccmCovariance::solve1( const Pel A[CCCM_NUM_PARAMS_MAX][CCCM_REF_SAMPLES_MAX], const Pel* C, const int sampleNum, const int chromaOffset, CccmModel& model )
#else
void CccmCovariance::solve1( const Pel A[CCCM_NUM_PARAMS_MAX][CCCM_REF_SAMPLES_MAX], const Pel* C, const int sampleNum, CccmModel& model )
#endif
{
  const int numParams = model.getNumParams();

  CHECK( CCCM_REF_SAMPLES_MAX < sampleNum, "Insufficient buffer size" );
  CHECK( CCCM_NUM_PARAMS_MAX < numParams, "Insufficient buffer size" );

  for( int i = 0; i < numParams; i++ )
  {
    memset( ATA[i], 0x00, sizeof( TCccmCoeff ) * numParams );
  }
  memset( ATCb, 0x00, sizeof( TCccmCoeff ) * numParams );

  for( int coli0 = 0; coli0 < numParams; coli0++ )
  {
    for( int coli1 = coli0; coli1 < numParams; coli1++ )
    {
      const Pel *col0 = A[coli0];
      const Pel *col1 = A[coli1];

      for( int rowi = 0; rowi < sampleNum; rowi++ )
      {
        ATA[coli0][coli1] += col0[rowi] * col1[rowi];
      }
    }
  }

  for( int coli = 0; coli < numParams; coli++ )
  {
    const Pel *col = A[coli];

    for( int rowi = 0; rowi < sampleNum; rowi++ )
    {
      ATCb[coli] += col[rowi] * C[rowi];
    }
  }

#if JVET_AB0174_CCCM_DIV_FREE
  // Remove chromaOffset from stats to update cross-correlation
  for( int coli = 0; coli < numParams; coli++ )
  {
    ATCb[coli] = ATCb[coli] - ((ATA[coli][numParams - 1] * chromaOffset) >> (model.bd - 1));
  }
#endif

  // Scale the matrix and vector to selected dynamic range
#if JVET_AJ0237_INTERNAL_12BIT
  int matrixShift = ((model.bd > 10) ? CCCM_MATRIX_BITS_HBD : 28) - 2 * model.bd - ceilLog2(sampleNum);
#else
  int matrixShift = 28 - 2 * model.bd - ceilLog2( sampleNum );
#endif

  if( matrixShift > 0 )
  {
    for( int coli0 = 0; coli0 < numParams; coli0++ )
    {
      for( int coli1 = coli0; coli1 < numParams; coli1++ )
      {
        ATA[coli0][coli1] <<= matrixShift;
      }
    }

    for( int coli = 0; coli < numParams; coli++ )
    {
      ATCb[coli] <<= matrixShift;
    }
  }
  else if( matrixShift < 0 )
  {
    matrixShift = -matrixShift;

    for( int coli0 = 0; coli0 < numParams; coli0++ )
    {
      for( int coli1 = coli0; coli1 < numParams; coli1++ )
      {
        ATA[coli0][coli1] >>= matrixShift;
      }
    }

    for( int coli = 0; coli < numParams; coli++ )
    {
      ATCb[coli] >>= matrixShift;
    }
  }

#if JVET_AC0053_GAUSSIAN_SOLVER
  // Solve the filter coefficients
  gaussElimination(ATA, ATCb, model.params.data(), nullptr, nullptr, numParams, 1, model.bd);
#else
  // Solve the filter coefficients using LDL decomposition
  TE U;       // Upper triangular L' of ATA's LDL decomposition
  Ty diag;    // Diagonal of D

  bool decompOk = ldlDecompose( ATA, U, diag, M );
  ldlSolve( U, diag, ATCb, model.params, M, decompOk );
#endif

#if JVET_AB0174_CCCM_DIV_FREE
  // Add the chroma offset to bias term (after shifting up by CCCM_DECIM_BITS and down by cccmModelCb.bd - 1)
#if JVET_AJ0237_INTERNAL_12BIT
  model.params[numParams - 1] += chromaOffset << (model.decimBits - (model.bd - 1));
#else
  model.params[numParams - 1] += chromaOffset << (CCCM_DECIM_BITS - (model.bd - 1));
#endif
#endif
}

#if JVET_AB0174_CCCM_DIV_FREE
void CccmCovariance::solve2( const Pel A[CCCM_NUM_PARAMS_MAX][CCCM_REF_SAMPLES_MAX], const Pel* Cb, const Pel* Cr, const int sampleNum, const int chromaOffsetCb, const int chromaOffsetCr, CccmModel& modelCb, CccmModel& modelCr
#if JVET_AE0059_INTER_CCCM
    , const bool interCccmMode
#endif
)
#else
void CccmCovariance::solve2( const Pel A[CCCM_NUM_PARAMS_MAX][CCCM_REF_SAMPLES_MAX], const Pel* Cb, const Pel* Cr, const int sampleNum, CccmModel& modelCb, CccmModel& modelCr
#if JVET_AE0059_INTER_CCCM
    , const bool interCccmMode
#endif
)
#endif
{

  const int numParams = modelCb.getNumParams();

  CHECK( modelCr.getNumParams() != numParams, "Chroma number of parameters don't match" );
  CHECK( CCCM_REF_SAMPLES_MAX < sampleNum, "Insufficient buffer size" );
  CHECK( CCCM_NUM_PARAMS_MAX < numParams, "Insufficient buffer size" );

  // Calculate autocorrelation matrix and cross-correlation vector
  for( int i = 0; i < numParams; i++ )
  {
    memset( ATA[i], 0x00, sizeof( TCccmCoeff ) * numParams );
  }
  memset( ATCb, 0x00, sizeof( TCccmCoeff ) * numParams );
  memset( ATCr, 0x00, sizeof( TCccmCoeff ) * numParams );

  for( int coli0 = 0; coli0 < numParams; coli0++ )
  {
    for( int coli1 = coli0; coli1 < numParams; coli1++ )
    {
      const Pel *col0 = A[coli0];
      const Pel *col1 = A[coli1];

      for( int rowi = 0; rowi < sampleNum; rowi++ )
      {
        ATA[coli0][coli1] += col0[rowi] * col1[rowi];
      }
    }
  }

  for( int coli = 0; coli < numParams; coli++ )
  {
    const Pel *col = A[coli];

    for( int rowi = 0; rowi < sampleNum; rowi++ )
    {
      ATCb[coli] += col[rowi] * Cb[rowi];
      ATCr[coli] += col[rowi] * Cr[rowi];
    }
  }

#if JVET_AB0174_CCCM_DIV_FREE
  // Remove chromaOffset from stats to update cross-correlation
  for( int coli = 0; coli < numParams; coli++ )
  {
    ATCb[coli] = ATCb[coli] - ((ATA[coli][numParams - 1] * chromaOffsetCb) >> (modelCb.bd - 1));
    ATCr[coli] = ATCr[coli] - ((ATA[coli][numParams - 1] * chromaOffsetCr) >> (modelCr.bd - 1));
  }
#endif

  // Scale the matrix and vector to selected dynamic range
  CHECK( modelCb.bd != modelCr.bd, "Bitdepth of Cb and Cr is different" );
#if JVET_AE0059_INTER_CCCM
#if JVET_AJ0237_INTERNAL_12BIT
  int matrixShift = ((modelCb.bd > 10) ? CCCM_MATRIX_BITS_HBD : (interCccmMode ? 28 : CCCM_MATRIX_BITS)) - 2 * modelCb.bd - ceilLog2(sampleNum);
#else
  int matrixShift = (interCccmMode ? 28 : CCCM_MATRIX_BITS) - 2 * modelCb.bd - ceilLog2( sampleNum );
#endif
#else
  int matrixShift = CCCM_MATRIX_BITS - 2 * modelCb.bd - ceilLog2( sampleNum );
#endif

  if( matrixShift > 0 )
  {
    for( int coli0 = 0; coli0 < numParams; coli0++ )
    {
      for( int coli1 = coli0; coli1 < numParams; coli1++ )
      {
        ATA[coli0][coli1] <<= matrixShift;
      }
    }

    for( int coli = 0; coli < numParams; coli++ )
    {
      ATCb[coli] <<= matrixShift;
    }

    for( int coli = 0; coli < numParams; coli++ )
    {
      ATCr[coli] <<= matrixShift;
    }
  }
  else if( matrixShift < 0 )
  {
    matrixShift = -matrixShift;

    for( int coli0 = 0; coli0 < numParams; coli0++ )
    {
      for( int coli1 = coli0; coli1 < numParams; coli1++ )
      {
        ATA[coli0][coli1] >>= matrixShift;
      }
    }

    for( int coli = 0; coli < numParams; coli++ )
    {
      ATCb[coli] >>= matrixShift;
    }

    for( int coli = 0; coli < numParams; coli++ )
    {
      ATCr[coli] >>= matrixShift;
    }
  }

#if JVET_AC0053_GAUSSIAN_SOLVER
  // Solve the filter coefficients
  gaussElimination(ATA, ATCb, modelCb.params.data(), ATCr, modelCr.params.data(), numParams, 2, modelCb.bd
#if JVET_AE0059_INTER_CCCM
    , interCccmMode
#endif
  );
#else
  // Solve the filter coefficients using LDL decomposition
  TE U;       // Upper triangular L' of ATA's LDL decomposition
  Ty diag;    // Diagonal of D

  bool decompOk = ldlDecompose( ATA, U, diag, M );

  ldlSolve( U, diag, ATCb, modelCb.params, M, decompOk );
  ldlSolve( U, diag, ATCr, modelCr.params, M, decompOk );
#endif

#if JVET_AB0174_CCCM_DIV_FREE
  // Add the chroma offset to bias term (after shifting up by CCCM_DECIM_BITS and down by cccmModelCb.bd - 1)
#if JVET_AJ0237_INTERNAL_12BIT
  modelCb.params[numParams - 1] += chromaOffsetCb << (modelCb.decimBits - (modelCb.bd - 1));
  modelCr.params[numParams - 1] += chromaOffsetCr << (modelCr.decimBits - (modelCr.bd - 1));
#else
  modelCb.params[numParams - 1] += chromaOffsetCb << (CCCM_DECIM_BITS - (modelCb.bd - 1));
  modelCr.params[numParams - 1] += chromaOffsetCr << (CCCM_DECIM_BITS - (modelCr.bd - 1));
#endif
#endif
}
#endif

#if JVET_AB0092_GLM_WITH_LUMA
void IntraPrediction::xGlmApplyModel(const PredictionUnit& pu, const ComponentID compId, const CompArea& chromaArea, CccmModel& glmModel, PelBuf &piPred)
{
  const  ClpRng& clpRng(pu.cu->cs->slice->clpRng(compId));
  Pel* samples = m_samples;

  CPelBuf refLumaBlk = xGlmGetGradPuBuf(pu, chromaArea, 0);
  CPelBuf refGradBlk = xGlmGetGradPuBuf(pu, chromaArea, pu.glmIdc.getIdc(compId, 0));

  for (int y = 0; y < refLumaBlk.height; y++)
  {
    for (int x = 0; x < refLumaBlk.width; x++)
    {
      samples[0] = refGradBlk.at(x, y); // luma gradient
      samples[1] = refLumaBlk.at(x, y); // luma value
      samples[2] = glmModel.bias();

      piPred.at(x, y) = ClipPel<Pel>(glmModel.convolve(samples), clpRng);
    }
  }
}

void IntraPrediction::xGlmCalcModel(const PredictionUnit& pu, const ComponentID compID, const CompArea& chromaArea, CccmModel& glmModel)
{
  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  const CPelBuf reco = pu.cs->picture->getRecoBuf(compID);
  PelBuf        refLuma = xGlmGetGradRefBuf(pu, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY, 0);
  PelBuf        refGrad = xGlmGetGradRefBuf(pu, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY, pu.glmIdc.getIdc(compID, 0));

  int sampleNum = 0;

#if JVET_AB0174_CCCM_DIV_FREE
  int chromaOffset = 1 << (pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_CHROMA) - 1);

  if (refSizeX || refSizeY)
  {
    int refPosX = refSizeX > 0 ? refSizeX - 1 : 0;
    int refPosY = refSizeY > 0 ? refSizeY - 1 : 0;

    chromaOffset = reco.at(refPosPicX + refPosX, refPosPicY + refPosY);
  }
#endif

  int sizeX = refSizeX + chromaArea.width;
  int sizeY = refSizeY + chromaArea.height;

  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      if (x >= refSizeX && y >= refSizeY)
      {
        continue;
      }
      if (pu.intraDir[1] == MDLM_L_IDX)
      {
        if (y < refSizeY)
        {
          continue;
        }
      }
      else if (pu.intraDir[1] == MDLM_T_IDX)
      {
        if (x < refSizeX)
        {
          continue;
        }
      }
      else
      {
        if (x >= sizeX || y >= sizeY)
        {
          continue;
        }
      }

      // 7-tap cross
      m_a[0][sampleNum] = refGrad.at(x, y); // luma gradient
      m_a[1][sampleNum] = refLuma.at(x, y); // luma value
      m_a[2][sampleNum] = glmModel.bias();

      m_cb[sampleNum] = reco.at(refPosPicX + x, refPosPicY + y);
      sampleNum++;
    }
  }

  if( !sampleNum ) // Number of sample can go to zero in the multimode case
  {
    glmModel.clearModel();
  }
  else
  {
#if JVET_AB0174_CCCM_DIV_FREE
    m_cccmSolver.solve1( m_a, m_cb, sampleNum, chromaOffset, glmModel );
#else
    m_cccmSolver.solve1( m_a, m_cb, sampleNum, glmModel );
#endif
  }
}

Pel IntraPrediction::xGlmGetGradVal(const PredictionUnit& pu, const int glmIdx, const CPelBuf pi, const int x, const int y) const
{
  const Pel* piSrc = pi.buf;
  const int iRecStride = pi.stride;
  Pel ypval = 0;
  if (glmIdx == 0)
  {
    if (pu.chromaFormat == CHROMA_444)
    {
      ypval = piSrc[x + iRecStride * y];
    }
    else if (pu.chromaFormat == CHROMA_422)
    {
      int s = 2;
      int offLeft = x > 0 ? -1 : 0;
      s += piSrc[2 * x + iRecStride * y] * 2;
      s += piSrc[2 * x + offLeft + iRecStride * y];
      s += piSrc[2 * x + 1 + iRecStride * y];
      ypval = s >> 2;
    }
    else if (pu.cs->sps->getCclmCollocatedChromaFlag())
    {
      int s = 4;
      int offLeft = x > 0 ? -1 : 0;
      int offAbove = y > 0 ? -1 : 0;
      s += piSrc[2 * x + iRecStride * 2 * y] * 4;
      s += piSrc[2 * x + offLeft + iRecStride * 2 * y];
      s += piSrc[2 * x + 1 + iRecStride * 2 * y];
      s += piSrc[2 * x + iRecStride * (2 * y + 1)];
      s += piSrc[2 * x + iRecStride * (2 * y + offAbove)];
      ypval = s >> 3;
    }
    else
    {
      int s = 4;
      int offLeft = x > 0 ? -1 : 0;
      s += piSrc[2 * x + iRecStride * y * 2] * 2;
      s += piSrc[2 * x + offLeft + iRecStride * y * 2];
      s += piSrc[2 * x + 1 + iRecStride * y * 2];
      s += piSrc[2 * x + iRecStride * (y * 2 + 1)] * 2;
      s += piSrc[2 * x + offLeft + iRecStride * (y * 2 + 1)];
      s += piSrc[2 * x + 1 + iRecStride * (y * 2 + 1)];
      ypval = s >> 3;
    }
#if JVET_AB0174_CCCM_DIV_FREE
    ypval -= m_glmLumaOffset;
#endif
  }
  else
  {
    int p = glmIdx > NUM_GLM_PATTERN ? glmIdx - NUM_GLM_PATTERN - 1 : glmIdx - 1;
    int c[6] = { 0 };
    c[0] = g_glmPattern[p][0], c[1] = g_glmPattern[p][1], c[2] = g_glmPattern[p][2];
    c[3] = g_glmPattern[p][3], c[4] = g_glmPattern[p][4], c[5] = g_glmPattern[p][5];

    int offLeft = x > 0 ? -1 : 0;
    int s[6] = { piSrc[2 * x + offLeft + iRecStride * y * 2], piSrc[2 * x + iRecStride * y * 2], piSrc[2 * x + 1 + iRecStride * y * 2],
                 piSrc[2 * x + offLeft + iRecStride * (y * 2 + 1)], piSrc[2 * x + iRecStride * (y * 2 + 1)], piSrc[2 * x + 1 + iRecStride * (y * 2 + 1)] };

    ypval = xGlmGetLumaVal(s, c, p + 1, 0);
  }

  return ypval;
}

void IntraPrediction::xGlmCalcRefArea(const PredictionUnit& pu, CompArea chromaArea)
{
  const ChannelType     chType = CHANNEL_TYPE_CHROMA;
  const CodingUnit&     cu = *pu.cu;
  const CodingStructure &cs = *cu.cs;
  const SPS             &sps = *cs.sps;
  const PreCalcValues   &pcv = *cs.pcv;

  const int tuWidth = chromaArea.width;
  const int tuHeight = chromaArea.height;

  const bool noShift = pcv.noChroma2x2 && chromaArea.width == 4;   // don't shift on the lowest level (chroma not-split)
  const int  compScaleX = getComponentScaleX(chromaArea.compID, sps.getChromaFormatIdc());
  const int  compScaleY = getComponentScaleY(chromaArea.compID, sps.getChromaFormatIdc());
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : compScaleX);
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : compScaleY);

  const int  totalAboveUnits = (2 * tuWidth + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (2 * tuHeight + (unitHeight - 1)) / unitHeight;
  const int  numAboveUnits = std::max<int>(tuWidth / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(tuHeight / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  static bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1] = { false }; // Just a dummy array here, content not used

  int avaiAboveRightUnits = isAboveRightAvailable(cu, chType, chromaArea.topRight(), numAboveRightUnits, unitWidth, (neighborFlags + totalLeftUnits + 1 + numAboveUnits));
  int avaiLeftBelowUnits = isBelowLeftAvailable(cu, chType, chromaArea.bottomLeft(), numLeftBelowUnits, unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits));

  int refSizeX, refSizeY;

  PU::getCccmRefLineNum(pu, chromaArea, refSizeX, refSizeY); // Reference lines available left and above

  int refWidth = chromaArea.width + refSizeX;              // Reference buffer size excluding paddings
  int refHeight = chromaArea.height + refSizeY;

  int extWidth = avaiAboveRightUnits * unitWidth;
  int extHeight = avaiLeftBelowUnits * unitHeight;

  refWidth += refSizeY ? extWidth : 0; // Add above right if above is available
  refHeight += refSizeX ? extHeight : 0; // Add below left if left is available

  m_glmRefArea = Area(chromaArea.x - refSizeX, chromaArea.y - refSizeY, refWidth, refHeight); // Position with respect to the PU
}

PelBuf IntraPrediction::xGlmGetGradRefBuf(const PredictionUnit& pu, CompArea chromaArea, int &areaWidth, int &areaHeight, int &refSizeX, int &refSizeY, int &refPosPicX, int &refPosPicY, int glmIdx) const
{
  refSizeX = chromaArea.x - m_glmRefArea.x;                        // Reference lines available left and above
  refSizeY = chromaArea.y - m_glmRefArea.y;
  areaWidth = m_glmRefArea.width;                    // Reference buffer size excluding paddings
  areaHeight = m_glmRefArea.height;
  refPosPicX = m_glmRefArea.x; // Position of the reference area in picture coordinates
  refPosPicY = m_glmRefArea.y;

  int refStride = areaWidth;

  int idx = glmIdx > NUM_GLM_PATTERN ? glmIdx - NUM_GLM_PATTERN : glmIdx;
  return PelBuf(m_glmGradBuf[idx], refStride, areaWidth, areaHeight);
}

PelBuf IntraPrediction::xGlmGetGradPuBuf(const PredictionUnit& pu, CompArea chromaArea, int glmIdx) const
{
  int refSizeX = chromaArea.x - m_glmRefArea.x; // Reference lines available left and above
  int refSizeY = chromaArea.y - m_glmRefArea.y;
  int tuWidth = chromaArea.width;
  int tuHeight = chromaArea.height;
  int refStride = m_glmRefArea.width;
  int refOrigin = refStride * refSizeY + refSizeX;

  int idx = glmIdx > NUM_GLM_PATTERN ? glmIdx - NUM_GLM_PATTERN : glmIdx;
  return PelBuf(m_glmGradBuf[idx] + refOrigin, refStride, tuWidth, tuHeight);
}

void IntraPrediction::xGlmCreateGradRef(const PredictionUnit& pu, CompArea chromaArea
#if JVET_AF0073_INTER_CCP_MERGE
    , bool isTemplate
#endif
)
{
  const CPelBuf recoLuma = pu.cs->picture->getRecoBuf(COMPONENT_Y);
  const int  maxPosPicX = pu.cs->picture->chromaSize().width - 1;
  const int  maxPosPicY = pu.cs->picture->chromaSize().height - 1;

  xGlmCalcRefArea(pu, chromaArea); // Find the reference area

  int areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY;

  PelBuf refLuma = xGlmGetGradRefBuf(pu, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY, 0);
  PelBuf refGrad = xGlmGetGradRefBuf(pu, chromaArea, areaWidth, areaHeight, refSizeX, refSizeY, refPosPicX, refPosPicY, pu.glmIdc.getIdc(chromaArea.compID, 0));

  int puBorderX = refSizeX + chromaArea.width;
  int puBorderY = refSizeY + chromaArea.height;

#if JVET_AB0174_CCCM_DIV_FREE
  xGlmSetLumaRefValue(pu, chromaArea);
#endif

#if JVET_AF0073_INTER_CCP_MERGE
  if (!isTemplate)
  {
#endif
  for (int y = 0; y < areaHeight; y++)
  {
    for (int x = 0; x < areaWidth; x++)
    {
      if ((x >= puBorderX && y >= refSizeY) ||
        (y >= puBorderY && x >= refSizeX))
      {
        continue;
      }

      int chromaPosPicX = refPosPicX + x;
      int chromaPosPicY = refPosPicY + y;

      chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
      chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

      refLuma.at(x, y) = xGlmGetGradVal(pu, 0, recoLuma, chromaPosPicX, chromaPosPicY);
      refGrad.at(x, y) = xGlmGetGradVal(pu, pu.glmIdc.getIdc(chromaArea.compID, 0), recoLuma, chromaPosPicX, chromaPosPicY);
    }
  }
#if JVET_AF0073_INTER_CCP_MERGE
  }
  else
  {
    // Generate top template
    if (refSizeY > 0)
    {
      int y = refSizeY - 1;
      for (int x = refSizeX; x < puBorderX; x++)
      {
        int chromaPosPicX = refPosPicX + x;
        int chromaPosPicY = refPosPicY + y;

        chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        refLuma.at(x, y) = xGlmGetGradVal(pu, 0, recoLuma, chromaPosPicX, chromaPosPicY);
        refGrad.at(x, y) = xGlmGetGradVal(pu, pu.glmIdc.getIdc(chromaArea.compID, 0), recoLuma, chromaPosPicX, chromaPosPicY);
      }
    }

    // Generate left template
    if (refSizeX > 0)
    {
      int x = refSizeX - 1;
      for (int y = refSizeY; y < puBorderY; y++)
      {
        int chromaPosPicX = refPosPicX + x;
        int chromaPosPicY = refPosPicY + y;

        chromaPosPicX = chromaPosPicX < 0 ? 0 : chromaPosPicX > maxPosPicX ? maxPosPicX : chromaPosPicX;
        chromaPosPicY = chromaPosPicY < 0 ? 0 : chromaPosPicY > maxPosPicY ? maxPosPicY : chromaPosPicY;

        refLuma.at(x, y) = xGlmGetGradVal(pu, 0, recoLuma, chromaPosPicX, chromaPosPicY);
        refGrad.at(x, y) = xGlmGetGradVal(pu, pu.glmIdc.getIdc(chromaArea.compID, 0), recoLuma, chromaPosPicX, chromaPosPicY);
      }
    }
  }
#endif
}

#if JVET_AB0174_CCCM_DIV_FREE
void IntraPrediction::xGlmSetLumaRefValue(const PredictionUnit& pu, CompArea chromaArea)
{
  int lumaPosX = chromaArea.x << getComponentScaleX(chromaArea.compID, pu.cu->chromaFormat);
  int lumaPosY = chromaArea.y << getComponentScaleY(chromaArea.compID, pu.cu->chromaFormat);

  if (lumaPosX || lumaPosY)
  {
    lumaPosX = lumaPosX ? lumaPosX - 1 : 0;
    lumaPosY = lumaPosY ? lumaPosY - 1 : 0;

    m_glmLumaOffset = pu.cs->picture->getRecoBuf(COMPONENT_Y).at(lumaPosX, lumaPosY);
  }
  else
  {
    m_glmLumaOffset = 1 << (pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA) - 1);
  }
}
#endif
#endif

#if JVET_AG0154_DECODER_DERIVED_CCP_FUSION
void IntraPrediction::filterPredInsideProbeLine(const ComponentID compID, const PredictionUnit &pu, bool isAbove)
{
  if (!pu.ccInsideFilter)
  {
    return;
  }

  CodingUnit   &cu = *pu.cu;
  int           W = pu.blocks[compID].width;
  int           H = pu.blocks[compID].height;

  const CPelBuf recoBuf = pu.cs->picture->getRecoBuf(compID);
  const int  recStride = recoBuf.stride;
  const Pel *pRec = &recoBuf.buf[pu.blocks[compID].y * recStride + pu.blocks[compID].x];

  Pel       *pTmp = m_pCCFilterTemp;
  const int  tmpStride = MAX_CU_SIZE + 2;

  if (isAbove)
  {
    Pel       *pTopProbeTemplate = m_decoderDerivedCcpProbeTemplateT[compID - 1];
    const int  topTmpStride = MAX_CU_SIZE + 2;

    bool isAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -3), toChannelType(compID)) ? true : false;
    if (!isAvailable)
    {
      memcpy(&pTmp[1], &pTopProbeTemplate[1 + topTmpStride], sizeof(Pel) * W);
    }
    else
    {
      memcpy(&pTmp[1], &pTopProbeTemplate[1], sizeof(Pel) * W);
    }
    pTmp[1 + W] = pTmp[W]; // pad right    
    for (int y = 1; y < 3; y++)
    {
      memcpy(&pTmp[1 + y * tmpStride], &pTopProbeTemplate[1 + y * topTmpStride], sizeof(Pel) * W);
      pTmp[1 + y * tmpStride + W] = pTmp[y * tmpStride + W]; // pad right     
    }

    for (int y = 0; y < 3; y++)
    {
      isAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, y - 2), toChannelType(compID)) ? true : false;
      if (isAvailable) // pad left
      {
        pTmp[y * tmpStride] = pRec[(y - 2) * recStride - 1];
      }
      else
      {
        pTmp[y * tmpStride] = pTmp[y * tmpStride + 1];
      }
    }

    pTmp = &m_pCCFilterTemp[1 + tmpStride];
    pTopProbeTemplate = &m_decoderDerivedCcpProbeTemplateT[compID - 1][1 + topTmpStride];
    for (int x = 0; x < W; x++)
    {
      int sum = *(pTmp + x - tmpStride - 1) + *(pTmp + x - tmpStride) + *(pTmp + x - tmpStride + 1) + *(pTmp + x - 1) + 8 * (*(pTmp + x)) + *(pTmp + x + 1)
        + *(pTmp + x + tmpStride - 1) + *(pTmp + x + tmpStride) + *(pTmp + x + tmpStride + 1);
      pTopProbeTemplate[x] = (sum + 8) >> 4;
    }
  }
  else
  {
    Pel       *pLeftProbeTemplate = m_decoderDerivedCcpProbeTemplateL[compID - 1];
    const int  leftTmpStride = 3;

    bool isAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(-3, 0), toChannelType(compID)) ? true : false;
    for (int y = 0; y < H; y++)
    {
      if (!isAvailable)
      {
        pTmp[(y + 1) * tmpStride] = pLeftProbeTemplate[(y + 1) * leftTmpStride + 1];
      }
      else
      {
        pTmp[(y + 1) * tmpStride] = pLeftProbeTemplate[(y + 1) * leftTmpStride];
      }
      pTmp[(y + 1) * tmpStride + 1] = pLeftProbeTemplate[(y + 1) * leftTmpStride + 1];
      pTmp[(y + 1) * tmpStride + 2] = pLeftProbeTemplate[(y + 1) * leftTmpStride + 2];
    }
    memcpy(&pTmp[(H + 1) * tmpStride], &pTmp[H * tmpStride], sizeof(Pel) * 3);

    for (int x = -2; x < 1; x++)
    {
      isAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(x, -1), toChannelType(compID)) ? true : false;
      if (isAvailable)
      {
        pTmp[x + 2] = pRec[-recStride + x];
      }
      else
      {
        pTmp[x + 2] = pTmp[x + 2 + tmpStride];
      }
    }

    pTmp = &m_pCCFilterTemp[1 + tmpStride];
    pLeftProbeTemplate = &m_decoderDerivedCcpProbeTemplateL[compID - 1][1 + leftTmpStride];
    for (int y = 0; y < H; y++)
    {
      int sum = *(pTmp + (y - 1) * tmpStride - 1) + *(pTmp + (y - 1) * tmpStride) + *(pTmp + (y - 1) * tmpStride + 1) + *(pTmp + y * tmpStride - 1) + 8 * (*(pTmp + y * tmpStride))
        + *(pTmp + y * tmpStride + 1) + *(pTmp + (y + 1) * tmpStride - 1) + *(pTmp + (y + 1) * tmpStride) + *(pTmp + (y + 1) * tmpStride + 1);
      pLeftProbeTemplate[y * leftTmpStride] = (sum + 8) >> 4;
    }
  }
}

int IntraPrediction::ddccpFusionTemplateCost(const PredictionUnit& pu, const ComponentID compID, const CompArea& chromaArea, int candIdx0, int candIdx1, int cost0, int cost1)
{
  const SizeType cWidth = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf0(compID == COMPONENT_Cb ? m_ddCCPFusionTempCb[candIdx0] : m_ddCCPFusionTempCr[candIdx0], maxSize, Size(maxSize, 2));
  PelBuf predBuf1(compID == COMPONENT_Cb ? m_ddCCPFusionTempCb[candIdx1] : m_ddCCPFusionTempCr[candIdx1], maxSize, Size(maxSize, 2));

  Pel *curChroma0;
  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
  Pel *curChromaBuf = chromaReco.buf;
  const int curStride = chromaReco.stride;

  int sad = 0;

  if (aboveAvailable)
  {
    curChroma0 = curChromaBuf - curStride;

    if (cost1 < cost0)
    {
      for (int pos = 0; pos < cWidth; pos++)
      {
        Pel predChroma = (3 * predBuf1.at(pos, 0) + predBuf0.at(pos, 0) + 2) >> 2;
        sad += abs(curChroma0[pos] - predChroma);
      }
    }
    else
    {
      for (int pos = 0; pos < cWidth; pos++)
      {
        Pel predChroma = (3 * predBuf0.at(pos, 0) + predBuf1.at(pos, 0) + 2) >> 2;
        sad += abs(curChroma0[pos] - predChroma);
      }
    }
  }

  if (leftAvailable)
  {
    curChroma0 = curChromaBuf - 1;

    if (cost1 < cost0)
    {
      for (int pos = 0; pos < cHeight; pos++, curChroma0 += curStride)
      {
        Pel predChroma = (3 * predBuf1.at(pos, 1) + predBuf0.at(pos, 1) + 2) >> 2;
        sad += abs(*curChroma0 - predChroma);
      }
    }
    else
    {
      for (int pos = 0; pos < cHeight; pos++, curChroma0 += curStride)
      {
        Pel predChroma = (3 * predBuf0.at(pos, 1) + predBuf1.at(pos, 1) + 2) >> 2;
        sad += abs(*curChroma0 - predChroma);
      }
    }
  }

  return sad;
}

void IntraPrediction::predDecoderDerivedIntraCCCMFusions(PredictionUnit& pu, PelBuf &predCb, PelBuf &predCr, std::vector<DecoderDerivedCcpCandidate> &decoderDerivedCcpList)
{
  if (!decoderDerivedCcpList[0].isFusion)
  {
    return;
  }

  int width = predCb.width;
  int height = predCb.height;
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, width, height));
  PelBuf predLmBufferCb = m_tempBuffer[0].getBuf(localUnitArea.Y());
  PelBuf predLmBufferCr = m_tempBuffer[1].getBuf(localUnitArea.Y());

  pu.intraDir[1] = decoderDerivedCcpList[1].lmIndex;
  pu.cccmFlag = decoderDerivedCcpList[1].isCccm;
  pu.glCccmFlag = decoderDerivedCcpList[1].isGlcccm;
  pu.ccInsideFilter = decoderDerivedCcpList[1].isInsideFilter;
  if (!pu.cccmFlag)
  {
    const CompArea &areaCb = pu.blocks[COMPONENT_Cb];
    int iLumaStride = MAX_CU_SIZE + 1;
    PelBuf temp = PelBuf(m_piTemp + iLumaStride + 1, iLumaStride, Size(areaCb));
    CclmModel cclmModelCb, cclmModelCr;
    PU::ccpParamsToCclmModel(COMPONENT_Cb, decoderDerivedCcpList[1].ddccpCand, cclmModelCb);
    PU::ccpParamsToCclmModel(COMPONENT_Cr, decoderDerivedCcpList[1].ddccpCand, cclmModelCr);

    predLmBufferCb.copyFrom(temp);
    predLmBufferCb.linearTransform(cclmModelCb.a, cclmModelCb.shift, cclmModelCb.b, true, pu.cs->slice->clpRng(COMPONENT_Cb));

    predLmBufferCr.copyFrom(temp);
    predLmBufferCr.linearTransform(cclmModelCr.a, cclmModelCr.shift, cclmModelCr.b, true, pu.cs->slice->clpRng(COMPONENT_Cr));
  }
  else
  {
    predIntraCCCM(pu, predLmBufferCb, predLmBufferCr, pu.intraDir[1], false, decoderDerivedCcpList[1].ddccpCand);
  }

  Pel *pelPredCb = predCb.buf;
  Pel *pelLmCb = predLmBufferCb.buf;
  Pel *pelPredCr = predCr.buf;
  Pel *pelLmCr = predLmBufferCr.buf;

  int  w0 = 3;
  int  w1 = 1;
  int  shift = 2;

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      int blend = pelPredCb[x] * w0;
      blend += pelLmCb[x] * w1;
      blend += 2;
      pelPredCb[x] = (Pel)(blend >> shift);

      blend = pelPredCr[x] * w0;
      blend += pelLmCr[x] * w1;
      blend += 2;
      pelPredCr[x] = (Pel)(blend >> shift);
    }
    pelPredCb += predCb.stride;
    pelLmCb += predLmBufferCb.stride;
    pelPredCr += predCr.stride;
    pelLmCr += predLmBufferCr.stride;
  }
}

int IntraPrediction::decoderDerivedCccmCost(const PredictionUnit &pu, int currIdx, const ComponentID compID, int intraDir, const CompArea &chromaArea, CccmModel cccmModel[2], int modelThr)
{
  CHECK(compID != chromaArea.compID, "Invalid component ID");

  const ClpRng &clpRng(pu.cu->cs->slice->clpRng(compID));
  Pel* samples = m_samples;

  int refSizeX = m_cccmBlkArea.x - m_cccmRefArea.x; // Reference lines available left and above
  int refSizeY = m_cccmBlkArea.y - m_cccmRefArea.y;

  CPelBuf refLumaBlk = xCccmGetLumaPuBuf(pu);

  const SizeType cWidth = refLumaBlk.width;
  const SizeType cHeight = refLumaBlk.height;

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool checkAbove = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool checkLeft = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  const Pel *srcColor0 = refLumaBlk.bufAt(0, 0);
  int srcStride = refLumaBlk.stride;

  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf(compID == COMPONENT_Cb ? m_ddCCPFusionTempCb[currIdx] : m_ddCCPFusionTempCr[currIdx], maxSize, Size(maxSize, 2));

  const Pel *curChroma0;
  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
  Pel *curChromaBuf = chromaReco.buf;
  const int curStride = chromaReco.stride;

  int totalSAD = 0;
  if (checkAbove)
  {
    Pel       *pTopProbeTemplate = m_decoderDerivedCcpProbeTemplateT[compID - 1];
    const int  topTmpStride = MAX_CU_SIZE + 2;

    for (int i = 0; i < 3; i++)
    {
      if (!pu.ccInsideFilter)
      {
        if (i != 1)
        {
          continue;
        }
      }
      else
      {
        if (i == 1)
        {
          continue;
        }
      }
      if (pu.ccInsideFilter && i == 2)
      {
        const bool isAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -3), toChannelType(compID)) ? true : false;
        if (!isAvailable)
        {
          continue;
        }
      }

      const Pel *src = srcColor0 - (srcStride * i); // luma position
      Pel *pred = pTopProbeTemplate + topTmpStride * (2 - i) + 1;

      for (int pos = 0; pos < cWidth; pos++, src++)
      {
        if (pu.glCccmFlag)
        {
          samples[0] = *src;
          samples[1] = 2 * (*(src - srcStride)) + (*(src - srcStride - 1)) + (*(src - srcStride + 1)) - 2 * (*(src + srcStride)) - (*(src + srcStride - 1)) - (*(src + srcStride + 1));
          samples[2] = 2 * (*(src - 1)) + (*(src - srcStride - 1)) + (*(src + srcStride - 1)) - 2 * (*(src + 1)) - (*(src - srcStride + 1)) - (*(src + srcStride + 1));
          samples[3] = (((refSizeY - i) + CCCM_LOC_OFFSET) << CCCM_LOC_SHIFT);
          samples[4] = ((pos + refSizeX + CCCM_LOC_OFFSET) << CCCM_LOC_SHIFT);
          samples[5] = cccmModel[0].nonlinear(*src);
          samples[6] = cccmModel[0].bias();
        }
        else
        {
          samples[0] = *src;                 // C
          samples[1] = *(src - srcStride);   // N
          samples[2] = *(src + srcStride);   // S
          samples[3] = *(src - 1);           // W
          samples[4] = *(src + 1);           // E
          samples[5] = cccmModel[0].nonlinear(*src);
          samples[6] = cccmModel[0].bias();
        }

#if MMLM
        if (PU::isMultiModeLM(pu.intraDir[1]))
        {
          if (*src <= modelThr)
          {
            pred[pos] = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);
          }
          else
          {
            pred[pos] = ClipPel<Pel>(cccmModel[1].convolve(samples), clpRng);
          }
        }
        else
#endif
          pred[pos] = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);
      }
    }

    filterPredInsideProbeLine(compID, pu, true);

    {
      int tuWidth = m_cccmBlkArea.width;
      curChroma0 = curChromaBuf - curStride;
      Pel *pred = pTopProbeTemplate + topTmpStride + 1;
      for (int pos = 0; pos < tuWidth; pos++)
      {
        predBuf.at(pos, 0) = pred[pos];
        totalSAD += abs(pred[pos] - curChroma0[pos]);
      }
    }
  }

  if (checkLeft)
  {
    Pel       *pLeftProbeTemplate = m_decoderDerivedCcpProbeTemplateL[compID - 1];
    const int  leftTmpStride = 3;

    for (int i = 0; i < 3; i++)
    {
      if (!pu.ccInsideFilter)
      {
        if (i != 1)
        {
          continue;
        }
      }
      else
      {
        if (i == 1)
        {
          continue;
        }
      }
      if (pu.ccInsideFilter && i == 2)
      {
        const bool isAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(-3, 0), toChannelType(compID)) ? true : false;
        if (!isAvailable)
        {
          continue;
        }
      }

      const Pel *src = srcColor0 - i; // luma position
      Pel *pred = pLeftProbeTemplate + leftTmpStride + 2 - i; // seems not correct for LPF

      for (int pos = 0; pos < cHeight; pos++, src += srcStride, pred += leftTmpStride)
      {
        if (pu.glCccmFlag)
        {
          samples[0] = *src;
          samples[1] = 2 * (*(src - srcStride)) + (*(src - srcStride - 1)) + (*(src - srcStride + 1)) - 2 * (*(src + srcStride)) - (*(src + srcStride - 1)) - (*(src + srcStride + 1));
          samples[2] = 2 * (*(src - 1)) + (*(src - srcStride - 1)) + (*(src + srcStride - 1)) - 2 * (*(src + 1)) - (*(src - srcStride + 1)) - (*(src + srcStride + 1));
          samples[3] = ((pos + refSizeY + CCCM_LOC_OFFSET) << CCCM_LOC_SHIFT);
          samples[4] = (((refSizeX - i) + CCCM_LOC_OFFSET) << CCCM_LOC_SHIFT);
          samples[5] = cccmModel[0].nonlinear(*src);
          samples[6] = cccmModel[0].bias();
        }
        else
        {
          samples[0] = *src;                 // C
          samples[1] = *(src - srcStride);   // N
          samples[2] = *(src + srcStride);   // S
          samples[3] = *(src - 1);           // W
          samples[4] = *(src + 1);           // E
          samples[5] = cccmModel[0].nonlinear(*src);
          samples[6] = cccmModel[0].bias();
        }

#if MMLM
        if (PU::isMultiModeLM(pu.intraDir[1]))
        {
          if (*src <= modelThr)
          {
            *pred = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);
          }
          else
          {
            *pred = ClipPel<Pel>(cccmModel[1].convolve(samples), clpRng);
          }
        }
        else
#endif
          *pred = ClipPel<Pel>(cccmModel[0].convolve(samples), clpRng);
      }
    }

    filterPredInsideProbeLine(compID, pu, false);

    {
      int tuHeight = m_cccmBlkArea.height;
      curChroma0 = curChromaBuf - 1;
      Pel *pred = pLeftProbeTemplate + leftTmpStride + 1;
      for (int pos = 0; pos < tuHeight; pos++, curChroma0 += curStride, pred += leftTmpStride)
      {
        predBuf.at(pos, 1) = *pred;
        totalSAD += abs(*pred - *curChroma0);
      }
    }
  }

  return totalSAD;
}

int IntraPrediction::decoderDerivedCclmCost(const PredictionUnit &pu, int currIdx, const ComponentID compID, int intraDir, const CompArea  &chromaArea, const CclmModel &cclmModel)
{
  int srcStride = MAX_CU_SIZE + 1;
  PelBuf temp = PelBuf(m_piTemp + srcStride + 1, srcStride, Size(chromaArea));

  const SizeType cWidth = chromaArea.width;
  const SizeType cHeight = chromaArea.height;

  CodingStructure  &cs = *(pu.cs);
  const CodingUnit &cu = *(pu.cu);

  const bool aboveAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(0, -1), toChannelType(compID)) ? true : false;
  const bool leftAvailable = cu.cs->getCU(cu.blocks[compID].pos().offset(-1, 0), toChannelType(compID)) ? true : false;

  int maxSize = std::max(cWidth, cHeight);
  PelBuf predBuf(compID == COMPONENT_Cb ? m_ddCCPFusionTempCb[currIdx] : m_ddCCPFusionTempCr[currIdx], maxSize, Size(maxSize, 2));

  Pel *srcColor0, *curChroma0;
  srcColor0 = temp.bufAt(0, 0);

  PelBuf chromaReco = cs.picture->getRecoBuf(chromaArea);
  Pel      *curChromaBuf = chromaReco.buf;
  const int curStride = chromaReco.stride;

  int totalSAD = 0;

  if (aboveAvailable)
  {
    curChroma0 = curChromaBuf - curStride;
    Pel *src = srcColor0 - srcStride;
    for (int pos = 0; pos < cWidth; pos++)
    {
      predBuf.at(pos, 0) = ClipPel(rightShift(cclmModel.a * src[pos], cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
      totalSAD += abs(predBuf.at(pos, 0) - curChroma0[pos]);
    }
  }

  if (leftAvailable)
  {
    curChroma0 = curChromaBuf - 1;
    Pel *src = srcColor0 - 1;
    for (int pos = 0; pos < cHeight; pos++)
    {
      predBuf.at(pos, 1) = ClipPel(rightShift(cclmModel.a * src[pos * srcStride], cclmModel.shift) + cclmModel.b, pu.cs->slice->clpRng(compID));
      totalSAD += abs(predBuf.at(pos, 1) - curChroma0[pos * curStride]);
    }
  }

  return totalSAD;
}

int IntraPrediction::tmCostDecoderDerivedCcp(PredictionUnit& pu, int currIdx, int intraDir, bool isCcpMerge)
{
  if (pu.cccmFlag)
  {
    if (pu.ccInsideFilter)
    {
      const int                  bitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
      CccmModel cccmModelCb[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };
      CccmModel cccmModelCr[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };

      if (intraDir == LM_CHROMA_IDX)
      {
        PU::ccpParamsToCccmModel(pu.curCand, cccmModelCb, cccmModelCr);
        int cccmSAD = decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cb, intraDir, pu.blocks[COMPONENT_Cb], &cccmModelCb[0], 0);
        cccmSAD += decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cr, intraDir, pu.blocks[COMPONENT_Cr], &cccmModelCr[0], 0);

        return cccmSAD;
      }
      else
      {
        // Multimode case
        int modelThr = pu.curCand.yThres;
        PU::ccpParamsToCccmModel(pu.curCand, cccmModelCb, cccmModelCr);
        int cccmSAD = decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cb, pu.intraDir[1], pu.blocks[COMPONENT_Cb], &cccmModelCb[0], modelThr);
        cccmSAD += decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cr, pu.intraDir[1], pu.blocks[COMPONENT_Cr], &cccmModelCr[0], modelThr);

        return cccmSAD;
      }
    }
    else
    {
      const int                  bitDepth = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
      CccmModel cccmModelCb[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };
      CccmModel cccmModelCr[2] = { CccmModel(CCCM_NUM_PARAMS, bitDepth), CccmModel(CCCM_NUM_PARAMS, bitDepth) };

      if (intraDir == LM_CHROMA_IDX)
      {
        if (!pu.glCccmFlag)
        {
          xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 0, 0, 2);
          int cccmSADtmp = decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cb, intraDir, pu.blocks[COMPONENT_Cb], &cccmModelCb[0], 0);
          cccmSADtmp += decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cr, intraDir, pu.blocks[COMPONENT_Cr], &cccmModelCr[0], 0);

          pu.curCand.type = CCP_TYPE_CCCM;
          pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
          pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;

          PU::cccmModelToCcpParams(pu.curCand, &cccmModelCb[0], &cccmModelCr[0], 0
#if JVET_AB0174_CCCM_DIV_FREE
            , m_cccmLumaOffset
#endif
          );

          return cccmSADtmp;
        }
        else
        {
          xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 0, 0);
          int cccmSAD = decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cb, intraDir, pu.blocks[COMPONENT_Cb], &cccmModelCb[0], 0);
          cccmSAD += decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cr, intraDir, pu.blocks[COMPONENT_Cr], &cccmModelCr[0], 0);

          pu.curCand.type = CCP_TYPE_GLCCCM;
          pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
          pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;

          PU::cccmModelToCcpParams(pu.curCand, &cccmModelCb[0], &cccmModelCr[0], 0
#if JVET_AB0174_CCCM_DIV_FREE
            , m_cccmLumaOffset
#endif
          );

          return cccmSAD;
        }
      }
      else
      {
        // Multimode case
        int modelThrTmp = m_mmlmThreshold2;
        xCccmCalcModels(pu, cccmModelCb[0], cccmModelCr[0], 1, modelThrTmp);
        xCccmCalcModels(pu, cccmModelCb[1], cccmModelCr[1], 2, modelThrTmp);
        int cccmSADtmp = decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cb, pu.intraDir[1], pu.blocks[COMPONENT_Cb], &cccmModelCb[0], modelThrTmp);
        cccmSADtmp += decoderDerivedCccmCost(pu, currIdx, COMPONENT_Cr, pu.intraDir[1], pu.blocks[COMPONENT_Cr], &cccmModelCr[0], modelThrTmp);

        pu.curCand.type = (CCP_TYPE_CCCM | CCP_TYPE_MMLM);
        pu.curCand.corOffX = m_cccmBlkArea.x - m_cccmRefArea.x;
        pu.curCand.corOffY = m_cccmBlkArea.y - m_cccmRefArea.y;

        PU::cccmModelToCcpParams(pu.curCand, &cccmModelCb[0], &cccmModelCr[0], modelThrTmp
#if JVET_AB0174_CCCM_DIV_FREE
          , m_cccmLumaOffset
#endif
        );

        return cccmSADtmp;
      }
    }
  }
  else
  {
    const CompArea &areaCb = pu.blocks[COMPONENT_Cb];
    const CompArea &areaCr = pu.blocks[COMPONENT_Cr];
    CclmModel cclmModelCb, cclmModelCr;

    initIntraPatternChType(*pu.cu, areaCb);
    xGetLMParametersLMS(pu, COMPONENT_Cb, areaCb, cclmModelCb);
    initIntraPatternChType(*pu.cu, areaCr);
    xGetLMParametersLMS(pu, COMPONENT_Cr, areaCr, cclmModelCr);

    pu.curCand.type = CCP_TYPE_CCLM;
    PU::cclmModelToCcpParams(COMPONENT_Cb, pu.curCand, cclmModelCb);
    PU::cclmModelToCcpParams(COMPONENT_Cr, pu.curCand, cclmModelCr);

    int cclmSAD = decoderDerivedCclmCost(pu, currIdx, COMPONENT_Cb, pu.intraDir[1], areaCb, cclmModelCb);
    cclmSAD += decoderDerivedCclmCost(pu, currIdx, COMPONENT_Cr, pu.intraDir[1], areaCr, cclmModelCr);

    return cclmSAD;
  }

  return MAX_INT;
}

int IntraPrediction::decoderDerivedCcp(PredictionUnit& pu, std::vector<DecoderDerivedCcpCandidate> &decoderDerivedCcpList)
{
  int numDdccpModes = 0;
  int cost = 0;
  int bestNoFusionCost = MAX_INT;
  int bestNoFusionIndex = 0;

  if (pu.cs->sps->getUseLMChroma())
  {
    pu.intraDir[1] = LM_CHROMA_IDX;
    pu.cccmFlag = 0;
    cost = tmCostDecoderDerivedCcp(pu, numDdccpModes, pu.intraDir[1]);
    decoderDerivedCcpList.push_back({ pu.curCand, cost, pu.intraDir[1], pu.cccmFlag, pu.glCccmFlag, pu.ccInsideFilter });
    if (cost < bestNoFusionCost)
    {
      bestNoFusionCost = cost;
      bestNoFusionIndex = numDdccpModes;
    }
    numDdccpModes++;
  }

  pu.intraDir[1] = LM_CHROMA_IDX;
  pu.cccmFlag = 1;
  for (int i = 0; i < 2; i++)
  {
    pu.ccInsideFilter = i;
    cost = tmCostDecoderDerivedCcp(pu, numDdccpModes, pu.intraDir[1]);
    decoderDerivedCcpList.push_back({ pu.curCand, cost, pu.intraDir[1], pu.cccmFlag, pu.glCccmFlag, pu.ccInsideFilter });
    if (cost < bestNoFusionCost)
    {
      bestNoFusionCost = cost;
      bestNoFusionIndex = numDdccpModes;
    }
    numDdccpModes++;
  }
  pu.ccInsideFilter = 0;

  pu.intraDir[1] = MMLM_CHROMA_IDX;
  pu.cccmFlag = 1;
  for (int i = 0; i < 2; i++)
  {
    pu.ccInsideFilter = i;
    cost = tmCostDecoderDerivedCcp(pu, numDdccpModes, pu.intraDir[1]);
    decoderDerivedCcpList.push_back({ pu.curCand, cost, pu.intraDir[1], pu.cccmFlag, pu.glCccmFlag, pu.ccInsideFilter });
    if (cost < bestNoFusionCost)
    {
      bestNoFusionCost = cost;
      bestNoFusionIndex = numDdccpModes;
    }
    numDdccpModes++;
  }
  pu.ccInsideFilter = 0;

  const int W = pu.blocks[COMPONENT_Cb].width;
  const int H = pu.blocks[COMPONENT_Cb].height;
  const int sizeThreshold = (pu.cs->slice->getSliceType() == I_SLICE) ? 32 : 8;
  if (W * H > sizeThreshold)
  {
    pu.intraDir[1] = LM_CHROMA_IDX;
    pu.cccmFlag = 1;
    pu.glCccmFlag = 1;
    cost = tmCostDecoderDerivedCcp(pu, numDdccpModes, pu.intraDir[1]);
    decoderDerivedCcpList.push_back({ pu.curCand, cost, pu.intraDir[1], pu.cccmFlag, pu.glCccmFlag, pu.ccInsideFilter });
    if (cost < bestNoFusionCost)
    {
      bestNoFusionCost = cost;
      bestNoFusionIndex = numDdccpModes;
    }
    numDdccpModes++;
    pu.glCccmFlag = 0;
  }

  const SizeType baseSize = (W + H) >> 1;
  if (bestNoFusionCost <= baseSize || numDdccpModes <= 1)
  {
    if (bestNoFusionIndex != 0)
    {
      decoderDerivedCcpList[0] = decoderDerivedCcpList[bestNoFusionIndex];
    }
    decoderDerivedCcpList[0].isFusion = false;
  }
  else
  {
    int bestIdx1 = 0;
    int bestIdx2 = 1;
    int bestFusionCost = MAX_INT;

    for (int i = 0; i < numDdccpModes - 1; i++)
    {
      for (int j = i + 1; j < numDdccpModes; j++)
      {
        cost = ddccpFusionTemplateCost(pu, COMPONENT_Cb, pu.Cb(), i, j, decoderDerivedCcpList[i].cost, decoderDerivedCcpList[j].cost);
        cost += ddccpFusionTemplateCost(pu, COMPONENT_Cr, pu.Cr(), i, j, decoderDerivedCcpList[i].cost, decoderDerivedCcpList[j].cost);

        if (cost < bestFusionCost)
        {
          bestIdx1 = i;
          bestIdx2 = j;
          bestFusionCost = cost;
        }
      }
    }

    if (bestNoFusionCost <= bestFusionCost)
    {
      if (bestNoFusionIndex != 0)
      {
        decoderDerivedCcpList[0] = decoderDerivedCcpList[bestNoFusionIndex];
      }
      decoderDerivedCcpList[0].isFusion = false;
    }
    else
    {
      DecoderDerivedCcpCandidate bestDdccp1 = decoderDerivedCcpList[bestIdx1];
      DecoderDerivedCcpCandidate bestDdccp2 = decoderDerivedCcpList[bestIdx2];

      if (bestDdccp2.cost < bestDdccp1.cost)
      {
        decoderDerivedCcpList[0] = bestDdccp2;
        decoderDerivedCcpList[1] = bestDdccp1;
      }
      else
      {
        decoderDerivedCcpList[0] = bestDdccp1;
        decoderDerivedCcpList[1] = bestDdccp2;
      }
      decoderDerivedCcpList[0].isFusion = true;
    }
  }

  return numDdccpModes;
}

void IntraPrediction::predDecoderDerivedCcpMergeFusion(PredictionUnit& pu, PelBuf &predCb, PelBuf &predCr, CCPModelCandidate decoderDerivedCcp1, CCPModelCandidate decoderDerivedCcp2)
{
  int width = predCb.width;
  int height = predCb.height;
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, width, height));
  PelBuf predLmBufferCb = m_tempBuffer[0].getBuf(localUnitArea.Y());
  PelBuf predLmBufferCr = m_tempBuffer[1].getBuf(localUnitArea.Y());

  pu.curCand = decoderDerivedCcp2;
  predCCPCandidate(pu, predLmBufferCb, predLmBufferCr);

  pu.curCand = decoderDerivedCcp1;
  predCCPCandidate(pu, predCb, predCr);

  for (int y = 0; y < height; y++)
  {
    for (int x = 0; x < width; x++)
    {
      predCb.at(x, y) = (predCb.at(x, y) + predLmBufferCb.at(x, y) + 1) >> 1;
      predCr.at(x, y) = (predCr.at(x, y) + predLmBufferCr.at(x, y) + 1) >> 1;
    }
  }
}
#endif

#if JVET_AB0157_TMRL
void IntraPrediction::xPredTmrlIntraDc(const CPelBuf& pSrc, Pel* pDst, int iDstStride)
{
  const Pel dcval = xGetPredValDc(pSrc, Size(tmrlInfo.uiWidth, tmrlInfo.uiHeight));
  for (int y = 0; y < tmrlInfo.uiRefHeight; y++, pDst += iDstStride)
  {
    if (y < tmrlInfo.uiTemplateAbove)
    {
      for (int x = tmrlInfo.uiTemplateLeft; x < tmrlInfo.uiRefWidth; x++)
      {
        pDst[x] = dcval;
      }
    }
    else // y >= tmrlInfo.uiTemplateAbove
    {
      for (int x = 0; x < tmrlInfo.uiTemplateLeft; x++)
      {
        pDst[x] = dcval;
      }
    }
  }
}

Pel tmrlFiltering(Pel* pSrc, const int deltaFrac)
{
#if JVET_AD0085_TMRL_EXTENSION
  const TFilterCoeff* const f = InterpolationFilter::getExtIntraCubicFilter(deltaFrac);
  int val = 0;
  for (int i = 0; i < 4; i++)
  {
    val += pSrc[i] * f[i];
  }
  val = (val + 128) >> 8;
#else
  const TFilterCoeff IntraCubicFilter[32][4] =
  {
    {  0, 64,  0,  0 },
    { -1, 63,  2,  0 },
    { -2, 62,  4,  0 },
    { -2, 60,  7, -1 },
    { -2, 58, 10, -2 },
    { -3, 57, 12, -2 },
    { -4, 56, 14, -2 },
    { -4, 55, 15, -2 },
    { -4, 54, 16, -2 },
    { -5, 53, 18, -2 },
    { -6, 52, 20, -2 },
    { -6, 49, 24, -3 },
    { -6, 46, 28, -4 },
    { -5, 44, 29, -4 },
    { -4, 42, 30, -4 },
    { -4, 39, 33, -4 },
    { -4, 36, 36, -4 },
    { -4, 33, 39, -4 },
    { -4, 30, 42, -4 },
    { -4, 29, 44, -5 },
    { -4, 28, 46, -6 },
    { -3, 24, 49, -6 },
    { -2, 20, 52, -6 },
    { -2, 18, 53, -5 },
    { -2, 16, 54, -4 },
    { -2, 15, 55, -4 },
    { -2, 14, 56, -4 },
    { -2, 12, 57, -3 },
    { -2, 10, 58, -2 },
    { -1,  7, 60, -2 },
    {  0,  4, 62, -2 },
    {  0,  2, 63, -1 },
  };

  int val = 0;
  for (int i = 0; i < 4; i++)
  {
    val += pSrc[i] * IntraCubicFilter[deltaFrac][i];
  }
  val = (val + 32) >> 6;
#endif
  return Pel(val);
}

void IntraPrediction::xPredTmrlIntraAng(const CPelBuf& pSrc, const ClpRng& clpRng, Pel* pTrueDst, int iDstStride)
{
  uint32_t uiWidth = tmrlInfo.uiWidth;
  uint32_t uiHeight = tmrlInfo.uiHeight;
  uint32_t uiTemplateAbove = tmrlInfo.uiTemplateAbove;
  uint32_t uiTemplateLeft = tmrlInfo.uiTemplateLeft;
  uint32_t uiRefWidth = tmrlInfo.uiRefWidth;
  uint32_t uiRefHeight = tmrlInfo.uiRefHeight;

  const bool bIsModeVer = m_ipaParam.isModeVer;
  int  multiRefIdx = m_ipaParam.multiRefIndex;
  const int  lineOffset = multiRefIdx - TMRL_TPL_SIZE;
  const int  intraPredAngle = m_ipaParam.intraPredAngle;
  const int  absInvAngle = m_ipaParam.absInvAngle;

  Pel* refMain;
  Pel* refSide;

#if JVET_AC0094_REF_SAMPLES_OPT
  Pel * refAbove = m_tempRefAbove;
  Pel * refLeft  = m_tempRefLeft;
#else
  Pel  refAbove[2 * MAX_CU_SIZE + 3 + 33 * MAX_REF_LINE_IDX];
  Pel  refLeft[2 * MAX_CU_SIZE + 3 + 33 * MAX_REF_LINE_IDX];
#endif

  // Initialize the Main and Left reference array.
  if (intraPredAngle < 0)
  {
    for (int x = 0; x <= uiWidth + 1 + multiRefIdx; x++)
    {
      refAbove[x + uiRefHeight] = pSrc.at(x, 0);
    }
    for (int y = 0; y <= uiHeight + 1 + multiRefIdx; y++)
    {
      refLeft[y + uiRefWidth] = pSrc.at(y, 1);
    }
    refMain = bIsModeVer ? refAbove + uiRefHeight : refLeft + uiRefWidth;
    refSide = bIsModeVer ? refLeft + uiRefWidth : refAbove + uiRefHeight;
    // Extend the Main reference to the left.
    int sizeSide = bIsModeVer ? uiRefHeight : uiRefWidth;
    for (int k = -sizeSide; k <= -1; k++)
    {
      refMain[k] = refSide[std::min((-k * absInvAngle + 256) >> 9, sizeSide)];
    }
  }
  else
  {
    for (int x = 0; x <= m_topRefLength + multiRefIdx; x++)
    {
      refAbove[x] = pSrc.at(x, 0);
    }
    for (int y = 0; y <= m_leftRefLength + multiRefIdx; y++)
    {
      refLeft[y] = pSrc.at(y, 1);
    }

    refMain = bIsModeVer ? refAbove : refLeft;
    refSide = bIsModeVer ? refLeft : refAbove;

    // Extend main reference to right using replication
    const int log2Ratio = floorLog2(uiWidth) - floorLog2(uiHeight);
    const int s = std::max<int>(0, bIsModeVer ? log2Ratio : -log2Ratio);
    const int maxIndex = (multiRefIdx << s) + 2;
    const int refLength = bIsModeVer ? m_topRefLength : m_leftRefLength;
    const Pel val = refMain[refLength + multiRefIdx];
    for (int z = 1; z <= maxIndex; z++)
    {
      refMain[refLength + multiRefIdx + z] = val;
    }
  }

  if (!bIsModeVer)
  {
    std::swap(uiHeight, uiWidth);
    std::swap(uiRefHeight, uiRefWidth);
    std::swap(uiTemplateAbove, uiTemplateLeft);
  }
  const int iAreaSize = MAX_CU_SIZE + TMRL_TPL_SIZE;
  static Pel tempArray[iAreaSize * iAreaSize];
  const int dstStride = iDstStride;
  Pel* pDstBuf = bIsModeVer ? pTrueDst : tempArray;

  // compensate for relative line offset in reference line buffers
  refMain += lineOffset;
  refSide += lineOffset;

  Pel* pDsty = pDstBuf;

  if (intraPredAngle == 0)  // pure vertical or pure horizontal
  {
    for (auto y = 0; y < uiTemplateAbove; y++)
    {
      memcpy(pDsty + y * dstStride + uiTemplateLeft, &refMain[1 + uiTemplateLeft], uiWidth * sizeof(Pel));
    }
    for (auto y = uiTemplateAbove; y < uiRefHeight; y++)
    {
      memcpy(pDsty + y * dstStride, &refMain[1], uiTemplateLeft * sizeof(Pel));
    }
  }
  else
  {
    for (int y = 0, deltaPos = intraPredAngle * (1 + lineOffset); y < uiRefHeight; y++, deltaPos += intraPredAngle, pDsty += dstStride)
    {
      int iStartIdx, iEndIdx;
      if (y < uiTemplateAbove)
      {
        iStartIdx = uiTemplateLeft;
        iEndIdx = uiRefWidth;
      }
      else
      {
        iStartIdx = 0;
        iEndIdx = uiTemplateLeft;
      }
#if JVET_AD0085_TMRL_EXTENSION
      const int deltaInt = deltaPos >> 6;
      const int deltaFract = deltaPos & 63;
      if (!isIntegerSlopeExt(abs(intraPredAngle)))
#else
      const int deltaInt = deltaPos >> 5;
      const int deltaFract = deltaPos & 31;
      if (!isIntegerSlope(abs(intraPredAngle)))
#endif
      {
        CHECK(deltaInt + iStartIdx + lineOffset < -int(uiRefHeight), "over the prepared reference buffer.");
        for (int x = iStartIdx; x < iEndIdx; x++)
        {
          Pel val = tmrlFiltering(&refMain[deltaInt + x], deltaFract);
          pDsty[x] = ClipPel(val, clpRng);   // always clip even though not always needed
        }
      }

      else
      {
        // Just copy the integer samples
        ::memcpy(pDsty + iStartIdx, refMain + deltaInt + 1 + iStartIdx, (iEndIdx - iStartIdx) * sizeof(Pel));
      }
    }
  }

  // Flip the block if this is the horizontal mode
  if (!bIsModeVer)
  {
    for (int y = 0; y < uiRefHeight; y++)
    {
      int iStartIdx, iEndIdx;
      if (y < uiTemplateAbove)
      {
        iStartIdx = uiTemplateLeft;
        iEndIdx = uiRefWidth;
      }
      else
      {
        iStartIdx = 0;
        iEndIdx = uiTemplateLeft;
      }

      for (int x = iStartIdx; x < iEndIdx; x++)
      {
        pTrueDst[x * iDstStride + y] = pDstBuf[y * dstStride + x];
      }
    }
  }
}

void IntraPrediction::predTmrlIntraAng(const PredictionUnit& pu, Pel* pPred, uint32_t uiStride)
{
  const CPelBuf& srcBuf = CPelBuf(m_refBuffer[COMPONENT_Y][0], m_refBufferStride[COMPONENT_Y], 2);
  const ClpRng& clpRng(pu.cu->cs->slice->clpRng(COMPONENT_Y));

  switch (pu.intraDir[0])
  {
  case(DC_IDX):     xPredTmrlIntraDc(srcBuf, pPred, uiStride); break;
  default:          xPredTmrlIntraAng(srcBuf, clpRng, pPred, uiStride); break;
  }
}

void IntraPrediction::initTmrlIntraParams(const PredictionUnit& pu, const CompArea area, const SPS& sps)
{
  const ComponentID compId = area.compID;
  const ChannelType chType = toChannelType(compId);
  const Size& blockSize = Size(pu.cu->blocks[compId].width, pu.cu->blocks[compId].height);
  const int      dirMode = PU::getFinalIntraMode(pu, chType);
#if JVET_AD0085_TMRL_EXTENSION
  const int     predMode = getWideAngleExt(blockSize.width, blockSize.height, dirMode);
  m_ipaParam.isModeVer = predMode >= EXT_DIA_IDX;
  m_ipaParam.multiRefIndex = pu.multiRefIdx;
  m_ipaParam.refFilterFlag = false;
  m_ipaParam.applyPDPC = false;
  const int    intraPredAngleMode = (m_ipaParam.isModeVer) ? predMode - EXT_VER_IDX : -(predMode - EXT_HOR_IDX);
  if (dirMode > DC_IDX)
  {
    int absAng = 0;
    static const int extAngTable[64] = { 0, 1, 2, 3, 4, 5, 6,7, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 43, 46, 49, 52, 55, 58, 61, 64, 67, 70, 74, 78, 84, 90, 96, 102, 108, 114, 121, 128, 137, 146, 159, 172, 188, 204, 230, 256, 299, 342, 427, 512, 597, 682, 853, 1024, 1536, 2048, 3072 };
    static const int extInvAngTable[64] = { 0, 32768, 16384, 10923, 8192, 6554, 5461, 4681, 4096, 3277, 2731, 2341, 2048, 1820, 1638, 1489, 1365, 1260, 1170, 1092, 1024, 964, 910, 862, 819, 762, 712, 669, 630, 596, 565, 537, 512, 489, 468, 443, 420, 390, 364, 341, 321, 303, 287, 271, 256, 239, 224, 206, 191, 174, 161, 142, 128, 110, 96, 77, 64, 55, 48, 38, 32, 21, 16, 11 }; // (512 * 64) / Angle

    const int     absAngMode = abs(intraPredAngleMode);
    const int     signAng = intraPredAngleMode < 0 ? -1 : 1;
    absAng = extAngTable[absAngMode];

    m_ipaParam.absInvAngle = extInvAngTable[absAngMode];
    m_ipaParam.intraPredAngle = signAng * absAng;
  }
#else
  const int     predMode = getModifiedWideAngle(blockSize.width, blockSize.height, dirMode);
  m_ipaParam.isModeVer = predMode >= DIA_IDX;
  m_ipaParam.multiRefIndex = pu.multiRefIdx;
  m_ipaParam.refFilterFlag = false;
  m_ipaParam.applyPDPC = false;

  const int    intraPredAngleMode = (m_ipaParam.isModeVer) ? (predMode - VER_IDX) : (-(predMode - HOR_IDX));
  int absAng = 0;
  if (dirMode > DC_IDX && dirMode < NUM_LUMA_MODE) // intraPredAngle for directional modes
  {
    static const int angTable[32] = { 0,    1,    2,    3,    4,    6,     8,   10,   12,   14,   16,   18,   20,   23,   26,   29,   32,   35,   39,  45,  51,  57,  64,  73,  86, 102, 128, 171, 256, 341, 512, 1024 };
    static const int invAngTable[32] = {
      0,   16384, 8192, 5461, 4096, 2731, 2048, 1638, 1365, 1170, 1024, 910, 819, 712, 630, 565,
      512, 468,   420,  364,  321,  287,  256,  224,  191,  161,  128,  96,  64,  48,  32,  16
    };   // (512 * 32) / Angle

    const int     absAngMode = abs(intraPredAngleMode);
    const int     signAng = intraPredAngleMode < 0 ? -1 : 1;

    absAng = angTable[absAngMode];
    m_ipaParam.absInvAngle = invAngTable[absAngMode];
    m_ipaParam.intraPredAngle = signAng * absAng;
  }
#endif
}

void IntraPrediction::getTmrlSearchRange(const PredictionUnit& pu, int8_t* tmrlRefList, uint8_t* tmrlIntraList, uint8_t& sizeRef, uint8_t& sizeMode)
{
  CodingUnit& cu = *pu.cu;
#if JVET_AH0065_RELAX_LINE_BUFFER
  int aboveLines = cu.block(COMPONENT_Y).y;
#else
  int aboveLines = (cu.block(COMPONENT_Y).y) % ((cu.cs->sps)->getMaxCUWidth());
#endif
  sizeRef = 0;

  for (; sizeRef < 5; sizeRef++)
  {
    tmrlRefList[sizeRef] = EXT_REF_LINE_IDX[sizeRef];
    if (EXT_REF_LINE_IDX[sizeRef] >= aboveLines)
    {
      break;
    }
  }
#if JVET_AD0085_TMRL_EXTENSION
  sizeMode = TMRL_MPM_SIZE;
#if JVET_AK0059_MDIP
  cu.isModeExcluded = false;
#endif
  int numCand = getSpatialIpm(pu, tmrlIntraList, sizeMode
#if JVET_AC0094_REF_SAMPLES_OPT
                            , true
#endif
                            , true
#if JVET_AK0061_PDP_MPM
    , false , false
#endif

  );
  fillMPMList(pu, tmrlIntraList, sizeMode, numCand, true
#if JVET_AK0061_PDP_MPM
    , false
#endif
  );
#if JVET_AK0059_MDIP
  cu.isModeExcluded = true;
#endif
#else
  // intra mode candidates
  sizeMode = 0;
  const CodingStructure& cs = *pu.cs;
  const int maxListSize = TMRL_MPM_SIZE;
  bool includedMode[NUM_LUMA_MODE]{ false };
  includedMode[PLANAR_IDX] = true;

  const CompArea& area = pu.block(COMPONENT_Y);
  const Position posA = area.topRight().offset(0, -1);
  const Position posAR = area.topRight().offset(1, -1);
  const Position posL = area.bottomLeft().offset(-1, 0);
  const Position posLB = area.bottomLeft().offset(-1, 1);
  const Position posAL = area.topLeft().offset(-1, -1);

  // left (Intra)
  const PredictionUnit* puLeft = cs.getPURestricted(posL, pu, pu.chType);
  if (puLeft && CU::isIntra(*puLeft->cu))
  {
    tmrlIntraList[sizeMode] = PU::getIntraDirLuma(*puLeft);
    if (puLeft->cu->timd)
    {
      tmrlIntraList[sizeMode] = MAP131TO67(tmrlIntraList[sizeMode]);
    }
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }
  // above (Intra)
  const PredictionUnit* puAbove = cs.getPURestricted(posA, pu, pu.chType);
  if (puAbove && CU::isIntra(*puAbove->cu))
  {
    tmrlIntraList[sizeMode] = PU::getIntraDirLuma(*puAbove);
    if (puAbove->cu->timd)
    {
      tmrlIntraList[sizeMode] = MAP131TO67(tmrlIntraList[sizeMode]);
    }
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }
  // left (Inter)
#if JVET_AC0112_IBC_CIIP
  if (puLeft && (CU::isInter(*puLeft->cu) || CU::isIBC(*puLeft->cu)))
#else
  if (puLeft && CU::isInter(*puLeft->cu))
#endif
  {
    tmrlIntraList[sizeMode] = puLeft->getIpmInfo(posL);
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }
  // above (Inter)
#if JVET_AC0112_IBC_CIIP
  if (puAbove && (CU::isInter(*puAbove->cu) || CU::isIBC(*puAbove->cu)))
#else
  if (puAbove && CU::isInter(*puAbove->cu))
#endif
  {
    tmrlIntraList[sizeMode] = puAbove->getIpmInfo(posA);
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }

  // above left (Intra)
  const PredictionUnit* puAboveLeft = cs.getPURestricted(posAL, pu, pu.chType);
  if (puAboveLeft && CU::isIntra(*puAboveLeft->cu))
  {
    tmrlIntraList[sizeMode] = PU::getIntraDirLuma(*puAboveLeft);
    if (puAboveLeft->cu->timd)
    {
      tmrlIntraList[sizeMode] = MAP131TO67(tmrlIntraList[sizeMode]);
    }
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }

  // left bottom (Intra)
  const PredictionUnit* puLeftBottom = cs.getPURestricted(posLB, pu, pu.chType);
  if (puLeftBottom && CU::isIntra(*puLeftBottom->cu))
  {
    tmrlIntraList[sizeMode] = PU::getIntraDirLuma(*puLeftBottom);
    if (puLeftBottom->cu->timd)
    {
      tmrlIntraList[sizeMode] = MAP131TO67(tmrlIntraList[sizeMode]);
    }
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }
  // above right (Intra)
  const PredictionUnit* puAboveRight = cs.getPURestricted(posAR, pu, pu.chType);
  if (puAboveRight && CU::isIntra(*puAboveRight->cu))
  {
    tmrlIntraList[sizeMode] = PU::getIntraDirLuma(*puAboveRight);
    if (puAboveRight->cu->timd)
    {
      tmrlIntraList[sizeMode] = MAP131TO67(tmrlIntraList[sizeMode]);
    }
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }

  // above left (Inter)
#if JVET_AC0112_IBC_CIIP
  if (puAboveLeft && (CU::isInter(*puAboveLeft->cu) || CU::isIBC(*puAboveLeft->cu)))
#else
  if (puAboveLeft && CU::isInter(*puAboveLeft->cu))
#endif
  {
    tmrlIntraList[sizeMode] = puAboveLeft->getIpmInfo(posAL);
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }

  // left bottom (Inter)
#if JVET_AC0112_IBC_CIIP
  if (puLeftBottom && (CU::isInter(*puLeftBottom->cu) || CU::isIBC(*puLeftBottom->cu)))
#else
  if (puLeftBottom && CU::isInter(*puLeftBottom->cu))
#endif
  {
    tmrlIntraList[sizeMode] = puLeftBottom->getIpmInfo(posLB);
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }

  // above right (Inter)
#if JVET_AC0112_IBC_CIIP
  if (puAboveRight && (CU::isInter(*puAboveRight->cu) || CU::isIBC(*puAboveRight->cu)))
#else
  if (puAboveRight && CU::isInter(*puAboveRight->cu))
#endif
  {
    tmrlIntraList[sizeMode] = puAboveRight->getIpmInfo(posAR);
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }

#if SECONDARY_MPM
  //adding dimd modes
  if (pu.cu->slice->getSPS()->getUseDimd())
  {
    if (pu.cu->dimdMode != -1)
    {
      tmrlIntraList[sizeMode] = pu.cu->dimdMode;
      if (!includedMode[tmrlIntraList[sizeMode]])
      {
        includedMode[tmrlIntraList[sizeMode++]] = true;
      }
    }

    if (pu.cu->dimdBlendMode[0] != -1)
    {
      tmrlIntraList[sizeMode] = pu.cu->dimdBlendMode[0];
      if (!includedMode[tmrlIntraList[sizeMode]])
      {
        includedMode[tmrlIntraList[sizeMode++]] = true;
      }
    }
  }
#endif

  tmrlIntraList[sizeMode] = DC_IDX;
  if (!includedMode[tmrlIntraList[sizeMode]])
  {
    includedMode[tmrlIntraList[sizeMode++]] = true;
  }

  const int offset = (int)NUM_LUMA_MODE - 6;
  const int mod = offset + 3;
  const int numCands = sizeMode;

  for (int deltaAngular = 0; deltaAngular < 4 && sizeMode < maxListSize; deltaAngular++)
  {
    for (int i = 0; i < numCands && sizeMode < maxListSize; i++)
    {
      if (tmrlIntraList[i] <= DC_IDX)
      {
        continue;
      }

      // try to fill mode - (delta + 1)
      tmrlIntraList[sizeMode] = ((tmrlIntraList[i] + offset - deltaAngular) % mod) + 2;
      if (!includedMode[tmrlIntraList[sizeMode]])
      {
        includedMode[tmrlIntraList[sizeMode++]] = true;
      }

      if (sizeMode >= maxListSize)
      {
        break;
      }

      // try to fill mode + delta + 1
      tmrlIntraList[sizeMode] = ((tmrlIntraList[i] - 1 + deltaAngular) % mod) + 2;
      if (!includedMode[tmrlIntraList[sizeMode]])
      {
        includedMode[tmrlIntraList[sizeMode++]] = true;
      }
    }
  }

  uint8_t mpmDefault[] = { DC_IDX, VER_IDX, HOR_IDX, VER_IDX - 4, VER_IDX + 4, 14, 22, 42, 58, 10, 26,
                            38, 62, 6, 30, 34, 66, 2, 48, 52, 16 };
  for (int idx = 0; sizeMode < maxListSize; idx++)
  {
    tmrlIntraList[sizeMode] = mpmDefault[idx];
    if (!includedMode[tmrlIntraList[sizeMode]])
    {
      includedMode[tmrlIntraList[sizeMode++]] = true;
    }
  }
#endif
}

void IntraPrediction::getTmrlList(CodingUnit& cu)
{
  // step-1. prepare buffers, cost functions, initialize size.
  const CompArea& area = cu.Y();
  PredictionUnit& pu = *cu.firstPU;
  int channelBitDepth = cu.slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  SizeType uiWidth = cu.lwidth();
  SizeType uiHeight = cu.lheight();
  tmrlInfo.uiWidth = uiWidth;
  tmrlInfo.uiHeight = uiHeight;
  tmrlInfo.uiTemplateAbove = TMRL_TPL_SIZE;
  tmrlInfo.uiTemplateLeft = TMRL_TPL_SIZE;
  tmrlInfo.uiRefWidth = uiWidth + TMRL_TPL_SIZE;
  tmrlInfo.uiRefHeight = uiHeight + TMRL_TPL_SIZE;
  uint32_t      uiRealW   = tmrlInfo.uiRefWidth + TMRL_TPL_SIZE;
  uint32_t      uiRealH   = tmrlInfo.uiRefHeight + TMRL_TPL_SIZE;
  const UnitArea localUnitArea(pu.chromaFormat, Area(0, 0, uiRealW, uiRealH));
  uint32_t       uiPredStride = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).stride;
  Pel *piPred = m_intraPredBuffer[0].getBuf(localUnitArea.Y()).buf;
  const CodingStructure& cs = *cu.cs;
  Pel* piOrg = cs.picture->getRecoBuf(area).buf;
  int iOrgStride = cs.picture->getRecoBuf(area).stride;
  piOrg -= (tmrlInfo.uiTemplateAbove * iOrgStride + tmrlInfo.uiTemplateLeft);

  DistParam distParamSad[2]; // above, left
  distParamSad[0].applyWeight = false;
  distParamSad[0].useMR = false;
  distParamSad[1].applyWeight = false;
  distParamSad[1].useMR = false;

#if JVET_AJ0096_SATD_REORDER_INTRA
  m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + tmrlInfo.uiTemplateLeft, piPred + tmrlInfo.uiTemplateLeft, iOrgStride, uiPredStride,
    channelBitDepth, COMPONENT_Y, uiWidth, tmrlInfo.uiTemplateAbove, 0, 1, true);
#else
  m_timdSatdCost->setTimdDistParam(distParamSad[0], piOrg + tmrlInfo.uiTemplateLeft, piPred + tmrlInfo.uiTemplateLeft, iOrgStride, uiPredStride,
    channelBitDepth, COMPONENT_Y, uiWidth, tmrlInfo.uiTemplateAbove, 0, 1, false);
#endif
  if (cu.lx())
  {
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + tmrlInfo.uiTemplateAbove * iOrgStride, piPred + tmrlInfo.uiTemplateAbove * uiPredStride,
      iOrgStride, uiPredStride, channelBitDepth, COMPONENT_Y, tmrlInfo.uiTemplateLeft, uiHeight, 0, 1, true);
#else
    m_timdSatdCost->setTimdDistParam(distParamSad[1], piOrg + tmrlInfo.uiTemplateAbove * iOrgStride, piPred + tmrlInfo.uiTemplateAbove * uiPredStride,
      iOrgStride, uiPredStride, channelBitDepth, COMPONENT_Y, tmrlInfo.uiTemplateLeft, uiHeight, 0, 1, false);
#endif
  }

  // step-2. define search range.
  int8_t tmrlRefList[MRL_NUM_REF_LINES]{ 0 };
  uint8_t tmrlIntraModeList[NUM_LUMA_MODE]{ 0 };
  uint8_t sizeRef, sizeMode;
  getTmrlSearchRange(pu, tmrlRefList, tmrlIntraModeList, sizeRef, sizeMode);

  // step-3. search and sort
  static_vector<TmrlMode, MRL_LIST_SIZE> uiModeList;
  static_vector<uint64_t, MRL_LIST_SIZE> uiCostList;

  int iBestN = MRL_LIST_SIZE;
  if (!pu.cs->pcv->isEncoder)
  {
    iBestN = pu.cu->tmrlListIdx + 1;
  }

  for (uint8_t refIdx = 0; refIdx < sizeRef; refIdx++)
  {
    setReferenceArrayLengths(area);
    pu.multiRefIdx = tmrlRefList[refIdx];
    CHECK(!pu.multiRefIdx, "mrl idx shall not be 0.");
#if JVET_AH0209_PDP
    m_refAvailable = false;
#endif
    xFillReferenceSamples(cs.picture->getRecoBuf(area), m_refBuffer[COMPONENT_Y][0], area, cu);

    for (uint8_t modeIdx = 0; modeIdx < sizeMode; modeIdx++)
    {
      pu.intraDir[0] = tmrlIntraModeList[modeIdx];
      initTmrlIntraParams(pu, pu.Y(), *(pu.cs->sps));
      predTmrlIntraAng(pu, piPred, uiPredStride);

      uint64_t uiCost = 0;
      uiCost += distParamSad[0].distFunc(distParamSad[0]);

      if (uiCostList.size() >= iBestN)
      {
        uint64_t uiCostMax = uiCostList[iBestN - 1];
        if (uiCost > uiCostMax)
        {
          continue;
        }
      }

      if (cu.lx())
      {
        uiCost += distParamSad[1].distFunc(distParamSad[1]);
      }
      updateCandList(TmrlMode(pu.multiRefIdx, pu.intraDir[0]), uiCost, uiModeList, uiCostList, iBestN);
    }
  }

  // step-4. fill the list
  for (auto i = 0; i < uiModeList.size(); i++)
  {
    m_tmrlList[i] = uiModeList[i];
  }
}
#endif

#if JVET_AJ0081_CHROMA_TMRL
void IntraPrediction::getChromaTmrlSearchRange(const PredictionUnit& pu, int8_t* tmrlRefList, uint8_t* tmrlIntraList, uint8_t& sizeRef, uint8_t& sizeMode)
{
  const CompArea& area = pu.Cb();
  CodingUnit& cu = *pu.cu;
  int aboveLines = cu.block(COMPONENT_Cb).y;
  sizeRef = 0;

  for (; sizeRef < MAX_CHROMA_MRL_IDX; sizeRef++)
  {
    tmrlRefList[sizeRef] = CHROMA_MULTI_REF_LINE_IDX[sizeRef];
    if (CHROMA_MULTI_REF_LINE_IDX[sizeRef] >= aboveLines)
    {
      break;
    }
  }

  sizeMode = CHROMA_TMRL_MPM_SIZE;
  uint8_t chromaDirMode;
  int vaildNum = 0;
  bool hasMode[67] = { false };
  hasMode[PLANAR_IDX] = true;
  chromaDirMode = PU::getCoLocatedIntraLumaMode(pu);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
  if (chromaDirMode == PNN_IDX)
  {
    chromaDirMode = PLANAR_IDX;
  }
#endif
  if (hasMode[chromaDirMode] == false)
  {
    hasMode[chromaDirMode] = true;
    tmrlIntraList[vaildNum] = chromaDirMode;
    vaildNum++;
  }
  chromaDirMode = cu.dimdChromaMode;
  if (hasMode[chromaDirMode] == false)
  {
    hasMode[chromaDirMode] = true;
    tmrlIntraList[vaildNum] = chromaDirMode;
    vaildNum++;
  }
  chromaDirMode = cu.dimdChromaModeSecond;
  if (hasMode[chromaDirMode] == false)
  {
    hasMode[chromaDirMode] = true;
    tmrlIntraList[vaildNum] = chromaDirMode;
    vaildNum++;
  }
  chromaDirMode = DC_IDX;
  if (hasMode[chromaDirMode] == false)
  {
    hasMode[chromaDirMode] = true;
    tmrlIntraList[vaildNum] = chromaDirMode;
    vaildNum++;
  }
  // get co-located modes
  CompArea lumaArea = CompArea(COMPONENT_Y, pu.chromaFormat, pu.Cb().lumaPos(), recalcSize(pu.chromaFormat, CHANNEL_TYPE_CHROMA, CHANNEL_TYPE_LUMA, pu.Cb().size()));
  lumaArea = clipArea(lumaArea, pu.cs->picture->block(COMPONENT_Y));

  Position posList[5] = { lumaArea.center(), lumaArea.topLeft(), lumaArea.topRight(), lumaArea.bottomLeft(), lumaArea.bottomRight() };
  for (int n = 0; n < 5; n++)
  {
    if (vaildNum < sizeMode)
    {
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
      const PredictionUnit* lumaPU = (CS::isDualITree(*pu.cs) || (pu.cu->isSST && pu.cu->separateTree))
        ? pu.cs->getLumaPU(posList[n], CHANNEL_TYPE_LUMA)
        : pu.cs->getPU(posList[n], CHANNEL_TYPE_LUMA);
#else
      const PredictionUnit* lumaPU = pu.cs->picture->cs->getPU(posList[n], CHANNEL_TYPE_LUMA);
#endif
      if (lumaPU->cu->timd || lumaPU->cu->tmrlFlag)
      {
        chromaDirMode = MAP131TO67(PU::getIntraDirLuma(*lumaPU, 0));
      }
      else
      {
        chromaDirMode = PU::getIntraDirLuma(*lumaPU, 0);
#if JVET_AJ0249_NEURAL_NETWORK_BASED
        if (chromaDirMode == PNN_IDX)
        {
          chromaDirMode = PLANAR_IDX;
        }
#endif
      }
      if (hasMode[chromaDirMode] == false)
      {
        hasMode[chromaDirMode] = true;
        tmrlIntraList[vaildNum] = chromaDirMode;
        vaildNum++;
      }
    }
  }

  // get neighboring modes
  const Position posCand[5] =
  {
    pu.chromaPos().offset(-1, area.height - 1),
    pu.chromaPos().offset(area.width - 1, -1),
    pu.chromaPos().offset(-1, area.height),
    pu.chromaPos().offset(area.width, -1),
    pu.chromaPos().offset(-1, -1)
  };

  for (const Position& posLT : posCand)
  {
    if (vaildNum < sizeMode)
    {
      const PredictionUnit* puRef = PU::getPUFromPos(pu, CHANNEL_TYPE_CHROMA, posLT);
#if JVET_AH0136_CHROMA_REORDERING
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
      if (puRef != nullptr && CU::isIntra(*puRef->cu) && !PU::isLMCMode(puRef->intraDir[1]) && !PU::isDbvMode(puRef->intraDir[1])
        && (puRef->intraDir[1] != DM_CHROMA_IDX || puRef->cu->slice->isIntra())
        && (puRef->intraDir[1] != DIMD_CHROMA_IDX || puRef->cu->slice->isIntra()))
#else
      if (puRef != nullptr && CU::isIntra(*puRef->cu) && !PU::isLMCMode(puRef->intraDir[1]) && !PU::isDbvMode(puRef->intraDir[1]))
#endif
#else
      if (puRef != nullptr && CU::isIntra(*puRef->cu) && !PU::isLMCMode(puRef->intraDir[1]) && puRef->intraDir[1] != DBV_CHROMA_IDX)
#endif
      {
        chromaDirMode = PU::getFinalIntraMode(*puRef, CHANNEL_TYPE_CHROMA);
        if (hasMode[chromaDirMode] == false)
        {
          hasMode[chromaDirMode] = true;
          tmrlIntraList[vaildNum] = chromaDirMode;
          vaildNum++;
        }
      }
    }
  }

#if JVET_AK0059_MDIP
  cu.isModeExcluded = false;
#endif
  fillMPMList(pu, tmrlIntraList, sizeMode, vaildNum, false
#if JVET_AK0061_PDP_MPM
    ,false
#endif


  );
#if JVET_AK0059_MDIP
  cu.isModeExcluded = true;
#endif
}
void IntraPrediction::predChromaTmrlIntraAng(PredictionUnit& pu, const ComponentID compID, Pel* pPred, uint32_t uiStride)
{
  const CPelBuf& srcBuf = CPelBuf(m_refBuffer[compID][0], m_refBufferStride[compID], 2);
  const ClpRng& clpRng(pu.cu->cs->slice->clpRng(compID));

  switch (pu.intraDir[1])
  {
  case(DC_IDX):     xPredTmrlIntraDc(srcBuf, pPred, uiStride); break;
  default:          xPredTmrlIntraAng(srcBuf, clpRng, pPred, uiStride); break;
  }
}
void IntraPrediction::getChromaTmrlList(const CPelBuf& recoBufY, const CPelBuf& recoBufCb, const CPelBuf& recoBufCr, const CompArea& areaY, const CompArea& areaCb, const CompArea& areaCr, CodingUnit& cu, PredictionUnit& pu
  , InterPrediction* pcInterPred)
{
  if (!CS::isDualITree(*pu.cs) || !pu.cs->sps->getUseTmrl())
  {
    return;
  }
  // step-1. prepare buffers, cost functions, initialize size.
  UnitArea area(CHROMA_420, areaY);
  CodingUnit lumaCU(area);
  PredictionUnit lumaPU(area);
  lumaPU.cu = &lumaCU;
  lumaCU.firstPU = &lumaPU;
  lumaCU.cs = cu.cs;
  lumaPU.cs = pu.cs;
  lumaCU.slice = cu.slice;
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
  lumaCU.isSST = cu.isSST;
  lumaCU.separateTree = cu.separateTree;
#endif
  int width = areaY.width;
  int height = areaY.height;
  const UnitArea localUnitArea(CHROMA_420, Area(0, 0, width, height));
  PelBuf predY = m_tempBuffer[0].getBuf(localUnitArea.Y());
  DistParam cDistParamSatd;
  m_timdSatdCost->setDistParam(cDistParamSatd, recoBufY, predY, pu.cs->sps->getBitDepth(CHANNEL_TYPE_LUMA), COMPONENT_Y, true);
  cDistParamSatd.applyWeight = false;
  cDistParamSatd.useMR = false;

  int intraDir = pu.intraDir[1];
  tmrlInfo.uiWidth = areaCb.width;
  tmrlInfo.uiHeight = areaCb.height;
  tmrlInfo.uiTemplateAbove = TMRL_TPL_SIZE;
  tmrlInfo.uiTemplateLeft = TMRL_TPL_SIZE;
  tmrlInfo.uiRefWidth = areaCb.width + TMRL_TPL_SIZE;
  tmrlInfo.uiRefHeight = areaCb.height + TMRL_TPL_SIZE;
  int line = TMRL_TPL_SIZE;
  const UnitArea localUnitArea2(CHROMA_420, Area(0, 0, (areaCb.width + line) * 2, (areaCb.height + line) * 2));
  PelBuf predCb = m_tempBuffer[0].getBuf(localUnitArea2.Cb());
  PelBuf predCr = m_tempBuffer[0].getBuf(localUnitArea2.Cr());
  int iRefX = 0;
  int iRefY = 0;
  uint32_t uiRefWidth = 0;
  uint32_t uiRefHeight = 0;
  TemplateType eTplType = CU::deriveTimdRefType(areaCb.x, areaCb.y, areaCb.width, areaCb.height, line, line, iRefX,
    iRefY, uiRefWidth, uiRefHeight);
  const Pel* piCb = recoBufCb.buf;
  int  iCbStride = recoBufCb.stride;
  piCb += (iRefY - areaCb.y) * iCbStride + (iRefX - areaCb.x);
  const Pel* piCr = recoBufCr.buf;
  int  iCrStride = recoBufCr.stride;
  piCr += (iRefY - areaCr.y) * iCrStride + (iRefX - areaCr.x);

  DistParam distParamSatd[2][2];   // above, left
  distParamSatd[0][0].applyWeight = false;
  distParamSatd[0][0].useMR = false;
  distParamSatd[0][1].applyWeight = false;
  distParamSatd[0][1].useMR = false;
  distParamSatd[1][0].applyWeight = false;
  distParamSatd[1][0].useMR = false;
  distParamSatd[1][1].applyWeight = false;
  distParamSatd[1][1].useMR = false;
  if (eTplType == LEFT_ABOVE_NEIGHBOR)
  {
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][0], piCb + line, predCb.buf + line, iCbStride, predCb.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cb, areaCb.width, line, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][1], piCb + line * iCbStride, predCb.buf + line * predCb.stride, iCbStride, predCb.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cb, line, areaCb.height, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][0], piCr + line, predCr.buf + line, iCrStride, predCr.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cr, areaCr.width, line, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][1], piCr + line * iCrStride, predCr.buf + line * predCr.stride, iCrStride, predCr.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cr, line, areaCr.height, 0, 1, false);
  }
  else if (eTplType == LEFT_NEIGHBOR)
  {
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][1], piCb, predCb.buf + line * predCb.stride, iCbStride, predCb.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cb, line, areaCb.height, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][1], piCr, predCr.buf + line * predCr.stride, iCrStride, predCr.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cr, line, areaCr.height, 0, 1, false);
  }
  else if (eTplType == ABOVE_NEIGHBOR)
  {
    m_timdSatdCost->setTimdDistParam(distParamSatd[0][0], piCb, predCb.buf + line, iCbStride, predCb.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cb, areaCb.width, line, 0, 1, false);
    m_timdSatdCost->setTimdDistParam(distParamSatd[1][0], piCr, predCr.buf + line, iCrStride, predCr.stride, pu.cs->sps->getBitDepth(CHANNEL_TYPE_CHROMA), COMPONENT_Cr, areaCr.width, line, 0, 1, false);
  }

  int logW = floorLog2(areaCb.width);
  int logH = floorLog2(areaCb.height);
  int logN = floorLog2(line);

  // step-2. define search range.
  int8_t tmrlRefList[MAX_CHROMA_MRL_IDX]{ 0 };
  uint8_t tmrlIntraModeList[NUM_LUMA_MODE]{ 0 };
  uint8_t sizeRef, sizeMode;
  getChromaTmrlSearchRange(pu, tmrlRefList, tmrlIntraModeList, sizeRef, sizeMode);

  // step-3. search and sort
  static_vector<TmrlMode, MRL_LIST_SIZE> uiModeList;
  static_vector<uint64_t, MRL_LIST_SIZE> uiCostList;

  int iBestN = CHROMA_TMRL_LIST_SIZE;

  if (!pu.cs->pcv->isEncoder)
  {
    iBestN = pu.chromaTmrlIdx + 1;
  }

  for (uint8_t refIdx = 0; refIdx < sizeRef; refIdx++)
  {
    lumaPU.multiRefIdx = tmrlRefList[refIdx] << 1;
    m_topRefLength = (areaCb.width + line) << 1;
    m_leftRefLength = (areaCb.height + line) << 1;
    pu.chromaMrlIdx = tmrlRefList[refIdx];
    xFillReferenceSamples(recoBufCb, m_refBuffer[COMPONENT_Cb][PRED_BUF_UNFILTERED], areaCb, *pu.cu);
    xFillReferenceSamples(recoBufCr, m_refBuffer[COMPONENT_Cr][PRED_BUF_UNFILTERED], areaCr, *pu.cu);
    for (uint8_t modeIdx = 0; modeIdx < sizeMode; modeIdx++)
    {
      Distortion uiCost = 0;
      lumaPU.intraDir[0] = tmrlIntraModeList[modeIdx];
      // pred co-located luma area
      predCoLuma(areaY, recoBufY, lumaPU, lumaPU.intraDir[0], predY, pcInterPred, cu);
      uiCost += cDistParamSatd.distFunc(cDistParamSatd);

      // chroma
      m_topRefLength = (areaCb.width + line) << 1;
      m_leftRefLength = (areaCb.height + line) << 1;
      pu.intraDir[1] = tmrlIntraModeList[modeIdx];
      if (eTplType != NO_NEIGHBOR)
      {
        Distortion costCbA = 0;
        Distortion costCbL = 0;
        Distortion costCrA = 0;
        Distortion costCrL = 0;
        initPredIntraParams(pu, areaCb, *(pu.cs->sps));
        predChromaTmrlIntraAng(pu, COMPONENT_Cb, predCb.buf, predCb.stride);
        initPredIntraParams(pu, areaCr, *(pu.cs->sps));
        predChromaTmrlIntraAng(pu, COMPONENT_Cr, predCr.buf, predCr.stride);

        if (eTplType == LEFT_ABOVE_NEIGHBOR)
        {
          costCbA += distParamSatd[0][0].distFunc(distParamSatd[0][0]);
          costCbL += distParamSatd[0][1].distFunc(distParamSatd[0][1]);

          costCrA += distParamSatd[1][0].distFunc(distParamSatd[1][0]);
          costCrL += distParamSatd[1][1].distFunc(distParamSatd[1][1]);
          uiCost += 8 * uiCost + ((costCbA + costCrA) << (logH + 2 - logN)) + ((costCbL + costCrL) << (logW + 2 - logN));
        }
        else if (eTplType == LEFT_NEIGHBOR)
        {
          costCbL += distParamSatd[0][1].distFunc(distParamSatd[0][1]);
          costCrL += distParamSatd[1][1].distFunc(distParamSatd[1][1]);
          uiCost += 8 * uiCost + ((costCbL + costCrL) << (logW + 2 - logN));
        }
        else if (eTplType == ABOVE_NEIGHBOR)
        {
          costCbA += distParamSatd[0][0].distFunc(distParamSatd[0][0]);
          costCrA += distParamSatd[1][0].distFunc(distParamSatd[1][0]);
          uiCost += 8 * uiCost + ((costCbA + costCrA) << (logH + 2 - logN));
        }
        else
        {
          CHECK(true, "wrong template type!");
        }
      }

      if (uiCostList.size() >= iBestN)
      {
        uint64_t uiCostMax = uiCostList[iBestN - 1];
        if (uiCost > uiCostMax)
        {
          continue;
        }
      }
      updateCandList(TmrlMode(tmrlRefList[refIdx], tmrlIntraModeList[modeIdx]), uiCost, uiModeList, uiCostList, iBestN);
    }
  }

  // step-4. fill the list
  for (auto i = 0; i < uiModeList.size(); i++)
  {
    m_chromaTmrlList[i] = uiModeList[i];
  }
  pu.chromaMrlIdx = 0;
  pu.intraDir[1] = intraDir;
}
#endif

#if JVET_AG0058_EIP
int64_t IntraPrediction::calcAeipGroupSum(const Pel* src1, const Pel* src2, const int numSamples)
{
  int64_t sum = 0;
  for (int i = 0; i < numSamples; i++)
  {
    sum += src1[i] * src2[i];
  }

  return sum;
}
#if JVET_AJ0082_MM_EIP
void CccmCovariance::solveEip(const TCccmCoeff* A, const TCccmCoeff* Y, const int sampleNum, const int lumaOffset, CccmModel& model, bool bMm)
#elif JVET_AB0174_CCCM_DIV_FREE
void CccmCovariance::solveEip(const TCccmCoeff* A, const TCccmCoeff* Y, const int sampleNum, const int lumaOffset, CccmModel& model)
#else
void CccmCovariance::solveEip(const TCccmCoeff* A, const TCccmCoeff* Y, const int sampleNum, CccmModel& model)
#endif
{
  const int numParams = model.getNumParams();
  CHECK( CCCM_REF_SAMPLES_MAX < sampleNum, "Insufficient buffer size" );
  CHECK( CCCM_NUM_PARAMS_MAX < numParams, "Insufficient buffer size" );

  int i = 0;
  for (int coli0 = 0; coli0 < numParams; coli0++)
  {
    for (int coli1 = coli0; coli1 < numParams; coli1++)
    {
      ATA[coli0][coli1] = A[i];
      i++;
    }
  }

#if JVET_AI0066_REGULARIZED_EIP
  // Regularization parameter: L2 multiplier * number of parameters
#if JVET_AJ0082_MM_EIP
  int regularizationParam;
  if (bMm)
  {
    if (sampleNum <= L2_MM_SAMPLE_THR[0])
    {
      regularizationParam = L2_MM_EIP_REG[0] * numParams;
    }
    else if (sampleNum <= L2_MM_SAMPLE_THR[1])
    {
      regularizationParam = L2_MM_EIP_REG[1] * numParams;
    }
    else if (sampleNum <= L2_MM_SAMPLE_THR[2])
    {
      regularizationParam = L2_MM_EIP_REG[2] * numParams;
    }
    else if (sampleNum <= L2_MM_SAMPLE_THR[3])
    {
      regularizationParam = L2_MM_EIP_REG[3] * numParams;
    }
    else if (sampleNum <= L2_MM_SAMPLE_THR[4])
    {
      regularizationParam = L2_MM_EIP_REG[4] * numParams;
    }
    else
    {
      regularizationParam = L2_MM_EIP_REG[5] * numParams;
    }
  }
  else
  {
    regularizationParam = (sampleNum <= REGULARIZED_EIP_L2_SAMPLE_THRESHOLD) ? REGULARIZED_EIP_L2_SMALL * numParams : REGULARIZED_EIP_L2_LARGE * numParams;
  }
#if JVET_AJ0237_INTERNAL_12BIT
  regularizationParam <<= 2 * std::max(0, model.bd - 10);
#endif
#else
#if JVET_AJ0237_INTERNAL_12BIT
  int regShift = 2 * std::max(0, model.bd - 10);
  const int regularizationParam = ((sampleNum <= REGULARIZED_EIP_L2_SAMPLE_THRESHOLD) ? REGULARIZED_EIP_L2_SMALL * numParams : REGULARIZED_EIP_L2_LARGE * numParams) << regShift;
#else
  const int regularizationParam = (sampleNum <= REGULARIZED_EIP_L2_SAMPLE_THRESHOLD) ? REGULARIZED_EIP_L2_SMALL * numParams : REGULARIZED_EIP_L2_LARGE * numParams;
#endif
#endif
  for (int coli0 = 0; coli0 < numParams - 1; coli0++) // The last term (bias) is not regularized.
  {
    ATA[coli0][coli0] += regularizationParam;
  }
#endif

  for (int coli = 0; coli < numParams; coli++)
  {
    ATCb[coli] = Y[coli];
  }
  
#if JVET_AB0174_CCCM_DIV_FREE
  // Remove chromaOffset from stats to update cross-correlation
  for( int coli = 0; coli < numParams; coli++ )
  {
    ATCb[coli] = ATCb[coli] - ((ATA[coli][numParams - 1] * lumaOffset) >> (model.bd - 1));
  }
#endif
  // Scale the matrix and vector to selected dynamic range
#if JVET_AJ0237_INTERNAL_12BIT
  int matrixShift = ((model.bd > 10) ? CCCM_MATRIX_BITS_HBD : 28) - 2 * model.bd - ceilLog2(sampleNum);
#else
  int matrixShift = 28 - 2 * model.bd - ceilLog2(sampleNum);
#endif

  if (matrixShift > 0)
  {
    for (int coli0 = 0; coli0 < numParams; coli0++)
    {
      for (int coli1 = coli0; coli1 < numParams; coli1++)
      {
        ATA[coli0][coli1] <<= matrixShift;
      }
    }

    for (int coli = 0; coli < numParams; coli++)
    {
      ATCb[coli] <<= matrixShift;
    }
  }
  else if (matrixShift < 0)
  {
    matrixShift = -matrixShift;

    for (int coli0 = 0; coli0 < numParams; coli0++)
    {
      for (int coli1 = coli0; coli1 < numParams; coli1++)
      {
        ATA[coli0][coli1] >>= matrixShift;
      }
    }

    for (int coli = 0; coli < numParams; coli++)
    {
      ATCb[coli] >>= matrixShift;
    }
  }
#if JVET_AC0053_GAUSSIAN_SOLVER
  // Solve the filter coefficients
  gaussElimination(ATA, ATCb, model.params.data(), nullptr, nullptr, numParams, 1, model.bd);
#else
  // Solve the filter coefficients using LDL decomposition
  TE U;       // Upper triangular L' of ATA's LDL decomposition
  Ty diag;    // Diagonal of D

  bool decompOk = ldlDecompose(ATA, U, diag, numParams);
  ldlSolve(U, diag, ATCb, model.params.data(), numParams, decompOk);
#endif

#if JVET_AB0174_CCCM_DIV_FREE
  // Add the chroma offset to bias term (after shifting up by CCCM_DECIM_BITS and down by cccmModelCb.bd - 1)
#if JVET_AJ0237_INTERNAL_12BIT
  model.params[numParams - 1] += lumaOffset << (model.decimBits - (model.bd - 1));
#else
  model.params[numParams - 1] += lumaOffset << (CCCM_DECIM_BITS - (model.bd - 1));
#endif
#endif
}

void IntraPrediction::initEipParams(const PredictionUnit& pu, const ComponentID compId)
{
  const ChannelType chType = toChannelType(compId);
  const CodingUnit& cu = *pu.cu;
  const CodingStructure& cs = *cu.cs;
  const SPS& sps = *cs.sps;
  const PreCalcValues& pcv = *cs.pcv;
  const auto& area = pu.blocks[compId];
  const int height = area.height;
  const int width = area.width;
  const bool noShift = pcv.noChroma2x2 && width == 4;   // don't shift on the lowest level (chroma not-split)
  const int  compScaleX = getComponentScaleX(compId, sps.getChromaFormatIdc());
  const int  compScaleY = getComponentScaleY(compId, sps.getChromaFormatIdc());
  const int  unitWidth = pcv.minCUWidth >> (noShift ? 0 : compScaleX);
  const int  unitHeight = pcv.minCUHeight >> (noShift ? 0 : compScaleY);

  const int  totalAboveUnits = (2 * width + (unitWidth - 1)) / unitWidth;
  const int  totalLeftUnits = (2 * height + (unitHeight - 1)) / unitHeight;
  const int  numAboveUnits = std::max<int>(width / unitWidth, 1);
  const int  numLeftUnits = std::max<int>(height / unitHeight, 1);
  const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
  const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

  static bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1] = { false }; // Just a dummy array here, content not used
  int avaiAboveRightUnits = isAboveRightAvailable(cu, chType, area.topRight(), numAboveRightUnits, unitWidth, (neighborFlags + totalLeftUnits + 1 + numAboveUnits));
  int avaiLeftBelowUnits = isBelowLeftAvailable(cu, chType, area.bottomLeft(), numLeftBelowUnits, unitHeight, (neighborFlags + totalLeftUnits - 1 - numLeftUnits));

  const Position tplSize = getRecoLinesEIP(cu, compId);
  m_cccmBlkArea.x = tplSize.x + EIP_FILTER_SIZE;
  m_cccmBlkArea.y = tplSize.y + EIP_FILTER_SIZE;
  m_cccmBlkArea.width = width + m_cccmBlkArea.x + avaiAboveRightUnits * unitWidth;
  m_cccmBlkArea.height = height + m_cccmBlkArea.y + avaiLeftBelowUnits  * unitHeight;
  m_cccmLumaOffset = pu.cs->picture->getRecoBuf(pu.blocks[compId]).at(-1, -1);

  // fill reconstruction buffer
  const int refSizeY = m_cccmBlkArea.y;
  const int refSizeX = m_cccmBlkArea.x;
  const int refHeight = m_cccmBlkArea.height;
  const int refWidth = m_cccmBlkArea.width;
  const int refPosPicX = pu.blocks[compId].x - refSizeX;
  const int refPosPicY = pu.blocks[compId].y - refSizeY;
  const Pel* piReco = cs.picture->getRecoBuf(compId).buf;
  const int picStride = cs.picture->getRecoBuf(compId).stride;
  CPelBuf recoTopAndTopLeft(piReco + refPosPicX + refPosPicY * picStride, picStride, refWidth, refSizeY);
  PelBuf refTopAndTopLeft(m_eipBuffer, refWidth, refWidth, refSizeY);
  refTopAndTopLeft.copyFrom(recoTopAndTopLeft);
  CPelBuf recoLeft(piReco + refPosPicX + (refPosPicY + refSizeY) * picStride, picStride, refSizeX, refHeight - refSizeY);
  PelBuf refLeft(m_eipBuffer + refWidth * refSizeY, refWidth, refSizeX, refHeight - refSizeY);
  refLeft.copyFrom(recoLeft);

#if JVET_AH0086_EIP_BIAS_AND_CLIP || JVET_AJ0082_MM_EIP
  int min = MAX_INT;
  int max = 0;
  int startY = refPosPicY < 0 ? -refPosPicY : 0;
  const int startX = refPosPicX < 0 ? -refPosPicX : 0;
#if JVET_AJ0082_MM_EIP
  double sum = 0;
  int samplesNum = 0;
#endif
  for(int y=startY;y<refTopAndTopLeft.height;y++)
  {
    for(int x=startX;x<refTopAndTopLeft.width;x++)
    {
      int sample = refTopAndTopLeft.at(x,y);
      min = sample < min ? sample : min;
      max = sample > max ? sample : max;
#if JVET_AJ0082_MM_EIP
      if(y >= (refTopAndTopLeft.height >> 1) && x >= (refSizeX >> 1))
      {
        sum += sample;
        samplesNum++;
      }
#endif
    }
  }
  startY = (refPosPicY + refSizeY) < 0 ? -(refPosPicY + refSizeY) : 0;
  for(int y=startY;y<refLeft.height;y++)
  {
    for(int x=startX;x<refLeft.width;x++)
    {
      int sample = refLeft.at(x,y);
      min = sample < min ? sample : min;
      max = sample > max ? sample : max;
#if JVET_AJ0082_MM_EIP
      if(x >= (refLeft.width >> 1))
      {
        sum += sample;
        samplesNum++;
      }
#endif
    }
  }
#if JVET_AH0086_EIP_BIAS_AND_CLIP
  m_eipClipMin = min;
  m_eipClipMax = max;
  m_eipBias    = 1 << (pu.cu->slice->getSPS()->getBitDepth(chType) - 1);
#endif
#if JVET_AJ0082_MM_EIP
  m_eipAvg = Pel( sum / samplesNum);
#endif
#endif
}

#if JVET_AH0086_EIP_BIAS_AND_CLIP
void IntraPrediction::setInputsVec(Pel *inputs, PelBuf &reco, int w, int h, int filterShape)
{
  inputs[EIP_FILTER_TAP - 1] = m_eipBias;
  
  for(int idx = 0; idx < EIP_FILTER_TAP - 1; idx++)
  {
    inputs[idx] = reco.at(w + g_eipFilter[filterShape][idx].x, h + g_eipFilter[filterShape][idx].y);
  }
}
#else
void setInputsVec(Pel *inputs, PelBuf &reco, int w, int h, int filterShape)
{
  for(int idx = 0; idx < EIP_FILTER_TAP; idx++)
  {
    inputs[idx] = reco.at(w + g_eipFilter[filterShape][idx].x, h + g_eipFilter[filterShape][idx].y);
  }
}
#endif

void IntraPrediction::getCurEipCands(const PredictionUnit& pu, static_vector<EipModelCandidate, NUM_DERIVED_EIP>& candList, const ComponentID compId, const bool fastTest)
{
  if(!getAllowedEip(*pu.cu, compId))
  {
    return;
  }

  const Position tplSize = getRecoLinesEIP(*pu.cu, compId);
  const int refSizeY = m_cccmBlkArea.y;
  const int refSizeX = m_cccmBlkArea.x;
  const int refHeight = m_cccmBlkArea.height;
  const int refWidth = m_cccmBlkArea.width;
  PelBuf refBuf(m_eipBuffer, refWidth, refHeight);
  const int bd = pu.cu->slice->getSPS()->getBitDepth(CHANNEL_TYPE_LUMA);
  const int log2BatchSize = 10;
  const int batchSize = (1 << log2BatchSize);
  const int sizeAtaBuf = ((EIP_FILTER_TAP + 1) * EIP_FILTER_TAP) >> 1;
  const int numInputs = EIP_FILTER_TAP;
  static_vector<EIPInfo, NUM_DERIVED_EIP> eipInfoList;
#if JVET_AJ0082_MM_EIP
  if (pu.cs->pcv->isEncoder)
  {
    m_numSigEip = getAllowedCurEip(*pu.cu, compId, eipInfoList, false);
    getAllowedCurEip(*pu.cu, compId, eipInfoList, true);
  }
  else
  {
    getAllowedCurEip(*pu.cu, compId, eipInfoList, pu.cu->eipMmFlag);
  }
  memset(mmEipATABuf, 0, sizeof(TCccmCoeff) * 2 * NUM_EIP_COMB * sizeAtaBuf);
  memset(mmEipATYBuf, 0, sizeof(TCccmCoeff) * 2 * NUM_EIP_COMB * EIP_FILTER_TAP);
#else
  getAllowedCurEip(*pu.cu, compId, eipInfoList);
#endif
  memset(ATABuf[0], 0, sizeof(TCccmCoeff) * NUM_EIP_COMB * sizeAtaBuf);
  memset(ATYBuf[0], 0, sizeof(TCccmCoeff) * NUM_EIP_COMB * EIP_FILTER_TAP);
  for (int i = 0; i < NUM_EIP_SHAPE * NUM_EIP_BASE_RECOTYPE; i++)
  {
    bSrcBufFilled[i] = false;
  }
  for (int i = 0; i < NUM_EIP_BASE_RECOTYPE; i++) 
  {
    bDstBufFilled[i] = false;
    numSamplesBuf[i] = 0;
  }
  if (!pu.cs->pcv->isEncoder) // decoder derives one set of coefficients.
  {
    const auto eipInfoBackup = eipInfoList[pu.intraDir[0]];
    eipInfoList.clear();
    eipInfoList.push_back(eipInfoBackup);
  }
  static_vector<int, NUM_EIP_BASE_RECOTYPE> refIdxList;
#if JVET_AJ0082_MM_EIP
  bool bMmMode = pu.cs->pcv->isEncoder || pu.cu->eipMmFlag;
  int thrd = m_eipAvg;
  for(int i = 0; i < eipInfoList.size(); i++)
  {
    EIPInfo mode = eipInfoList[i];
    EipModelCandidate cand;
    cand.bMm = pu.cs->pcv->isEncoder ? (i >= m_numSigEip): pu.cu->eipMmFlag;
#else
  for (auto mode : eipInfoList)
  {
#endif
    int recoType = mode.recoType, filterShape = mode.filterShape;
    CccmModel model(EIP_FILTER_TAP, bd);
    TCccmCoeff ATA[sizeAtaBuf]{ 0 };
    TCccmCoeff ATY[EIP_FILTER_TAP]{ 0 };
    int totalSamples = 0;
#if JVET_AJ0082_MM_EIP
    CccmModel model1(EIP_FILTER_TAP, bd);
    TCccmCoeff ATA1[sizeAtaBuf]{ 0 };
    TCccmCoeff ATY1[EIP_FILTER_TAP]{ 0 };
    int totalSamples1 = 0;
#endif
    // push needed refIdx for current mode.
    refIdxList.clear();
    if (recoType == EIP_AL || recoType == EIP_AL_A || recoType == EIP_AL_L || recoType == EIP_AL_A_L) 
    {
      refIdxList.push_back(EIP_AL);
    }
    if (recoType == EIP_A || recoType == EIP_AL_A || recoType == EIP_AL_A_L)
    {
      refIdxList.push_back(EIP_A);
    }
    if (recoType == EIP_L || recoType == EIP_AL_L || recoType == EIP_AL_A_L)
    {
      refIdxList.push_back(EIP_L);
    }
#if JVET_AJ0082_MM_EIP
    for (auto refIdx: refIdxList)
    {
      const int srcBufIdx = filterShape + refIdx * NUM_EIP_BASE_RECOTYPE;
      const int mmIdx0    = srcBufIdx << 1;
      const int mmIdx1    = mmIdx0 + 1;

      // fill src buffer
      if (!bSrcBufFilled[srcBufIdx])
      {
        bSrcBufFilled[srcBufIdx] = true;

        int startX, startY, endX, endY;

        if (refIdx == EIP_AL)
        {
          startX = refSizeX - tplSize.x;
          startY = refSizeY - tplSize.y;
          endX   = refSizeX;
          endY   = refSizeY;
        }
        else if (refIdx == EIP_A)
        {
          startX = refSizeX;
          startY = refSizeY - tplSize.y;
          endX   = refWidth;
          endY   = refSizeY;
        }
        else   // EIP_L
        {
          startX = refSizeX - tplSize.x;
          startY = refSizeY;
          endX   = refSizeX;
          endY   = refHeight;
        }

        if (bMmMode)
        {
          int numMmSamples[2] = {};

          for (int y = startY; y < endY; y++)
          {
            for (int x = startX; x < endX; x++)
            {
#if JVET_AH0086_EIP_BIAS_AND_CLIP
              m_mmEipInputs[0][numInputs - 1][numMmSamples[0]] =  m_mmEipInputs[1][numInputs - 1][numMmSamples[1]] = m_eipBias;

              for (int inputIdx = 0; inputIdx < numInputs - 1; inputIdx++)
#else
              for (int inputIdx = 0; inputIdx < numInputs; inputIdx++)
#endif
              {
                m_mmEipInputs[0][inputIdx][numMmSamples[0]] =  m_mmEipInputs[1][inputIdx][numMmSamples[1]] = 
                    refBuf.at(x + g_eipFilter[filterShape][inputIdx].x, y + g_eipFilter[filterShape][inputIdx].y);
              }

              m_mmEipYBuffer[mmIdx0][numMmSamples[0]] = m_mmEipYBuffer[mmIdx1][numMmSamples[1]] = refBuf.at(x, y);

              const int ref =  filterShape == 0 ? ((m_mmEipInputs[0][0][numMmSamples[0]] + m_mmEipInputs[0][3][numMmSamples[0]] + 1) >> 1): m_mmEipInputs[0][1][numMmSamples[0]];

              numMmSamples[0] += ref <= thrd ? 1: 0;
              numMmSamples[1] += ref > thrd ? 1: 0;
            }
          }

          for (int part = 0; part < 2; part++)
          {
            const int numSamples                      = numMmSamples[part];
            numMmSamplesBuf[part][srcBufIdx]          = numSamples;
            const int samplesInBatches                = (numSamples >> log2BatchSize) << log2BatchSize;
            int       i                               = 0;
            for (int coli0 = 0; coli0 < numInputs; coli0++)
            {
              for (int coli1 = coli0; coli1 < numInputs; coli1++)
              {
                for (int offset = 0; offset < samplesInBatches; offset += batchSize)
                {
                  mmEipATABuf[part][srcBufIdx][i] +=
                    m_calcAeipGroupSum(&m_mmEipInputs[part][coli0][offset],
                                        &m_mmEipInputs[part][coli1][offset], batchSize);
                }
                mmEipATABuf[part][srcBufIdx][i] += m_calcAeipGroupSum(
                  &m_mmEipInputs[part][coli0][samplesInBatches],
                  &m_mmEipInputs[part][coli1][samplesInBatches], numSamples - samplesInBatches);

                i++;
              }
            }

            for (int coli = 0; coli < numInputs; coli++)
            {
              for (int offset = 0; offset < samplesInBatches; offset += batchSize)
              {
                mmEipATYBuf[part][srcBufIdx][coli] +=
                  m_calcAeipGroupSum(&m_mmEipInputs[part][coli][offset],
                                      &m_mmEipYBuffer[mmIdx0 + part][offset], batchSize);
              }
              mmEipATYBuf[part][srcBufIdx][coli] += m_calcAeipGroupSum(
                &m_mmEipInputs[part][coli][samplesInBatches],
                &m_mmEipYBuffer[mmIdx0 + part][samplesInBatches], numSamples - samplesInBatches);
            }
          }
        }
        else
        {
          int numSamples = 0;
          for (int y = startY; y < endY; y++)
          {
            for (int x = startX; x < endX; x++)
            {
#if JVET_AH0086_EIP_BIAS_AND_CLIP
              m_a[numInputs - 1][numSamples] = m_eipBias;
            
              for (int inputIdx = 0; inputIdx < numInputs - 1; inputIdx++)
#else
              for (int inputIdx = 0; inputIdx < numInputs; inputIdx++)
#endif
              {
                m_a[inputIdx][numSamples] = refBuf.at(x + g_eipFilter[filterShape][inputIdx].x, y + g_eipFilter[filterShape][inputIdx].y);
              }
              numSamples++;
            }
          }
          numSamplesBuf[refIdx] = numSamples;

          if (!bDstBufFilled[refIdx])
          {
            bDstBufFilled[refIdx] = true;
            numSamples            = 0;
            for (int y = startY; y < endY; y++)
            {
              for (int x = startX; x < endX; x++)
              {
                m_eipYBuffer[refIdx][numSamples++] = refBuf.at(x, y);
              }
            }
          }

          const int samplesInBatches = (numSamples >> log2BatchSize) << log2BatchSize;
          int       i                = 0;
          for (int coli0 = 0; coli0 < numInputs; coli0++)
          {
            for (int coli1 = coli0; coli1 < numInputs; coli1++)
            {
              for (int offset = 0; offset < samplesInBatches; offset += batchSize)
              {
                ATABuf[srcBufIdx][i] += m_calcAeipGroupSum(&m_a[coli0][offset], &m_a[coli1][offset], batchSize);
              }
              ATABuf[srcBufIdx][i] += m_calcAeipGroupSum(&m_a[coli0][samplesInBatches], &m_a[coli1][samplesInBatches],
                                                          numSamples - samplesInBatches);
              i++;
            }
          }

          for (int coli = 0; coli < numInputs; coli++)
          {
            for (int offset = 0; offset < samplesInBatches; offset += batchSize)
            {
              ATYBuf[srcBufIdx][coli] +=
                m_calcAeipGroupSum(&m_a[coli][offset], &m_eipYBuffer[refIdx][offset], batchSize);
            }
            ATYBuf[srcBufIdx][coli] += m_calcAeipGroupSum(
              &m_a[coli][samplesInBatches], &m_eipYBuffer[refIdx][samplesInBatches], numSamples - samplesInBatches);
          }
        }
      }
      if (cand.bMm)
      {
        for (int i = 0; i < sizeAtaBuf; i++)
        {
          ATA[i] += mmEipATABuf[0][srcBufIdx][i];
          ATA1[i] += mmEipATABuf[1][srcBufIdx][i];
        }

        for (int coli = 0; coli < numInputs; coli++)
        {
          ATY[coli] += mmEipATYBuf[0][srcBufIdx][coli];
          ATY1[coli] += mmEipATYBuf[1][srcBufIdx][coli];
        }
        totalSamples += numMmSamplesBuf[0][srcBufIdx];
        totalSamples1 += numMmSamplesBuf[1][srcBufIdx];
      }
      else if(pu.cs->pcv->isEncoder)
      {
        for (int i = 0; i < sizeAtaBuf; i++)
        {
          ATA[i] += (mmEipATABuf[0][srcBufIdx][i] + mmEipATABuf[1][srcBufIdx][i]);
        }

        for (int coli = 0; coli < numInputs; coli++)
        {
          ATY[coli] += (mmEipATYBuf[0][srcBufIdx][coli] + mmEipATYBuf[1][srcBufIdx][coli]);
        }
        totalSamples += (numMmSamplesBuf[0][srcBufIdx] + numMmSamplesBuf[1][srcBufIdx]);
      }
      else
      {
        for (int i = 0; i < sizeAtaBuf; i++)
        {
          ATA[i] += ATABuf[srcBufIdx][i];
        }

        for (int coli = 0; coli < numInputs; coli++)
        {
          ATY[coli] += ATYBuf[srcBufIdx][coli];
        }
        totalSamples += numSamplesBuf[refIdx];
      }
    }
    m_cccmSolver.solveEip(ATA, ATY, totalSamples, m_cccmLumaOffset, model, cand.bMm);
    cand.filterShape = filterShape;
    memcpy(cand.params, model.params.data(), sizeof(cand.params));

    if(cand.bMm)
    {
      cand.eipMmThrd = thrd;
      m_cccmSolver.solveEip(ATA1, ATY1, totalSamples1, m_cccmLumaOffset, model1, true);
      memcpy(cand.params1, model1.params.data(), sizeof(cand.params1));
    }

    candList.push_back(cand);
#else
    for (auto refIdx : refIdxList)
    {
      const int srcBufIdx = filterShape + refIdx * NUM_EIP_BASE_RECOTYPE;
      // fill src buffer
      if (!bSrcBufFilled[srcBufIdx])
      {
        bSrcBufFilled[srcBufIdx] = true;
        int startX, startY, endX, endY;
        if (refIdx == EIP_AL) 
        {
          startX = refSizeX - tplSize.x;
          startY = refSizeY - tplSize.y;
          endX = refSizeX;
          endY = refSizeY;
        }
        else if (refIdx == EIP_A)
        {
          startX = refSizeX;
          startY = refSizeY - tplSize.y;
          endX = refWidth;
          endY = refSizeY;
        }
        else // EIP_L
        {
          startX = refSizeX - tplSize.x;
          startY = refSizeY;
          endX = refSizeX;
          endY = refHeight;
        }

        int numSamples = 0;
        for (int y = startY; y < endY; y++)
        {
          for (int x = startX; x < endX; x++)
          {
#if JVET_AH0086_EIP_BIAS_AND_CLIP
            m_a[numInputs - 1][numSamples] = m_eipBias;
            
            for (int inputIdx = 0; inputIdx < numInputs - 1; inputIdx++)
#else
            for (int inputIdx = 0; inputIdx < numInputs; inputIdx++)
#endif
            {
              m_a[inputIdx][numSamples] = refBuf.at(x + g_eipFilter[filterShape][inputIdx].x, y + g_eipFilter[filterShape][inputIdx].y);
            }
            numSamples++;
          }
        }
        numSamplesBuf[refIdx] = numSamples;

        if (!bDstBufFilled[refIdx])
        {
          bDstBufFilled[refIdx] = true;
          numSamples = 0;
          for (int y = startY; y < endY; y++)
          {
            for (int x = startX; x < endX; x++)
            {
              m_eipYBuffer[refIdx][numSamples++] = refBuf.at(x, y);
            }
          }
        }

        const int samplesInBatches = (numSamples >> log2BatchSize) << log2BatchSize;
        int i = 0;
        for (int coli0 = 0; coli0 < numInputs; coli0++)
        {
          for (int coli1 = coli0; coli1 < numInputs; coli1++)
          {
            for (int offset = 0; offset < samplesInBatches; offset += batchSize)
            {
              ATABuf[srcBufIdx][i] += m_calcAeipGroupSum(&m_a[coli0][offset], &m_a[coli1][offset], batchSize);
            }
            ATABuf[srcBufIdx][i] +=
              m_calcAeipGroupSum(&m_a[coli0][samplesInBatches], &m_a[coli1][samplesInBatches], numSamples - samplesInBatches);
            i++;
          }
        }

        for (int coli = 0; coli < numInputs; coli++)
        {
          for (int offset = 0; offset < samplesInBatches; offset += batchSize)
          {
            ATYBuf[srcBufIdx][coli] += m_calcAeipGroupSum(&m_a[coli][offset], &m_eipYBuffer[refIdx][offset], batchSize);
          }
          ATYBuf[srcBufIdx][coli] += m_calcAeipGroupSum(&m_a[coli][samplesInBatches], &m_eipYBuffer[refIdx][samplesInBatches], numSamples - samplesInBatches);
        }
      }

      CHECK(!bSrcBufFilled[srcBufIdx], "srcBuf is not filled.");
      
      for (int i = 0; i < sizeAtaBuf; i++)
      {
        ATA[i] += ATABuf[srcBufIdx][i];
      }

      for (int coli = 0; coli < numInputs; coli++)
      {
        ATY[coli] += ATYBuf[srcBufIdx][coli];
      }
      totalSamples += numSamplesBuf[refIdx];
    }

    m_cccmSolver.solveEip(ATA, ATY, totalSamples, m_cccmLumaOffset, model);
    EipModelCandidate cand;
    cand.filterShape = filterShape;
    memcpy(cand.params, model.params.data(), sizeof(cand.params));
    candList.push_back(cand);
#endif
  }
}

void IntraPrediction::eipPred(const PredictionUnit& pu, PelBuf& piPred, const ComponentID compId)
{
  EipModelCandidate model = pu.cu->eipModel;
  CccmModel cand(EIP_FILTER_TAP, pu.cu->slice->getSPS()->getBitDepth(toChannelType(compId)));
  memcpy(cand.params.data(), model.params, sizeof(model.params));

  const int refSizeY = m_cccmBlkArea.y;
  const int refSizeX = m_cccmBlkArea.x;
  const int stride = m_cccmBlkArea.width;
  const int blockHeight = piPred.height;
  const int blockWidth = piPred.width;

  PelBuf predBuf(m_eipBuffer + refSizeY * stride + refSizeX, stride, blockWidth, blockHeight);
  const ScanElement* scan = g_scanOrder[SCAN_UNGROUPED][SCAN_DIAG][gp_sizeIdxInfo->idxFrom(blockWidth)][gp_sizeIdxInfo->idxFrom(blockHeight)];
  const int num = blockWidth * blockHeight;
  Pel inputs[EIP_FILTER_TAP];
#if JVET_AH0086_EIP_BIAS_AND_CLIP
  ClpRng clipRng = pu.cu->slice->clpRngs().comp[compId];
  clipRng.min = std::max( clipRng.min, m_eipClipMin);
  clipRng.max = std::min( clipRng.max, m_eipClipMax);
#else
  const ClpRng clipRng = pu.cu->slice->clpRngs().comp[compId];
#endif
#if JVET_AJ0082_MM_EIP
  if(model.bMm)
  {
    CccmModel cand1(EIP_FILTER_TAP, pu.cu->slice->getSPS()->getBitDepth(toChannelType(compId)));
    memcpy(cand1.params.data(), model.params1, sizeof(model.params1));
    const int thrd = model.eipMmThrd;
    for (int scanIdx = 0; scanIdx < num; scanIdx++)
    {
      setInputsVec(inputs, predBuf, scan[scanIdx].x, scan[scanIdx].y, model.filterShape);

      if (getEipInputsAvg(inputs, model.filterShape) <= thrd)
      {
        predBuf.at(scan[scanIdx].x, scan[scanIdx].y) = ClipPel(cand.convolve(inputs), clipRng);
      }
      else
      {
        predBuf.at(scan[scanIdx].x, scan[scanIdx].y) = ClipPel(cand1.convolve(inputs), clipRng);
      }
    }
  }
  else
  {
#endif
  for (int scanIdx = 0; scanIdx < num; scanIdx++)
  {
    setInputsVec(inputs, predBuf, scan[scanIdx].x, scan[scanIdx].y, model.filterShape);
    predBuf.at(scan[scanIdx].x, scan[scanIdx].y) = ClipPel(cand.convolve(inputs), clipRng);
  }
#if JVET_AJ0082_MM_EIP
  }
#endif
  piPred.copyFrom(predBuf);
}

void IntraPrediction::getNeiEipCands(const PredictionUnit& pu, static_vector<EipModelCandidate, MAX_MERGE_EIP>& candList, const ComponentID compId)
{
  if(!getAllowedEipMerge(*pu.cu, compId))
  {
    return;
  }

  const CompArea& area = pu.blocks[compId];
  const ChannelType channelType = toChannelType(compId);
  int numCand = 0;
  const int maxCands = MAX_MERGE_EIP;
  const CodingStructure &cs = *pu.cs;
  const Position topLeft = area.topLeft();
  const Position posCand[5] = {
    topLeft.offset(-1, area.height - 1),
    topLeft.offset(area.width - 1, -1),
    topLeft.offset(-1, -1),
    topLeft.offset(area.width, -1),
    topLeft.offset(-1, area.height),
  };

  auto getEipModel = [&](Position pos) -> void
  {
    const PredictionUnit* neighborPu = cs.getPURestricted(pos, pu, channelType); // PU::getPUFromPos(pu, channelType, pos);
    if (neighborPu && neighborPu->cu->eipFlag)
    {
      EipModelCandidate cand = neighborPu->cu->eipModel;
      bool bIncludedModel = false;
      for (auto i = 0; i < candList.size(); i++) 
      {
        if(cand.isTheSameParams(candList[i]))
        {
          bIncludedModel = true;
          break;
        }
      }
      if(!bIncludedModel)
      {
        candList.push_back(cand);
        numCand++;
      }
    }
    if (numCand >= maxCands)
    {
      return;
    }
  };

  for (int posIdx = 0; posIdx < 5; posIdx++)
  {
    getEipModel(posCand[posIdx]);
  }

  auto tryToAddOneModel = [&](const EipModelCandidate& cand)
  {
    bool bIncludedModel = false;
    for (auto i = 0; i < candList.size(); i++) 
    {
      if(cand.isTheSameParams(candList[i]))
      {
        bIncludedModel = true;
        break;
      }
    }
    if(!bIncludedModel)
    {
      candList.push_back(cand);
      numCand++;
    }
    if (numCand >= maxCands)
    {
      return;
    }
  };
  const Slice &slice = *pu.cs->slice;
  if (!slice.isIntra() && compId == COMPONENT_Y)
  {
    const Picture* const pColPic = slice.getRefPic(RefPicList(slice.isInterB() ? 1 - slice.getColFromL0Flag() : 0), slice.getColRefIdx()); 
    bool isRefScaled = pColPic->isRefScaled(slice.getPPS());
    if(pColPic && !isRefScaled)
    {
      const PreCalcValues& pcv = *cs.pcv;
      bool c0Avail;
      bool c1Avail;
      bool boundaryCond;
      const SubPic& curSubPic = pu.cs->slice->getPPS()->getSubPicFromPos(pu.lumaPos());
      int lumaScaleX = getChannelTypeScaleX( channelType, pu.chromaFormat );
      int lumaScaleY = getChannelTypeScaleY( channelType, pu.chromaFormat );
      Position posRB = pu.blocks[compId].bottomRight().offset(-1, -1);
      Position posCenter = pu.blocks[compId].center();
      Position posC0;
      Position posC1;

      int offsetX0 = 0, offsetX1 = 0, offsetX2 = 0, offsetX3 = pu.blocks[compId].width >> 1;
      int offsetY0 = 0, offsetY1 = 0, offsetY2 = 0, offsetY3 = pu.blocks[compId].height >> 1;

      const int numNACandidate[5] = { 2, 2, 2, 2, 2 };
      const int idxMap[5][2] = { { 0, 1 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 } };

      for (int iDistanceIndex = 0; iDistanceIndex < 5 && numCand < maxCands; iDistanceIndex++)
      {
        const int iNADistanceHor = pu.blocks[compId].width  * iDistanceIndex;
        const int iNADistanceVer = pu.blocks[compId].height * iDistanceIndex;

        for (int naspIdx = 0; naspIdx < numNACandidate[iDistanceIndex] && numCand < maxCands; naspIdx++)
        {
          switch (idxMap[iDistanceIndex][naspIdx])
          {
          case 0: offsetX0 = offsetX2 = 2 + iNADistanceHor; offsetY0 = offsetY2 = 2 + iNADistanceVer; offsetX1 = iNADistanceHor; offsetY1 = iNADistanceVer; break;
          case 1: offsetX0 = 2; offsetY0 = 0; offsetX1 = 0; offsetY1 = 2; break;
          case 2: offsetX0 = offsetX2; offsetY0 = 2 - offsetY3; offsetX1 = 2 - offsetX3; offsetY1 = offsetY2; break;
          default: printf("error!"); exit(0); break;
          }
        
          c0Avail = false;
          if (curSubPic.getTreatedAsPicFlag())
          {
            boundaryCond = ((posRB.x + offsetX0) <= (curSubPic.getSubPicRight() >> lumaScaleX)) && ((posRB.y + offsetY0) <= (curSubPic.getSubPicBottom() >> lumaScaleY));
          }
          else
          {
            boundaryCond = ((posRB.x + offsetX0) < (pcv.lumaWidth >> lumaScaleX)) && ((posRB.y + offsetY0) < (pcv.lumaHeight >> lumaScaleY));
          }
          if (boundaryCond)
          {
            posC0 = posRB.offset(offsetX0, offsetY0);
            c0Avail = true;
          }

          if (idxMap[iDistanceIndex][naspIdx] == 0)
          {
            c1Avail = false;
            if (curSubPic.getTreatedAsPicFlag())
            {
              boundaryCond = ((posCenter.x + offsetX1) <= (curSubPic.getSubPicRight() >> lumaScaleX) && (posCenter.y + offsetY1) <= (curSubPic.getSubPicBottom() >> lumaScaleY));
            }
            else
            {
              boundaryCond = ((posCenter.x + offsetX1) < (pcv.lumaWidth >> lumaScaleX)) && ((posCenter.y + offsetY1) < (pcv.lumaHeight >> lumaScaleY));
            }
            if (boundaryCond)
            {
              posC1 = posCenter.offset(offsetX1, offsetY1);
              c1Avail = true;
            }
          }
          else
          {
            c1Avail = false;
            if (curSubPic.getTreatedAsPicFlag())
            {
              boundaryCond = ((posRB.x + offsetX1) <= (curSubPic.getSubPicRight() >> lumaScaleX) && (posRB.y + offsetY1) <= (curSubPic.getSubPicBottom() >> lumaScaleY));
            }
            else
            {
              boundaryCond = ((posRB.x + offsetX1) < (pcv.lumaWidth >> lumaScaleX)) && ((posRB.y + offsetY1) < (pcv.lumaHeight >> lumaScaleY));
            }
            if (boundaryCond)
            {
              posC1 = posRB.offset(offsetX1, offsetY1);
              c1Avail = true;
            }
          }

          if (c0Avail || c1Avail)
          {
            int modelIdx = c0Avail? pColPic->cs->getEipIdxInfo(posC0) 
                            : pColPic->cs->getEipIdxInfo(posC1);
            if (modelIdx > 0)
            {
              const EipModelCandidate currEipModel = pColPic->cs->m_eipModelLUT[modelIdx-1];
              tryToAddOneModel(currEipModel);
            }
          }
        }
      }
    }
  }

  // Non-adjacent candidates round 1
  int offsetX = 0;  int offsetY = 0;
  int offsetX0 = 0; int offsetX1 = 0; int offsetX2 = pu.blocks[compId].width >> 1;
  int offsetY0 = 0; int offsetY1 = 0; int offsetY2 = pu.blocks[compId].height >> 1;

  const int horNAInterval = std::max((int)(pu.blocks[compId].width * 2) >> 1, 4);
  const int verNAInterval = std::max((int)(pu.blocks[compId].height * 2) >> 1, 4);
  const int numNACandidate[7] = { 5, 9, 9, 9, 9, 9, 9 };
  const int idxMap[7][9] = {
    { 0, 1, 2, 3, 4 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
    { 0, 1, 2, 3, 4, 5, 6, 7, 8 }
  };

  for (int iDistanceIndex = 0; iDistanceIndex < 7 && numCand < maxCands; iDistanceIndex++)
  {
    const int iNADistanceHor = horNAInterval * (iDistanceIndex + 1);
    const int iNADistanceVer = verNAInterval * (iDistanceIndex + 1);

    for (int naspIdx = 0; naspIdx < numNACandidate[iDistanceIndex] && numCand < maxCands; naspIdx++)
    {
      switch (idxMap[iDistanceIndex][naspIdx])
      {
      case 0: offsetX = offsetX0 = -iNADistanceHor - 1;                  offsetY = offsetY0 = verNAInterval + iNADistanceVer - 1;  break;
      case 1: offsetX = offsetX1 = horNAInterval + iNADistanceHor - 1;  offsetY = offsetY1 = -iNADistanceVer - 1;                  break;
      case 2: offsetX = offsetX2;       offsetY = offsetY1;       break;
      case 3: offsetX = offsetX0;       offsetY = offsetY2;       break;
      case 4: offsetX = offsetX0;       offsetY = offsetY1;       break;
      case 5: offsetX = -1;             offsetY = offsetY0;       break;
      case 6: offsetX = offsetX1;       offsetY = -1;             break;
      case 7: offsetX = offsetX0 >> 1;  offsetY = offsetY0;       break;
      case 8: offsetX = offsetX1;       offsetY = offsetY1 >> 1;  break;
      default: printf("error!"); exit(0); break;
      }

      getEipModel(topLeft.offset(offsetX, offsetY));
    }
  }

  // Non-adjacent candidates round 2
  const int numNACandidate2[7] = { 4, 4, 4, 4, 4, 4, 4 };
  const int idxMap2[7][5]        = { { 0, 1, 2, 3 }, { 0, 1, 2, 3 }, { 0, 1, 2, 3 }, { 0, 1, 2, 3 },
                                     { 0, 1, 2, 3 }, { 0, 1, 2, 3 }, { 0, 1, 2, 3 } };

  for (int iDistanceIndex = 0; iDistanceIndex < 7 && numCand < maxCands; iDistanceIndex++)
  {
    const int horNADistance = horNAInterval * (iDistanceIndex + 1);
    const int verNADistance = verNAInterval * (iDistanceIndex + 1);

    for (int naspIdx = 0; naspIdx < numNACandidate2[iDistanceIndex] && numCand < maxCands; naspIdx++)
    {
      switch (idxMap2[iDistanceIndex][naspIdx])
      {
      case 0: offsetX = offsetX0 = -horNADistance - 1;          offsetY = offsetY2 + ((verNAInterval + verNADistance - 1 - offsetY2) >> 1); break;
      case 1: offsetX = offsetX2 + ((horNAInterval + horNADistance - 1 - offsetX2) >> 1); offsetY = offsetY0 = -verNADistance - 1; break;
      case 2: offsetX = offsetX0;                                offsetY = offsetY0 + ((offsetY2 - offsetY0) >> 1); break;
      case 3: offsetX = offsetX0 + ((offsetX2 - offsetX0) >> 1); offsetY = offsetY0; break;
      default: printf("error!"); exit(0); break;
      }

      getEipModel(topLeft.offset(offsetX, offsetY));
    }
  }

  // Shifted temporal eip models
  if (!slice.isIntra() && compId == COMPONENT_Y)
  {
    const Picture* const pColPic = slice.getRefPic(RefPicList(slice.isInterB() ? 1 - slice.getColFromL0Flag() : 0), slice.getColRefIdx()); 
    bool isRefScaled = pColPic->isRefScaled(slice.getPPS());

    if (pColPic && !isRefScaled)
    {
      const PreCalcValues& pcv = *cs.pcv;

      bool c0Avail;
      bool c1Avail;
      bool boundaryCond;
      const SubPic& curSubPic = pu.cs->slice->getPPS()->getSubPicFromPos(pu.lumaPos());
      int lumaScaleX = getChannelTypeScaleX( channelType, pu.chromaFormat );
      int lumaScaleY = getChannelTypeScaleY( channelType, pu.chromaFormat );
      Position posRB = pu.blocks[compId].bottomRight().offset(-1, -1);
      Position posCenter = pu.blocks[compId].center();
      
      Position posC0;
      Position posC1;

      int offsetX0 = 0, offsetX1 = 0, offsetX2 = 0, offsetX3 = pu.blocks[compId].width >> 1;
      int offsetY0 = 0, offsetY1 = 0, offsetY2 = 0, offsetY3 = pu.blocks[compId].height >> 1;

      const int numNACandidate[5] = { 2, 2, 2, 2, 2 };
      const int idxMap[5][2] = { { 0, 1 },{ 0, 2 },{ 0, 2 },{ 0, 2 },{ 0, 2 } };

      const unsigned plevel = pu.cs->sps->getLog2ParallelMergeLevelMinus2() + 2;

      MotionInfo miNeigh;
      bool foundNeighMV = false;
      bool useL0;
      const int colPOC     = pColPic->getPOC();

      for (int posIdx = 0; posIdx < 5 && foundNeighMV == false; posIdx++)
      {
        const PredictionUnit *puRef = cs.getPURestricted(posCand[posIdx], pu, pu.chType);
        bool isAvailableNeigh = puRef && 
                                PU::isDiffMER(pu.lumaPos(), posCand[posIdx], plevel) && 
                                pu.cu != puRef->cu && 
                                CU::isInter(*puRef->cu);

        if (isAvailableNeigh)
        {
          miNeigh = puRef->getMotionInfo(posCand[posIdx]);
          for (int i = 0; i < 2 && foundNeighMV == false; i++)
          {
            int refIdx = miNeigh.refIdx[i];
#if JVET_AI0082_GPM_WITH_INTER_IBC
            if (miNeigh.isInter && refIdx != -1)
#else
            if (refIdx != -1)
#endif
            {
              const int currRefPOC = slice.getRefPic(RefPicList(i), refIdx)->getPOC();
              if (currRefPOC == colPOC)
              {
                foundNeighMV = true;
                useL0 = i == 0 ? 1 : 0;
              }
            }
          }
        }
      }
      
      Mv   shiftMv;
      if (foundNeighMV)
      {
        shiftMv = useL0 ? miNeigh.mv[0] : miNeigh.mv[1];
        shiftMv.changePrecision(MV_PRECISION_INTERNAL, MV_PRECISION_INT);
        shiftMv.hor = shiftMv.hor >> lumaScaleX;
        shiftMv.ver = shiftMv.ver >> lumaScaleY;
      }
      else
      {
        shiftMv.set(0,0);
      }

      for (int iDistanceIndex = 0; iDistanceIndex < 5 && numCand < maxCands; iDistanceIndex++)
      {
        const int iNADistanceHor = pu.blocks[compId].width  * iDistanceIndex;
        const int iNADistanceVer = pu.blocks[compId].height * iDistanceIndex;

        for (int naspIdx = 0; naspIdx < numNACandidate[iDistanceIndex] && numCand < maxCands; naspIdx++)
        {
          switch (idxMap[iDistanceIndex][naspIdx])
          {
          case 0: offsetX0 = offsetX2 = 2 + iNADistanceHor; offsetY0 = offsetY2 = 2 + iNADistanceVer; offsetX1 = iNADistanceHor; offsetY1 = iNADistanceVer; break;
          case 1: offsetX0 = 2; offsetY0 = 0; offsetX1 = 0; offsetY1 = 2; break;
          case 2: offsetX0 = offsetX2; offsetY0 = 2 - offsetY3; offsetX1 = 2 - offsetX3; offsetY1 = offsetY2; break;
          default: printf("error!"); exit(0); break;
          }
        
          c0Avail = false;
          if (curSubPic.getTreatedAsPicFlag())
          {
            boundaryCond = ((posRB.x + shiftMv.hor + offsetX0) <= (curSubPic.getSubPicRight() >> lumaScaleX)) && ((posRB.y + shiftMv.ver + offsetY0) <= (curSubPic.getSubPicBottom() >> lumaScaleY));
          }
          else
          {
            boundaryCond = ((posRB.x + shiftMv.hor + offsetX0) < (pcv.lumaWidth >> lumaScaleX)) && ((posRB.y + shiftMv.ver + offsetY0) < (pcv.lumaHeight >> lumaScaleY));
          }
          if (boundaryCond)
          {
            posC0 = posRB.offset(shiftMv.hor + offsetX0, shiftMv.ver + offsetY0);
            c0Avail = true;
          }

          if (idxMap[iDistanceIndex][naspIdx] == 0)
          {
            c1Avail = false;
            if (curSubPic.getTreatedAsPicFlag())
            {
              boundaryCond = ((posCenter.x + shiftMv.hor + offsetX1) <= (curSubPic.getSubPicRight() >> lumaScaleX) && (posCenter.y + shiftMv.ver + offsetY1) <= (curSubPic.getSubPicBottom() >> lumaScaleY));
            }
            else
            {
              boundaryCond = ((posCenter.x + shiftMv.hor + offsetX1) < (pcv.lumaWidth >> lumaScaleX)) && ((posCenter.y + shiftMv.ver + offsetY1) < (pcv.lumaHeight >> lumaScaleY));
            }
            if (boundaryCond)
            {
              posC1 = posCenter.offset(shiftMv.hor + offsetX1, shiftMv.ver + offsetY1);
              c1Avail = true;
            }
          }
          else
          {
            c1Avail = false;
            if (curSubPic.getTreatedAsPicFlag())
            {
              boundaryCond = ((posRB.x + shiftMv.hor + offsetX1) <= (curSubPic.getSubPicRight() >> lumaScaleX) && (posRB.y + shiftMv.ver + offsetY1) <= (curSubPic.getSubPicBottom() >> lumaScaleY));
            }
            else
            {
              boundaryCond = ((posRB.x + shiftMv.hor + offsetX1) < (pcv.lumaWidth >> lumaScaleX)) && ((posRB.y + shiftMv.ver + offsetY1) < (pcv.lumaHeight >> lumaScaleY));
            }
            if (boundaryCond)
            {
              posC1 = posRB.offset(shiftMv.hor + offsetX1, shiftMv.ver + offsetY1);          
              c1Avail = true;
            }
          }
          if (c0Avail || c1Avail)
          {
            int modelIdx = c0Avail? pColPic->cs->getEipIdxInfo(posC0) 
                            : pColPic->cs->getEipIdxInfo(posC1);
            if (modelIdx > 0)
            {
              const EipModelCandidate currEipModel = pColPic->cs->m_eipModelLUT[modelIdx-1];
              tryToAddOneModel(currEipModel);
            }
          }
        }
      }
    }
  }

  auto tryHistEip = [&](const static_vector<EipModelCandidate, MAX_NUM_HEIP_CANDS>& lut)-> void
  {
#if JVET_AI0136_ADAPTIVE_DUAL_TREE
    if (!pu.cs->slice->isIntra() && pu.cs->slice->getSeparateTreeEnabled())
    {
      return;
    }
#endif
    for (int idx = 0; idx < lut.size() && numCand < maxCands; idx++)
    {
      EipModelCandidate cand;
      pu.cs->getOneModelFromEipLut(lut, cand, idx);
      bool duplication = false;

      for (int j = 0; j < candList.size(); j++)
      {
        if (cand.isTheSameParams(candList[j]))
        {
          duplication = true;
          // THROW("Should not duplicated");
          break;
        }
      }
      if (!duplication)
      {
        candList.push_back(cand);
        numCand++;
      }
      if(numCand >= maxCands)
      {
        return;
      }
    }
  };

#if JVET_Z0118_GDR
  if (pu.cs->isGdrEnabled() && pu.cs->isClean(pu))
  {
    tryHistEip(pu.cs->eipLut.lutEip1);  
  }
  else
  {
    tryHistEip(pu.cs->eipLut.lutEip0); 
  }
#else
  tryHistEip(pu.cs->eipLut.lutEip); 
#endif
}

void IntraPrediction::reorderEipCands(const PredictionUnit& pu, static_vector<EipModelCandidate, MAX_MERGE_EIP>& candList, const ComponentID compId)
{
  if (candList.size() <= 1)
  {
    return;
  }

  CHECK(candList.size() > MAX_MERGE_EIP, "candlist size is error.");
  const int refSizeY = m_cccmBlkArea.y;
  const int refSizeX = m_cccmBlkArea.x;
  const int stride = m_cccmBlkArea.width;
  const int blockHeight = pu.blocks[compId].height;
  const int blockWidth = pu.blocks[compId].width;
  const int topOffset = stride * (refSizeY - EIP_TPL_SIZE) + refSizeX;
  const int leftOffset = stride * refSizeY + refSizeX - EIP_TPL_SIZE;
  PelBuf recoTop(m_eipBuffer + topOffset, stride, blockWidth, EIP_TPL_SIZE);
  PelBuf recoLeft(m_eipBuffer + leftOffset, stride, EIP_TPL_SIZE, blockHeight);
  PelBuf predTop(m_eipPredTpl[0], blockWidth, EIP_TPL_SIZE);
  PelBuf predLeft(m_eipPredTpl[1], EIP_TPL_SIZE, blockHeight);

  DistParam cDistParam;
  cDistParam.applyWeight = false;
  Distortion uiCost;
  static_vector<Distortion, MAX_MERGE_EIP> candCostList;
  static_vector<EipModelCandidate, MAX_MERGE_EIP> tmpCandList;
  Pel inputs[EIP_FILTER_TAP];
  const ChannelType chType = toChannelType(compId);
#if JVET_AH0086_EIP_BIAS_AND_CLIP
  ClpRng clipRng = pu.cu->slice->clpRngs().comp[compId];
  clipRng.min = std::max( clipRng.min, m_eipClipMin);
  clipRng.max = std::min( clipRng.max, m_eipClipMax);
#else
  const ClpRng clipRng = pu.cu->slice->clpRngs().comp[compId];
#endif
  for(auto model: candList)
  {
    CccmModel cand(EIP_FILTER_TAP, pu.cu->slice->getSPS()->getBitDepth(toChannelType(compId)));
    memcpy(cand.params.data(), model.params, sizeof(model.params));
#if JVET_AJ0082_MM_EIP
    CccmModel cand1(EIP_FILTER_TAP, pu.cu->slice->getSPS()->getBitDepth(toChannelType(compId)));
    Pel thrd = model.eipMmThrd;
    memcpy(cand1.params.data(), model.params1, sizeof(model.params1));
#endif
    uiCost = 0;
    for (int h = 0; h < EIP_TPL_SIZE; h++)
    {
      for (int w = 0; w < blockWidth; w++)
      {
        setInputsVec(inputs, recoTop, w, h, model.filterShape);
#if JVET_AJ0082_MM_EIP
        if (model.bMm && getEipInputsAvg(inputs, model.filterShape) > thrd)
        {
          predTop.at(w, h) = ClipPel(cand1.convolve(inputs), clipRng);
        }
        else
        {
          predTop.at(w, h) = ClipPel(cand.convolve(inputs), clipRng);
        }
#else
        predTop.at(w, h) = ClipPel(cand.convolve(inputs), clipRng);
#endif
      }
    }
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_dbvSadCost->setDistParam(cDistParam, predTop, recoTop, pu.cs->sps->getBitDepth(chType), compId, true);
#else
    m_dbvSadCost->setDistParam(cDistParam, predTop, recoTop, pu.cs->sps->getBitDepth(chType), compId, false);
#endif
    uiCost += cDistParam.distFunc(cDistParam);

    for (int h = 0; h < blockHeight; h++)
    {
      for (int w = 0; w < EIP_TPL_SIZE; w++)
      {
        setInputsVec(inputs, recoLeft, w, h, model.filterShape);
#if JVET_AJ0082_MM_EIP
        if (model.bMm && getEipInputsAvg(inputs, model.filterShape) > thrd)
        {
          predLeft.at(w, h) = ClipPel(cand1.convolve(inputs), clipRng);
        }
        else
        {
          predLeft.at(w, h) = ClipPel(cand.convolve(inputs), clipRng);
        }
#else
        predLeft.at(w, h) = ClipPel(cand.convolve(inputs), clipRng);
#endif
      }
    }
#if JVET_AJ0096_SATD_REORDER_INTRA
    m_dbvSadCost->setDistParam(cDistParam, predLeft, recoLeft, pu.cs->sps->getBitDepth(chType), compId, true);
#else
    m_dbvSadCost->setDistParam(cDistParam, predLeft, recoLeft, pu.cs->sps->getBitDepth(chType), compId, false);
#endif
    uiCost += cDistParam.distFunc(cDistParam);

    updateCandList(model, uiCost, tmpCandList, candCostList, NUM_EIP_MERGE_SIGNAL);
  }
  candList.clear();
  for(auto model: tmpCandList)
  {
    candList.push_back(model);
  }
}
#endif
#if JVET_AK0118_BF_FOR_INTRA_PRED
bool IntraPrediction::checkBfLmcsApplication ( CodingStructure &cs, Reshape* reshape, ChannelType channelType )
{
  bool applyInverseLmcs = false;
  if( isLuma( channelType ) )
  {
    bool spsLmcsEnable = cs.sps->getUseLmcs();
    bool phLmcsEnable = cs.picHeader->getLmcsEnabledFlag();
    bool sliceLmcsEnable = reshape->getSliceReshaperInfo().getUseSliceReshaper();
    bool ctuLmcsEnable = cs.slice->getSliceType() == I_SLICE ? sliceLmcsEnable : reshape->getCTUFlag();
    applyInverseLmcs = spsLmcsEnable && phLmcsEnable && sliceLmcsEnable && ctuLmcsEnable;
  }
  return applyInverseLmcs;
}

bool IntraPrediction::checkBfApplication( int blkQp, int blkWidth, int blkHeight )
{
  bool applyBf = false;
  bool widthValid = false, heightValid = false;
  if( blkQp > 17 && blkWidth <= 128 && blkHeight <= 128 )
  {
    if( blkWidth == 4 || blkWidth == 8 || blkWidth == 16 || blkWidth == 32 || blkWidth == 64 || blkWidth == 128 )
    {
      widthValid = true;
    }
    if( blkHeight == 4 || blkHeight == 8 || blkHeight == 16 || blkHeight == 32 || blkHeight == 64 || blkHeight == 128 )
    {
      heightValid = true;
    }
    applyBf = widthValid && heightValid;
  }

  if( applyBf )
  {
    int totalSample = blkWidth * blkHeight;
    applyBf &= ( totalSample ) > 16 ? true : false;
    applyBf &= ( totalSample ) < 1024 ? true : false;

    int widthLog2 = floorLog2(blkWidth);
    int heightLog2 = floorLog2(blkHeight);

    applyBf &= ( blkWidth > blkHeight ) && ( widthLog2 - heightLog2 > 2 ) ? false : true;
    applyBf &= ( blkHeight > blkWidth ) && ( heightLog2 - widthLog2 > 2 ) ? false : true;
  }
  return applyBf;
}

bool IntraPrediction::checkBfModeApplication( int modeIdx )
{
  bool applyBf = true;

  if( (modeIdx >= 2 && modeIdx <= 3) || ( modeIdx >= 17 && modeIdx <= 19 ) || ( modeIdx >= 33 && modeIdx <= 35 ) || ( modeIdx >= 49 && modeIdx <= 51 ) || ( modeIdx >= 65 && modeIdx <= 66 ) )
  {
    applyBf = false;
  }
  return  applyBf;
}

void IntraPrediction::bilateralFilterPredDiamond5x5Clip(CodingStructure& cs, ChannelType channelType, PelBuf& predBuf, int blkWidth, int blkHeight, int blkQp, const ClpRng& clpRng, bool isIntraMode, CodingUnit& currCu )
{

  if( isChroma( channelType ) || !cs.sps->getUseIntraPredBf() )
  {
    return;
  }

  bool applyBfToPred = getApplyBfToPred(cs, blkWidth, blkHeight, channelType, blkQp, isIntraMode );
  if( !applyBfToPred )
  {
    return;
  }

  int uiWidth = blkWidth;
  int uiHeight = blkHeight;

  const int padSize = NUMBER_PADDED_SAMPLES;
  const int padSizeDou = padSize << 1;

  int uiPredStride = predBuf.stride;
  Pel *piPred = predBuf.buf;

  const uint32_t uiWidthExt = uiWidth + padSizeDou;
  const uint32_t uiHeightExt = uiHeight + padSizeDou;

  int iWidthExtSIMD = uiWidthExt | 0x04;
  if( uiWidth < 8 )
  {
    iWidthExtSIMD = 8 + padSizeDou;
  }

  bool applyLmcs = checkBfLmcsApplication(cs, m_pcReshape, channelType);
  if( isLuma( channelType ) && applyLmcs )
  {
    //Do Inverse Mapping
    for(int y = 0; y < uiHeight; y++)
    {
      Pel* predTmp = piPred + y * uiPredStride;
      for(int x = 0; x < uiWidth; x++)
      {
        Pel curr = predTmp[x];
        predTmp[x] = m_pcReshape->getInvLUT()[curr];
      }
    }
  }

  //Define Filtering Params
  int madValue = 0;
  bool isLowMadValue = true;
  int lowMadTh = 10;
  int bfac = 1;
  const int bifRoundAdd = BIF_ROUND_ADD >> 1;
  const int bifRoundShift = BIF_ROUND_SHIFT - 1;
  const int bifQpOffset = 0;
  const int cutBitsNum = isLuma( channelType ) ? 3 : 2;
  const char* lutRowPtr = nullptr;
  if( isLuma( channelType ) )
  {
    lutRowPtr = m_pcBilateralFilter->getFilterLutParameters(piPred, uiPredStride, uiWidth, uiHeight, isIntraMode ? MODE_INTRA : MODE_INTER, blkQp + bifQpOffset, bfac, madValue );
  }
  else
  {
    CHECK( isChroma(channelType), "IntraPredBf Can Not Apply to Chroma");
  }
  isLowMadValue = madValue < lowMadTh ? true : false;

  if( !isLowMadValue )
  {
    if( isLuma( channelType ) && applyLmcs )
    {
      //Do Forward Mapping
      for(int y = 0; y < uiHeight; y++)
      {
        Pel* predTmp = piPred + y * uiPredStride;
        for(int x = 0; x < uiWidth; x++)
        {
          Pel curr = predTmp[x];
          predTmp[x] = m_pcReshape->getFwdLUT()[curr];
        }
      }
    }
    //Skip BF for Blocks with High MAD
    return;
  }

  //Reuse Loop-Filter Bf Buffer
  Pel* bfTempBlock = m_pcBilateralFilter->tempblock;
  Pel* bfTempBlockFiltered = m_pcBilateralFilter->tempblockFiltered;

  //Move block to temporary block
  for (int y = 0; y < uiHeight; y++)
  {
    Pel* predTmp = piPred + y * uiPredStride;
    Pel* bfTmp   = bfTempBlock + (y + padSize) * iWidthExtSIMD + padSize;
    memcpy(bfTmp, predTmp, sizeof(Pel) * uiWidth );
  }
  //Reset Ptr
  piPred = predBuf.buf;

  //Perform Mirrored Padding
  //Left and Right
  for( int y = 0; y < uiHeight; y++ )
  {
    int yPos = y + padSize;
    bfTempBlock[yPos * iWidthExtSIMD + 0] = bfTempBlock[yPos * iWidthExtSIMD + 3];
    bfTempBlock[yPos * iWidthExtSIMD + 1] = bfTempBlock[yPos * iWidthExtSIMD + 2];
    bfTempBlock[yPos * iWidthExtSIMD + uiWidthExt - 1 - 0] = bfTempBlock[yPos * iWidthExtSIMD + uiWidthExt - 1 - 3];
    bfTempBlock[yPos * iWidthExtSIMD + uiWidthExt - 1 - 1] = bfTempBlock[yPos * iWidthExtSIMD + uiWidthExt - 1 - 2];
  }
  //Top and Bottom
  int64_t copySize = sizeof(Pel) * iWidthExtSIMD;
  memcpy( bfTempBlock + 0 * iWidthExtSIMD, bfTempBlock + 3 * iWidthExtSIMD, copySize );
  memcpy( bfTempBlock + 1 * iWidthExtSIMD, bfTempBlock + 2 * iWidthExtSIMD, copySize );
  memcpy( bfTempBlock + (uiHeightExt - 1 - 0) * iWidthExtSIMD, bfTempBlock + (uiHeightExt - 1 - 3) * iWidthExtSIMD, copySize );
  memcpy( bfTempBlock + (uiHeightExt - 1 - 1) * iWidthExtSIMD, bfTempBlock + (uiHeightExt - 1 - 2) * iWidthExtSIMD, copySize );

  //Cover Positions that Padded
  if( isLuma( channelType ) )
  {
    const SPS             &sps = *cs.sps;
    const PreCalcValues   &pcv = *cs.pcv;
    const CompArea        &area = currCu.blocks[COMPONENT_Y];
    const ChannelType     chType = toChannelType(area.compID);

    const PelBuf recoBuf        = cs.picture->getRecoBuf(area);

    const int  tuWidth = area.width;
    const int  tuHeight = area.height;
    const int  predSize = tuWidth << 0;
    const int  predHSize = tuHeight << 0;

    const int scaleX = getChannelTypeScaleX( channelType, sps.getChromaFormatIdc() );
    const int scaleY = getChannelTypeScaleY( channelType, sps.getChromaFormatIdc() );

    const bool noShift = pcv.noChroma2x2 && area.width == 4; // don't shift on the lowest level (chroma not-split)
    const int  unitWidth  = tuWidth  <= 2 && currCu.ispMode && isLuma( area.compID ) ? tuWidth  : pcv.minCUWidth  >> ( noShift ? 0 : scaleX );
    const int  unitHeight = tuHeight <= 2 && currCu.ispMode && isLuma( area.compID ) ? tuHeight : pcv.minCUHeight >> ( noShift ? 0 : scaleY );

    const int  totalAboveUnits = ( predSize + ( unitWidth - 1 ) ) / unitWidth;
    const int  totalLeftUnits = ( predHSize + ( unitHeight - 1 ) ) / unitHeight;
    const int  totalUnits = totalAboveUnits + totalLeftUnits + 1; //+1 for top-left
    const int  numAboveUnits = std::max<int>( tuWidth / unitWidth, 1 );
    const int  numLeftUnits = std::max<int>( tuHeight / unitHeight, 1 );
//    const int  numAboveRightUnits = totalAboveUnits - numAboveUnits;
//    const int  numLeftBelowUnits = totalLeftUnits - numLeftUnits;

//    CHECK( numAboveUnits <= 0 || numLeftUnits <= 0 || numAboveRightUnits <= 0 || numLeftBelowUnits <= 0, "Size not supported" );

    CHECK( numAboveUnits <= 0 || numLeftUnits <= 0 , "Size not supported" );

    // ----- Step 1: analyze neighborhood -----
    const Position posLT = area;
//    const Position posRT = area.topRight();
//    const Position posLB = area.bottomLeft();

    bool neighborFlags[4 * MAX_NUM_PART_IDXS_IN_CTU_WIDTH + 1] = { false };
    int numIntraNeighbor = 0;

    neighborFlags[ totalLeftUnits ] = isAboveLeftAvailable( currCu, chType, posLT );
    numIntraNeighbor += neighborFlags[ totalLeftUnits ] ? 1 : 0;
    numIntraNeighbor += isAboveAvailable( currCu, chType, posLT, numAboveUnits, unitWidth, ( neighborFlags + totalLeftUnits + 1 ) );
//    numIntraNeighbor += isAboveRightAvailable( currCu, chType, posRT, numAboveRightUnits, unitWidth, ( neighborFlags + totalLeftUnits + 1 + numAboveUnits ) );
    numIntraNeighbor += isLeftAvailable( currCu, chType, posLT, numLeftUnits, unitHeight, ( neighborFlags + totalLeftUnits - 1 ) );
//    numIntraNeighbor += isBelowLeftAvailable( currCu, chType, posLB, numLeftBelowUnits, unitHeight, ( neighborFlags + totalLeftUnits - 1 - numLeftUnits ) );

    int recoStride = recoBuf.stride;
    Pel* recoPtr   = recoBuf.buf;

    Pel *bfTmp, *recoTmp;

    if( numIntraNeighbor == 0 )
    {
      //None Avai
      //Do Nothing
    }
    else if( numIntraNeighbor == totalUnits )
    {
      //Fully Avai

      //Top-Left
      bfTmp = bfTempBlock + ( 0 ) * iWidthExtSIMD + 0;
      recoTmp = recoPtr + ( 0 - padSize ) * recoStride - padSize;
      bfTmp[0] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[0] ] : recoTmp[0];
      bfTmp[1] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[1] ] : recoTmp[1];

      bfTmp[iWidthExtSIMD + 0] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[recoStride + 0] ] : recoTmp[recoStride + 0];
      bfTmp[iWidthExtSIMD + 1] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[recoStride + 1] ] : recoTmp[recoStride + 1];
      //Left
      for( int hh = 0; hh < uiHeight; hh++)
      {
        bfTmp = bfTempBlock + ( padSize + hh ) * iWidthExtSIMD + 0;
        recoTmp = recoPtr + ( hh ) * recoStride - padSize;
        bfTmp[0] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[0] ] : recoTmp[0];
        bfTmp[1] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[1] ] : recoTmp[1];
      }
      //Top
      for(int ww = 0; ww < uiWidth; ww++)
      {
        bfTmp = bfTempBlock + ( 0 ) * iWidthExtSIMD + padSize + ww;
        recoTmp = recoPtr + ( 0 - padSize ) * recoStride - 0 + ww;
        bfTmp[0] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[0] ] : recoTmp[0];
        bfTmp[iWidthExtSIMD] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[recoStride] ] : recoTmp[recoStride];
      }
    }
    else
    {
      //Partialy Avai

      //Top-Left
      if( neighborFlags[ totalLeftUnits ] )
      {
        bfTmp = bfTempBlock + ( 0 ) * iWidthExtSIMD + 0;
        recoTmp = recoPtr + ( 0 - padSize ) * recoStride - padSize;
        bfTmp[0] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[0] ] : recoTmp[0];
        bfTmp[1] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[1] ] : recoTmp[1];

        bfTmp[iWidthExtSIMD + 0] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[recoStride + 0] ] : recoTmp[recoStride + 0];
        bfTmp[iWidthExtSIMD + 1] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[recoStride + 1] ] : recoTmp[recoStride + 1];
      }
      //Left
      int unitCheckedLeft = 0;
      for(int unitIdx = totalLeftUnits - 1; unitIdx > 0; unitIdx-- )
      {
        if( neighborFlags[unitIdx] )
        {
          for(int hh = 0; hh < unitHeight; hh++)
          {
            bfTmp = bfTempBlock + ( padSize + ( unitCheckedLeft ) * unitHeight + hh ) * iWidthExtSIMD + 0;
            recoTmp = recoPtr + ( ( unitCheckedLeft ) * unitHeight + hh ) * recoStride - padSize;
            bfTmp[0] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[0] ] : recoTmp[0];
            bfTmp[1] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[1] ] : recoTmp[1];
          }
        }
        unitCheckedLeft ++;
      }
      //Top
      int unitCheckedTop = 0;
      for(int unitIdx = totalLeftUnits + 1; unitIdx < totalUnits - 1; unitIdx++)
      {
        if( neighborFlags[unitIdx] )
        {
          for(int ww = 0; ww < unitWidth; ww++)
          {
            bfTmp = bfTempBlock + ( 0 ) * iWidthExtSIMD + padSize + ( unitCheckedTop ) * unitWidth + ww;
            recoTmp = recoPtr + ( 0 - padSize ) * recoStride + ( unitCheckedTop ) * unitWidth + ww;
            bfTmp[0            ] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[0         ] ] : recoTmp[0         ];
            bfTmp[iWidthExtSIMD] = applyLmcs ? m_pcReshape->getInvLUT()[ recoTmp[recoStride] ] : recoTmp[recoStride];
          }
        }
        unitCheckedTop ++;
      }

    }//Replace Padding
  }//is Luma

  //Only Perform BF when MAD is Lower than TH
  if( isLowMadValue )
  {
    //Perform BF and Store Offset into Filtered Buff

    //Perform Clip Here
    bool noClip = false;
    //Consider Higher Input Bit Depth Here
    int bitDepthShift = std::max(0, m_pcBilateralFilter->getInternalBitDepth() - 10);
    bool isRdo = false;
    bool isIntraPredBf = true;

    m_pcBilateralFilter->m_bilateralFilterDiamond5x5(uiWidth, uiHeight, bfTempBlock, bfTempBlockFiltered, clpRng, piPred, uiPredStride, iWidthExtSIMD, bfac, bifRoundAdd, bifRoundShift, isRdo, lutRowPtr, noClip, cutBitsNum, bitDepthShift, isIntraPredBf );

    //Copy Back to Pred
    piPred = predBuf.buf;
    for(int yy = 0; yy < uiHeight; yy++)
    {
      Pel* predTmp = piPred + yy * uiPredStride;
      Pel* bfTmp   = bfTempBlockFiltered + (padSize + yy) * iWidthExtSIMD + padSize;
      if( !noClip )
      {
        memcpy(predTmp, bfTmp, sizeof(Pel) * uiWidth );
      }
      else
      {
        for(int xx = 0; xx < uiWidth; xx++)
        {
          predTmp[xx] = ClipPel(predTmp[xx] + bfTmp[xx], clpRng);
        }
      }
    }
  }

  if( isLuma( channelType ) && applyLmcs )
  {
    //Do Forward Mapping
    for(int y = 0; y < uiHeight; y++)
    {
      Pel* predTmp = piPred + y * uiPredStride;
      for(int x = 0; x < uiWidth; x++)
      {
        Pel curr = predTmp[x];
        predTmp[x] = m_pcReshape->getFwdLUT()[curr];
      }
    }
  }
}

int IntraPrediction::calcRefSampleTexture(const int16_t* block, int stride, int width, int height, int whlog2)
{
  int average = 0;
  for (int i = 0; i < height; i++)
  {
    for (int j = 0; j < width; j++)
    {
      average += block[j];
    }
    block += stride;
  }
  block -= stride * height;
  average = (average + (1 << (whlog2 - 1))) >> whlog2;
  int mad = 0;
  for (int i = 0; i < height; i++)
  {
    for (int j = 0; j < width; j++)
    {
      mad += std::abs(block[j] - average);
    }
    block += stride;
  }
  mad = (mad + (1 << (whlog2 - 1))) >> whlog2;

  return mad;
}

bool IntraPrediction::getApplyBfToPred( CodingStructure& cs, int blkWidth, int blkHeight, ChannelType channel, int blkQp, bool isIntra )
{
  bool applyBfToPred =  blkQp > 17 ? true : false;
  if (applyBfToPred )
  {
    int w = blkWidth, h = blkHeight;
    char(*factor)[64] = nullptr;

    if (isLuma(channel))
    {
      factor = m_pcBilateralFilter->m_tuSizeFactor;

      w = floorLog2(w), h = floorLog2(h);
      w = std::min(w, 7), h = std::min(h, 7);
      applyBfToPred = factor[!isIntra][w * 8 + h] != 0 ? true : false;
    }
    else
    {
      applyBfToPred = false;
    }
  }

  return applyBfToPred;
}
#endif
//! \}
