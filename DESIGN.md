# ECM-16.1 二次变换项目总体说明（Twostage MTS + Implicit 2×2 Transform）

> 说明：本文件既描述算法框架，也维护项目进度（见第 8 节“进度与任务清单”），请在实际开发过程中不断更新。

---

## 1. 项目背景与动机

本项目基于 **VVC ECM-16.1** 参考软件，对 **变换/量化链路（TrQuant, MTS, RDOQ, DepQuant）** 进行扩展研究。  
标准 ECM 中的 MTS 仅在有限个显式二维核（DCT2/DCT8/DST7/EMT 等）之间做 R–D 搜索，并通过比特流显式信令所选核的 `mtsIdx`。变换本身为一次性二维整数变换，后接量化/RDOQ。

本项目在 **不改变比特流语法（不新增语法元素）** 的前提下，引入：

> **“显式 MTS + 高频隐式二次变换”**  
> 使用一次显式 MTS 选定的核做主变换，再在高频子空间上叠加若干 2×2 稀疏正交变换（Hadamard/旋转），并通过 LUT 隐式决定是否启用及如何启用。

目标是：  
- 在 **码率不显著升高** 的前提下，改善高频系数的能量压缩与稀疏性；  
- 控制整体编码复杂度增加不超过约 **5%**；  
- 为后续论文撰写与工具集成提供可复现的工程平台。

---

## 2. 代码基线与涉及模块

本项目以 `ECM-16.1` 为基线，核心涉及以下模块（路径以原 ECM 工程为准）：

- `source/Lib/CommonLib/`
  - `TrQuant.cpp`, `TrQuant.h`
    - TU 级变换入口（MTS / TransformSkip）
    - 关键接口：
      - `void TrQuant::transformNxN( TransformUnit& tu, const ComponentID& compID, const QpParam& cQP, std::vector<TrMode>* trModes, const int maxCand );`
      - `uint64_t TrQuant::transformNxN( TransformUnit& tu );`
    - 内部使用：
      - `CoeffBuf tempCoeff( m_mtsCoeffs[tu.mtsIdx[compID]], rect );`
      - `xT()` / `xTransformSkip()` 完成整数二维变换或 skip。
  - `TrQuant_EMT.cpp`, `TrQuant_EMT.h`
    - 显式 MTS/EMT 核实现（DCT2/8、DST7 及扩展核）。
  - `Quant.cpp`, `QuantRDOQ.cpp`, `DepQuant.cpp`
    - 量化 / RDOQ / 依赖量化逻辑。
  - `Unit.h`
    - `TransformUnit` 定义，包含 `uint8_t mtsIdx[MAX_NUM_TBLOCKS];` 等。

- `source/Lib/EncoderLib/`
  - `IntraSearch.cpp`
    - 帧内预测与 TU 级 MTS RDO：
      - `xIntraCodingTUBlock()` 中构造 `std::vector<TrMode> trModes`，调用 `TrQuant::transformNxN(...)`。
  - `InterSearch.cpp`
    - 帧间预测与 TU 级 MTS RDO（Inter MTS）。
  - `EncCu.cpp`, `EncGOP.cpp`
    - CTU/TU 编码流程与 R–D 驱动。

**二次变换相关代码** 将优先挂接在：
- `TrQuant::transformNxN()` 内部（一次变换完成后、量化/RDOQ 之前）；
- 以及配套的日志/LUT 逻辑。

---

## 3. 方法概述：显式 MTS + 高频隐式二次变换

### 3.1 一次显式 MTS 变换

对每个 TU，在 ECM 原有 MTS 候选集合中进行 R–D 搜索，选定显式核索引 `m = tu.mtsIdx[compID]`：

\[
\mathbf{c} = T^{(m)} \mathbf{x}
\]

其中：
- \(\mathbf{x}\)：TU 残差块；
- \(T^{(m)}\)：由 `mtsIdx` 决定的二维整数核（DCT2/DCT8/DST7/EMT 等）；
- \(\mathbf{c}\)：一次变换系数（存放于 `m_mtsCoeffs[tu.mtsIdx[compID]]`）。

### 3.2 低频保留与特征提取（一次系数）

对一次变换系数 \(\mathbf{c}\) 的**左上低频区域**进行保留和特征提取，其中保留区域大小基于 **1D 核长度** 的经验规则（可调）：

- 1D 核长 4 → 初始保留 2 个系数；
- 1D 核长 8 → 初始保留 4 个系数；
- 1D 核长 16 → 初始保留 6 个系数；
- 1D 核长 >16 → 初始保留 8 个系数。

二维 TU（例如 4×16）中：
- 纵向按高方向核长度取对应数量（如 2）；
- 横向按宽方向核长度取对应数量（如 6）；
- 得到约 **2×6** 的保留低频区域。

> ⚠️ 上述保留尺寸为**初始配置**，在项目中视为 **超参数**，后续通过实验（RD/复杂度消融）进行调整和精简。

从保留系数中提取特征，拟支持两类方案（均为可选、可扩展）：

1. **基于最大系数位置的快速方案（低复杂度）**
   - 在保留区域中选取若干幅度最大的系数；
   - 使用其 **二维位置索引**（以及可选的幅度区间/符号）编码为特征。
2. **基于统计量的精细方案（高表达力）**
   - 例如：
     - 总能量等级（smooth vs texture）；
     - 水平/垂直/对角能量占比；
     - 高频系数占比（在保留区域内再划分子带）。
   - 具体特征维数与量化边界视实验结果确定。

### 3.3 高频 2×2 稀疏正交二次变换

将一次系数拆分为低频与高频：

\[
\mathbf{c} =
\begin{bmatrix}
\mathbf{c}_L \\
\mathbf{c}_H
\end{bmatrix}
\]

在高频子空间 \(\mathbf{c}_H\) 上，按 **2×2 子块** 施加稀疏正交变换：

\[
\mathbf{d}_H = U_s \mathbf{c}_H,\quad
\mathbf{d} =
\begin{bmatrix}
\mathbf{c}_L \\
\mathbf{d}_H
\end{bmatrix}
\]

其中 \(U_s\) 由若干 2×2 Hadamard 或 Givens 旋转块构成，对应整体有效变换：

\[
T_{\text{eff}}^{(m,s)} = \tilde{U}_s T^{(m)},\quad
\tilde{U}_s =
\begin{bmatrix}
I & 0\\
0 & U_s
\end{bmatrix}
\]

当前优先考虑的 **二次核候选** 为 2×2 Hadamard：

\[
H_1 = \frac{1}{\sqrt{2}}
\begin{bmatrix}
1 & 1 \\
1 & -1
\end{bmatrix}
\]

对某个 2×2 高频子块 \(X\)：

\[
Y = \frac{1}{2} H_1 X H_1^T
\]

整数实现可通过加减 + 移位近似，复杂度极低。  
是否引入更复杂的旋转核 \(H_2(\theta)\)、每个 TU 最多允许多少个 2×2 子块参与二次变换（参数 \(n\)）等，均作为 **可调超参数**，由后续实验决定。

---

## 4. LUT 设计与隐式决策机制

### 4.1 LUT 输入维度（bucket 定义）

LUT 以 “bucket” 为单位组织，每个 bucket 由以下信息确定（暂定）：

- QP；
- TU 尺寸 / 形状（`tu.blocks[compID].width/height`）；
- 显式 MTS 核类型（`tu.mtsIdx[compID]`）；
- 一次变换低频系数提取的特征（位置/能量/方向等）。

### 4.2 LUT 输出内容

对每个 bucket，LUT 输出：

- 是否对该 TU 启用二次变换（enable flag）；
- 若启用：
  - 被选中的若干 2×2 高频子块位置集合；
  - 每个子块所用核类型（Hadamard / 旋转核等）。

### 4.3 显式 vs 隐式开启策略

项目内部区分两种策略：

1. **显式方式（可选扩展）**
   - 比特流中额外信令 1 bit 标志 TU 是否启用二次变换；
   - 编码端可对“启用/不启用”做一次简单 R–D 比较；
   - 会影响语法，当前阶段**不作为主线**实现。

2. **隐式方式（重点方向）**
   - 不新增语法，**完全由 LUT 决定**是否启用；
   - LUT 输入仅依赖编码/解码端共有的信息（QP、TU 尺寸、MTS 模式、低频系数特征），保证解码端可复现；
   - LUT 训练时要求策略 **相对保守**：在统计意义上保证码率不显著增加，尽量降低“坏块比例”。

当前工程阶段默认采用 **隐式方式** 进行算法验证。

---

## 5. 代码修改范围与不变约束

### 5.1 允许修改的部分

- `TrQuant::transformNxN()` 内部：
  - 添加一次系数的低频保留与特征提取；
  - 调用二次变换核，对 `CoeffBuf tempCoeff` 中指定高频 2×2 子块进行更新；
  - 为 LUT 训练增加日志输出（可编译时开关）。
- 必要时在 `Quant/QuantRDOQ/DepQuant` 之前或之中插入与二次变换兼容的处理逻辑（**不改变 RDOQ 的基本框架**）。
- Encoder 侧新增：
  - LUT 查询模块（C++ 实现，或从外部文件加载）；
  - 日志控制、统计计数、调试开关。

### 5.2 原则上不修改/需保持兼容的部分

- **比特流语法与解码流程**：  
  - 当前阶段不新增语法元素；  
  - 解码端最终 recon 与编码端内部使用的有效变换需保持一致（如未来在 Decoder 集成对应 LUT 与逆二次变换）。
- 预测模块（帧内/帧间预测、帧内角度、运动补偿等）不做结构性修改；
- 熵编码（CABAC）语法与上下文建模不做结构性修改。

---

## 6. 实验与数据流流程（训练 → LUT → 编码）

1. **LUT 训练日志阶段**
   - 在特定测试序列与 QP（22/27/32/37）下，对 TU 进行扩展 R–D 搜索：
     - 一次变换后，枚举/近似搜索若干 2×2 二次变换组合；
     - 基于两阶段搜索（单块评估 → 候选组合）降低复杂度；
     - 记录：
       - bucket 信息（QP、TU 尺寸、MTS 模式、一次特征）；
       - 二次变换配置（子块位置 + 核类型）；
       - R–D 结果（ΔJ、ΔRate、ΔDistortion）。
   - 日志以结构化格式输出（建议 JSON/CSV），由 Python/脚本处理。

2. **离线 LUT 生成**
   - Python 脚本对日志进行统计：
     - 在同一 bucket 内，对不同二次配置的平均增益与“坏块比例”进行统计；
     - 选择在平均 BD-rate / J 方面表现较优、坏块比例可接受的配置写入 LUT；
     - 对无明显增益或风险较高的 bucket，将 LUT 设置为“不启用二次变换”。

3. **LUT 集成与在线编码**
   - 将生成的 LUT 文件随 ECM 一起加载（或编译为静态表）；
   - 在线编码时：
     - 一次变换 → 低频特征 → bucket → LUT 查询；
     - 若 LUT 指示启用，则对指定高频 2×2 子块执行二次变换；
     - 之后进入原有量化/RDOQ/熵编码流程；
   - 统计整体编码时间、BD-rate、坏块比例及复杂度变化。

---

## 7. 后续工作与开放参数

项目中以下内容为 **开放设计/待实验确认**：

- 一次低频保留区域的具体尺寸（各 TU 尺寸、各方向保留长度）；
- 一次特征的具体组成（最大系数位置 vs 统计特征，分档方式）；
- 允许二次变换的 2×2 高频子块总数及分布（参数 \(n\)）；
- 二次变换核集合（仅 Hadamard vs 加入有限个旋转核角度）；
- LUT 训练中的“坏块比例”阈值与 bucket 划分粒度；
- 是否在特定场景下增加轻量级的在线 R–D 检查（显式 vs 隐式混合策略）。

---

## 8. 实验与开发步骤清单（按时间顺序）

> 使用规则：  
> - `[ ]` 表示待完成，`[x]` 表示已完成；  
> - 整个清单是“从无到有”的流程，建议按顺序执行，不要跳步；  
> - **每完成一个小项（例如 1-2、3-1），建议同时做两件事：**
>   1. 在本清单中把对应条目前加上 `[x]`，并在末尾用简短文字标注本次修改的内容和日期，例如：`[x] 2025-11-18：实现低频扫描 + 基本统计。`
>   2. 在 git 提交信息中简要概括修改内容，例如：`feat(trquant): add low-freq stats extraction` 或 `log: add TU RD logging for twostage`.
>
> 测试视频说明：  
> - 所有测试序列存放在：`\\wsl$\Ubuntu-22.04\home\zhy\videos`  
> - 目录下有 `classA`–`classF` 六个子目录，对应 JVET/CTC 的不同分辨率等级。  
> - **小规模/快速测试阶段默认使用 `classD` 序列**（例如 BQSquare、RaceHorses 等），以减少编码时间；大规模评估时再扩展到 `classB/C` 甚至 `classA`。
---

### 8.1 阶段 0：环境与基线确认

- [ ] **0-1. 编译与运行基线 ECM-16.1**
  - 编译当前分支（不带任何二次变换改动）。
  - 运行至少 1 条 RA 配置命令（如 Class C BQMall，QP=32）。
  - 确认：
    - 编码正常结束（无崩溃、无断言）。
    - 输出 bitstream + log 与官方基线一致或误差在可接受范围内。
  - **建议记录：** 在本条后面注明“已确认编译与单条 RA 运行正常（日期）”。

- [ ] **0-2. 基线复杂度与 RD 记录**
  - 在 2–3 个代表性序列上（如 BQSquare、BQMall、BQTerrace）跑 QP=22/27/32/37。
  - 记录：
    - 总编码时间（或者平均每帧时间）。
    - Y/UV BD-rate 的基线参考（以后对比用）。
  - 将这些结果存入独立的 `baseline_results.md` 或 CSV 文件。
  - **建议记录：** 在本条后面写明“已生成 baseline_results.md，包含哪些序列和 QP（日期）”。

---

### 8.2 阶段 1：一次变换访问与低频扫描（不改变 R–D）

**目标：只读一次变换系数 + 计算低频特征，不改变 bitstream / RD。**

- [ ] **1-1. 在 `TrQuant::transformNxN()` 中访问一次变换系数**
  - 在 `xT()` 之后、量化之前，获得当前 TU 对应的 `CoeffBuf tempCoeff`。
  - 写一个内部函数，如：
    - `void TrQuant::xExtractLowFreq(const TransformUnit& tu, const ComponentID compID, const CoeffBuf& coeffs, LowFreqStats& stats);`
  - 先只在 C++ 层面读取，不写文件、不修改任何系数。
  - **建议记录：** 完成后在本条后面写上“增加 xExtractLowFreq 接口，仅做内存访问测试（日期）”。

- [ ] **1-2. 实现低频保留区域扫描**
  - 按当前约定规则（例如 1D 长 4/8/16/... → 保留 2/4/6/...）确定二维保留区大小。
  - 在保留区内计算简单统计量，例如：
    - 非零系数个数。
    - sumAbs。
    - 最大绝对值及其位置。
  - 用 `assert` 或 debug 打印在少量 TU 上验证计算是否合理。
  - **建议记录：** 在本条末尾写“完成 XX 尺寸的低频区规则 + 基本统计（日期）”。

- [ ] **1-3. 小规模 sanity test**
  - 在一个小序列（例如 2 秒 BQSquare，QP=32）上，开启低频扫描代码。
  - 确认：
    - 编码时间变化接近 0（< 1% 差异，允许有 debug 的轻微开销）。
    - 输出 bitstream 与未改动前完全一致（可通过 diff 或 checksum 检查）。
  - **建议记录：** 标注“已在 BQSquare QP=32 上验证 bitstream 一致（日期）”。

---

### 8.3 阶段 2：二次变换核心实现（固定配置，暂不开 LUT）

**目标：实现 2×2 Hadamard 二次变换内核，并验证“只改系数不炸”的工程稳定性。**

- [ ] **2-1. 实现 2×2 Hadamard 内核函数**
  - 新增函数，如：
    - `void TrQuant::xHadamard2x2(Coeff &a00, Coeff &a01, Coeff &a10, Coeff &a11);`
  - 采用整数近似实现：
    - 明确输入/输出范围，避免溢出。
    - 添加必要的 `CHECK` 或 `assert`。
  - **建议记录：** “新增 xHadamard2x2，使用 XXX 方式避免溢出（日期）”。

- [ ] **2-2. 在单个 TU 上做“硬编码二次变换”测试**
  - 例如：只对 `w=h=8` 的 Y 分量 TU，在系数矩阵右下角的某个固定 2×2 区域应用二次变换。
  - 不依赖 LUT，也不做任何 R–D 比较，只是“固定地变一下”。
  - 运行非常小的序列（几帧）：
    - 确认编码不崩溃。
    - 解码画面主观上正常（不会出现明显马赛克或花屏）。
  - **建议记录：** “对 8×8 TU 硬编码一个 2×2 二次变换，视觉检查看起来正常（日期）”。

- [ ] **2-3. 记录初始 RD 影响**
  - 在一个序列上（如 BQMall，QP=32），开启该“硬编码二次变换”。
  - 粗略记录：
    - 码率与 PSNR 的变化趋势（可能会变差，这是正常的）。
    - 编码时间的变化（验证复杂度增量量级）。
  - **建议记录：** “记录初始 RD 变化（码率 +X%，PSNR -Y dB，时间 +Z%）（日期）”。

> 说明：这一阶段目的是验证“数学实现”和“数值范围”，即便 RD 变差也没关系。

---

### 8.4 阶段 3：日志输出与 Python 解析基础框架

**目标：搭建从 C++→日志→Python 脚本的完整数据通道。**

- [ ] **3-1. 设计日志格式（建议 JSON 行 / CSV）**
  - 每条日志至少包含：
    - TU 位置（POC、x、y、w、h、comp）。
    - QP，`tu.mtsIdx[compID]`。
    - 一次低频特征（如 max 位置、sumAbs 等）。
    - 当前二次变换配置（暂时可以是“是否对某个固定 2×2 区域启用”）。
    - 对应的 R–D 代价（J / rate / distortion）。
  - 将格式写在注释/文档里，方便以后维护。
  - **建议记录：** “确定日志字段列表 + 示例行格式（日期）”。

- [ ] **3-2. 在 `TrQuant::transformNxN()` 中添加日志输出（可开关控制）**
  - 使用宏或配置项控制，比如 `TWOSTAGE_LOG_ENABLE`。
  - 确保：
    - 日志写入采用缓冲方式（避免频繁 `fopen/fclose`）。
    - 日志路径固定（例如 `logs/twostage_pocXXXX.jsonl`）。
  - **建议记录：** “新增日志开关 TWOSTAGE_LOG_ENABLE，输出到 logs/……（日期）”。

- [ ] **3-3. Python 解析脚本 v0**
  - 编写一个简单脚本：
    - 读取日志文件。
    - 解析为 `pandas.DataFrame`。
    - 输出前几行、统计 TU 数量、维度等。
  - 验证：
    - 字段解析正确，无缺失/错位。
    - 可以按 `QP`、`w×h`、`mtsIdx` 分组计数。
  - **建议记录：** “log_parse_v0.py 可正常读入并打印统计信息（日期）”。

---

### 8.5 阶段 4：离线两阶段搜索 & LUT 原型（小规模）

**目标：在离线脚本中实现“两阶段搜索 + bucket 统计”的完整流程，先对极小子集试运行。**

- [ ] **4-1. 构造离线“单块评估 + 组合评估”逻辑**
  - 在 Python 中模拟：
    - 给定某个 TU 的候选 2×2 子块集合（例如 8×8 高频区内的 4–6 个子块）。
    - 读取对应日志中的 RD 数据（或先在 C++ 中多跑几种配置把结果打出来）。
    - 实现：
      - 单块评估 → 选出 top-K。
      - 在 top-K 内穷举组合，找到最优组合。
  - **建议记录：** “两阶段搜索逻辑在模拟数据上验证通过（日期）”。

- [ ] **4-2. 定义 bucket 结构并聚合统计**
  - 按 (QP, w, h, mtsIdx, feature_bin…) 对 TU 分 bucket。
  - 对每个 bucket：
    - 统计各候选二次配置的平均增益（ΔRate / ΔDistortion / ΔJ）。
    - 统计“坏块比例”（二次变换后变差的 TU 占比）。
  - **建议记录：** “完成 bucket 设计 + 聚合统计代码（日期）”。

- [ ] **4-3. 生成 LUT 原型（仅覆盖小部分 bucket）**
  - 为覆盖样本充足的 bucket 选出一个“最优”或“次优且更稳健”的配置。
  - 将结果导出为简易 LUT 文件，例如：
    - `bucket_key -> {enable: 1, blocks: [...], kernel_id: ...}`。
  - 不要求覆盖所有 TU，只要有一小部分 bucket 有明确决策即可。
  - **建议记录：** “生成 LUT 原型 v0，仅覆盖 XX 个 bucket（日期）”。

---

### 8.6 阶段 5：在线 LUT 模式接入（部分覆盖）

**目标：在编码器中真正使用离线生成的 LUT，对一部分 TU 启用“隐式二次变换”。**

- [ ] **5-1. 实现 LUT 加载与查询接口**
  - 在 Encoder 初始化时加载 LUT 文件（可选 JSON / 自定义二进制）。
  - 提供函数：
    - `bool TrQuant::xQueryTwostageLUT(const TransformUnit& tu, const ComponentID compID, const LowFreqStats& stats, TwostageConfig& cfg);`
  - 若当前 bucket 无记录，则返回“不启用二次变换”。
  - **建议记录：** “实现 xQueryTwostageLUT，可成功加载 v0 LUT（日期）”。

- [ ] **5-2. 将 LUT 查询结果应用到二次变换调用**
  - 在 `transformNxN()` 中：
    - 一次变换 + 特征提取后调用 `xQueryTwostageLUT`。
    - 若启用，则对 LUT 指定的 2×2 子块调用 `xHadamard2x2`。
  - 保留原有“硬编码测试”路径作为 debug 选项（用宏区分）。
  - **建议记录：** “在线 LUT 调用已打通，可通过宏切换 debug/hardcoded/path（日期）”。

- [ ] **5-3. 小规模在线验证**
  - 选择 1–2 个 LUT 覆盖较多的场景（例如中等 TU 尺寸、某个特定 QP）。
  - 在对应序列上编码：
    - 确认编码、解码正常。
    - 比较码率/PSNR 的变化趋势。
    - 记录编码时间（估计复杂度增量）。
  - **建议记录：** “在 XX 序列 + QP 上完成第一次在线 LUT 对比（日期）”。

---

### 8.7 阶段 6：扩展到更多 TU / QP / 序列 + 复杂度评估

**目标：把 LUT 的覆盖范围和实验范围逐步扩大，形成较稳定的整体评估。**

- [ ] **6-1. 扩大 LUT 训练与生成范围**
  - 在更多序列（Class B/C/D）和 QP（22/27/32/37）上跑日志模式。
  - 使用已有 Python 脚本重新统计，生成覆盖更多 bucket 的 LUT。
  - 添加一些保守的筛选阈值（例如坏块比例上限）。
  - **建议记录：** “生成 LUT v1，覆盖 XX% 的 TU（日期）”。

- [ ] **6-2. 在同一套序列上跑“开/关 LUT”的完整对比**
  - 基本设置：
    - 相同配置，编码两轮：原 ECM vs 启用隐式二次变换版本。
    - 序列：至少覆盖不同分辨率和内容类型（平滑 / 纹理 / 运动丰富）。
  - 记录：
    - Y/UV BD-rate。
    - 总编码时间、TrQuant 层面时间占比（如可测）。
    - LUT 命中率、启用二次变换的 TU 比例。
  - **建议记录：** “完成 v1 LUT 的全套 BD-rate 和复杂度对比（日期）”。

- [ ] **6-3. 复杂度与超参数初步调优**
  - 根据时间开销和 RD 结果：
    - 粗略调节参数 `n`（每 TU 最大 2×2 子块数）。
    - 视情况缩小 LUT 覆盖范围或减少高复杂度 bucket。
  - 目标：在典型配置下总编码时间增量控制在 ~5% 左右。
  - **建议记录：** “调节 n 和覆盖范围，使时间增量约为 X%（日期）”。

---

### 8.8 阶段 7：消融实验与最终配置确定

**目标：针对关键设计自由度做有针对性的消融，确定一套“推荐配置”。**

- [ ] **7-1. 一次低频保留区域大小的消融**
  - 设计 2–3 套不同的保留区配置（例如：更小 / 标准 / 更大）。
  - 在相同序列集上比较：
    - RD 性能。
    - 特征统计稳定性（bucket 中样本数）。
    - 日志量和 LUT 大小。
  - **建议记录：** “完成保留区大小的消融，对比结果简要总结（日期）”。

- [ ] **7-2. 二次变换块数 n 的消融**
  - 尝试不同的 n（例如 1、2、3、4）：
    - 对比 BD-rate 与编码时间。
    - 观察高 n 是否存在明显“收益递减”。
  - **建议记录：** “完成 n 的消融，推荐值 = N（日期）”。

- [ ] **7-3. 核集合的消融（仅 Hadamard vs Hadamard+旋转）**（如实现了旋转核）
  - 若已实现少量旋转核：
    - 比较只用 Hadamard 和加入旋转核两种配置。
    - 注意评估乘法引入的复杂度开销是否划算。
  - **建议记录：** “核集合消融结果：是否保留旋转核（日期）”。

- [ ] **7-4. 确定一套“最终推荐配置”**
  - 结合上述消融结果，给出：
    - 最终保留区规则。
    - 最终 n。
    - 是否使用旋转核。
    - LUT bucket 粒度（QP / 尺寸 / 特征分档）。
  - 将该配置写入文档和代码注释中，作为项目默认设置。
  - **建议记录：** “冻结最终配置 vFinal（日期），写入文档与默认宏（日期）”。
